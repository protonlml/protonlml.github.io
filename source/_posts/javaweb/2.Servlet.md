---
title: 2.Servlet
date: 2019-10-07 09:00:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- javaweb
categories:   # 添加博文分类
	- Servlet

---

<h1><center>Servlet</center></h1>

## 1.什么是Servlet

> ==``Servlet 是运行在服务端（tomcat）的 java 小程序``==，是sun公司提供的一套定义动态资源规范；从代码层面上来讲Servlet就是一个接口

- 用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。我们可以把Servlet称为Web应用中的==控制器==
- 不是所有的JAVA类都能用于处理客户端请求，能处理客户端请求并做出响应的一套技术标准就是Servlet 
- Servlet是运行在服务端的，所以Servlet ==``必须在WEB项目中``==开发且在Tomcat 这样的服务容器中运行

## 2.浏览器请求-服务器响应的过程

​		2.1 首先要知道，在Tomcat(web项目运行容器)中，lib目录下就有Servlet.jar     api  ，这个是tomcat自带的，我们在web项目中，不需要重复导入这个jar包。但是项目在Modules设置中要加入tomcat依赖才能生效。

 		2.2我们要自定义Servlet类，来继承HttpServlet 这个抽象类，（它是Servlet.jar包中的）

​		        重写 service方法（HttpServlet中的service方法，是用来判断请求是哪种类型的请求，如果是get就跳转到doGet 方法执行，如果是post				方式请求则跳转doPost 方法执行）或者直接重写  doGet 或者 doPost方法

​		2.3 在web.xml文件中，配置servlet路径映射。注意标签不要写颠倒了. 



![image-20241127211141030](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411272111359.png)



## 3.Concent_type

Concent_type 应答类型

浏览器 上传文件时，在请求头中，有一行是Concent_type:text 这种，告诉服务器tomcat上传的数据是什么类型的。

在响应头中也有Concent_type 一行的值。 告诉浏览器，响应的是什么类型的资源。浏览器好作出响应的解析

这种映射关系，是tomcat中的web.xml文件中的映射，tomcat提前已经写好了

![image-20241128000116783](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411280001093.png)

## 4.请求路径，怎么找到servlet资源的.

![image-20241128000455241](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411280029090.png)

## 5.Servlet的注解方式配置

直接在Servlet类上面，使用@WebServlet注解来映射地址，这样就不用在web.xml配置文件中书写一大堆servl映射了。

![image-20241128002741401](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411280029810.png)

## 6.Servlet生命周期

应用程序中的对象不仅在空间上有层次结构的关系，在时间上也会因为处于程序运行过程中的不同阶段而表现出不同状态和不同行为，这就是对象的生命周期。

简单的叙述生命周期，就是对象在容器中从开始创建到销毁的过程。

Servlet对象是Servlet容器创建的，生命周期方法都是由容器（目前我们使用的是Tomcat）调用的。这一点和我们之前所编写的代码有很大不同。在今后的学习中我们会看到，越来越多的对象交给容器或框架来创建，越来越多的方法由容器或框架来调用，开发人员要尽可能多的将精力放在业务逻辑的实现上。

servlet对象一般是在第一次请求时，才进行创建,而且时单例的（请求时稍慢）

如果配置了loadOnStartup 配置的是正数，那么就会在tomcat启动时就创建servlet(请求时就快了)

```xml
<servlet>
	<servlet-name>servletLifeCycle</servlet-name>
	<servlet-class>com.atguigu.servlet.ServletLifeCycle</servlet-class>
	<!--load-on-startup
 		如果配置的是正整数 则表示容器在启动时就要实例化Servlet,  数字表示的是实例化的顺序 
	-->
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>servletLifeCycle</servlet-name>
	<url-pattern>/servletLiftCycle</url-pattern>
</servlet-mapping>
```

注解方式：==@WebServlet(value="/s1",loadOnStartup = 6)==

### 6.1生命周期总结

1.通过生命周期测试发现Servlet>对象在容器中是单例的；

2.容器是可以处理并发的用户请求的，每个请求在容器中都会开启一个线程；

3.多个线程可能会使用相同的Servlet对象，所以在Servlet中，==我们不要轻易定义一些需要经常修改的成员变量；==

![image-20241128010320114](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411280103727.png)

4.load-on-startupl中定义的正整数表示实例化顺序，如果数字重复了，容器会自行解决实例化顺序问题，但是应该避免重复：

5.Tomcat容器中，已经定义了一些随系统启动实例化的Servlet，自定义的Servlet的load-on-startup尽量不要占用数字1-5；

## 7.defaultServlet

defaultServlet是tomcat中自带的在tomcat的web.xml文件中设置了<load-on-startup>1</load-on-startup>

它是在启动tomcat的时候，就创建了。

作用是：请求所有的静态资源都会走这个defaultServlet 根据请求的资源路径以及名称去找对应的资源，然后将IO流的方式写入到response对象中，返回给前端。

springMVC中也有一个servlet，如果项目不是前后端分离，单体ssm项目，那这个springmvc会导致这个tomcat中默认的defaultServlet失效，导致访问不到静态资源，需要配置才能恢复访问。

## 8.servlet的继承结构

![image-20241128012505065](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411280125087.png)

在HttpServlet中的service方法，是用来判断请求是哪种类型的请求，如果是get就跳转到doGet 方法执行，如果是post				方式请求则跳转doPost 方法执行

继承HttpServlet后，要么重写service 要么重写 doGet/doPost

如果两个都重写了，则service优先



## 9.ServletConfig（了解）

> #### ServletConfig是什么？
>
> 1.为Servlet提供初始配置参数的一种对象，每个Servlet都有自己独立唯一的ServletConfig
>
> 2.对象容器会为每个Servlet实例化一个ServletConfig对象，并通过Servlet生命周期的init方法传入给Servlet作为属性



一个servlet对应一个ServletConfig 为其提供服务，在其内部配置参数。

Servlet是单例多线程的，（多个客户端请对一个servlet进行请求）当tomcat启动时，或者第一次请求servlet时，servlet会被创建。

![image-20241130220638340](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411302206526.png)

（当然在web.xml中同一个servlet被声明多次，也会出现多个实例对象）

![image-20241130220536044](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411302206506.png)

- 一个servlet对应一个ServletConfig

![image-20241130220240724](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411302206497.png)

- 在service中ServletConfig 来获取 当前Servlet的init配置参数
- ![image-20241130224444103](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411302244599.png)



## 10.ServletContext

ServletContext  => Servlet上下文对象

>####  ServletContext  是什么？
>
>- ServletContext 对象 有称呼为上下文对象，或者叫应用域对象（后面统一讲解域对象）
>- 容器会为每个app项目创建一个独立的唯一的 ServletContext对象
>- ServletContext对象为所有的 Servlet所共享、
>- ServletContext可以为所有的Servlet提供初始配置参数

一个项目，就只有一个ServletContext 对象

ServletContext 对象是单例的，不管你用什么方式获取 getServletContext 都是同一个

### 作用

#### 1.为所有servlet提供初始配置

![image-20241130230111164](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411302301800.png)

```java
/**
 *      servletConfig 对象的使用
 *      一个servlet对应一个ServletConfig对象为其服务
 *
 */
@WebServlet(value = "/s1", loadOnStartup = 6,
        initParams = {@WebInitParam(name = "a", value = "2222")}
)
public class Servlet1 extends HttpServlet {
    @Override
    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
        ServletConfig servletConfig = getServletConfig();

//        获取到迭代器对象
        Enumeration<String> initParameterNames = servletConfig.getInitParameterNames();
        while (initParameterNames.hasMoreElements()) { //判断有没有下一个参数，有返回true 无返回false
//            取出下一个元素
            String s = initParameterNames.nextElement();
//            取出配置的值
            String value = getInitParameter(s);
            System.out.println(value);
        }
        System.out.println("servlet1执行了");
    }
}
```



#### 2. 获取资源的磁盘路径

 涉及到文件上传，并将文件存到当前项目中   肯定会用到 getRealPath

```java
String realPath = servletContext.getRealPath("资源在web目录中的路径");
```

- 例如我们的目标是需要获取项目中某个静态资源的路径，不是工程目录中的路径，而是部署目录中的路径；我们如果直接拷贝其在我们电脑中的完整路径的话其实是有问题的，因为如果该项目以后部署到公司服务器上的话，路径肯定是会发生改变的，所以我们需要使用代码动态获取资源的真实路径。
- 只要使用了servletContexti动态获取资源的真实路径，那么无论项目的部署路径发生什么变化，都会动态获取项目运行时候的实际磁盘路径，所以就不会发生由于写死真实路径而导致项目部署位置改变引发的路径错误问题。
- ![image-20241201004041981](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202412010040982.png)

#### 3.动态获取项目的上下文路径(项目的访问路径)

```java
servletContext.getContextPath();   // 获取的是项目的访问路径
```



项目的部署名称，也叫项目的上下文路径，在部署进入tomcat时所使用的路径，该路径是可能发生变化的，通过该P动态获取项目真实的上下文路径，可以帮助我们解决一些后端页面渲染技术或者请求转发和响应重定向中的路径问题。

![image-20241201004100093](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202412010041224.png)





## 11.域对象的理解

- #### 域对象有：

  - 应用域对象是ServletContext，传递数据的范围是本应用之内（当前项目中），可以跨多个会话，

  - 会话域对象是HttpSession，传递数据的范围是一次会话之内，可以跨多个请求；

  - 请求域对象是HttpServletRequest，传递数据的范围是一次请求之内及请求转发；

    

- 域对象：一些用于在一些特定的范围内存储数据和传递数据的对象，不同的范围称为不同的“域”不同的域对象代表不同的域，共享数据的范围也不同；
- ServletContext代表应用，所以ServletContexti域也叫作应用域，是webapp中最大的域，可以在本应用内实现数据的共享和传递；
- webapp 中的三大域对象，分别是应用域，会话域，请求域。

```java
/**
 * servletConText 对象作为域对象的使用
 *  servletContext.setAttribute(key,value);
 *  servletContext.getAttribute(key);
 *  //        移除域中指定的值
 *         servletContext.removeAttribute("key1");
 *
 *
 */

@WebServlet("/servlet3")
public class Servlet3 extends HttpServlet {

    @Override
    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {

        ServletContext application = getServletContext();
//       在 servletContext 作用域中，设置一个值
        application.setAttribute("key1","value1");

    }
}


/**
 * servletContext的使用
 *  ServletConText 对象 一个app项目中只有一个
 *  4. 作为全局域对象
 *         ServletContext 对象，又叫作 应用域对象
 *         在里面存储一值，整个app项目都能拿到
 *
 *
 */
@WebServlet("/servlet2")
public class Servlet2 extends HttpServlet {
    @Override
    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
        ServletContext servletContext = servletConfig.getServletContext();
        
//        获取servletContext作用域中，存储的值
        String key1 = (String) servletContext.getAttribute("key1");
        System.out.println(key1);
//        移除域中指定的值
        servletContext.removeAttribute("key1");

// 获取作用域中的所有key以及value
        Enumeration<String> attributeNames = servletContext.getAttributeNames();
        while (attributeNames.hasMoreElements()){
            String key = attributeNames.nextElement();
            System.out.println(key);
            String value = (String) servletContext.getAttribute(key);
            System.out.println(key+"===================="+value);
        }

    }
}

```



## 12.HttpServletRequest(请求对象)

>#### HttpServletRequest是什么？
>
>HttpServletRequest是一个接口，其父接口是 ServletRequest；
>HttpServletRequest是Tomcat将请求报文转换封装而来的对象，在Tomcati调用service方法时传入；
>HttpServletRequest代表客户端发来的请求，请求中的所有信息都可以通过该对象获得；

### 12.1 HttpServletRequest怎么用？

```java

/**
 *  HttpRequest  请求对象的使用
 */
@WebServlet("/servlet4")
public class Servlet4 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        /**
         * 获取请求行，信息相关（方式，请求的URL，协议及版本）
         */
        //1.获取客户端请求的URL
        StringBuffer requestURL = request.getRequestURL();
        System.out.println(requestURL); //http://localhost:8080/d02/servlet4

        //2.获取客户端请求的URI
        String requestURI = request.getRequestURI();
        System.out.println(requestURI);///d02/servlet4

        //3.获取客户端发送请求时的端口。（可以是代理端口）
        int serverPort = request.getServerPort();
        System.out.println(serverPort);//8080

        //4.获取本应用在所在容器的端口。（tomcat端口）
        int localPort = request.getLocalPort();
        System.out.println(localPort);//8080

        //5.获取客户端程序的端口。
        int remotePort = request.getRemotePort();
        System.out.println(remotePort);//8546

        //6.获取请求协议。
        String scheme = request.getScheme();
        System.out.println(scheme);//http

        //7.获取请求协议及版本号。
        String protocol = request.getProtocol();
        System.out.println(protocol);//HTTP/1.1

        //8.获取请求方式。
        String method = request.getMethod();
        System.out.println(method);//GET

        System.out.println("*************获取请求参数相关**************************");
       
        //1.根据请求参数名获取请求单个参数值。
        String username = request.getParameter("username");
        System.out.println(username);
        System.out.println("***************************************");
        //2.根据请求参数名获取请求多个参数值数组。
        String[] habbies = request.getParameterValues("habby");
        for (String habby : habbies) {
            System.out.println(habby);
        }
        System.out.println("***************************************");

        //3.获取所有请求参数名。
        Enumeration<String> parameterNames = request.getParameterNames();
        while (parameterNames.hasMoreElements()) {
            String parameterName = parameterNames.nextElement();
            System.out.println(parameterName);
        }
        System.out.println("***************************************");

       /**
         * 获取请求参数相关
         *
         * 我们获取参数，有时候参数名是一个，但是参数值有多个
         *  比如：爱好 habby
         *  基于这种情况，我们就使用Map来获取请求参数
         *  将所有请求参数的值都看作多个来获取
         *
         */
        //4.获取所有请求参数的键值对集合。
        Map<String, String[]> parameterMap = request.getParameterMap();
        Set<String> strings = parameterMap.keySet();
        for (String parameterName : strings) {
            String[] value = parameterMap.get(parameterName);
            if(value.length>1){
                //请求参数有多个
                System.out.println(parameterName + "========" + Arrays.toString(value));
            } else {
                //请求参数有一个
                System.out.println(parameterName + "========" + value[0]);
            }
        }

        System.out.println("***************************************");
        /**
         * 获取请求体中，非键值对数据
         *
         * //5.获取读取请求体的字符输入流。 JSON字符串
         *         BufferedReader reader = request.getReader();
         *         System.out.println("***************************************");
         *
         * //6.获取读取请求体的字节输入流。 文件  文件上传
         *         ServletInputStream inputStream = request.getInputStream();
         *         System.out.println("***************************************");
         *
         */


        //7.获得请求体长度的字节数。
        int contentLength = request.getContentLength();
        System.out.println(contentLength);


        System.out.println("*****************其他API **********************");
        /**
         * 其他API
         */
        //1.获取请求的Servlet的映射路径。
        String servletPath = request.getServletPath();
        System.out.println(servletPath);//   /servlet4

        //2.获取ServletContext 对象。
        ServletContext servletContext = request.getServletContext();

        //3.获取请求中的所有cookie。
        Cookie[] cookies = request.getCookies();

        //4.获取Session对象。
        HttpSession session = request.getSession();
        session.setAttribute("sessionKey","sessionValue");
        String sessionKey = (String) session.getAttribute("sessionKey");
        System.out.println(sessionKey); //sessionValue

        //5.设置请求体字符集。
        String characterEncoding = request.getCharacterEncoding();
        System.out.println(characterEncoding);//UTF-8


    }
}

```









## 13.HttpResponse(响应对象)

> #### HttpServletResponse是什么？
>
> HttpServletResponse是一个接口，其父接口是ServletResponse；
> HttpServletResponse，是Tomcat 预先创建的，在Tomcat 调用service方法时传入；
> HttpServletResponse代表对客户端的响应，该对象会被转换成响应的报文发送给客户端，通过该对象我们可以设置响应信息；

### 13.1HttpResponse怎么用？

```java

/**
 *  HTppServletResponse
 *
 *  响应对象的使用
 *
 */
@WebServlet("/servlet5")
public class Servlet5 extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        //1.设置响应状态码
        response.setStatus(200);

        //2.设置/修改  响应头键值对
        response.setHeader("key1","value1");

        //3.设置content-type响应头  及响应字符集（设置MIME类型）
        response.setContentType("text/html");

        //4.获得向响应体放入信息的字符输出流
        PrintWriter writer = response.getWriter();
        writer.print("aaa");
        //5.获得向响应体放入信息的字节输出流

        ServletOutputStream outputStream = response.getOutputStream();

        //6.设置响应体的字节长度，其实就是在设置content--length响应头
        response.setContentLength(2);

        //7.向客户端响应错误信息的方法，需要指定响应码和响应信息
        response.sendError(1);
        
        //8.向响应体中增加cookie
        response.addCookie(new Cookie("JSESSIONID","484512424"));
        //9.设置响应体字符集
        response.setCharacterEncoding("UTF-8");
                

    }
}

```



## 14.MIME类型

通常在响应设置 httpServletResponse.SetContextType("MIME类型")

- MME类型，可以理解为文档类型，用户表示传递的数据是属于什么类型的文档；

- 浏览器可以根据MME类型决定该用什么样的方式解析接收到的响应体数据；

- 可以这样理解：前后端交互数据时，告诉对方发给对方的是html/css/js/图片/声音/视频/。…；

- tomcat/conf/web.xml中配置了常见文件的拓展名和MIMIE类型的对应关系；

  常见的MIME类型举例如下：

| 文件拓展名              | MIME类型               |
| ----------------------- | ---------------------- |
| .html                   | text/html              |
| .css                    | text/css               |
| .js                     | application/javascript |
| .json                   | application/json       |
| .png/.jpeg/.jpg/... ... | image/jpeg             |
| .mp3/.mpe/.mpeg/... ... | audio/mpeg             |
| .mp4                    | video/mp4              |
| .m1v/.m2v/.mpe/... ...  | video/mpeg             |
|                         |                        |













---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>








</escape>

----



