---
title: 49.File类
date: 2019-09-26 08:31:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- java基础
categories:   # 添加博文分类
	- java


---

<h1><center>File类</center></h1>

## 一、File

- ### 对File的理解

- #### File 出现，new出来肯定是带（绝对路径的，已经存在的）

  - #### 1.形参中是文件的绝对路径（此时就表示一个文件）

  - #### 2.形参中是文件夹的绝对路径（此时就表示一个文件夹）

---

- ####  new File(形参) 是 不存在的路径，就表示一个路径而已，使用File中的方法来创建实际文件或者文件夹。

---

- ####  为什么要用File类，就是为了表述系统中的文件，使用File类中的方法，对当前File进行操作。

---

---

![image-20240702175109110](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021751478.png)

![image-20240702175127948](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021751937.png)

![image-20240702181421477](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021814490.png)





![image-20240702181153076](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021811150.png)



## 二、File 的方法

![image-20240702181526494](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021815581.png)



![image-20240702215257042](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407022152070.png)





![image-20240702181546913](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021815145.png)

![image-20240702215518579](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407022155698.png)





![image-20240702181630094](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021819918.png)



![image-20240702220240753](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407022202896.png)





# 练习

### 1.file获取文件名f.getName()带后缀名

```java

/**
 * 定义一个方法找某一个文件夹中，是否有以 avi 结尾的电影。
 * （暂时不需要考虑子文件夹）
 */
public class FileDemo4 {
    public static void main(String[] args) {


        File file = new File("C:\\Users\\lml\\Downloads\\aaa");
        boolean b = existAvi(file);
        System.out.println(b);

    }


    public static boolean existAvi(File file){
        // C:\Users\lml\Downloads\aaa 文件夹
        File[] files = file.listFiles();
        for (File f : files) {
            // 遍历aaa文件夹下的 文件夹以及文件的路径
            if(f.isFile()&&f.getName().endsWith(".avi")){
                return true;
            }
        }
        return false;
    }
    
}
```

### 2.涉及到多级文件夹，需要递归

```java
package com.atlml.file_demo;


import java.io.File;

/**
 * 找到电脑中所有以avi结尾的电影。
 * (需要考虑子文件夹）
 *
 *
 *  思想：把大问题拆分，拆到某一个文件夹中不包含其他文件夹为止
 *
 *        递归思想，就是将大的问题，拆成小的问题去解决
 *
 *        凡事要考虑文件夹里面的内容了，就使用下面的套路
 *        写递归方法的套路
 *        套路：
 *          1.进入文件夹
 *          2.遍历数组
 *              2.1.遍历内部：判断，如果是文件  就执行题目的业务逻辑
 *              2.2.遍历内部：判断，如果不是文件，他就是文件夹，继续调用当前方法，递归
 *
 */
public class FileDemo5 {
    public static void main(String[] args) {
        
       /* File file = new File("C:\\"); //C盘
        findAVI(file);*/
        findAVI();
    }
    /**
     * 查询电脑上 所有盘符 中 avi文件的路径
     */
    public static void findAVI(){

        File[] files = File.listRoots(); //获取系统中所有的盘符
        for (File file : files) {
            findAVI(file);
        }
    }
    /**
     * 递归方法
     * 递归查询 指定文件夹 中的内容
     */
    public  static void findAVI(File file){
        //1.进入文件夹,找到当前文件夹下面 所有的路径
        // 包含当前文件夹下的 所有文件夹，文件
        File[] files = file.listFiles();

        //注意细节：file可能为null 因为盘符有权限可能进不去
        if(files!=null){

            //2.遍历数组
            for (File src : files) {
                //3.判断，如果是文件就执行题目的业务逻辑
                if(src.isFile()){
                    if(src.getName().endsWith(".avi")){
                        System.out.println(src);
                    }
                }else {
                    //4.判断，如果不是文件，他就是文件夹，继续调用当前方法，递归
                    // 注意 src 一定是 file 的下级目录
                    findAVI(src);
                }
            }
        }
    }
}

```

### 3.删除多级文件夹

```java
/**
 * 删除多级文件夹
 */
public class FileDemo6 {

    public static void main(String[] args) {
        /**
         * 先思考删除一个文件夹内的内容怎么删
         * 如果 当前文件夹下面 还有文件夹 再调用
         */
        File file = new File("C:\\Users\\lml\\Downloads\\aaa\\eee");
        deleteMultilevelDirectory(file);
    }

    /**
     * @param src 文件夹地址
     * @return 删除成功与否
     */
    public static void deleteMultilevelDirectory(File src) {
        File[] files = src.listFiles();
        if (files != null) {
            for (File file : files) {
                if(file.isFile()){ //是文件直接删除
                    file.delete();
                }else { //是文件夹，且文件夹不是空的 递归
                    deleteMultilevelDirectory(file);
                }
            }
        }
        // 自己也删
        src.delete();
    }
```

### 4.递归多级目录，递归方法中的局部变量怎么统计 

```java

/**
 * 需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）
 * <p>
 * ① 打印格式如下：
 * ②    txt：3个
 * ③    doc：4个
 * ④     jpg：6个
 * 。。。。
 */
public class FileDemo7 {

    public static void main(String[] args) {

        File file = new File("C:\\Users\\lml\\Downloads\\aaa");

        Map<String, Integer> count = getCount(file);
        System.out.println(count); //{jpg=9, txt=4, xlsx=1, avi=1, doc=4}

    }

    /**
     * 统计文件夹下面的 各种文件格式 个数
     * 并打印
     *
     *  使用了 map 的统计思想
     *
     *        因为是递归方法，
     *        所以其中的 局部变量怎么能产生关系?
     *
     *        就是在调用递归之后，回到当前方法，把递归的值，返回给当前
     *
     */
    public static Map<String, Integer> getCount(File src) {

        HashMap<String, Integer> hm = new HashMap<>();

        File[] files = src.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isFile()) {
                    //如果当前是文件，判断文件的 格式 并记录
                    String name = file.getName();
                    //注意这里的截取 点 要加 双反斜线
                    String[] split = name.split("\\.");
                    if (split.length >= 2) {
                        //这里是有后缀名的文件才进行统计
                        //a.txt 统计 //a.a.b,txt 统计
                        // aaa无后缀名 不统计
                        //利用Map 进行统计
                        String suffix = split[split.length - 1]; //后缀
                        if (hm.containsKey(suffix)) {
                            //map中已经存在这个 格式 如：txt
                            Integer count = hm.get(suffix);
                            count++;
                            hm.put(suffix, count);
                        } else {
                            //第一次添加
                            hm.put(suffix, 1);
                        }
                    }
                } else {
                    //不是文件，是文件夹（递归）结果是子文件夹的统计
                    // hm {txt=3,doc=4,jpg=1 }
                    // map{txt=1,doc=1,jpg=1,xlsx=1}
                    Map<String, Integer> map = getCount(file); //走到这一步，下面就先不看，再旁边想象新的方法，结果放在这里
                    //遍历map
                    map.forEach((k, v) -> {

                        if (hm.containsKey(k)) {
                            Integer count = hm.get(k);
                            // 说明已经有 这个后缀
                            hm.put(k, v + count);
                        } else {
                            //这里表示hm中不存在的 key格式值
                            hm.put(k, v);
                        }
                    });
                }
            }
        }
        return hm;
    }
}

```

### 5.递归方法中的局部变量怎么处理

```java

/**
 * 统计一个文件夹内所有文件的总大小
 */
public class FileDemo8 {

    public static void main(String[] args) {

        /**
         *
         * 1.先路径定义到 这个文件夹
         * 2. 将文件夹展开
         *     如果是文件直接统计大小
         *     如果是文件夹，继续递归第2步
         *     最终将所有的文件大小加在一起
         *  3.返回统计值
         *
         *
         */
        //这里统计 aaa文件夹总大小
        File file = new File("C:\\Users\\lml\\Downloads\\aaa");

        Long size = countTotalSize(file);
        System.out.println(size);


    }

    private static Long countTotalSize(File src) {
        //注意这个length是局部变量，第二次递归的时候，这个值就又变成了0
        // 怎么解决？把递归的结果加在第一次执行时length上面。
        // 执行到递归时，就想旁边有一个一模一样的方法，它的计算和 当前方法执行 没有关系
        long length = 0;
        File[] files = src.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isFile()) {
                    //如果是文件，直接算出大小
                    length = length + file.length();
                } else {
                    length = length + countTotalSize(file);
                }
            }
        }
        return length;
    }
    
}
```







---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>



</escape>

----

