---
title: 6.mysql第09章子查询
date: 2019-10-03 14:00:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- mysql8.0.22
categories:   # 添加博文分类
	- mysql8.0.22


---

<h1><center>子查询</center></h1>



### 一、子查询



```mysql
/**
  子查询:
 */
# 需求：员工表中，比Abel的工资高的都有那些

select last_name,salary
from employees
where salary>(select salary
              from employees
              where last_name='Abel');

/**
  子查询的分类
  我们按内查询的结果返回一条还是多条记录,将子查询分为 单行子查询 、 多行子查询 。
 */

/**
    单行子查询：
  因为，单行子查询的返回结果，只有一行，就一个值，所以可使用 = > >= < <= <> 进行比较操作
  例如：
  题目:查询工资大于149号员工工资的员工的信息
 */
select last_name,salary
from employees
where salary>(
    select salary from employees where employee_id='149' #10500
    );

# 题目:返回job_id与141号员工相同,salary比143号员工多的员工姓名,job_id和工资

select  last_name,job_id,salary
from employees
where job_id=(select job_id from employees where employee_id='141')
and salary>(select salary from employees where employee_id='141');

# 题目:返回公司工资最少的员工的last_name,job_id和salary
select last_name,job_id,salary
from employees
where salary=(
    select min(salary) from employees
    );

# 题目:查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id, manager_id,department_id
select employee_id,manager_id,department_id
from employees
where manager_id in (select  manager_id from employees where employee_id in(141,174))
and department_id in (select  department_id from employees where employee_id in(141,174))
and employee_id not in (141,174);

/**
   HAVING 中的子查询
    首先执行子查询。
    向主查询中的HAVING 子句返回结果。
 */
# 题目:查询最低工资
# 大于 50号部门最低工资
# 的部门 id和其最低工资
select  department_id,min(salary)
from employees e
group by department_id
having min(salary) > (
                select min(salary)
                from employees
                where department_id=50
                group by department_id
    );


/**
   CASE中的子查询
    在CASE表达式中使用单列子查询:
 */
#
# 题目:显式员工的 employee_id,last_name和location。
# 其中,若员工department_id
# 与   location_id为1800 的department_id相同,20
# 则location为’Canada’,其余则为’USA’。

select employee_id,last_name, (case department_id
                                when (
                                    select department_id from departments
                                    where location_id=1800
                                    ) then 'Canada'
                                else 'USA' end ) location

from employees;



/*-------------------------------------------------------------------------------------------------------*/
/**
  多行子查询
   子查询的结果，是多行的，所以使用多行比较操作符
多行比较操作符
    in 等于列表中的任意一个
    ANY 需要和单行比较操作符一起使用,和子查询返回的某一个值比较
    ALL 需要和单行比较操作符一起使用,和子查询返回的所有值比较
    SOME 实际上是ANY的别名,作用相同,一般常使用ANY
 */
# 题目:返回
# 其它job_id中比   job_id为‘IT_PROG’部门 任一工资低
# 的 员工的员工号、姓名、job_id 以及salary

#
# select d.department_id,e.salary
# from employees e join departments d
#     on e.department_id=d.department_id
# where e.job_id='IT_PROG';


select employee_id,last_name,job_id,salary
from employees
where salary< any(
    select salary from employees where job_id='IT_PROG'
    )
and job_id <> 'IT_PROG';

select * from departments;


# 题目:查询平均工资最低的部门id
# 将 虚拟表。作为 from后面的表进行查询
# 查询了员工所在的所有部门的 平均工资
select department_id,avg(salary) t_dep_gr_avgsalary
from employees
group by department_id;


# 平均工资最低是多少
select  min(t_dep_gr_avgsalary)
from (select avg(salary) t_dep_gr_avgsalary
from employees
group by department_id) dept_avg_sal ;


select department_id,avg(salary) t_dep_gr_avgsalary
from employees
group by department_id
having avg(salary) = (select  min(t_dep_gr_avgsalary)
from (select avg(salary) t_dep_gr_avgsalary
from employees
group by department_id) dept_avg_sal);


/**
  相关子查询：外部的表，存在于内部子查询当中

    如果子查询的执行依赖于外部查询,通常情况下都是因为子查询中的表用到了外部的表,并进行了条件
    关联,因此每执行一次外部查询,子查询都要重新计算一次,这样的子查询就称之为 关联子查询 。

        步骤是： 1.外查询，先查询到了107条记录。
                2.将第一条记录取出来，送进子查询中，送进来的这条记录，使用外表的这条记录，获取到employee_id。查出子查询的结果
                3.将子查询的结果，返回到外查询，继续外查询语句的过滤条件，得到最终结果

  题目:查询员工中工资 大于 本部门平均工资的员工的last_name,salary和其department_id
   :这里的相关子查询，子查询中使用主查询中的列
 */

select last_name, e.employee_id ,salary
from employees e
where salary > (select avg(salary)
                from employees em
                where em.department_id=e.employee_id
);


/**
  相关子查询， 子查询在 from 后面
  from型的子查询:子查询是作为from的一部分,子查询要用()引起来,并且要给这个子查询取别
    名, 把它当成一张“临时的虚拟的表”来使用。
 */
 #:查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id
SELECT last_name,salary,e1.department_id
FROM employees e1,(
                    SELECT department_id,AVG(salary) dept_avg_sal
                    FROM employees
                    GROUP BY department_id) e2
WHERE e1.`department_id` = e2.department_id
AND e2.dept_avg_sal < e1.`salary`;

/**
  在ORDER BY 中使用 相关子查询:
  题目:查询员工的id,salary,按照department_name 排序
 */
select  distinct department_name
from employees e2  left join departments d
on e2.department_id = d.department_id;

# select e1.last_name, e1.employee_id,e1.salary
# from employees e1
# order by (select  distinct department_name
# from employees e2  left join departments d
# on e2.department_id = d.department_id
#     where e1.employee_id=e2.employee_id) asc;

SELECT employee_id, salary
FROM employees e
ORDER BY (
             SELECT department_name
             FROM departments d
             WHERE e.`department_id` = d.`department_id`
         );


/**
  EXISTS 与 NOT EXISTS关键字
  关联子查询通常也会和 EXISTS操作符一起来使用,用来检查在子查询中是否存在满足条件的行。
        如果在子查询中不存在满足条件的行:
        条件返回 FALSE
        继续在子查询中查找
        如果在子查询中存在满足条件的行:
        不在子查询中继续查找
        条件返回 TRUE
        NOT EXISTS关键字表示如果不存在某种条件,则返回TRUE,否则返回FALSE。
 */

#  题目:查询公司 管理者的 employee_id, last_name, job_id,department_id 信息
# 方法一：表自连接
SELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_id
FROM
 employees e1 JOIN employees e2
WHERE e1.employee_id = e2.manager_id;
# 方法二、
SELECT employee_id, last_name, job_id, department_id
FROM employees e1
WHERE EXISTS(SELECT *
             FROM employees e2
             WHERE e2.manager_id =
                   e1.employee_id);


# 查询    departments表 中 不存在于 employees表中的部门     的department_id和department_name
SELECT department_id, department_name
FROM departments d
WHERE NOT EXISTS (SELECT 'X'
FROM
 employees
WHERE
 department_id = d.department_id);

/**
  ------------------------------------------------------------------------
  子查询练习
 */
#1.查询和Zlotkey相同部门的员工姓名和工资

select e1.department_id ,e1.last_name,e1.salary from employees e1
where  e1.department_id =(select department_id from employees e2 where e2.last_name='Zlotkey');

#2.查询  工资比公司平均工资高的  员工的员工号,姓名和工资。
select employee_id,last_name,salary
from employees
where salary>(select avg(salary) from employees);
#公司的平均工资
select avg(salary) from employees;

#3.选择工资大于 所有JOB_ID = 'SA_MAN'的员工的工资 的员工的last_name, job_id, salary

select last_name,job_id,salary
from employees
where salary> all(select salary from employees
where job_id='SA_MAN');
#所有JOB_ID = 'SA_MAN'的员工的工资
select salary from employees
where job_id='SA_MAN'

#4.查询   和姓名中包含字母u的员工 在 相同部门 的员工   的员工号和姓名
select employee_id,last_name
from employees
where department_id in (select distinct department_id  from employees
where last_name like '%U%');
# 查询和   姓名中包含字母u的员工 在相同部门的员工
# 查询姓名中包含字母u的员工 的部门id
select distinct department_id  from employees
where last_name like '%U%';


#5.查询在 部门的location_id为1700的部门工作的 员工的员工号

select employee_id ,last_name
from employees
where department_id in(
                        select department_id
                        from departments
                        where location_id='1700'
                      );

# 查询 location_id为1700的部门id号
select department_id
from departments
where location_id='1700';

#6.查询管理者是King的员工姓名和工资

select last_name, salary,manager_id
from employees
where manager_id=(select employee_id
from employees
where last_name='King' and manager_id is null);
# 查询King 管理者的 employee_id
select employee_id
from employees
where last_name='King' and manager_id is null ;


#7.查询工资最低的员工信息: last_name, salary
select last_name,salary
from employees
where salary=(select min(salary) from employees);

#查询员工表的最低工资是多少
select min(salary)
from employees;

#8.查询平均工资 最低的部门信息




#查找各个部门的平均工资
select  avg(salary) avg_salary
from employees
group by department_id;
# 查找部门的最低工资
select min(avg_salary)
from (select  avg(salary) avg_salary
from employees
group by department_id) t_avg_em;
# 查找最低工资的部门
select *
from departments
where department_id=(
        select department_id from employees
        group by department_id
        having avg(salary)=(
                            select min(avg_salary)
                            from (
                            select  avg(salary) avg_salary
                            from employees
                            group by department_id) t_avg_em
                            )
                    );



#9.查询平均工资 最低的部门 信息  和  该部门的平均工资(相关子查询)
select  department_id,avg(salary)
from employees
group by department_id
having avg(salary)<=ALL (
    #求出每个部门的平均工资
                select avg(salary)
                from employees
                group by department_id
);

# 记住一点：这种子查询，就抓住，子查询后出来的值




#10.查询平均工资最高的 job 信息
# 注意：看题目，题目要查job信息，肯定是 from jobs表,然后再去凑条件
select * from jobs;

# 查询每个工种的 平均工资
select job_id,avg(salary)
from employees
group by job_id;

# 查询  平均工资最高的 工种 job_id
select job_id
from employees
group by job_id
having avg(salary)>=ALL (
        select avg(salary)
        from employees
        group by job_id
);
#最终
select * from jobs
where job_id=(select job_id
from employees
group by job_id
having avg(salary)>=ALL (
        select avg(salary)
        from employees
        group by job_id
));

#11.查询 平均工资  高于 公司平均工资 的部门有哪些?
select * from
departments;

#查询公司的平均工资
select avg(salary)
from employees;

# 查询部门的平均工资
select department_id,avg(salary)
from employees
group by department_id;

# 查询 平均工资  高于 公司平均工资 的部门有哪些?
select department_id,avg(salary)
from employees
where department_id is not null
group by department_id
having avg(salary) >(
    select avg(salary)
    from employees
    ) ;


#12.查询出公司中所有 manager(管理者) 的详细信息
# manager也是员工
# 这题只要是，将employees表，想象成两张表，一张是员工表，一张是 管理者表。
# 只要 员工表的 员工id=管理者表中的 管理id ,那么这个人这条记录就是管理者
# 自连接查询
select * from employees;

select DISTINCT em.employee_id, em.last_name, em.salary
from employees em join employees ma
on em.employee_id=ma.manager_id;
#方法2
SELECT employee_id, last_name, salary
FROM employees
WHERE employee_id IN (
    SELECT DISTINCT manager_id
    FROM employees
);
#相关子查询   查询第一行时， 外查询的条件，进入到内查询，内查询执行使用外查询条件。完毕。 跳出内查询，到外查询继续执行
#方式3:  where 后面判断 存在 EXISTS 存在返回true
SELECT employee_id, last_name, salary
FROM employees e1
WHERE EXISTS(SELECT *
             FROM employees e2
             WHERE e2.manager_id = e1.employee_id);


#13.各个部门中 最高工资中 最低的那个部门的 最低工资是多少?
# 求各个部门的最高工资
# 将各个部门的最高工资进行比较，最低的那个部门的工资是多少

#从最高工资中找到最低工资
select min(mx_salary)
from (
    # 求各个部门的最高工资
    select  max(salary) mx_salary
    from employees
    group by department_id ) a;

# 抓住核心思想，求什么就先把字段写好，后面再往上面凑
select department_id, salary
from employees
where department_id =
(select department_id
from employees
group by department_id
having max(salary) =
       (select max(salary) m_sa
        from employees
        group by department_id
        order by m_sa
        limit 0,1
       ));


#14.查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary
# 求平均工资最高的部门id
select department_id
from employees
group by department_id
having avg(salary)>=ALL (
    select avg(salary)
    from employees
    group by department_id
);

#求这个平均工资最高的部门中，多个管理者的 id
select distinct manager_id
from employees
where department_id  =(
    #查询平均工资最高的部门
    select department_id
    from employees
    group by department_id
    having avg(salary) >= ALL (
        #每个部门的平均工资
        select avg(salary)
        from employees
        group by department_id
    )
);
# 查询员工表
select employee_id, last_name, department_id, email, salary
from employees
where employee_id in (
    select distinct manager_id
    from employees
    where department_id = (
        #查询平均工资最高的部门
        select department_id
        from employees
        group by department_id
        having avg(salary) >= ALL (
            #每个部门的平均工资
            select avg(salary)
            from employees
            group by department_id
        )
    )
);




#15. 查询部门的部门号,其中不包括job_id是"ST_CLERK"的部门号

# 查询所有部门，然后排除 Job_id是"ST_CLERK"的部门

# 查询 Job_id是"ST_CLERK"的 所有部门id
select department_id
from employees
group by department_id,job_id
having job_id='ST_CLERK';


select department_id
from departments
where department_id not in(
        select department_id
        from employees
        group by department_id,job_id
        having job_id='ST_CLERK'
    );
#相关子查询，将部门表作为主体，条件来判断是不是为真。满足就输出，不满足就继续下一行
SELECT department_id
FROM departments d
WHERE NOT EXISTS(
        SELECT *
        FROM employees e
        WHERE d.`department_id` = e.`department_id`
          AND job_id = 'ST_CLERK'
    );




#16. 选择所有 没有管理者的员工的last_name

# 查询 管理者的id为null的 员工信息

select *
from employees
where manager_id is null ;

# 查询所有管理者的id
# 员工的管理者，与其匹配，不在里面的 记录一行

select *
from employees e1 # e1看作员工表
where not exists(
        select * from employees e2 #e2看作管理员表
        where e1.manager_id=e2.employee_id
    );

#17.查询员工号、姓名、雇用时间、工资, 其中员工的 管理者为 'De Haan'

# 查询 last_name='De Haan'的员工号
select * from employees where last_name='De Haan';# employee_id =102

select employee_id,last_name,hire_date,salary
from employees
where manager_id=(
    select employee_id from employees where last_name='De Haan'
    );


#18.查询   各部门中工资 比本部门平均工资高    的员工的员工号, 姓名和工资(相关子查询)

#查询各个部门中的工资(所有人的工资)
# 必须以部门和人分组，不能以部门和工资分组，工资有可能 两个人一样的。也被合并了。错误的
select employee_id, last_name, salary
from employees e1
group by department_id, employee_id
having salary>(
    select  AVG(salary)
    from employees e2
    where e1.department_id=e2.department_id
    group by department_id
    );


# 错误的分组
select department_id,salary
from employees
group by department_id, salary;


# 查询各个部门的 平均工资
select department_id,AVG(salary)
from employees
group by department_id;




#19.查询每个部门下的部门人数大于 5 的部门名称(相关子查询)

# 查询每个部门，部门下的 人数
# 思考，部门表，和 员工表 相关查询

select *
from departments d
where 5<(
    select count(1)
    from employees e
    where d.department_id=e.department_id
    ) ;

# 某个部门下的人数
select count(1)
from employees
where department_id='90';



#20.查询每个国家下的部门个数大于 2 的国家编号(相关子查询)

select * from countries;

# 查看部门在哪国家

select *
from departments;
select *
from locations;

# 查询国家countries表

select * from countries  c
where 2<(
        select count(1)
        from departments d  join locations l
        on d.location_id=l.location_id
        where  c.country_id=l.country_id
    );


# 所有部门所在的城市
select d.department_id,l.country_id
from departments d  join locations l
on d.location_id=l.location_id;


SELECT country_id
FROM locations l
WHERE 2 < (
    SELECT COUNT(*)
    FROM departments d
    WHERE l.`location_id` = d.`location_id`
);


```







---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>






</escape>

----



