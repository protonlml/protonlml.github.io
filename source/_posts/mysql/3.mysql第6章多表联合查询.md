---
title: 3.mysql第6章多表联合查询
date: 2019-10-03 10:00:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- mysql8.0.22
categories:   # 添加博文分类
	- mysql8.0.22


---

<h1><center>多表联合查询.md</center></h1>



```mysql
/**
  第六章：多表联查
        在现实情况中，查询字段不在同一张表中，就需要多张表进行联合查询
        多表联查，需要有 连接条件
  注意：在多表联查的时候，多张表请务必取别名，使用别名，指定字段是哪个表中的，这样提高查询的速度

  sql 的执行顺序是：
        1.先执行from 挑出表
            from 表1，表2.(挑出这两个表来)
        2.执行where 筛选条件，以及后面的语句
            where 筛选条件
            order by
            limit 0,10;
        3.最后挑选出需要的字段
            select 指定字段
  所以在from 后面给表起了别名，就会覆盖原表名，在后续的order by ...等等的语句中，必须使用表的别名来指定
 */

## 查询员工表
select *
from employees;
## 查询部门表
select *
from departments;


/**
   sql  99版本的写法
        多表联查
        两个 交表，又叫两个表联查
    多表查询的分类
        角度1： 等值连接 vs 非等值连接
        角度2： 自连接 vs 非自连接
        角度3： 内连接 VS 外连接
 */

## 将 员工表和部门表进行联合查询
## 这种92写法 不用
## 等值连接
select *
from employees e,
     departments d
where e.department_id = d.department_id;

## 非等值连接
select *
from employees e,
     job_grades jg
where e.salary between jg.lowest_sal and jg.highest_sal;

/**
  自连接 VS 非自连接
    表：表，自己连接自己
 */
# 自连接，练习：查询员工id 员工姓名 及其管理者id以及姓名
# 思路：管理者也是员工，员工表自己连接自己，将一张表看作是 员工表，另一张表看作是 管理者表
# 内连接：使用 join  on  (取两个表交集的结果，满足on 条件的所有结果)
# 得到的结果是 满足on 后面的 条件的
select e.employee_id, e.last_name, e.manager_id, gl.employee_id, gl.last_name, gl.manager_id
from employees e
         join employees gl
              on e.employee_id = gl.manager_id
order by e.salary desc;



/**
  内连接vs外连接

  内连接：合并具有同一列的两个以上的表的行，结果集中 不包含一个表与另一个表不匹配的行
  外连接：合并具有同一列的两个以上的表的行,结果集中除了包含一个表与另一个表匹配的行之外,还查询到了左表或右表中不匹配的行。
            左外连接：查询的结果集中，包含左表的所有值(左表中不匹配的行,也会存在)，以及on后面条件，两个表之间匹配的行
            右外连接：查询的结果集中，包含右表的所有值(右表中不匹配的行,也会存在)，以及on后面条件，两个表之间匹配的行
            满外连接：左表，右表所有的匹配的行取出来，也包括有 左表不匹配的行，以及右表不匹配的行。
    左外连接:两个表在连接过程中除了返回满足连接条件的行以外，还返回左表中不满足条件的行。
    右外连接:两个表在连接过程中除了返回满足连接条件的行以外，还返回右表中不满足条件的行。
 */
/**
  内连接
   employees员工表107行数据。 departments是 部门表
  # 下面语句结果集有106行，因为employees员工表中有一个人的 department_id为null 它没有部门，所以结果中没有它
    # 其他所有人都有 department_id ，所有人都有部门。所以结果 106条（取两表匹配的行组成结果集，取交集）
  练习：查询员工 last name 姓名 ,department_name部门姓名 信息（这里面是查询员工的，部门信息，有的员工没有存在任何一个部门那么结果就不返回，这里是内连接取交集）
 */
select *
from employees e
         join departments d on e.department_id = d.department_id;

/**
  # 左外连接
  employees员工表107行数据。 departments是 部门表
   练习：查询所有的员工 last name 姓名 ,department_name部门姓名 信息
  （这里面是查询所有员工的，部门信息，即使员工不存在部门，员工信息也要返回，所以是 左外连接 查询，查询结果是 所有员工匹配所有部门的行，以及包括不存在部门的员工信息行也在结果集中）
# 结果是 左表所有值，以及 满足条件的交集值
# 结果107行，虽然employees员工表中King的 department_id为null 它没有部门，但是这个left join 左表所有员工都展示出来，交表部分没有值就null 着
#                                                                               department_id
# 178,Kimberely,Grant,KGRANT,011.44.1644.429263,1999-05-24,SA_REP,7000,0.15,149,    null,       null,null,null,

 */
select *
from employees e
         left join departments d on e.department_id = d.department_id;


/**
  满外连接
   mysql 不支持满外连接 FULL JOIN ON
   可以通过其他方式实现满外链接

  一般在使用满外链接，使用到合并多个结果集的操作

  使用 UNION 操作符 合并查询结果
  UNION操作符返回两个查询的结果集的并集,去除重复记录.（多一步去重操作）
  开发中一般使用
    UNION ALL  进行 两个查询结果集求并集，不去重，效率高
结论:如果明确知道合并数据后的结果数据不存在重复数据,或者不需要去除重复的数据，则尽量使用UMION ALL语句,以提高数据查询的效率

 */

```









## 二、七种JOIN的实现

![Snipaste_2024-10-08_23-15-32](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202410082319686.jpg)

```mysql
# 中图：内连接（只要两表之间的共同满足条件的部分）
select e.employee_id,d.department_name
from employees e join departments d
on e.department_id = d.department_id;

# 左上图：左外连接
select e.employee_id,d.department_name
from employees e left join departments d
                   on e.department_id = d.department_id;

# 右上图：右外连接
select e.employee_id,d.department_name
from employees e right join departments d
                    on d.department_id = e.department_id;

# 左中图
select e.employee_id,d.department_name
from employees e left join departments d
on e.department_id=d.department_id
where d.department_id is NULL;

#右中图
select e.employee_id,d.department_name from
employees e right join departments d
on e.department_id = d.department_id
where e.department_id is null;

# 左下图：满外链接
# 实现满外链接查询
#  方法一： 使用 左上图和右中图，进行UNIN ALL 合并结果集，并给这两个图没有重复部分，所以可以使用UNIN ALL 不用去重操作，效率还快
select e.employee_id,d.department_name from
employees e
left join departments d
on e.department_id=d.department_id # (左外连接)
UNION ALL
select e.employee_id,d.department_name
from employees e right join departments d
    on d.department_id = e.department_id
where e.department_id is null ;

# 方法二：
# 左中图和右上图 合并
select e.last_name, e.manager_id, e.department_id, d.department_name, d.department_id
from employees e
         left join departments d
                   on e.employee_id = d.manager_id # 左外连接 去除结果中匹配的行，只剩下一个不匹配的
where e.department_id is null
UNION ALL# 合并结果集
select e.last_name, e.manager_id, e.department_id, d.department_name, d.department_id
from employees e
         right join departments d
                    on e.department_id = d.department_id;# 右外连接，得到满足条件的所有行，以及右表的所有数据

# 上面两个结果及合并，正好是满外链接。上面两个结果集，不存在重复的数据，直接使用UNION ALL 就可以还提升效率




# 右下图：满外链接，去除 满足条件的中间公共部分
# 使用左中图和右中图进行合并 UNION ALL
select e.employee_id,d.department_name from employees e
left join departments d
on e.department_id=d.department_id
where e.department_id is null
UNION ALL
select e.employee_id,d.department_name from employees e
right join departments d
on d.department_id=e.department_id
where e.department_id is null ;
```

## 注意:

我们要 控制连接表的数量 。多表连接就相当于嵌套 for 循环一样,非常消耗资源,会让 SQL 查询性能下
降得很严重,因此不要连接不必要的表。在许多 DBMS 中,也都会有最大连接表的限制。

> 【强制】超过三个表禁止 join。需要 join 的字段,数据类型保持绝对一致;多表关联查询时, 保
> 证被关联的字段需要有索引。
> 说明:即使双表 join 也要注意表索引、SQL 性能。
> 来源:阿里巴巴《Java开发手册》

## 多表查询练习

```mysql

/**
  # 练习:
# 1.显示所有员工的姓名,部门号和部门名称。
# 2.查询90号部门员工的job_id和90号部门的location_id
# 3.选择所有有奖金的员工的 last_name , department_name , location_id , city
# 4.选择city在Toronto工作的员工的 last_name , job_id , department_id , department_name
# 5.查询员工所在的部门名称、部门地址、姓名、工作、工资,其中员工所在部门的部门名称为’Executive’
# 6.选择指定员工的姓名,员工号,以及他的管理者的姓名和员工号,结果类似于下面的格式
# 7.查询哪些部门没有员工
# 8. 查询哪个城市没有部门
# 9. 查询部门名为 Sales 或 IT 的员工信息
 */

 # 1.显示所有员工的姓名,部门号和部门名称。
# 注意这里是所有员工,就要求 员工表的所有数据都显示出来

select * from employees;
select * from departments;

select e.last_name,e.department_id,d.department_name
from employees e left join departments d
on e.department_id=d.department_id;


# 工作职位等级,最低最高工资
select * from job_grades;
# 工作时间记录 入职时间,离职时间
select * from job_history;
# 工作表 工作名称 最高工资,最低工资
select * from jobs;
#实际住址表
select * from locations;


# 2.查询 90号部门  员工的job_id和90号部门的location_id
# 思路  内连接 员工表和部门表,找到所有员工存在部门的数据集
# 员工表中有 部门id, 部门表 departments 中 有 location_id 地址id

select e.job_id,d.location_id
from departments d join employees e
on d.department_id=e.department_id
where d.department_id=90;


# 3.查询所有 有奖金的员工的 last_name , department_name , location_id , city
# 这里面 有个人,有奖金,但是没有部门,也要显示出来,对应也没有城市,也要显示出来
# 所以都是左外连接
select e.last_name,d.department_name,l.location_id,l.city
from employees e
left join departments d
on e.department_id=d.department_id
left join locations l
on d.location_id=l.location_id
where e.commission_pct is not null ;

#4.选择city在Toronto 工作的员工的 last_name , job_id , department_id , department_name

select e.last_name,e.job_id,e.department_id,d.department_name
from employees e  join departments d
on e.department_id=d.department_id
 join locations l
    on d.location_id = l.location_id
where l.city='Toronto';

# 总结: 写多表联查的时候,先看字段来自于哪些表,再看表与表之间用什么字段连接, 先直接写join on 连接,写完后再考虑是外连接还是内连接;

# 5.查询员工所在的 部门名称、部门地址、姓名、工作、工资, 其中员工所在部门的部门名称为’Executive’

select d.department_name,l.street_address,e.last_name,e.job_id,e.salary
from departments d join employees e
 on d.department_id = e.department_id
join locations l on d.location_id = l.location_id
where d.department_name='Executive';


# 6.选择 指定员工 的姓名,员工号,以及他的管理者的姓名和员工号,结果类似于下面的格式
# employees  Emp # manager Mgr#
# kochhar  101  king  100
select * from employees;
# 员工表的自连接
select Emp.last_name,Emp.employee_id,Mgr.last_name,Mgr.employee_id
from employees Emp left join  employees Mgr
on Emp.manager_id=Mgr.employee_id;

# 7.查询哪些部门没有员工
select * from employees e right join departments d on e.department_id = d.department_id
where e.employee_id is null;
# 8. 查询哪个城市没有部门
desc locations;
desc departments;

select l.city,d.location_id
from departments d right join locations l on d.location_id = l.location_id
where d.location_id is  null;

# 从from 后面 开始读,departments 部门表和 locations 地址表 连接
# (on 后面的条件 可先想两个表之间是 多对多 还是 1对多,如上 部门可以存在 多个 城市中,on后面是取部门在这个城市的行, 部门也可以不在这个城市 部门的locationid也可以是null 如果是left join 表示 部门不存在城市中的值也要 )
# on 后面的意思是
# 部门表中 有 location_id 地址id 的数据全部取出来.
# 如果 部门表中的某一行中的 地址id 是null 这个部门没有对应的城市

# 反之: join  表示 location 表中的 部门存在的数据 全部取出来
#      right join  表示地址表 location 表 的所有数据取出来,包括有城市,不存在部门,部门id为null的数据也取出来.
# where d.location_id is  null; 表示交表后结果集取出,部门是null的数据,就是城市没有部门的数据


select * from locations;

# 9. 查询  部门名为 Sales 或 IT 的 员工信息
select e.last_name,d.department_name
from employees e join departments d on e.department_id=d.department_id
where d.department_name in ('Sales','IT');


```



## 练习 二

```mysql
 #1.所有有门派的人员信息
#     ( A、B两表共有)
select * from t_dept;# 门派表

select * from t_emp;# 人员表

select * from
t_dept d left join t_emp e
on d.id=e.deptId;

# on 后面 读作 门派中有 人 的数据 取出来.
# 题目中要求所有门派,那么门派中也可能没有人,所以使用的是 left join 左外连接, 将所有门派给取出来.
# 门派中有人,门派中没人都取出来
```























---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>





</escape>

----



