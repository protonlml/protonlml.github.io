---
title: 9.mysql第12章数据类型精讲
date: 2019-10-03 17:00:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- mysql8.0.22
categories:   # 添加博文分类
	- mysql8.0.22




---

<h1><center>数据类型精讲</center></h1>

## 1. MySQL中的数据类型

![image-20241102232236359](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022322751.png)

## 常见数据类型的属性,如下: 

![image-20241102232308544](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022323536.png)



## 2. 整数类型

### 2.1 类型介绍

整数类型一共有 5 种,包括 TINYINT、SMALLINT、MEDIUMINT、INT(INTEGER)和 BIGINT。

它们的区别如下表所示:

![image-20241102232401099](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022324114.png)

### 2.2 适用场景

 >TINYINT :一般用于枚举数据,比如系统设定取值范围很小且固定的场景。
 >SMALLINT :可以用于较小范围的统计数据,比如统计工厂的固定资产库存数量等。
 >MEDIUMINT :用于较大整数的计算,比如车站每日的客流量等。
 >INT、INTEGER :取值范围足够大,一般情况下不用考虑超限问题,用得最多。比如商品编号。
 >BIGINT :只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证
 >券公司衍生产品持仓等。

### 2.4 如何选择?

在评估用哪种整数类型的时候,你需要考虑 存储空间 和 可靠性 的平衡问题:一方 面,用占用字节数少
的整数类型可以节省存储空间;另一方面,要是为了节省存储空间, 使用的整数类型取值范围太小,一
旦遇到超出取值范围的情况,就可能引起 系统错误 ,影响可靠性。
举个例子,商品编号采用的数据类型是 INT。原因就在于,客户门店中流通的商品种类较多,而且,每
天都有旧商品下架,新商品上架,这样不断迭代,日积月累。
如果使用 SMALLINT 类型,虽然占用字节数比 INT 类型的整数少,但是却不能保证数据不会超出范围
65535。相反,使用 INT,就能确保有足够大的取值范围,不用担心数据超出范围影响可靠性的问题。
你要注意的是,在实际工作中,系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。因
此,我建议你首先确保数据不会超过取值范围,在这个前提之下,再去考虑如何节省存储空间。 



## 3.浮点类型

### 3.1 类型介绍
浮点数和定点数类型的特点是可以 处理小数 ,你可以把整数看成小数的一个特例。因此,浮点数和定点
数的使用场景,比整数大多了。 MySQL支持的浮点数类型,分别是 FLOAT、DOUBLE、REAL。

- FLOAT 表示单精度浮点数;
- DOUBLE 表示双精度浮点数;

![image-20241102232555529](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022325661.png)

- REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ REAL_AS_FLOAT ”,那 么,MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”,可以通过以下 SQL 语句实现:

  - ```mysql
    SET sql_mode = “REAL_AS_FLOAT”;
    ```



> - 问题1:FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢?
>   - FLOAT 占用字节数少,取值范围小;DOUBLE 占用字节数多,取值范围也大。
> - 问题2:为什么浮点数类型的无符号数取值范围,只相当于有符号数取值范围的一半,也就是只相当于有符号数取值范围大于等于零的部分呢?
>   - MySQL 存储浮点数的格式为: 符号(S) 、 尾数(M) 和 阶码(E) 。因此,无论有没有符号,MySQL 的浮
>     点数都会存储表示符号的部分。因此, 所谓的无符号数取值范围,其实就是有符号数取值范围大于等于
>     零的部分。

### 3.2 数据精度说明

对于浮点类型,在MySQL中单精度值使用 4 个字节,双精度值使用 8 个字节。

从MySQL 8.0.17开始,FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用,将来可能被移除。另外,关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了,将来也可能被移除。

### 3.3 精度误差说明

浮点数类型有个缺陷,就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如,我们设计一个表,有f1这个字段,插入值分别为0.47,0.44,0.19,我们期待的运行结果是:0.47 + 0.44 + 0.19 =1.1。而使用sum之后查询:

​		查询结果是 1.0999999999999999。看到了吗?虽然误差很小,但确实有误差。 你也可以尝试把数据类型改成 FLOAT,然后运行求和查询,得到的是, 1.0999999940395355。显然,误差更大了。
​		那么,为什么会存在这样的误差呢?问题还是出在 MySQL 对浮点类型数据的存储方式上。
​		MySQL 用 4 个字节存储 FLOAT 类型数据,用 8 个字节来存储 DOUBLE 类型数据。无论哪个,都是采用二进制的方式来进行存储的。比如 9.625,用二进制来表达,就是 1001.101,或者表达成 1.001101×2^3。如果尾数不是 0 或 5(比如 9.624),你就无法用一个二进制数来精确表达。进而,就只好在取值允许的范围内进行四舍五入。
​		在编程中,如果用到浮点数,要特别注意误差问题,==因为浮点数是不准确的,所以我们要避免使用“=”来判断两个数是否相等。==同时,在一些对精确度要求较高的项目中,千万不要使用浮点数,不然会导致结果错误,甚至是造成不可挽回的损失。那么,MySQL 有没有精准的数据类型呢?当然有,这就是定点数类型: DECIMAL 。



## 4. 定点数类型

### 4.1 类型介绍

-  MySQL中的定点数类型只有 DECIMAL 一种类型。
- ![image-20241102233224592](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022332185.png)

使用 DECIMAL(M,D) 的方式表示高精度小数。其中,M被称为精度,D被称为标度。0<=M<=65,0<=D<=30,D<M。例如,定义DECIMAL(5,2)的类型,表示该列取值范围是-999.99~999.99。

- ==DECIMAL(M,D)的最大取值范围与DOUBLE类型一样==,但是有效的数据范围是由M和D决定的。
  DECIMAL 的存储空间并不是固定的,由精度值M决定,总共占用的存储空间为M+2个字节。也就是说,在一些对精度要求不高的场景下,比起占用同样字节长度的定点数,浮点数表达的数值范围可以更大一些。
- 定点数在MySQL内部是以 ==字符串== 的形式进行存储,这就决定了它一定是精准的。
- 当DECIMAL类型不指定精度和标度时,其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时,则MySQL同样会进行四舍五入处理。
- ==浮点数 vs 定点数==
  - 浮点数相对于定点数的优点是在长度一定的情况下,浮点类型取值范围大,但是不精准,适用于需要取值范围大,又可以容忍微小误差的科学计算场景(比如计算化学、分子建模、流体动力学等)
  - 定点数类型取值范围相对小,但是精准,没有误差,适合于对精度要求极高的场景 (比如涉及金额计算的场景)

### 4.2 开发中经验

> “由于 DECIMAL 数据类型的精准性,在我们的项目中,除了极少数(比如商品编号)用到整数类型外,其他的数值都用的是 DECIMAL,原因就是这个项目所处的零售行业,要求精准,一分钱也不能差。 ” ——来自某项目经理



## 5. 位类型:BIT

BIT类型中存储的是二进制值,类似010110。

![image-20241102233413752](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022334206.png)

BIT类型,如果没有指定(M),默认是1位。这个1位,表示只能存1位的二进制值。这里(M)是表示二进制的位数,位数最小值为1,最大值为64。

使用SELECT命令查询位字段时,可以用 ==BIN()== 或 ==HEX()== 函数进行读取。

## 6. 日期与时间类型

日期与时间是重要的信息,在我们的系统中,几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签,从而进行数据查询、统计和处理MySQL有多种表示日期和时间的数据类型,不同的版本可能有所差异,MySQL8.0版本支持的日期和时间类型主要有:YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。

- YEAR 类型通常用来表示年
- DATE 类型通常用来表示年、月、日\
- TIME 类型通常用来表示时、分、秒
- DATETIME 类型通常用来表示年、月、日、时、分、秒
- TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒

![image-20241102233649031](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022338787.png)



可以看到,不同数据类型表示的时间内容不同、取值范围不同,而且占用的字节数也不一样,你要根据实际需要灵活选取。
为什么时间类型 TIME 的取值范围不是 -23:59:59~23:59:59 呢?原因是 MySQL 设计的 TIME 类型,不光表示一天之内的时间,而且可以用来表示一个时间间隔,这个时间间隔可以超过 24 小时。

### 6.1 YEAR类型

YEAR类型用来表示年份,在所有的日期时间类型中所占用的存储空间最小,只需要 1个字节 的存储空间。
在MySQL中,YEAR有以下几种存储格式:

- 以4位字符串或数字格式表示YEAR类型,其格式为YYYY,最小值为1901,最大值为2155。
- 以2位字符串格式表示YEAR类型,最小值为00,最大值为99。
  - 当取值为01到69时,表示2001到2069;
  - 当取值为70到99时,表示1970到1999;
  - 当取值整数的0或00添加的话,那么是0000年;
  - 当取值是日期/字符串的'0'添加的话,是2000年。



==从MySQL5.5.27开始,2位格式的YEAR已经不推荐使用==。YEAR默认格式就是“YYYY”,没必要写成YEAR(4),
从MySQL 8.0.19开始,不推荐使用指定显示宽度的YEAR(4)数据类型。

###  6.2 DATE类型

DATE类型表示日期,没有时间部分,格式为 YYYY-MM-DD ,其中,YYYY表示年份,MM表示月份,DD表示日期。需要 3个字节 的存储空间。在向DATE类型的字段插入数据时,同样需要满足一定的格式条件。

- 以 YYYY-MM-DD 格式或者 YYYYMMDD 格式表示的字符串日期,其最小取值为1000-01-01,最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。
- 以 YY-MM-DD 格式或者 YYMMDD 格式表示的字符串日期,此格式中,年份为两位数值或字符串满足YEAR类型的格式条件为:当年份取值为00到69时,会被转化为2000到2069;当年份取值为70到99时,会被转化为1970到1999。
- 使用 CURRENT_DATE() 或者 NOW() 函数,会插入当前系统的日期。

### 6.4 DATETIME类型

DATETIME类型在所有的日期时间类型中占用的存储空间最大,总共需要 8 个字节的存储空间。在格式上为DATE类型和TIME类型的组合,可以表示为 YYYY-MM-DD HH:MM:SS ,其中YYYY表示年份,MM表示月份,DD表示日期,HH表示小时,MM表示分钟,SS表示秒。

在向DATETIME类型的字段插入数据时,同样需要满足一定的格式条件。

- 以==YYYY-MM-DD HH:MM:SS== 格式或者 ==YYYYMMDDHHMMSS== 格式的字符串插入DATETIME类型的字段时,最小值为1000-01-01 00:00:00,最大值为9999-12-03 23:59:59。
  - 以YYYYMMDDHHMMSS格式的数字插入DATETIME==类型的字段时,会被转化为YYYY-MM-DD
    HH:MM:SS格式。
- 以 ==YY-MM-DD HH:MM:SS== 格式或者 ==YYMMDDHHMMSS== 格式的字符串插入DATETIME类型的字段时,两位
  数的年份规则符合YEAR类型的规则,00到69表示2000到2069;70到99表示1970到1999。
- 使用函数 ==CURRENT_TIMESTAMP()== 和 ==NOW()== ,可以向DATETIME类型的字段插入系统的当前日期和
  时间。

#### 举例	

```mysql
#创建数据表,表中包含一个DATETIME类型的字段dt。
CREATE TABLE test_datetime1(
dt DATETIME
);
Query OK, 0 rows affected (0.02 sec)

# 插入数据
INSERT INTO test_datetime1
VALUES ('2021-01-01 06:50:30'), ('20210101065030');
INSERT INTO test_datetime1
VALUES ('99-01-01 00:00:00'), ('990101000000'), ('20-01-01 00:00:00'),
('200101000000');
INSERT INTO test_datetime1
VALUES (20200101000000), (200101000000), (19990101000000), (990101000000);
INSERT INTO test_datetime1
VALUES (CURRENT_TIMESTAMP()), (NOW());
```





### 6.6 开发中经验
​		用得最多的日期时间类型,就是 DATETIME 。虽然 MySQL 也支持 YEAR(年)、 TIME(时间)、DATE(日期),以及 TIMESTAMP 类型,但是在实际项目中,尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息,取值范围也最大,使用起来比较方便。毕竟,如果日期时间信息分散在好几个字段,很不容易记,而且查询的时候,SQL 语句也会更加复杂。

此外,一般存注册时间、商品发布时间等,不建议使用DATETIME存储,而是使用 时间戳 ,因为DATETIME虽然直观,但不便于计算。



## 7. 文本字符串类型

在实际的项目中,我们还经常遇到一种数据,就是字符串数据。
MySQL中,文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、LONGTEXT 、 ENUM 、 SET 等类型。

![image-20241102234617169](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022346720.png)



### 7.1 CHAR与VARCHAR类型

CHAR和VARCHAR类型都可以存储比较短的字符串。

![image-20241102234637669](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022346540.png)

### CHAR类型:

- CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M),则表示长度默认是1个字符。
- 如果保存时,数据的实际长度比CHAR类型声明的长度小,则会在 右侧填充 空格以达到指定的长度。当MySQL检索CHAR类型的数据时,CHAR类型的字段会去除尾部的空格。
- 定义CHAR类型字段时,声明的字段长度即为CHAR类型字段所占的存储空间的字节数。

```mysql
CREATE TABLE test_char1(
c1 CHAR,
c2 CHAR(5)
);
DESC test_char1;
```

### VARCHAR类型:

- VARCHAR(M) 定义时, 必须指定 长度M,否则报错。
- MySQL4.0版本以下,varchar(20):指的是20字节,如果存放UTF8汉字时,只能存6个(每个汉字3字节) ;MySQL5.0版本以上,varchar(20):指的是20字符。
- 检索VARCHAR类型的字段数据时,会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。

```mysql
CREATE TABLE test_varchar3(
NAME VARCHAR(5)
);
INSERT INTO test_varchar3
VALUES('尚硅谷'),('尚硅谷教育');
```



### ==哪些情况使用 CHAR 或 VARCHAR 更好==

![image-20241102234844766](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022348968.png)

> 情况1: 存储很短的信息。比如门牌号码101,201......这样很短的信息应该用char,因为varchar还要占个byte用于存储信息长度,本来打算节约存储的,结果得不偿失。
>
> 情况2:固定长度的。比如使用uuid作为主键,那用char应该更合适。因为他固定长度,varchar动态根据长度的特性就消失了,而且还要占个长度信息。
> 情况3:十分频繁改变的column。因为varchar每次存储都要有额外的计算,得到长度等工作,如果一个非常频繁改变的,那就要有很多的精力用于计算,而这些对于char来说是不需要的。
> 情况4:具体存储引擎中的情况:
>
> - ==MyISAM== 数据存储引擎和数据列:MyISAM数据表,最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化,从而使 ==数据检索更快== ,用空间换时间。
> - ==MEMORY== 存储引擎和数据列:MEMORY数据表目前都使用固定长度的数据行存储,因此无论使用CHAR或VARCHAR列都没有关系,两者都是作为CHAR类型处理的。
> - ==InnoDB== 存储引擎,建议使用VARCHAR类型。因为对于InnoDB数据表,内部的行存储格式并没有区分固定长度和可变长度列(所有数据行都使用指向数据列值的头指针),而且==主要影响性能的因素是数据行使用的存储总量==,由于char平均占用的空间多于varchar,所以除了简短并且固定长度的,其他考虑varchar。这样节省空间,对磁盘I/O和数据存储总量比较好。



### 7.2 TEXT类型

在MySQL中,TEXT用来保存文本类型的字符串,总共包含4种类型,分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。
在向TEXT类型的字段保存和查询数据时,系统自动按照实际长度存储,不需要预先定义长度。这一点和VARCHAR类型相同。
每种TEXT类型保存的数据长度和所占用的存储空间不同,如下:

![image-20241102235053468](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022350635.png)



由于实际存储的长度不确定,MySQL 不允许 TEXT 类型的字段做主键。遇到这种情况,你只能采用
CHAR(M),或者 VARCHAR(M)。

### 举例:

```mysql
# 创建数据表:
CREATE TABLE test_text(
tx TEXT
);
#插入数据
INSERT INTO test_text
VALUES('atguigu
 ');
SELECT CHAR_LENGTH(tx)
FROM test_text; #10
# 说明在保存和查询数据时,并没有删除TEXT类型的数据尾部的空格。
```

### 开发中经验:
TEXT文本类型,可以存比较大的文本段,搜索速度稍慢,因此如果不是特别大的内容,建议使用CHAR,VARCHAR来代替。还有TEXT类型不用加默认值,加了也没用。而且text和blob类型的数据删除后容易导致“空洞”,使得文件碎片比较多,所以频繁使用的表不建议包含TEXT类型字段,建议单独分出去,单独用一个表。





## 8. ENUM类型

ENUM类型也叫作枚举类型,ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时,ENUM类型只允许从成员中选取单个值,不能一次选取多个值。
其所需要的存储空间由定义ENUM类型时指定的成员个数决定。

![image-20241102235312051](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022353961.png)

- 当ENUM类型包含1~255个成员时,需要1个字节的存储空间;
- 当ENUM类型包含256~65535个成员时,需要2个字节的存储空间。
- ENUM类型的成员个数的上限为65535个。

### 举例:
```mysql
# 创建表如下
CREATE TABLE test_enum(
season ENUM('春','夏','秋','冬','unknow')
);
# 添加数据
INSERT INTO test_enum
VALUES('春'),('秋');
# 忽略大小写
INSERT INTO test_enum
VALUES('UNKNOW');
# 允许按照角标的方式获取指定索引位置的枚举值
INSERT INTO test_enum
VALUES('1'),(3);
# Data truncated for column 'season' at row 1
INSERT INTO test_enum
VALUES('ab');
# 当ENUM类型的字段没有声明为NOT NULL时,插入NULL也是有效的
INSERT INTO test_enum
VALUES(NULL);
```



## 13. 小结及选择建议

在定义数据类型时,如果确定是 ==整数== ,就用 ==INT== ; 如果是 ==小数== ,一定用定点数类型==DECIMAL(M,D)== ; 如果是==日期与时间==,就用 ==DATETIME== 。
这样做的好处是,首先确保你的系统不会因为数据类型定义出错。不过,凡事都是有两面的,可靠性好,并不意味着高效。比如,TEXT 虽然使用方便,但是效率不如 CHAR(M) 和 VARCHAR(M)。

关于字符串的选择,建议参考如下阿里巴巴的《Java开发手册》规范:

### ==阿里巴巴《Java开发手册》之MySQL数据库:==

- 任何字段如果为非负数,必须是 UNSIGNED
- 【 ==强制== 】小数类型为 DECIMAL,禁止使用 FLOAT 和 DOUBLE。说明:在存储的时候,FLOAT 和 DOUBLE 都存在精度损失的问题,很可能在比较值的时候,得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围,建议将数据拆成整数和小数并分开存储。
- 【 ==强制== 】如果存储的字符串长度几乎相等,使用 CHAR 定长字符串类型。
- 【 ==强制== 】VARCHAR 是可变长字符串,不预先分配存储空间,长度不要超过 5000。如果存储长度大于此值,定义字段类型为 TEXT,独立出来一张表,用主键来对应,避免影响其它字段索引效率。



---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>






</escape>

----









