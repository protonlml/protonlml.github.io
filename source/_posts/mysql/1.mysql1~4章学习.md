---
title: mysql1~4章学习
date: 2019-10-02 09:00:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- mysql8.0.22
categories:   # 添加博文分类
	- mysql8.0.22

---

<h1><center>sql笔记</center></h1>

## 

```mysql

/**
  SQL 语句的注意事项
    MySQL 在 Windows 环境下是大小写不敏感的
    MySQL 在 Linux 环境下是大小写敏感的
    数据库名、表名、表的别名、变量名是严格区分大小写的
    关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。
    推荐采用统一的书写规范:
    数据库名、表名、表别名、字段名、字段别名等都小写
    SQL 关键字、函数名、绑定变量等都大写
    一句写完使用 ;  结尾

  关于标点符号
    必须保证所有的()、单引号、双引号是成对结束的
    必须使用英文状态下的半角输入方式
    字符串型和日期时间类型的数据可以使用单引号(' ')表示
    列的别名,尽量使用双引号(" "),而且不建议省略as
    select id as "编号", `name` as "姓名" from t_stu; #起别名时,as都可以省略
    select id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格,那么可以省略""
    select id as 编 号, `name` as 姓 名 from t_stu; #错误,如果字段别名中有空格,那么不能省略""

 */

/**
  着重号 ''
 */
##  表名是关键字，查询的时候要加入 '' 单引号，来告诉Mysql这是一个表
select * from `order`;

/**
  0. 查看表结构
        desc 表名;
 */

 DESC  employees;

/**
  1.查询语句
     select * from 表名
 */

select 1+12 from dual; # dual 是一个伪表的概念;

select * from employees;

select  employee_id,employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, manager_id, department_id  from employees;

/**
  2.查询 字段 的别名(列的别名)
        (作用：查询出来的表字段和java对象中的属性值相对应)
        字段名 as "别名"
    简写: 字段名  别名  （别名中不能有空格）

 */
## 取别名，给 每个字段 取别名

desc employees;
# 1直接在字段后面跟着 别名  2 使用 as 关键字来取别名 3 如果别名上面有空格，那么这个别名要使用"" 引起来
select first_name 名字 , last_name 姓氏 , email as 邮箱 , phone_number  "手 机号"  from employees;


/**
  3. 查询结果 去重
     distinct 字段
 */
select distinct department_id from employees;

/**
  4.  空值参与运算，null

      只要字段是null值，那么结果一定是 null
      实际开发中，某个字段值是null 我们想将其看作是 0  ,使用 IFNULL(字段,0);

 */
 # 查询员工一年的工资 （工资+奖金）*12 （有的员工的奖金是null 所以结果是 null ）
select last_name, first_name, salary * (1 + commission_pct) * 12 一年工资
from employees;
# 正确写法：
select last_name, first_name, salary,salary * (1 + IFNULL(commission_pct,0)) * 12 一年工资
from employees;


/**
  5. 查询常数
     特殊场景需要： 查询时，某个字段在每一条记录中都存在，但是又没有表中的字段与之对应。
                 需要返回的结果集中，每一条记录都带有这个常数
 */

select '尚硅谷', employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, manager_id, department_id from employees;


/**
  6. 过滤数据 where  声明在from 后面
      select * from 表名 where 过滤条件

     在MySql中 where 后面的 语句 是一个可以计算得出结果的，条件成立 返回1，条件不成立返回0
 */

select *
from employees
where job_id = 'SH_CLERK';

/**
  --select 查询的基本练习
    1.查询员工12个月的工资总和，并起别名为 ANNUAL SALARY
    2.查询employees表中去除重复的job id以后的数居
    3.查询工资大于12000的 员工姓名和工资
    4.查询员工号为176的员工的姓名和部门号
    5.显示表departments的结构，并查而其中的全部数据
 */
 ## 1.查询员工12个月的工资总和，并起别名为 ANNUAL SALARY
 select salary*(1+IFNULL(commission_pct,0))*12   "ANNUAL SALARY" from employees;
## 2.查询employees表中去除重复的job_id 以后的数据
select distinct job_id
from employees;


##    3.查询工资大于12000的 员工姓名和工资

select last_name,first_name,salary from employees
where salary > 12000;

## 4.查询员工号为176的员工的姓名和部门号
select * from employees
where employee_id=176;

## 5.显示表departments的结构，并查而其中的全部数据
desc departments;
select * from departments;


/**
  select * from jobs;
select * from job_grades;
select * from job_history;
 */
## -----------------------------------------------------------------------##

/**
  运算符
     + - * /   div(除)  %   mod(取模)

 */

 ## 6. + - 运算符,浮点数参与运算，结果就是浮点型
select 12+11, 22-0, 50+13.2 , 55-33.8  from dual;
select 78+'12' from dual;## + 表示 加号，‘’单引号中的数字，隐式转换为数字1
select 12+'e' from  dual;## 'e' 看作是0

## 7. * /(div)
SELECT 100,
       100 * 1,
       100 * 1.0,
       100 / 1.0,
       100 / 2,
       100 + 2 * 5 / 2,
       100 / 3,
       100 DIV 0
FROM dual;

## 练习：查询员工的ID 为偶数的员工信息

select * from employees
where employee_id%2=0;


/**
  比较运算符
     =   <=> （安全等于，为null而生的）
     <>  !=   (不等于)
     < <=
     > >=
比较运算符，返回的是真或者假， 这里真是1 假是0
 */
 select 1=2,1!=2,2<>3 from dual;


## 8.NULL 参与运算，结果还是NULL
## where 后面跟的结果是 null
select * from employees
where commission_pct=null;


## 9.非符号类型的运算符
## IS NULL  ; IS NOT NULL ; ISNULL() 函数

select * from employees
where commission_pct is null ;

select * from employees
where ISNULL(commission_pct);


select * from employees
where commission_pct <=> NULL;


/**

   求最大，最小值
   least(字段1，字段2)
   greatest(字段1，字段2)
 */
# 取字段的最大最小值

select least(salary,employee_id) from employees;


/**
  范围查找
  求区间的值 100 -10000 之间的
    between 100 and 10000;
  相当于
    >= 100 && <=10000;
 */
select * from employees
where salary>=100 && salary<=10000 ;

select * from employees
where salary between 100 and 10000;

## && 相当于 and
select * from employees
where salary >=1000 and salary<=10000;

/**
   查询工资不在100-10000 之间的员工信息
 */

select * from employees
where NOT salary between 100 and 10000;

select * from employees
where salary <100 || salary>10000;
## || 相当于 or
select * from employees
where salary <100 or salary>10000;

/**
    in (set) / not in (set)
    在       或 不在
    离散值的查找
    某个值在不在这个集合中
 */
## 练习1： 查找部门为 10，20，30的部门员工信息
select * from employees
##where department_id=10 or department_id=20 or department_id=30;
where department_id in (10,20,30);

## 练习2：查询员工工资不是 6000 7000 8000 的员工信息

select * from employees
where salary not in(6000,7000,8000);

/**
        like  模糊查询
        % 表示匹配 不确定个数的字符（0个，1个，或者多个）
 */

## 练习: 查询last_name 中包含字符'a' 的员工信息
select * from employees
where last_name like '%a%';
## 练习: 查询last_name 中 第一个是字符'a' 的员工信息
select * from employees
where last_name like 'a%';
## 练习：查咨last_name 中 第二个是字符'a' 的员工信息
## 这里 _ 表示任意字符占第一个位值，
select * from employees
where last_name like '_a%';

## 练习：查询last_name 中包含a 又包含 e 的 员工信息
select * from employees
where last_name like '%a%' and last_name like '%e%';

## 练习： 查询 第二个字符是_ 且 第三个字符是a 的员工信息
##  like '_/_a%'; 表示 第一个字符是任意字符占第一个位置，第二个字符是_ 这里使用 \ 转义了就表示_ ， 第三个字符就是a ，后面%模糊匹配
select * from employees
where last_name like '_\_a%';

/**
  正则表达式
    ^s 表示以s开始
    t$ 表示以t结尾
   用到了查表
 */
 SELECT 'shkstart' REGEXP '^s', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk';

/**
   逻辑运算符
    and  与
    or  或
    not 非
    XOR  异或（两边取不同，左真右假，左假右真，追求的就是这个异）
 */
SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;

## 在10和20部门员工，且工资小于8000的 员工信息
## 不在10和20部门员工，且工资大于8000的员工信息
select last_name,department_id,salary
from employees
where department_id in (10,20) XOR salary > 8000;



/**
   记住 () 的优先级最高
   以后要想先运算谁，就用() 给它包起来
 */



# 记住 least Greatest  只能用在 select 后面的 字段上面。
# where  后面跟的条件，sql先执行where后面的条件，成立返回1，不成立返回0.
# 这里面where 后面跟的 条件根本不能成立
select * from employees
 where 0;


/**
    对字段进行限定的 关键词
       distinct 字段   去除重复的 字段。
       IFNULL(字段,0)  字段为null 则以0参与运算
    求最大，最小值
        least(字段1，字段2)
        greatest(字段1，字段2)
 */

/**
  练习
 */
# 1.选择工资不在5000到12000的员工的姓名和工资
select last_name 姓名, salary 工资 from employees
where salary not between 5000 and 12000;

# 2.选择在20或50号部门工作的员工姓名和部门号
select * from employees em
where em.department_id =20|| em.department_id=50;

select * from employees
where department_id in(20,50);
# 3.选择公司中没有管理者的员工姓名及job_id
select * from employees
where manager_id is null;
# where manager_id <=> null;

# 4.选择公司中有奖金的员工姓名,工资和奖金级别
select * from employees
where commission_pct is not null;

# 5.选择员工姓名的第三个字母是a的员工姓名
select * from employees
where last_name like '__a%';

# 6.选择姓名中有字母a和k的员工姓名
select * from employees
where last_name like '%a%'and last_name like '%k%';

# 7.显示出表 employees 表中 first_name 以 'e'结尾的员工信息
## 正则表达式
select * from employees
where first_name regexp 'e$';

select * from employees
where first_name like '%e';

# 8.显示出表 employees 部门编号在 80-100 之间的姓名、工种
select * from employees
where department_id between 80 and 100;

# 9.显示出表 employees 的 manager_id 是 100,101,110 的员工姓名、工资、管理者id
select * from employees
where manager_id in(100,101,110);







```









---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>




</escape>

----



