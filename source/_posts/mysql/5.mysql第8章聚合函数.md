---
title: 5.mysql第8章聚合函数
date: 2019-10-03 13:00:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- mysql8.0.22
categories:   # 添加博文分类
	- mysql8.0.22

---

<h1><center>聚合函数</center></h1>



### 1.聚合函数类型（记住聚合函数就这5种）

>AVG(字段) 求平均值
>  SUM(字段) 求和
>  MAX(字段) 求最大值
>  MIN(字段) 求最小值
>  COUNT(某字段) 求字段有多少个
>  注意1：聚合函数一般是配合 group by 分组 来使用的
>    select  MAX(salary) from employees;
>  注意2：where 后面不能跟 聚合函数
>  注意3：聚合函数不能嵌套使用

```mysql
/**
  五、聚合函数类型（记住聚合函数就这5种）
  AVG(字段) 求平均值
  SUM(字段) 求和
  MAX(字段) 求最大值
  MIN(字段) 求最小值
  COUNT(某字段) 求字段有多少个
  注意1：聚合函数一般是配合 group by 分组 来使用的
    select  MAX(salary) from employees;
  注意2：where 后面不能跟 聚合函数
  注意3：聚合函数不能嵌套使用

# 练习： 求 所有人中，最高工资的那个人
  错误的写法：
 有矛盾之处，查这张员工表，求出 最大工资的那个，应该是1个结果，而字段中还有last_name字段是表示显示表employees中所有人的姓名，有冲突
 select last_name, MAX(salary) from employees;
 # 正确写法：求 所有人中，最高工资的那个人( 用到子查询)
  select employee_id, last_name, salary from employees
    where salary=(select max(salary)from employees);

 */
select * from employees;
select  MAX(salary) from employees;

# 求 所有人中，最高工资的那个人( 用到子查询)
select employee_id, last_name, salary from employees
where salary=(select max(salary)from employees);

#聚合函数，配合group by 使用：按照部门分组，求出每个部门中最高工资
select department_id,MAX(salary) from employees
group by department_id;

/**
  统计个数的字段
  COUNT()
  # 字段commission_pct有35行有值，null不统计
 */
select COUNT(commission_pct) from employees;

```



### 2.group---by

#### 可以使用GROUP BY子句将表中的数据分成若干组

```mysql
SELECT column, group_function(column)
FROM table
[WHERE
 condition]
[GROUP BY
 group_by_expression]
[ORDER BY
 column];
```

>明确:WHERE一定放在FROM后面

## ☆☆☆group....by... 的sql语句理解☆☆☆

```mysql
select department_id ,avg(salary)  # select 读作 这一个部门中 工资的平均值
from employees
group by department_id; 
# 通过select 后面的 语句，就可以看出分组后的 表张什么样子了
# 这里 肯定是 每一个部门 在第一列， 第二列是 每个部门的 平均工资
#如下图
```

![image-20241014005523571](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202410140055769.png)

```mysql
select department_id,job_id ,avg(salary)  
from employees
group by department_id,job_id;

# 每个部门分组后， 部门里面再按照 工种id(job_id) 进行分组.
# 可以预见查出来的表 ,一个部门，要分多行了，因为一个部门里面有多个工种，每个工种在进行算工资平均值
# 如下图
```

![image-20241014005425668](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202410140054911.png)





```mysql

/**
  --------------------------------------group---by----字段分组的使用-------------------------------------------------
 */

/**
  分组：
对于 group by 分组的理解

# 结论1：在select 后面声明的 字段，除了组函数之外的字段，一定要出现在 group by 后面;
# 反之group by 后面声明的 字段，不一定要出现在 select  后面
# 反正就是，只要出现了分组， 在select 后面声明的字段 ，在 group by 后面要全部都给写上，并且select 后面一定要有一个聚合函数，来计算组意图结果。

# 结论2：group by 声明在from后面、where后面,      order by 排序前面、limit 分页前面。 （可以理解，结果集群都都处理完毕，在进行排序，和分页）
--------------------------------------------------
select department_id,avg(salary)
from employees
group by department_id,job_id;
--------------------------------------------------
select department_id,job_id ,avg(salary)
from employees
group by department_id,job_id;

 */
select * from employees;
# 求所有员工的 工资平均值  AVG = SUM / COUNT(1)
select SUM(salary) / count(1) from employees;
# 求所有员工的 工资平均值
select avg(salary)
from employees;

#

# 查询   每个部门 有多少人
# 先找到employees表
# 然后group by 按照department_id 部门分组，有null,10，20，30，40，50，60，70，80，90，100这12个部门,此时结果集已经形成12条数据，12个部门
# 随后 count(1)  再次限定结果集，将每个部门多少人求出来
select department_id ,count(1)
from employees
group by department_id;

# 每个部门中 的 平均工资是多少
# 求每个部门的 平均工资
select department_id ,avg(salary)
from employees
group by department_id;

# 先找到employees表
#  然后group by 按照department_id 部门分组，在按照 工种job_id 进行 分组。
# 比如90号部门的AD_PRES 在一行，90号部门的AD_VP工种 在一行，求平均工资值。
select department_id,job_id ,avg(salary)
from employees
group by department_id,job_id;

#错误写法 这种错误就是 按照 department_id分组后的结果集，
# 在select 后面的语句，并没有进行操作，只要显示last_name
# 这里 按照 department_id分组后，展示字段last_name ，不可能的事情，是错误的写法
select department_id ,last_name
from employees
group by department_id;


# 错误写法
# 只按照 department_id 进行分组，不能查到job_id 字段
select department_id,job_id,avg(salary)
from employees
group by department_id;

# 结论：在select 后面声明的 字段，除了组函数之外的字段，一定要出现在 group by 后面;
# 反之group by 后面声明的 字段，不一定要出现在 select  后面

/**
  # 结论3.

只要看见sql语句中有group by 就要想，结果集是 进行分组的结果， select 后面的字段，就是分组的字段，聚合函数就是对这分组后的操作。
        如果分组后的结果继续筛选，就要使用having 进行筛选， 后面跟的是聚合函数。
         这里不能使用where ,where  可以直接使用表中的字段作为筛选条件,但不能使用分组中的 聚合函数 作为筛选条件;
  HAVING 必须要与 GROUP BY 配合使用,可以把分组计算的聚合函数和分组字段作为筛选条件。
 */


#按照部门分组，部门有 null,10,20,30,40,50,60,70,80,90,100,110
select department_id  from employees
group by department_id;
#按照 部门和工资分组
# 一个部门中有很多人工资不一样，一样的分为一组 如：90号部门工资有两种24000，17000
select department_id ,salary from employees
group by department_id,salary;
#求 每个部门中 工资最高是多少
select department_id , max(salary) from employees
group by department_id;

# 需求： 查询出 每个部门中最高工资 ，且最高工资超过10000的部门。
select  department_id, MAX(salary)
from employees
GROUP BY department_id
having MAX(salary)>10000 ; # 对分组再进行筛选

# 需求： 查询出 50，90，110 部门中，最高工资超过10000的部门是那几个。
# 这里 where 后面的条件 是先筛选 符合条件的部门，提高了查询速度
#     having 后面的筛选条件，记住就跟聚合函数
select  department_id, MAX(salary)
from employees
where department_id in(50,90,110)
GROUP BY department_id
having MAX(salary)>10000 ; # 对分组再进行筛选

# ----------------牢记sql语句的执行过程----------------------
```









---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>





</escape>

----



