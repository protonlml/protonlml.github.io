---
title: 14.面向对象细节性的知识点
date: 2019-09-24 21:50:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	-  java基础
categories:   # 添加博文分类
	- java



---

<h1><center>面向对象细节性的知识点</h1>

# 面向对象细节性的知识点

- ### 1.对象总结：在java中，一个java文件，一般就写一个class类，一个类就代表一类对象。

- ### 2.类中有成员变量，成员方法，以及构造器。

- ### 3.有两种类：
  - #### 一般javaBen 这种类，只是为了描述对象使用，内部不会使用static来修饰成员变量，或者成员方法。

  - #### 另一种类，就是工具类，里面的成员方法比较多，而且是static修饰的，目的是方便用类进行调用

  - #### static 修饰的成员方法，或者成员变量，都是与类相关，随着类加载而加载。

- ### 4.类与类之间，可以实现单继承，多层继承。
  - #### 子类继承父类中所有公有的成员变量以及成员方法，子类都可以使用。子类还有自己的方法，这样子类的功能就变强大了。

  - #### 子类中，如果定义了与父类中相同的方法，那么就称子类中，对该方法进行了重写。（这就是方法重写）目的是个性化子类当前方法功能

- ### 5.有了继承，那么就有很多类，共同继承同一个父类，此时就形成一种关系叫做多态

- ### 多态：目的是，在某个方法形式参数中，使用一类对象，来进行调用。参数可以使用父类来充当。只要继承了当前这个父类，那么其子类都能赋值于这某个方法形参上面进行使用



---



---



# 包

## 一、什么是包

- ![image-20240618010737972](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180107089.png)

![image-20240618011009253](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180110321.png)

## 二、总结

![image-20240618011240474](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180112838.png)

---

---



# final关键字

## 一、final 修饰，方法，类，变量

![image-20240618011629270](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180116437.png)



![image-20240618012639444](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180126921.png)



---



---

# 权限修饰符

![image-20240618013727977](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180137064.png)

![image-20240618014053071](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180140999.png)



---



---



# 代码块

### 代码块：局部代码块，构造代码块，静态代码块

## 一、局部代码块（淘汰了，了解）

- #### 1.局部代码就是写在方法里面的一对单独的 { }

- #### 2.本质的作用就是节约内存

![image-20240618130809765](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181308802.png)

## 二、构造代码块（淘汰了，了解）

- #### 1.构造代码块，就是在类中，写在成员位置的代码块，当我们创建本类对象时，会优先于构造方法执行。

- #### 2. 将多个构造方法中，重复的代码，写在构造代码块中（弊端：每次创建本类对象，都会执行一次，有局限性）

![image-20240618130422500](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181304720.png)

## 三、静态代码块

- #### ![image-20240618131119469](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181311753.png)

- ![image-20240618131836167](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181318379.png)

- ##### 当一个类被加载时，静态代码块会被执行。这个过程通常在首次创建类的实例之前发生，或者在访问类的静态成员变量或静态方法之前发生。静态代码块可以用来初始化静态成员变量，执行静态方法，加载静态资源，或者进行其他静态的初始化操作。

-  ## 静态代码块的特点

  - **执行顺序**：静态代码块在类被加载时执行，按照它们在类中出现的顺序执行。如果一个类中有多个静态代码块，它们会按照在源代码中的顺序依次执行。
  - **只执行一次**：静态代码块只会执行一次，即使类被加载多次也是如此。这意味着静态代码块中的代码在整个应用程序的生命周期中只会执行一次。

  - **访问权限**：静态代码块可以访问类的静态成员变量和静态方法，但是不能直接访问非静态成员变量和非静态方法。非静态成员变量和非静态方法只有在类的实例被创建后才能被访问。

  - **异常处理**：静态代码块中的异常可以通过捕获并处理来防止类加载失败。如果静态代码块中发生了异常，并且没有被处理，类加载过程将被终止，导致类加载失败。

## 总结：

![image-20240618131347941](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181313431.png)









---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>



</escape>

----



