---
title: 53.序列化流反序列化流
date: 2019-09-26 09:40:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- java基础
categories:   # 添加博文分类
	- java

---

<h1><center>序列化流反序列化流</center></h1>

# 序列化流（对象操作输出流）

![image-20240721222543452](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407212225359.png)

### 一、可以把java中的对象写到本地文件中

- #### 写到本地文件中的对象信息，我们是看不懂的，需要进行反序列化，读取到内存中，即可成为对象

### 二、为什么不直接将对象属性值，给保存到本地文件中呢，非得使用序列化给序列到本地文件中，还是看不懂的？

- #### 比如游戏中的关键信息，不使用序列化的话，在本地直接明文展示，那就会被修改了，游戏中的属性也就被修改了

![image-20240720233221141](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407202332127.png)



## 三、序列化流的细节

- ### 使用对象输出流将对象保存到文件时会出现NotSerializableException异常

- ### 解决方案：需要让javabean类实现Serializable接口,同时自动生成版本号UID

![image-20240721000353503](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407210003873.png)





# 反序列化流

## 一、本地文件中的序列化对象，反序列化到内存

![image-20240720234733168](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407202347575.png)

![image-20240721004416055](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407210044370.png)



---

---



# 细节：

- #### 一个对象实现了Serializable接口，说明这个类的对象可以被序列化的

- #### java底层会根据这个类的成员变量，静态变量，构造方法，成员方法，简单的说就是根据这个类中的所有内容计算出一个long类型的序列号。这个序列号，就是这个类的版本号。

- #### 在将对象序列化，以及反序列化的时候，使用的UID是唯一的





![image-20240721005942108](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407210059140.png)



![image-20240721010128414](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407210101542.png)



# 练习

- ## 将多个对象序列化到本地，再反序列化到内存

  - #### 使用ArrayList集合来装多个对象，然后再进行序列化和反序列化

![image-20240721222252005](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407212222367.png)

```java
package com.atlml.Serialized_stream;

import java.io.Serial;
import java.io.Serializable;

/**
 *  小狗类
 */
public class Dog implements Serializable {

    @Serial
    private static final long serialVersionUID = 5061231638733610552L;

    private Integer age;
    private String name;

    public Dog() {
    }

    public Dog(Integer age, String name) {
        this.age = age;
        this.name = name;
    }


    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}

```

```java
package com.atlml.Serialized_stream;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.ArrayList;

/**
 * 将多个自定义对象序列化到文件中，但是由于对象的个数不确定，反序列化流该如何读取呢？
 */
public class SerializedStream2 {
    
    public static void main(String[] args) throws IOException {

        /**
         * 如果在代码中，一次需要将多个对象序列化到本地文件中， 
         *          我们一般会采用，将多个对象放在集合当中
         *          我们将这个集合给序列化到本地文件中
         *          取得时候，也是直接取一个集合。
         *          然后再遍历
         */

        Dog bozai = new Dog(5, "波仔");
        Dog keji = new Dog(3, "柯基");
        Dog tudou = new Dog(1, "土豆");
        ArrayList<Dog> dogs = new ArrayList<>();
        dogs.add(bozai);
        dogs.add(keji);
        dogs.add(tudou);

        //序列化流，将多个对象 序列化到 本地文件中去
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("javabasis\\aaa\\myio\\a.txt"));
        objectOutputStream.writeObject(dogs);//序列化集合
        objectOutputStream.close();
        
        


    }
    
}

```

```java
package com.atlml.Serialized_stream;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.ArrayList;

/**
 * 反序列化，
 *     将保存在本地的 对象。 反序列化到程序中
 *     这里是将 ArrayList 集合反序列化到内存中
 *      List集合中，存放了多个对象
 */
public class SerializedStream3 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {


        //反序列化一个集合
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("javabasis\\aaa\\myio\\a.txt"));
        ArrayList doglist = (ArrayList) objectInputStream.readObject();

        doglist.forEach(d-> System.out.println(d));
        //Dog{age=5, name='波仔'}
        //Dog{age=3, name='柯基'}
        //Dog{age=1, name='土豆'}

    }

}

```













---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>



</escape>

----

