---
title: 51.IO流-字节缓冲流与字符缓冲流
date: 2019-09-26 09:35:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- java基础
categories:   # 添加博文分类
	- java


---

<h1><center>IO流-字节缓冲流与字符缓冲流</center></h1>

## 一、字节缓冲流与字符缓冲流体系

![image-20240708225354464](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082253166.png)

- ### 1.为什么使用缓冲流

  - #### 缓冲流底层自带了一个数组8192个字节，一次能读8192个字节。到缓冲区

  - #### 所以，为了提高读取和写出的效率，使用缓冲流

- ### 2.怎么使用

  - ### 直接包在字节流，或者字符流的外面就行了

  - ![image-20240708231220196](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082312042.png)

  - #### 虽然“字符流”已经有了缓冲区，包与不包读取写出区别不大，但是它中有特有方法，可以对纯文本文件更好的操作，所以说也有包的必要



## 二、字节缓冲流提高效率的原理

![image-20240708230554407](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082305501.png)

## 三、实操

- ![image-20240708231850012](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082318280.png)

## 

---



---



## 四、字符缓冲流

- ### 特殊方法的使用

![image-20240708232247136](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082322199.png)

## readLine()方法的细节

- #### readLine方法在读取的时候，一次读一整行，遇到回车换行结束

- #### 但是他不会把回车换行读到内存当中

![image-20240708234153183](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082349685.png)





# 总结

![image-20240708235024071](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082350588.png)







# 练习

```java
package com.atlml.io_stream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

public class Test01 {

    public static void main(String[] args) throws IOException {

        /**
         * 将出师表csb.txt文章中的顺序恢复
         */
        BufferedReader br = new BufferedReader(new FileReader("javabasis/aaa/csb.txt"));
        TreeMap<Integer, String> map = new TreeMap<>(); //使用treeMap 排序
        String line;
        while ((line=br.readLine())!=null){
            String[] strs = line.split("\\.");
            //读取一行，进行排序
            map.put(Integer.parseInt(strs[0]),strs[1]);
        }
        System.out.println(map);
        br.close();

        //写出到本地文件中
        BufferedWriter bw = new BufferedWriter(new FileWriter("javabasis/aaa/result.txt"));
        Set<Map.Entry<Integer, String>> entries = map.entrySet();

        for (Map.Entry<Integer, String> entry : entries) {
            bw.write(entry.getValue());
            bw.newLine();
        }

        bw.close();
    }
}

```

![image-20240709002104483](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407090021748.png)











---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>





</escape>

----

