---
title: 57.多线程
date: 2019-09-28 09:38:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- java基础
categories:   # 添加博文分类
	- java
---

<h1><center>多线程</center></h1>

## 一、多线程

------

-----

### 多线程：

- 一个软件运行了，就相当于一个“进程”，然后软件中，有很多独立的功能，多个功能就是多个线程。
- 比如：腾讯电脑管家运行了，他是一个进程，里面的“病毒查杀”“垃圾清理”“电脑加速”等功能分别是多个线程，他们可以同时在这个“电脑管家”进程中，同步进行。并列执行。这就是多线程
- （比如：手机启动游戏的时候，有线程是加载本地文件，有的线程是加载背景音乐，有的线程是加载动态背景图，多个线程并行运行）

##### 开发中，需要用到多线程的时候，当前模块项目就是一个进程，里面有很多独立的业务流程，他们是可以并行执行的。不一定都是单线程的，执行了这个功能，需要等待执行完才能执行下一个功能。这样是很慢的。所以需要多线程。

##### 当业务代码中需要多线程的时候，我们用代码手动创建另一个或者多个线程，将不同的业务代码流程，分别写在多个线程内部。当执行这个软件的时候，执行到此部分多线程业务时，会自动的开多线程并行执行多个业务功能，同时产生结果，最终返回给主线程。、

##### 项目主业务流程都是在，main中开始的线程，就是主线程。当需要执行其他的业务流程时，需要从main其中开启其他线程的。

##### （比如：手机启动游戏的时候，有线程是加载本地文件，有的线程是加载背景音乐，有的线程是加载动态背景图，多个线程并行运行）

//一般java中有线程池，我们使用线程池来拿线程就行了，然后进行使用。目的是：线程也是资源，每次都要创建需要耗费时间，如果某个线程一直不释放，就会占用很长时间的资源内存。所以我们写代码时，不要自己创建，java已经给创建好了，我们只需要从线程池中拿线程对象来开启新线程。并且java也会自动管理这个线程。//

##### CPU 执行多个线程，单核cpu就是，执行1线程，然后又去执行2线程，执行3线程，多个线程交替执行，由于cpu速度非常快，感觉几个线程是，同时并行执行的，其实不是。

##### CPU多核多线程，如4核8线程，指的是CPU能够同时一下8个线程同时并行执行，每个线程都是独立的，速度更快。如果此时开启了16个线程，那么它也是8个线程，和另8个线程交替执行。

![image-20240716210939135](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407162109692.png)

--------



------

### 并发：在同一时刻，多个指令在单个CPU上交替执行。

### 并行：在同一时刻。有多个指令在多个CPU上同时执行。



## 二、多线程三种实现方式

- #### 第一种

  - ![image-20240716231323298](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407170010593.png)  

- #### 第二种

  - ![image-20240716231542532](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172314637.png)

- #### 第三种

  - ![image-20240716231717003](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172314542.png)



## 三、Thread中常见的成员方法

![image-20240716231816958](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172314187.png)

- ##### 线程的优先级

  - 设置线程 的优先级，线程默认的优先级是5，主线程main线程默认的也是5，如果设置的优先级越高，线程抢到Cpu的概率就越高

- ##### 守护线程

  - 线程设置为守护线程（备胎线程），当其他的非守护线程执行完毕，守护线程会陆续结束。
    - 例如：线程1是正常线程，线程2是守护线程，（线程1，线程2并行，同时抢占CPU线程）如果线程1中的要执行的业务结束了，那么线程2也会慢慢的结束掉自己的线程。线程2不是立马结束的。
  - 应用场景
    - qq聊天，同时传输完毕，聊天是线程1，传输文件是线程2，聊天窗口结束了，传输文件也没必要存在了，会陆续结束

- ##### 出让线程

  - 出让当前线程的执行权，当前线程抢到了cpu资源，执行完线程中的代码，最下面可以出让当前cpu资源，这样就尽可能的保证每个线程都运行均匀的，每个线程执行是平均的（了解）

- ##### 插入线程

  - 将其他线程，插入到当前线程。（了解）

---

---



## 四、线程的生命周期

![image-20240716233244394](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172314669.png)





---

---

---

## 五、线程安全问题：

- ### 1.出现线程安全的例子

  - 比如，卖100张票，创建了3个线程假设为3个窗口，3个线程中执行的业务代码是一样的，3个线程都要对这同100张票进行售卖。
  - 这里100张票，属于3个线程的共享数据，共享数据只能有一份。某个线程对这个共享数据进行修改了，都会影响到其他线程中使用这个数据。
  - 这里static 修饰的ticket变量作为“电影票变量”  在 线程任务对象中，只有一份，不管创建几个同种任务对象，都共享这个变量的值ticket,因为其是static的，属于类，类加载就加载了在方法区，只有一份。以后每次new的任务对象都在堆中，所以可以共享。（静态变量可以作数据共享，如所有学生对象，有同一个静态变量老师）
  - 但是，在每个线程中，操作共享数据的代码，每个线程是抢夺cpu调度的，也就是说，线程1在操作这个共享ticket数据时，刚改完，线程2可能就抢到了cpu调度，线程2又把这个共享ticket数据给改了，那就会导致最终的共享数据是错误的。

  - ### 2.解决办法

  - 就是，将线程中，操作共享数据的这部分代码，给锁起来。如：线程1抢到了cpu调度时，执行操作共享数据这部分代码时，给包裹起来，此时只有线程1能执行它线程中这部分代码。其他线程都得等线程1执行完共享数据的操作，开锁了。其他线程才可以抢cpu调度 {执行操作共享数据的代码}。

  - 这样就保证了，多线程共享数据的安全性，只有当某个线程全部操作完共享数据的代码，就是改完了确定改好了，才让其他线程去改。
  - 这个锁就是同步代码块，让同步代码块里面的代码是线程轮流执行的

- ### 3.同步代码块

  - ![image-20240716233808998](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172314872.png)

  - #### 示例

    - ![image-20240716235608810](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172315543.png)

- ### 4.同步方法

  - #### 我们想要把一个方法中所有的代码都锁起来，直接在方法上加关键字synchronized

    ![image-20240717000339935](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172321046.png)

![image-20240717000359423](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172316132.png)





------------



--------------

### 字符串拼接的时候StringBuffer 是线程安全的

- #### StringBuffer 是线程安全的，它的所有方法，都是synchronized修饰的，同步方法，所以它线程安全（一个线程执行当前方法，其他任何线程只能等着我当前线程执行完毕，才释放）这种运行慢

- #### StringBuilder 是线程不安全的

![image-20240717000908402](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172316509.png)





---

---



## 六、Lock锁

![image-20240717001410133](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172321144.png)

![image-20240717200036131](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172321923.png)





## 七、死锁是一个错误

- #### 以后在写锁得时候，千万千万不能让几个锁嵌套在一起了，之所以出现死锁是因为将，锁嵌套的写了。

- ![image-20240717200516612](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172322153.png)

-----



-----

## 八、等待唤醒机制（生产者，消费者)

![image-20240717200713011](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172320979.png)

![image-20240717200833346](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172320920.png)

- ## 8.1.（使用阻塞队列）实现消息唤醒 

  - #### 连接生产者与消费者之间的管道

![image-20240717201508690](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172319292.png)

![image-20240717201829145](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172319901.png)



![image-20240717202953133](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172318453.png)

- ### 厨师往队列中放一个，吃货从队列中吃一个

---

---

## 九、线程的6种状态

![image-20240717203309171](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172318960.png)

![image-20240717203531276](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407172317184.png)

----

----

















---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>




</escape>

----



