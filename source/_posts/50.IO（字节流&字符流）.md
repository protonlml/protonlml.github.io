---
title: 50.IO（字节流&字符流）
date: 2019-09-26 09:31:00
author: 𝚲𝚳𝚲
tags:   # 添加博文标签
	- java基础
categories:   # 添加博文分类
	- java

---

<h1><center>IO（字节流&字符流）</center></h1>

## 一、什么是IO流？

- #### 存储和读取数据的解决方案

  - #### 只要项目中，需要对本地文件进行读取和写入操作，肯定是需要用到IO流处理

---

![image-20240705172745968](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407051727884.png)

## 二、IO流体系

![image-20240705174236054](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407051742916.png)

---



---

![image-202407082305501.png](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082306087.png)



---

## IO流的使用原则

- #### 随用随创建

- #### 什么时候不用，什么时候关闭

- #### 切记，不要上来就把所有的流都创建在代码的最上面。

---

# 1.字节流

![image-20240705174330297](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407051743687.png)

---

- ### 1. 字节输出流 FileOutputStream 

  - #### 操作本地文件的字节输出流，可以把程序中的数据写到本地文件中。

![image-20240705215025016](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407052150386.png) 

- ### 续写：

  - ![image-20240705215327806](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407052153443.png)

![image-20240705215909710](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407052159728.png)

---



---

- ### 2. 字节输入流 FileInputStream

  - #### 操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来。

  - ### 这里面要记住，循环读取的套路书写方法

![image-20240705223257226](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407052232409.png)

- ### 一次读一个字节，效率太慢了，一次读多个字节？

  - #### 注意：一次读一个字节数组的数据，每次读取会尽可能把数组装满。![image-20240706001005685](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407060010806.png)

  - #### (循环读，就能读取本地文件中的所有内容)

  - ![image-20240706001357137](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407060013097.png)

---



---

# 练习

- ### 拷贝文件

![image-20240705232843350](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407052328373.png)

- ### 拷贝大文件

  - ![image-20240706001710617](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407060017137.png)



---

---

# 注意：

- #### 字节流读取文件的时候，文件中不要有中文

- 使用字节流读取纯文本文件时，内容中有 “汉字” 读取到系统内存之后，会有乱码。

  - 因为：字节流 FileinputStream的read方法，读取文件时，是一个字节一个字节读取的，而一个汉字，在计算机中占用3个字节，Unicode组织制定的（GBK是2个字节），有可能读取的时候，字节没有读取完整。
  - 但是拷贝纯文本文件没有问题，因为是全部字节循环读取，最终都会被读取完毕，再写到目标文件中也是完整的。

- 字节流：一次只能读取一个字节

  在计算机中，一个字母正好是一个字节（不管是ASCII 还是Unicode字符集）

  但是在Unicode字符集中，规定一个汉字占用了3个字节。（Unicode组织制定的，全世界通用）

  在GBK字符集中，一个汉字占用了两个字节（我国自己指定的）

  所以使用字节流来读取文本文件(内部是汉字)会出现乱码，因为一次只读取了一个字节。

  - 在系统中使用的Unicode字符集，是通用的，需要使用UTF-8来编解码。

---

---



# 2. 字符流

![image-20240706013200033](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407060132692.png)

- ### 字符流，最适合操作纯文本文件，遇到中文也不会出现乱码

![image-20240706013041354](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407060130593.png)

- ## 2.1 字符输入流FileReader

  - ## 就是从本地文件中，读取内容 

  - ![image-20240706021838958](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407060218923.png)



![image-20240703184711072](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407031847873.png)

![image-20240703185620400](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407031856921.png)



### 字符输入流，就是从本地文件中读取文本内容到系统中。

- ##### 原理是，在创建字符输入流的时候，它会在底层创建一个字节数组长度为8192，read一次就会尽可能的将这个字节数组给填满。（他就是缓冲区）。下一次读，就会直接在缓冲区中读，缓冲区中读取完了，再将本地文本再次加载到缓冲区。（提高读取文件的效率）

- ##### 字节输入流，没有这个缓冲区



- ##  2.2 字符输出流 FileWriter

  - ## 就是将程序中的数据，写出到本地文件中。（write的两种方式）

  - ![image-20240706023312824](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407060233450.png)

----

----

# 字符流的底层原理（有缓冲区）

- ### 字符输入流的底层原理

![image-20240706023516385](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407060235307.png)

- ### 字符输出流的底层原理

  ![image-20240706024303312](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407060243864.png)

## 使用场景

![image-20240708000749263](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407080149822.png)

# 练习

### 拷贝文件夹中的所有文件（包括子文件夹）

![image-20240708020125127](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407080201552.png)

```java
package com.atlml.io_stream;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * 练习一：
 * <p>
 * 拷贝：
 * 拷贝一个文件夹，考虑子文件夹
 */
public class Practice1 {
    public static void main(String[] args) throws IOException {
        
        /**
         * 将一个文件夹中的所有 内容拷贝
         *
         */

        //源文件路径
        File src = new File("javabasis\\aaa");
        // 目标文件路径
        File to = new File("javabasis\\copy_directorys");

        //拷贝就想  使用 字节流  来操作

        long l = System.currentTimeMillis();
        copyDirectorys(src, to);
        long l1 = System.currentTimeMillis();
        System.out.println("拷贝完成用时" + (l1 - l) + "豪秒");
    }

    /**
     * @param src 文件夹源路径
     * @param to  目标路径
     * @return 是否成功
     */
    private static void copyDirectorys(File src, File to) throws IOException {
        //由于目的地文件夹如果不存在，会报错。所以先创建。即使目的文件夹有，也没关系不报错
        to.mkdir();

        // src 从源文件夹中 拿出所有的文件包括文件夹
        File[] files = src.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isFile()) {
                    FileInputStream fis = new FileInputStream(file);
                    //使用缓冲流包一下，目的是流 读到 缓冲区，再从缓冲区往外写 效率速度提高
                    BufferedInputStream bfis = new BufferedInputStream(fis); //

                    FileOutputStream fos = new FileOutputStream(new File(to, file.getName()));
                    //使用缓冲流包一下，目的是流先 写到缓冲区，再从缓冲区写到文本中 效率速度提高
                    BufferedOutputStream bfos = new BufferedOutputStream(fos);

                    //是文件直接拷贝
                    /**
                     * 一个字节，一个字节的读，一个字节一个字节的写
                     * 非常慢
                     * 等了好久也没结束
                     */
                    /*int b;
                    while ((b = fis.read()) != -1) {
                        fos.write(b); //读多少就写多少
                    }
                    fos.close();
                    fis.close();*/
                    /*-----------------------------------------*/
                    /*
                     * 使用字节数组，指定一次读取 0.5M
                     *
                     * 因为都是小文件，中间的容器创建太大，导致空间浪费，速度反而慢
                     *
                     * 最终 拷贝完成用时 577~668豪秒
                     */

                     /*int len;
                     byte[] b = new byte[1024 * 1024 * 1/2]; //0.5M大小
                     while ((len = fis.read(b)) != -1) {
                     fos.write(b, 0, len); //读多少就写多少
                     }
                     fos.close();
                     fis.close();*/
                    /*-----------------------------------------*/
                    /**
                     * 使用缓冲流包一下，速度快了一点
                     *
                     * 最终 拷贝完成用时797豪秒
                     */
                    /*
                        int b;
                        while ((b=bfis.read())!=-1){
                            bfos.write(b);
                        }
                        bfos.close();
                        bfis.close();
                    */
                    /*-----------------------------------------*/
                    /**
                     * 使用缓冲流，
                     * 同时加上 还指定一次读0.5M数组
                     * 更快
                     *
                     * 最终：拷贝完成用时 511~616 豪秒
                     *
                     * 最快的
                     */
                    int len;
                    byte[] b = new byte[1024 * 1024 * 1 / 2]; //一次读取 0.5M 大小到数组中
                    while ((len = bfis.read(b)) != -1) {
                        bfos.write(b, 0, len);//一次写出 0.5M 到本地文件中
                    }
                    bfos.close();
                    bfis.close();

                } else {
                    //是文件夹，进入再拷贝
                    copyDirectorys(file, new File(to, file.getName()));
                }
            }
        }
    }


}

```

---

---

### 二、文件加密

- #### 利用(^异或) （如：100^10=110；110^10=100） 一个十进制数异或同一个数字两次，可以得到原数据

```java
package com.atlml.io_stream;


import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Practice2 {
    public static void main(String[] args) throws IOException {

        /**
         * 对文件进行加密
         *
         * 将一个文件读出来之后，对其字节进行操作
         * 字节流
         */

        File src = new File("javabasis\\aaa\\aaa.mp4");
        File ency = new File("javabasis\\aaa\\bbbbbbbb.mp4");

        //文件加密 存到 本地
            fileEncryption(src,ency);

        //文件解密
        // fileEncryption(ency,src);


    }

    /**
     * 加密/解密
     * @param src
     * @param ency
     * @throws IOException
     */
    private static void fileEncryption(File src,File ency) throws IOException {

        FileInputStream fileInputStream = new FileInputStream(src);

        FileOutputStream fileOutputStream = new FileOutputStream(ency);

        byte[] b = new byte[1024*1024/2]; //0.5M 的 转移 容器
        int len;//每次转移的字节数量
        byte myb=10; //声明一个字节默认值是 10
        while ((len=fileInputStream.read(b))!=-1){
            for (int i = 0; i <len; i++) {
                b[i]= (byte) (b[i]^myb);//将每个字节异或操作后，在存到字节数组中（加密）
            }
            fileOutputStream.write(b,0,len);
        }
        fileOutputStream.close();
        fileInputStream.close();
    }




}

```



## 三、文件排序

```java
   public static void main(String[] args) throws IOException {
        /*   *
         * 文本文件中有以下的数据：
         * 2-1-9-4-7-8
         * 将文件中的数据进行排序，变成以下的数据：
         * 1-2-4-7-8-9
         */

        File file = new File("javabasis\\aaa\\num.txt");
        FileReader fr = new FileReader(file);//字符输入流
        FileWriter fw = new FileWriter("javabasis\\aaa\\numSort.txt");

        ArrayList<String> str = new ArrayList<>();
        char[] ch = new char[2];
        int len;
        while ((len = fr.read(ch)) != -1) {
            for (int i = 0; i < len; i++) {
                String s = String.valueOf(ch[i]);
                if (!"-".equals(s)) {
                    str.add(s);
                    //不是"-"横线
                }
            }
        }
        Collections.sort(str);//从小到大排序
        StringJoiner stringJoiner = new StringJoiner("-", "", "");
        for (String s : str) {
            stringJoiner.add(s);
        }

        fw.write(stringJoiner.toString());

        fw.close();
        fr.close();

    }
```

![image-20240708225004524](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082250732.png)

![image-20240708224703567](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082250650.png)

![image-20240708224820724](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407082248942.png)







---


----

© 版权声明

<escape>

<div>
    <h3 align="center"  style="color: brown;" >版权声明</h3>
    <table>
   		<tr>
    		<ol>
				<li>本网站名称：𝚲𝚳𝚲</li>
				<li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>
				<li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>
				<li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>
        		<li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li> 
        		<li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>
        		<li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>  
			</ol>
		</tr>
	</table>
</div>




</escape>

----

