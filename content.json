{"meta":{"title":"Hexo","subtitle":"","description":"","author":"𝚲𝚳𝚲","url":"https://protonlml.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-06-15T06:14:52.776Z","updated":"2024-06-15T06:14:52.776Z","comments":false,"path":"/404.html","permalink":"https://protonlml.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2024-06-15T06:14:53.352Z","updated":"2024-06-15T06:14:53.352Z","comments":false,"path":"books/index.html","permalink":"https://protonlml.github.io/books/index.html","excerpt":"","text":""},{"title":"关于我","date":"2024-06-15T06:14:53.350Z","updated":"2024-06-15T06:14:53.350Z","comments":false,"path":"about/index.html","permalink":"https://protonlml.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718/** ┏┓ ┏┓ * ┃ ┃ + +* ┃ ━ ┃ ++ + + +* ████━████┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问我的博客* ┃ ┃ + * ┃ ┻ ┃ + + * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽护体，永无bug * ┃ ┃ +* ┃ ┗━━━┓+* ┃ ┣┓ 📬 联系我：lmle_mail@163.com* ┃ ┏┛ + + * ┗┓┓┏━┳┓┏┛ +* ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */"},{"title":"分类","date":"2024-06-15T06:14:53.353Z","updated":"2024-06-15T06:14:53.353Z","comments":false,"path":"categories/index.html","permalink":"https://protonlml.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-06-15T06:14:53.360Z","updated":"2024-06-15T06:14:53.360Z","comments":false,"path":"repository/index.html","permalink":"https://protonlml.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-06-15T06:14:53.358Z","updated":"2024-06-15T06:14:53.358Z","comments":true,"path":"links/index.html","permalink":"https://protonlml.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-06-15T06:14:53.362Z","updated":"2024-06-15T06:14:53.362Z","comments":false,"path":"tags/index.html","permalink":"https://protonlml.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码","slug":"挂年兽","date":"2024-01-01T03:00:00.000Z","updated":"2024-06-16T01:41:24.580Z","comments":true,"path":"2024/01/01/挂年兽/","link":"","permalink":"https://protonlml.github.io/2024/01/01/%E6%8C%82%E5%B9%B4%E5%85%BD/","excerpt":"","text":"换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码 摘要 这篇文章介绍了一个在博客网站右上角添加悬挂年兽的方法。通过在CSS代码中插入相应的素材链接，可以实现在网站右上角挂上一个龙的效果。对于自定义主题的网站，可以将相关的CSS和HTML代码添加到自定义头部中。对于全屏网站，建议在CSS代码的16行左右插入一行代码以实现相应效果。 一、简介-教程 换新颜新气象，给网站右上角挂一个龙，吸吸龙气 css第6行放入下面素材链接（本站开了防盗所以给你也无用就放下面了） 如果你的主题是自定义，那就是主题设置自定义里面 自定义css 1234567891011121314151617181920212223242526@media screen and (min-width: 850px)&#123; .NewYear &#123; width: 260px; height: 300px; display: inline-block; background: url(https://img.ly522.com/LY/uploads/2023/12/longgyaj.gif) no-repeat 50%/100%; vertical-align: middle; position: fixed; left: 85.8%; top: 55px; z-index: 50; cursor: pointer; animation: new-year 1.2s ease-in-out 0s infinite alternate; margin-left: -1px; transform-origin: 50% 0; pointer-events: none; &#125; &#125; @keyframes new-year&#123; 0% &#123; transform: rotate(10deg); &#125; 100%&#123; transform: rotate(-10deg); &#125; &#125; html放到你的自定义头部html即可！！ 1&lt;div class=&quot;NewYear&quot;&gt;&lt;/div&gt; 注意：如果你的是全屏网站建议在pointer-events: none;下面加一行。即css代码16行左右哪里加 1z-index: 999; 演示图 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！ ​","categories":[{"name":"新年快乐","slug":"新年快乐","permalink":"https://protonlml.github.io/categories/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"}],"tags":[{"name":"春节挂件","slug":"春节挂件","permalink":"https://protonlml.github.io/tags/%E6%98%A5%E8%8A%82%E6%8C%82%E4%BB%B6/"},{"name":"技巧优化","slug":"技巧优化","permalink":"https://protonlml.github.io/tags/%E6%8A%80%E5%B7%A7%E4%BC%98%E5%8C%96/"}],"author":"𝚲𝚳𝚲"},{"title":"","slug":"51.IO流（其他流）","date":"2023-05-19T13:05:34.491Z","updated":"2024-07-21T15:44:00.684Z","comments":true,"path":"2023/05/19/51.IO流（其他流）/","link":"","permalink":"https://protonlml.github.io/2023/05/19/51.IO%E6%B5%81%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/","excerpt":"","text":"1. 缓冲流昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。 1.1 概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 1.2 字节缓冲流构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;)); 效率测试查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。 基本流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream(&quot;jdk9.exe&quot;); FileOutputStream fos = new FileOutputStream(&quot;copy.exe&quot;) )&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;十几分钟过去了... 缓冲流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;)); )&#123; // 读写数据 int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;缓冲流复制时间:8016 毫秒 如何更快呢？ 使用数组的方式，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;)); )&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;缓冲流使用数组复制时间:666 毫秒 1.3 字符缓冲流构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(&quot;br.txt&quot;));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)); 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示，代码如下： 123456789101112131415public class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;)); // 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) &#123; System.out.print(line); System.out.println(&quot;------&quot;); &#125; // 释放资源 br.close(); &#125;&#125; newLine方法演示，代码如下： 1234567891011121314151617181920public class BufferedWriterDemo throws IOException &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;)); // 写出数据 bw.write(&quot;黑马&quot;); // 写出换行 bw.newLine(); bw.write(&quot;程序&quot;); bw.newLine(); bw.write(&quot;员&quot;); bw.newLine(); // 释放资源 bw.close(); &#125;&#125;输出效果:黑马程序员 1.4 练习:文本排序请将文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 案例分析 逐行读取文本信息。 把读取到的文本存储到集合中 对集合中的文本进行排序 遍历集合，按顺序，写出文本信息。 案例实现1234567891011121314151617181920212223242526272829303132333435363738public class Demo05Test &#123; public static void main(String[] args) throws IOException &#123; //1.创建ArrayList集合,泛型使用String ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //2.创建BufferedReader对象,构造方法中传递FileReader对象 BufferedReader br = new BufferedReader(new FileReader(&quot;10_IO\\\\in.txt&quot;)); //3.创建BufferedWriter对象,构造方法中传递FileWriter对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;10_IO\\\\out.txt&quot;)); //4.使用BufferedReader对象中的方法readLine,以行的方式读取文本 String line; while((line = br.readLine())!=null)&#123; //5.把读取到的文本存储到ArrayList集合中 list.add(line); &#125; //6.使用Collections集合工具类中的方法sort,对集合中的元素按照自定义规则排序 Collections.sort(list, new Comparator&lt;String&gt;() &#123; /* o1-o2:升序 o2-o1:降序 */ @Override public int compare(String o1, String o2) &#123; //依次比较集合中两个元素的首字母,升序排序 return o1.charAt(0)-o2.charAt(0); &#125; &#125;); //7.遍历ArrayList集合,获取每一个元素 for (String s : list) &#123; //8.使用BufferedWriter对象中的方法wirte,把遍历得到的元素写入到文本中(内存缓冲区中) bw.write(s); //9.写换行 bw.newLine(); &#125; //10.释放资源 bw.close(); br.close(); &#125;&#125; 2. 转换流2.1 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 编码:字符(能看懂的)–字节(看不懂的) 解码:字节(看不懂的)–&gt;字符(能看懂的) 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 编码表:生活中文字和计算机中二进制的对应规则 字符集 **字符集 Charset**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 2.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 123456789101112public class ReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader(&quot;E:\\\\File_GBK.txt&quot;); int read; while ((read = fileReader.read()) != -1) &#123; System.out.print((char)read); &#125; fileReader.close(); &#125;&#125;输出结果：��� 那么如何读取GBK编码的文件呢？ 2.3 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;); 指定编码读取1234567891011121314151617181920212223public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = &quot;E:\\\\file_gbk.txt&quot;; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , &quot;GBK&quot;); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; 2.4 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;); 指定编码写出12345678910111213141516171819public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = &quot;E:\\\\out.txt&quot;; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(&quot;你好&quot;); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = &quot;E:\\\\out2.txt&quot;; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;); // 写出数据 osw2.write(&quot;你好&quot;);// 保存为4个字节 osw2.close(); &#125;&#125; 转换流理解图解转换流是字节与字符间的桥梁！ 2.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 案例实现12345678910111213141516171819202122232425public class TransDemo &#123; public static void main(String[] args) &#123; // 1.定义文件路径 String srcFile = &quot;file_gbk.txt&quot;; String destFile = &quot;file_utf8.txt&quot;; // 2.创建流对象 // 2.1 转换输入流,指定GBK编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , &quot;GBK&quot;); // 2.2 转换输出流,默认utf8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile)); // 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) &#123; // 循环写出 osw.write(cbuf,0,len); &#125; // 4.释放资源 osw.close(); isr.close(); &#125;&#125; 3. 序列化3.1 概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： 3.2 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out) ： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream(&quot;employee.txt&quot;);ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 12345678public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println(&quot;Address check : &quot; + name + &quot; -- &quot; + address); &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 12345678910111213141516171819202122public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = &quot;zhangsan&quot;; e.address = &quot;beiqinglu&quot;; e.age = 20; try &#123; // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;)); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。 &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125;输出结果：Serialized data is saved 3.3 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728public class DeserializeDemo &#123; public static void main(String [] args) &#123; Employee e = null; try &#123; // 创建反序列化流 FileInputStream fileIn = new FileInputStream(&quot;employee.txt&quot;); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close(); &#125;catch(IOException i) &#123; // 捕获其他异常 i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; // 捕获类找不到异常 System.out.println(&quot;Employee class not found&quot;); c.printStackTrace(); return; &#125; // 无异常,直接打印输出 System.out.println(&quot;Name: &quot; + e.name); // zhangsan System.out.println(&quot;Address: &quot; + e.address); // beiqinglu System.out.println(&quot;age: &quot; + e.age); // 0 &#125;&#125; 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 123456789101112public class Employee implements java.io.Serializable &#123; // 加入序列版本号 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() &#123; System.out.println(&quot;Address check : &quot; + name + &quot; -- &quot; + address); &#125;&#125; 3.4 练习：序列化集合 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。 案例分析 把若干学生对象 ，保存到集合中。 把集合序列化。 反序列化读取时，只需要读取一次，转换为集合类型。 遍历集合，可以打印所有的学生信息 案例实现12345678910111213141516171819202122232425262728293031323334public class SerTest &#123; public static void main(String[] args) throws Exception &#123; // 创建 学生对象 Student student = new Student(&quot;老王&quot;, &quot;laow&quot;); Student student2 = new Student(&quot;老张&quot;, &quot;laoz&quot;); Student student3 = new Student(&quot;老李&quot;, &quot;laol&quot;); ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(student); arrayList.add(student2); arrayList.add(student3); // 序列化操作 // serializ(arrayList); // 反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;)); // 读取对象,强转为ArrayList类型 ArrayList&lt;Student&gt; list = (ArrayList&lt;Student&gt;)ois.readObject(); for (int i = 0; i &lt; list.size(); i++ )&#123; Student s = list.get(i); System.out.println(s.getName()+&quot;--&quot;+ s.getPwd()); &#125; &#125; private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123; // 创建 序列化流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;)); // 写出对象 oos.writeObject(arrayList); // 释放资源 oos.close(); &#125;&#125; 4. 打印流4.1 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 4.2 PrintStream类构造方法 public PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： 1PrintStream ps = new PrintStream(&quot;ps.txt&quot;)； 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。 1234567891011121314public class PrintDemo &#123; public static void main(String[] args) throws IOException &#123; // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(&quot;ps.txt&quot;); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); &#125;&#125; 5. 压缩流和解压缩流压缩流： ​ 负责压缩文件或者文件夹 解压缩流： ​ 负责把压缩包中的文件和文件夹解压出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** 解压缩流** */public class ZipStreamDemo1 &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个File表示要解压的压缩包 File src = new File(&quot;D:\\\\aaa.zip&quot;); //2.创建一个File表示解压的目的地 File dest = new File(&quot;D:\\\\&quot;); //调用方法 unzip(src,dest); &#125; //定义一个方法用来解压 public static void unzip(File src,File dest) throws IOException &#123; //解压的本质：把压缩包里面的每一个文件或者文件夹读取出来，按照层级拷贝到目的地当中 //创建一个解压缩流用来读取压缩包中的数据 ZipInputStream zip = new ZipInputStream(new FileInputStream(src)); //要先获取到压缩包里面的每一个zipentry对象 //表示当前在压缩包中获取到的文件或者文件夹 ZipEntry entry; while((entry = zip.getNextEntry()) != null)&#123; System.out.println(entry); if(entry.isDirectory())&#123; //文件夹：需要在目的地dest处创建一个同样的文件夹 File file = new File(dest,entry.toString()); file.mkdirs(); &#125;else&#123; //文件：需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放） FileOutputStream fos = new FileOutputStream(new File(dest,entry.toString())); int b; while((b = zip.read()) != -1)&#123; //写到目的地 fos.write(b); &#125; fos.close(); //表示在压缩包中的一个文件处理完毕了。 zip.closeEntry(); &#125; &#125; zip.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class ZipStreamDemo2 &#123; public static void main(String[] args) throws IOException &#123; /* * 压缩流 * 需求： * 把D:\\\\a.txt打包成一个压缩包 * */ //1.创建File对象表示要压缩的文件 File src = new File(&quot;D:\\\\a.txt&quot;); //2.创建File对象表示压缩包的位置 File dest = new File(&quot;D:\\\\&quot;); //3.调用方法用来压缩 toZip(src,dest); &#125; /* * 作用：压缩 * 参数一：表示要压缩的文件 * 参数二：表示压缩包的位置 * */ public static void toZip(File src,File dest) throws IOException &#123; //1.创建压缩流关联压缩包 ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest,&quot;a.zip&quot;))); //2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹 //参数：压缩包里面的路径 ZipEntry entry = new ZipEntry(&quot;aaa\\\\bbb\\\\a.txt&quot;); //3.把ZipEntry对象放到压缩包当中 zos.putNextEntry(entry); //4.把src文件中的数据写到压缩包当中 FileInputStream fis = new FileInputStream(src); int b; while((b = fis.read()) != -1)&#123; zos.write(b); &#125; zos.closeEntry(); zos.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ZipStreamDemo3 &#123; public static void main(String[] args) throws IOException &#123; /* * 压缩流 * 需求： * 把D:\\\\aaa文件夹压缩成一个压缩包 * */ //1.创建File对象表示要压缩的文件夹 File src = new File(&quot;D:\\\\aaa&quot;); //2.创建File对象表示压缩包放在哪里（压缩包的父级路径） File destParent = src.getParentFile();//D:\\\\ //3.创建File对象表示压缩包的路径 File dest = new File(destParent,src.getName() + &quot;.zip&quot;); //4.创建压缩流关联压缩包 ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest)); //5.获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中 toZip(src,zos,src.getName());//aaa //6.释放资源 zos.close(); &#125; /* * 作用：获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中 * 参数一：数据源 * 参数二：压缩流 * 参数三：压缩包内部的路径 * */ public static void toZip(File src,ZipOutputStream zos,String name) throws IOException &#123; //1.进入src文件夹 File[] files = src.listFiles(); //2.遍历数组 for (File file : files) &#123; if(file.isFile())&#123; //3.判断-文件，变成ZipEntry对象，放入到压缩包当中 ZipEntry entry = new ZipEntry(name + &quot;\\\\&quot; + file.getName());//aaa\\\\no1\\\\a.txt zos.putNextEntry(entry); //读取文件中的数据，写到压缩包 FileInputStream fis = new FileInputStream(file); int b; while((b = fis.read()) != -1)&#123; zos.write(b); &#125; fis.close(); zos.closeEntry(); &#125;else&#123; //4.判断-文件夹，递归 toZip(file,zos,name + &quot;\\\\&quot; + file.getName()); // no1 aaa \\\\ no1 &#125; &#125; &#125;&#125; 6. 工具包（Commons-io）介绍： ​ Commons是apache开源基金组织提供的工具包，里面有很多帮助我们提高开发效率的API 比如： ​ StringUtils 字符串工具类 ​ NumberUtils 数字工具类 ​ ArrayUtils 数组工具类 ​ RandomUtils 随机数工具类 ​ DateUtils 日期工具类 ​ StopWatch 秒表工具类 ​ ClassUtils 反射工具类 ​ SystemUtils 系统工具类 ​ MapUtils 集合工具类 ​ Beanutils bean工具类 ​ Commons-io io的工具类 ​ 等等….. 其中：Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。 作用：提高IO流的开发效率。 使用方式： 1，新建lib文件夹 2，把第三方jar包粘贴到文件夹中 3，右键点击add as a library 代码示例： 12345678910111213141516171819202122232425262728293031323334353637public class CommonsIODemo1 &#123; public static void main(String[] args) throws IOException &#123; /* FileUtils类 static void copyFile(File srcFile, File destFile) 复制文件 static void copyDirectory(File srcDir, File destDir) 复制文件夹 static void copyDirectoryToDirectory(File srcDir, File destDir) 复制文件夹 static void deleteDirectory(File directory) 删除文件夹 static void cleanDirectory(File directory) 清空文件夹 static String readFileToString(File file, Charset encoding) 读取文件中的数据变成成字符串 static void write(File file, CharSequence data, String encoding) 写出数据 IOUtils类 public static int copy(InputStream input, OutputStream output) 复制文件 public static int copyLarge(Reader input, Writer output) 复制大文件 public static String readLines(Reader input) 读取数据 public static void write(String data, OutputStream output) 写出数据 */ /* File src = new File(&quot;myio\\\\a.txt&quot;); File dest = new File(&quot;myio\\\\copy.txt&quot;); FileUtils.copyFile(src,dest);*/ /*File src = new File(&quot;D:\\\\aaa&quot;); File dest = new File(&quot;D:\\\\bbb&quot;); FileUtils.copyDirectoryToDirectory(src,dest);*/ /*File src = new File(&quot;D:\\\\bbb&quot;); FileUtils.cleanDirectory(src);*/ &#125;&#125; 7. 工具包（hutool）介绍： ​ Commons是国人开发的开源工具包，里面有很多帮助我们提高开发效率的API 比如： ​ DateUtil 日期时间工具类 ​ TimeInterval 计时器工具类 ​ StrUtil 字符串工具类 ​ HexUtil 16进制工具类 ​ HashUtil Hash算法类 ​ ObjectUtil 对象工具类 ​ ReflectUtil 反射工具类 ​ TypeUtil 泛型类型工具类 ​ PageUtil 分页工具类 ​ NumberUtil 数字工具类 使用方式： 1，新建lib文件夹 2，把第三方jar包粘贴到文件夹中 3，右键点击add as a library 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test1 &#123; public static void main(String[] args) &#123; /* FileUtil类: file：根据参数创建一个file对象 touch：根据参数创建文件 writeLines：把集合中的数据写出到文件中，覆盖模式。 appendLines：把集合中的数据写出到文件中，续写模式。 readLines：指定字符编码，把文件中的数据，读到集合中。 readUtf8Lines：按照UTF-8的形式，把文件中的数据，读到集合中 copy：拷贝文件或者文件夹 */ /* File file1 = FileUtil.file(&quot;D:\\\\&quot;, &quot;aaa&quot;, &quot;bbb&quot;, &quot;a.txt&quot;); System.out.println(file1);//D:\\aaa\\bbb\\a.txt File touch = FileUtil.touch(file1); System.out.println(touch); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); File file2 = FileUtil.writeLines(list, &quot;D:\\\\a.txt&quot;, &quot;UTF-8&quot;); System.out.println(file2);*/ /* ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); File file3 = FileUtil.appendLines(list, &quot;D:\\\\a.txt&quot;, &quot;UTF-8&quot;); System.out.println(file3);*/ List&lt;String&gt; list = FileUtil.readLines(&quot;D:\\\\a.txt&quot;, &quot;UTF-8&quot;); System.out.println(list); &#125;&#125;","categories":[],"tags":[]},{"title":"matery主题的使用","slug":"matery主题的使用","date":"2020-03-17T03:00:00.000Z","updated":"2024-06-16T02:11:38.377Z","comments":true,"path":"2020/03/17/matery主题的使用/","link":"","permalink":"https://protonlml.github.io/2020/03/17/matery%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"matery主题的使用一、下载matery主题 1.GitHub源项目 GitHub - blinkfox&#x2F;hexo-theme-matery: 一个基于材料设计和响应式设计而成的全面、美观的Hexo主题。 2.在本地clone下来 1git clone https://github.com/blinkfox/hexo-theme-matery.git 二、配置hexo根yml文件 三、自定义主题 1.修改导航名称和路径图标 添加导航二级菜单的写法（如下是“关于”一级菜单修改） 注意：1.菜单导航名称可以是中文也可以是英文(如：Index或主页) ​ 2.图标icon 可以在Font Awesome 中查找 ,线上的 1234567891011About: url: /about # icon: fas fa-user-circle 注释掉原来的，加上下面这一段 icon: fas fa-list children: - name: 爱的颜色 url: /love icon: fas fa-heart - name: 生日快乐 url: /birthday icon: fas fa-cake 2.手机二级菜单配置123navMenu: mleft: true # 二级侧栏子菜单是否对齐左边 bgColor: &quot; &quot; # 二级侧栏子菜单背景颜色,留空即为全局背景色 3.首页中间右侧 banner1234githubLink: enable: true # 是否开启 url: https://github.com/sitoi/sitoi.github.io # GitHub 仓库地址 title: Fork Me # 显示文字 4.首页轮播图相关配置123456cover: showPrevNext: false # 是否显示左右切换按钮 showIndicators: false # 是否显示指示器 autoLoop: false # 是否自动轮播 duration: 120 # 切换延迟时间，默认单位 秒 intervalTime: 5000 # 自动切换下一张的间隔时间 参考： Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐 (blinkfox.github.io) 基于 Hexo GitHub 从零开始搭建个人博客（三）：Matery 主题（DIY 版）详细配置教程，附博客源码 | Sitoi (๑•̀ㅂ•́) ✧被发现了～ (sunhwee.com) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"matery主题","slug":"matery主题","permalink":"https://protonlml.github.io/tags/matery%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"Maven","slug":"Maven","date":"2019-10-10T03:00:00.000Z","updated":"2024-06-16T02:15:54.402Z","comments":true,"path":"2019/10/10/Maven/","link":"","permalink":"https://protonlml.github.io/2019/10/10/Maven/","excerpt":"","text":"Maven 一、Maven的一些理解 1.项目的构建，是指项目的“打包”，“编译”，“部署”，“运行”等一系列操作。 2.用Maven就可以使我们的项目，能够自动化构建。 3.maven是java项目的自动化构建工具。 4.Maven可以，将一个大型的项目的不同功能，拆分成多个模块，分别进行开发管理。 5.Maven可以，通过配置poom文件，来导入某个技术的jar包，同时会自动的导入这个jar包的相关依赖jar包。 二、Maven程序的执行原理 maven核心程序指的是，解压后的maven程序目录。也是maven软件的目录里面的内容。 Maven在自动构建项目的时候，使用插件会在本地仓库中找，使用依赖jar包也在本地仓库中找。本地找不到就到中央仓库中下载。 怎么使用maven？（不用开发工具） 创建一个maven规定的项目目录结构，在有poom.xml文件的目录下面，执行maven命令 当我们执行的Maven命令需要用到某些插件的时候，Maven核心程序会首先到本地仓库中查找 本地仓库的默认位置：[系统当前用户的家目录].m2\\repository(Maven找插件的时候，自动创建) Maven核心程序如果在本地仓库中找不到需要的插件的时候，那么它会自动联网，到中央仓库中下载。 Maven的生命周期就是指的是“项目的构建过程”，项目的构建是有顺序的，执行的任何一个Maven命令都是从生命周期的头开始。 Maven构建项目完成之后，生成的“产品”就放在“项目src所在目录”中的“target”目录中。 Pom 【1】含义：project Object Model 项目对象模型。 pom.xml对于Maven工程师核心配置文件，与构建过程相关的一切设置都在这个文件中进行 Maven坐标类比一下： 数学中可以用（x,yz）三个项量来确定一个空间的点。 Maven的pom文件中，也是使用三个项量，来在仓库中唯一定位一个Maven工程 [1]：groupid：公司或组织域名倒序+项目名 1&lt;groupId&gt;cn.itcast&lt;/groupId&gt; [2]：artifactid：模块名 [3]：version：版本 只要讲“gav”就讲的是Maven的坐标。 [4] :Maven工程的坐标与仓库中的路径对应关系。 在Maven仓库里面。每一个Maven工程，他的坐标一定是不重复的，即标识了这个Maven工程信息，同时也决定了他在仓库中存放的目录是什么。 仓库中保存的内容：宽泛的说就是（Maven工程项目） 主要有3大块： -[1]：Maven核心软件，自身所需要的一些插件 [2]：第三方框架或工具的jar包(其实就是第三方项目，打成了jar包) [3]：我们自己开发的工程。Maven将“插件”、“框架jar包”、“我们自己的项目”都用统一的目录结构，放在了仓库中，这样就方便Maven核心程序的管理和使用。 pom.xml文件解析。 创建的Maven项目中有pom.xml文件，他是Maven项目的核心配置文件。 【1】.除了上面三个坐标用来，定位当前项目用Maven核心程序安装在仓库中的位置。 2】.中间部分是“依赖部分”，就是指当前项目，所使用的到的“其他模块项目和jar包”，在Maven仓库中的坐标。如果仓库中没有指定的依赖jar包，就会自动从私服上面下载，私服上面没有就会到中央仓库中下载。 但是如果当前项目，用到我们自己写的模块，这时候就需要将，要使用的模块项目给“安装”到仓库中，用“ mvn install”命令进行安装。是不可能从网上下载的，因为这是我们自己写的，不是第三方jar包项目。这样我们就可以将一个大的项目，进行拆分成很多小的模块，然后各个模块之间用“依赖坐标”，来互相关联。 【3】最下面是“插件”部分。 依赖 ①Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。 对于我们自己开发的Maven工程，使用mvn install命令安装后就可以进入仓库。 ②依赖的范围 【1】在pom.xml文件中依赖的范围 依赖的范围一般常用的有三个：compile，test、provided三个。 依赖范围：意思就是，当前项目所依赖的这个“依赖”，在编译，测试，打包。过程当中时候有效。 [1]compile范围的“依赖”（编译范围） 对主程序是否有效：有效 对测试程序是否有效：有效 是否参与打包：参与 是否 参与部署：参与 [2]test范围的“依赖”（测试范围） 对主程序是否有效：无效 对测试程序是否有效：有效 是否参与打包：不参与 是否参与部署：不参与 典型例子：“junit依赖”它就是测试依赖，这个jar包，不参与打包，在主程序中没有。 [3]provided范围的“依赖”，通常是为web工程来添加的（不参与部署的范围）。 说明只要加了provided范围的“依赖”，web容器中都有。比如：servlet的这个依赖，部署的时候就不需要，因为Tomcat服务器本身就有servlet的jar包。 对主程序是否有效：有效 对测试程序是否有效：有效 是否参与打包：不参与 是否参与部署：不参与 典型例子：servlet-api.jar maven命令是什么？ maven这个程序，用来构建项目所使用的命令。（这些命令的顺序，就是生命周期的顺序） 比如【1】清理：mvn clean 【2】：编译主程序：mvn compile 【3】：编译测试程序：mvn test-compile 【4】：执行测试：mvn test 【5】：打包：mvn package 【6】：安装：mvn install 【7】：生成站点：mvn site这些命令，构成了Maven构建项目时的，不同生命周期， 12.Maven的生命周期 【1】意思：就是Maven构建项目的的，各个构建环节执行的顺序。：不能打乱顺序，必须按照既定的正确顺序来执行，是生命周期的各个阶段的命令来实现的。 【2】生命周期是在Maven的核心程序中定义了，抽象的生命周期。 生命周期中各个阶段的具体任务是由插件来完成的。 【3】有三套独立的生命周期： ①Clean Lifecycle（清理生命周期）在进行，在真正的构建一个项目之前，必须先进行一些清理工作。 ②Default lifecycle（默认的生命周期）构建的核心部分，编译，测试，打包，安装，部署等等。 ③Site Lifecycle（生成站点生命周期）生成项目报告，站点，发布站点。 【4】每个生命周期的具体实现 比如：只执行“mvn clean 清理命令”就会进行清理生命周期。 执行“mvn install 安装命令”就会进行Maven构建项目的默认生命周期，此时Maven核心程序，会从头开始执行“clean清理”,“compile 编译”，“test-compile 编译测试”，“test 执行测试”，“package 打包”，“install 安装”这一系列的过程。 执行“site 生成站点”，也会从头开始，将所有过程进行一边。这是生成站点生命周期 Maven核心程序为了更好的实现自动化构建，按照这一的特点执行生命周期中的各个阶段：不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行。 【5】生命周期的各个阶段仅仅定义了要执行的任务是什么（命令）完成这个命令，是由特定的Maven插件来完成的。 创建Maven工程之前，需要将IDEA编辑器，和本地下载的Maven程序，进行关联配置。具体操作，见文末。 三、使用IDEA创建普通的javaMaven工程 四、.使用IDEA创建webMaven工程（Maven要聚合模块的做法） 【1】必须先创建一个空的工程。在空的工程中添加模块。（每次添加模块都要使用快捷键“ctrl+alt+shift+s”来调出Project Structure窗口，在这个窗口中添加模块，不能直接在模块上面右键添加模块。（在模块上右键模块会添加到“模块里面”）） 【标准的Maven工程，分模块的大型web项目，目录结构】 说明 我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。 五、依赖 依赖的传递性： 【1】依赖的传递性是指，如果在一个大型的项目当中，各个模块相互依赖，那么在“最下面的模块（依赖关系最下面，这个模块只是被依赖，不去依赖别的模块）”中，pom.xml文件里面，配置的compile”范围的依赖jar包，其他模块的pom.xml文件虽然没有声明一样的compile”范围的依赖jar包，但是也可以使用这个依赖。 【2】前提是“compile”范围的依赖才能传递，“test”“provided”范围的依赖不能传递。所以在各个工程模块中，能够传递的依赖，只在“最下面”模块中声明一次就可以了，不能够传递的“test”“provided”范围的依赖就得各个模块中重复声明依赖。比如：servlet的依赖，他就是“provided范围的模块”，需要在每一个项目模块pom.xml文件中，都要重复声明。 【3】我们在开发项目的时候，会有一个专门的模块来负责维护这些框架jar包的依赖信息的。在这个模块中，全部都写“compile”范围的依赖”，让其他功能模块，来依赖这个“专门模块”，就可以实现“compile”范围的依赖”通用。 【4】子类继承了父类模块，也可以实现依赖传递，默认就是依赖的，不需要再在子类中，重新声明依赖父类，只在子类中声明父类就可以了。 依赖的排除： 依赖的排除，在哪个工程里面排除的，就在哪个工程里面生效。 【1】当我们导入某些依赖jar包的时候，Maven会自动将这个jar的其他依赖jar包也一起导入到工程当中，这个时候，如果不需要这个额外的jar包，就可以用“排除依赖”来进行排除。 【2】找到要排除的依赖的ID（假如spring-jcl依赖要被排除） 3】添加 标签 依赖原则： 解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决） 前提是因为“依赖的传递性”导致的jar包冲突问题。 冲突情景： properties标签配合自定义标签声明数据的配置并。(可以利用这个标签，实现在一个页面上，同种类型的框架jar包，版本号相同，)在父模块中就更简便了 123456789101112131415161718&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;!--不是只能用于声明依赖的版本号。凡是需要统一声明后再引用的场合都可以使用。--&gt;&lt;/properties&gt;&lt;!--spring-core依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring-core依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 六、Mavne继承（pom文件的继承） 存在的问题：我们都知道在一个“模块项目1”中配置了“compile”范围的依赖jar包”，“其他模块项目”来依赖这个“模块项目1”的时候，“其他模块项目”中会自动的存在了“项目模块1的”“compile”范围的依赖jar包”。这是依赖的传递性。只用在“模块项目1”中声明一份就可以了。 但是：如果是““test”“provided”范围的依赖是不能传递的”，需要在每一个模块中都要，重复的手动添加““test”“provided”范围的依赖”，比如“junit依赖”，他就是“test范围的依赖”。（不能够传递的依赖，他就是零散的分散在各个模块当中，就很容易造成各个模块工程之间的版本不一致）。 这就存在一个问题，开发一个大型项目的时候，各个模块是不同开发组来开发的，使用“junit这种依赖”的时候，可能版本号就会不相同，导致各个模块之间不统一。 解决办法：使用Maven的继承，统一成同一个版本。（以junit依赖为例） 【1】专门创建一个模块是所有模块的“父模块”，可以用作““compile”范围的依赖jar包”传递依赖。也可以用作““test”“provided”范围的依赖”的版本管理。 【2】解决思路：将junit依赖统一提取到“父”工程中，在子工程中声明junit依赖时不指定版本，以父工程中统一设定的为准。同时也便于修改。 【3】操作步骤 [1]创建一个Maven工程作为父工程。注意：打包的方式pom 1234&lt;groupId&gt;com.atlml.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; [2]在子工程中声明对父工程的引用（认干爹的一个仪式） 123456789&lt;!--子工程中声明父工程--&gt;&lt;parent&gt; &lt;groupId&gt;com.atlml.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--以当前pom文件为基准的,找父工程pom.xml文件的相对路径--&gt; &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; [3]在父工程中统一管理junit的依赖 1234567891011121314&lt;!--依赖管理，这里专门用来管理，不能够传递的依赖，进行版本号控制--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- junit是“test”范围的依赖，不能够传递，在这里面统一管理版本号--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; [4]在子工程中删除junit依赖的版本号部分 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--&lt;version&gt;4.11&lt;/version&gt;--&gt; 删除掉 &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; [5]实现效果 [6]：父模块的Pom.xml文件的配置。 七、Maven的聚合： （聚合就是Maven中，各个模块的一键安装。） 注意：配置了继承的模块，在执行安装命令（ install）的时候，要先安装 “父模块”再安装其他模块才能成功。 Maven中的一件安装，就可以自动的按顺序，将每个模块都按依赖顺序进行安装。 实现一件安装步骤： 【1】创建一个“总的聚合工程”，（一般把“父模块”作为“总的聚合工程”，大的情况下也是将，聚合的配置，也配在父模块内） 【2】在一个”总的聚合工程”的pom.xml文件中，配置各个參与聚合的模块 123456&lt;!--配置聚合--&gt;&lt;modules&gt; &lt;!--指定各个子工程的相对路径--&gt; &lt;module&gt;../Hellow&lt;/module&gt; &lt;module&gt;../HellowFriend&lt;/module&gt;&lt;/modules&gt; 八、Maven仓库地址 Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com) 仓库服务 (aliyun.com) 九、IDEA中Maven配置IDEA配置Maven的超详细步骤_java_脚本之家 (jb51.net) IDEA配置Maven（详细版）_idea maven-CSDN博客 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"},{"name":"maven","slug":"java/maven","permalink":"https://protonlml.github.io/categories/java/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://protonlml.github.io/tags/maven/"},{"name":"项目自动化构建工具","slug":"项目自动化构建工具","permalink":"https://protonlml.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}],"author":"𝚲𝚳𝚲"},{"title":"javaScript","slug":"javascript","date":"2019-10-01T04:00:00.000Z","updated":"2024-06-16T02:11:23.105Z","comments":true,"path":"2019/10/01/javascript/","link":"","permalink":"https://protonlml.github.io/2019/10/01/javascript/","excerpt":"","text":"javaScript 静态网页资源的三剑客：HTML（文本），CSS（样式），JavaScript（行为）。把后面两个效果，加在HTML文本上，就会呈现出很好看的网页界面。 程序设计有两种架构：1 c&#x2F;s架构，是客户端和服务器端，要开发两个程序。2 b&#x2F;s架构，是浏览器和服务端。只用浏览器来申请服务器端的资源，再展示出来就好了。只用开发服务器端一个软件。 javaWeb开发，是B&#x2F;S架构的。 事件：事件是什么意思？通俗的理解，HTML中的元素组件，被某个动作（事件的属性），触动后，会发生一定的变化。（执行了另一个js代码）。 将HTML，CSS，JavaScript分别独立出来，可以降低耦合度， javaScript最初被设计用于浏览器中，他和java语言没有关系，他是客户端脚本语言 javaScript语言运行出错，要在浏览器控制台上面查看。F12打开控制台。 - 一、javaScript 注意：在一个html的页面中，可以定义多个script的标签，而且存放的位置是任意的，但是会影响运行的先后顺序，一般都是等html页面元素全部加载完毕，再运行js代码，并且是一种等待状态。当在html中的某个位置，触发了某个事件，此时对应的js等待代码，就会执行。从而产生行为效果 1.javascript与HTML的关联方式： 内部关联 外部关联 2.javascript的数据类型 原始数据类型： 1. number：数字 。 整数/小数/ NAN （not a number 一个不是数字的数字类型） 2. string ：字符串。字符串 &quot;abc&quot; &quot;a&quot; &#39;abc&#39; 3. boolean：true 和 false 4. null：一个对象为空的占位符 5. undefined：未定义，如果一个变量没有给他初始化值，则会被默认赋值为undefined 注意：NaN是number类型，他是（不是数字的数字）。在js当中，运算符，后面的运算数，不是运算符要求的类型，js就会自动的将运算数进行类型转换。比如：numb&#x3D; +”abc”;此时：number根据”+”运算符，如果是数字，就会直接转换成数字，但是转换符后面跟的不是数字类型，则会转换成不是数字的数字类型。值为NaN. 3.JavaScript的变量 什么是变量：变量就是内存空间中的一小片区域。有类型，有名称，有值。比如：int a&#x3D;3; JavaScript的变量是弱类型的，什么叫弱类型，就是不管定义什么类型的变量，都用var开头。 而java中定义整型用int，定义字符型用char 。所以java是强类型的。 ☆ 通过typeof(变量名)可以得到变量的类型 注释:你也许会问,为什么typeof运算符对于nul值会返回”object”.这实际上是javaScript最初实现中的个错误,然后被ECMAScript沿用了,现在,null被认为是 对象的占位符,从而解释了这一矛盾,但从技求上来说,它仍是原始值。 4.javascript中的运算符 ①一元运算符：就是只有一个运运算数的运算符。 ++ 、–、+（正号）、-（负号） “++（–）”在前，先自增（自减），再运算。 “++（–）”在后，先运算，再自增（自减）。 +（-）（正负号） ②算数运算符：“+”，“-”，“* ”，“&#x2F;” ，“%”（和java中使用方法相同） ③赋值运算符：“+&#x3D;”，“-&#x3D;”“&#x3D;”（和java中使用方法相同） ④ 比较运算符：“&gt;”，“&lt;”，“&gt;&#x3D;”，“&lt;&#x3D;”，“&#x3D;&#x3D;”， “&#x3D; &#x3D;&#x3D;（全等于）” “&#x3D; &#x3D;”是比较两个数是否相等，“&#x3D;&#x3D;&#x3D;全等于”是加上了类型的比较。 ⑤ 逻辑运算符：“&amp;&amp;”，“||”，“！” ⑥ 三元运算符“ ？：表达式” 二、javascript 中的特殊语法.(了解一下就好，但是要和java规范一样写代码，不要省“；”，也不要省“var”，带var的变量，是局部变量，不带var的变量是全局变量 。) 三、流程控制语句 练习 ：javascript（9x9乘法表） 四、BOM对象： 概念：Browser object Model 浏览器对象模型。将浏览器各个组成部分封装为对象。 BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。① window窗口对象。 window窗口的第一类方法：弹窗有关的方法 window窗口的第二类方法：打开关闭窗口的方法。 window窗口的第三类方法：与定时器有关的方法 Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（.html文件对象）。直接写就可以用 ②、 Location地址栏对象 Location 对象的方法。reload().用来刷新当前页面。 属性：href Location地址栏对象，他的一个属性href。有两个作用，设置当前页面的URL和获取当前页面的完整的URL.（这里面的设置和获取URL都是针对当前页面的。设置的话，就是重新赋值，设置为新的地址，这样当前页面就会跳转到设置的地址页面中去） 倒计时跳转网页案例 ③、 history当前页面历史记录对象。 属性：length：history.length；返回的是。历史记录的个数。 方法：back();加载history列表中的上一个URL。绑定单击事件，就可以做一个后退的按钮。 方法： forword(); 加载history列表中的下一个URL。绑定单击事件，就可以做一个前进的按钮。 方法：go(); 加载history列表中的某一个具体页面。 五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML DOM对象。） ☆ DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。 ☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。 DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析） DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。 ①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element(其他标签对象)对象。或者是创建Element (其他标签对象)对象。 document.write(““) 向页面上写出一条横线（就是往页面写出信息的） 1.1 document对象：获取element对象的方法。 getElementById（） ：根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName （） ：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName （）：根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName（）：根据name属性值获取元素对象们。返回值是一个数组 1.2 document对象：创建其他DOM对象： createElement（“标签名”）：创建元素节点（记住） createAttribute（name）：创建拥有指定名称的属性节点，并返回新的Attr对象。（了解） createComment（）：创建注释节点。（了解） createTextNode（）：创建文本节点。（了解） ②：Element对象（元素标签对象） 1，获取&#x2F;创建：通过document来获取和创建 2.方法： removeAttribute（“”） ：删除属性 setAttribute（“属性名”，“属性值”） ：设置属性值。 补充：input框框，有个value属性，用其节点对象.value可以得到，文本框里面的内容。 ③：Node对象 （是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。 appendchild（节点对象名） ：向节点的子节点列表的结尾添加新的子节点。（增） removechild（节点对象名） ：删除（并返回）当前节点的指定子节点。（删） replacechild（节点对象名） ：用新节点替换一个子节点。（改，不常用）。 属性：父节点&#x3D;当前节点.parentNode; 返回当前节点的父节点。 六、☆javascript 中的几个对象的学习。 1.☆ function函数方法对象、Array数组对象。 function对象，在javascript 中，定义方法，是用function对象，来定义方法的。 语法：function 方法名（参数列表）{方法体} &#x2F;&#x2F; javascript中定义方法，的写法和java类似。 但是是用的function对象定义的方法 &#x2F;&#x2F; js中用function定义的方法，参数列表不用写类型，返回值不用写类型 &#x2F;&#x2F; js中用function定义的方法，如果有多个同名的方法，那么后面的同名方法，会覆盖前面的同名方法， &#x2F;&#x2F; js中用function定义的方法，在调用方法时，只要方法名确定就会调用最后面的同名不同参数的方法。他和参数列表无关。 &#x2F;* js中用function定义的方法，参数列表的括号里面隐藏了一个内置对象，是一个arguments的数组。 所以当参数列表中不写形式参数时，function add(){ 方法体} 括号里面就是一个可变形参 每一个传递过来的实参，都存在arguments[0].arguments[1]……..等数组中。 *&#x2F; 2.☆ Array数组对象 3.☆ Date日期对象 4.☆Math数学对象 5.☆ regExp：正则表达式对象。 先了解什么是正则表达式 正则表达式就是定义字符串的组成规则（通用的规则，在Java中或者其他语言中都可以使用）。在表单的输入框的地方，实现校验输入的字符串是不是符合正则表达式的规则。不符合校验失败，阻止表单的提交。 ☆ Javascript对表单的校验，是依赖于正则表达式的。 正则表达式对象。regExp 6.☆全局对象 在javascript中，有一个全局对象Global，他不用创建对象，直接用其内部的方法，就可以实现对应的功能，一般有字符串的URL编解码方法。 七、 事件绑定的方式 得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。 八、HTML DOM：是关于如何获取、修改、添加或删除HTML元素的标准 ☆①所有的节点对象都有的关键的属性innerHTML innerHTML。是获取节点对象，里面的所有内容。就是获取了，一对“&lt;&gt;标签体&lt;&#x2F;&gt;”中的标签体的内容。标签体可以是一段文字，也可以是其他标签。 通过给innerHTML赋值或者追加值，可以改表标签体的内容。如下图 上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。 ☆②所有的节点对象都有的关键的属性style。 1.给style属性赋值，就可以改变其样式。 注意：两个单词的写法 2. 改变节点对象的class值。用className属性。 3.要想设置和修改，节点的属性值。查Api文档。例如： 标签图片标签，每出现一次，一个 Image 对象就会被创建。找image对象的属性，src设置或返回图像的 URL 九、事件 事件分类 1.点击事件 onclick：单机事件 ondblclick ：双击事件 2.焦点事件 onblur：失去焦点 一般用于表单验证,当光标不在输入框时，就会失去焦点，触发onblur事件发生。 onfocus：元素获得焦点 3.加载事件 onload：一张页面或者一幅图像完成加载 内部加载方式：script标签如果写在head标签里面，在上面的话，要使用窗口的事件机制，加载事件来控制，js 代码，在HTML页面加载完全，才运行。 如下图 4.鼠标事件 onmousedown ：标按钮披按下. 定义方法时,定义一个形参,接受 event 对象. eventi对象的button属性可以获取鼠标按钮键被点击了. onmouseup ：鼠标按键被松开. onmousemove ：鼠标被移动. onmouseover：鼠标移到某元素之上. onmouseout：鼠标从某元素移开. 5.键盘事件 onkeydown： 某个键盘按键被按下. onkeyup ：某个键盘按键被松开. onkeypress： 某个键盘按键被按下并松开. 6.选择和改变事件 onchange：域的内容被改变. ☆ 当在选择的下拉列表上，选择某个选项会触发该事件。 onselect：文本被选中. 7.表单事件: onsubmit：确认按钮被点击. 可以阻止表单的提交 方法返回falsel则表单被阻止提交. 写法： onreset：重置按钮被点击. 练习：动态表格案例 ☆动态表格案例总结：用DOM对象在内存层面你，不管创建了多少子节点或者父节点，这些结构都是在内存层面上的，在浏览器页面上不能够直接显示，要想显示，必须有html的已有标签对象。先获取已有的html标签对象节点，将内存层面上的节点，appendChild为已有节点的子节点。同时，属性的样式会关联到css样式表中，只要和css表中的选择器对应的上，就可以显示样式。 ☆ 技巧：怎样获取当前标签的对象，直接在html标签后面，加上事件属性。绑定事件方式一，事件调用指定方法，括号里面写this。 那么就可以在方法声明的地方，形式参数就是当前对象。如下图： 总结1： 怎么来理解BOM对象和DOM对象以及HTML DOM对象？ 1 . BOM对象，就是将浏览器各个组成部分，封装为对象。有显示器对象、浏览器对象、windows窗口对象、URL地址栏对象、以及历史记录对象，这5个BOM对象。windows窗口对象，是BOM对象中的主要对象，因为其他对象都在一个窗口当中。可以通过windows对象来获取，其他4个BOM对象。 2 .在windows窗口获取的document对象，是DOM对象。 document对象是DOM对象的主要对象。DOM对象也在窗口内，但是只有document对象（.html文件对象）是通过窗口获取，其他DOM对象是通过document对象获取的。 3 .document对象，他是将整个文档封装成一个document对象。对应着HTML里面最外层标签。他可以获取其他节点对象 document.getElementById()；。或者对象们；另外也可以创建其他DOM对象。 4.有了一些基础的DOM对象，也就是有了某个标签的（节点）的对象之后。然后用HTML DOM来、对这个对象进行获取、修改、添加或删除操作。 5.从上往下看，一层一层的，从窗口(window)——&gt;文本对象(document)——&gt;单个文本元素对象(element)——&gt;单个文本元素操作（HTML DOM）这样方便记忆。也便于理解。 节点：在HTML中所有的单个元件，就是单个节点。对应着一对，一对的标签。 子节点：外标签包着内标签，也就是节点包着子节点。例如：文字 超链接。 Node 节点对象：他可以认为是虚有的，它里面的方法用来“CRUDdom树” 其实就是所有的DOM对象，都是一个节点，DOM对象本身，就可以增加节点，删除节点，替换节点，查询节点。 有了DOM这些对象，用他们的功能。就可以用javaScript语言对HTML的标签进行操作。 要记住：虽然能用，JavaScript语言来操作，内存层面的HTML的元素对象代码，使其在浏览器上面显示样式。但是他和HTML里面的标签没有，任何关系。 执行了“JavaScript语言操作的元件对象，比如添加节点，删除节点”不会再HTML文档中自动生成，HTML代码。 理解、标签、标签体、标签属性、控制元素的样式。 1.1标签: 标签就是一对对的&lt;&gt;&lt;&#x2F;&gt;。例如：&lt;img&gt; &lt;/img&gt; 1.2标签体:一对标签里面的内容。例如：&lt;img&gt;这是标签体，可以是子标签也可以是文字 &lt;/img&gt; 1.3 标签属性: 定义在标签&lt;&gt;里面的。例如：&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt; 1.4 标签控制样式: 总结2： 一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求 &lt;script&gt;js代码&lt;/script&gt;，标签一般都写在&lt;body&gt;......&lt;script&gt;&lt;/body&gt;body标签的最下面。 js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://protonlml.github.io/tags/javaScript/"}],"author":"𝚲𝚳𝚲"},{"title":"59.动态代理","slug":"59.动态代理","date":"2019-09-30T15:38:00.000Z","updated":"2024-07-20T15:00:19.850Z","comments":true,"path":"2019/09/30/59.动态代理/","link":"","permalink":"https://protonlml.github.io/2019/09/30/59.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"动态代理 一、动态代理; 为什么要有动态代理对象？ 因为在已有的项目的老代码中，我们不可能去修改，某个对象中的方法。修改了之后可能会导致整体项目崩溃。 那么我们在新业务中又想用这个已有老对象中的老方法，但是这个方法，它功能太落后了。我想给它添加一些其他功能，而且又不能修改原有代码。 解决办法; 非侵入式增加功能。 1.我们可以将这个对象中要用到，需要增强功能的多个方法，给抽象到一个接口当中。然后将这个对象所在类实现这个接口。 2.然后生成一个代理对象，这个代理对象也要实现这个接口，重写接口中的方法，这样这个代理对象就有了需要用到的所有方法。并且可以在其中添加增强功能的代码，然后真正的核心代码还是调用老对象中的老方法来实现。代理对象中，只做了增强功能的代码，核心还是原来老对象的方法。 注意：代理对象在java中是有固定对象的，newProxyInstance(); 所以我们要创建一个生成动态代理对象的工具类，在这个工具类中定义生成某个对象的代理对象方法。 动态代理的写法","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"58.反射","slug":"58.反射","date":"2019-09-29T14:38:00.000Z","updated":"2024-07-20T14:58:43.828Z","comments":true,"path":"2019/09/29/58.反射/","link":"","permalink":"https://protonlml.github.io/2019/09/29/58.%E5%8F%8D%E5%B0%84/","excerpt":"","text":"反射 一、反射 二、获取class对象的三种方式123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atlml.reflex;import java.lang.reflect.InvocationTargetException;/** * 获取反射的 class对象的三种方式 */public class ReflexDemo &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; /** * 获取class字节码对象的三种方式 * * 1.Class.forName(全限定类名); * 2.类名.class * 3.对象.getclass */ //1.Class.forName(); // 最为常用 Class clazz = Class.forName(&quot;com.atlml.reflex.Student&quot;); System.out.println(clazz); //2.类名.class //当作参数传递 /* synchronized (Student.class)&#123; &#125; */ Class&lt;Student&gt; studentClass = Student.class; System.out.println(studentClass); //3. 对象.getClass //有局限性，当只有 对象 才能使用 Student student = new Student(); Class&lt;? extends Student&gt; aClass = student.getClass(); System.out.println(aClass); //class com.atlml.reflex.Student //class com.atlml.reflex.Student //class com.atlml.reflex.Student &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.atlml.reflex;import java.io.IOException;public class Student extends Teacher &#123; //年级 这个成员变量是 公共的 public String grade; //性别 公共的 public String gender; private Integer age; private String name; public Student() &#123; &#125; public Student(Integer age) &#123; this.age = age; &#125; public Student(String name) &#123; this.name = name; &#125; /** * 私有的全参构造器 * * @param age * @param name */ Student(Integer age, String name) &#123; this.age = age; this.name = name; &#125; /** * 公有的静态方法， */ public static void lookbook(String book) &#123; System.out.println(&quot;公有的静态方法，学生看&quot; + book + &quot;书&quot;); &#125; /** * 私有的静态方法 */ private static void shopping() &#123; System.out.println(&quot;私有的静态方法，学生购物&quot;); &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; /** * 学生学习方法 */ public void study() &#123; System.out.println(&quot;这是公有的方法，学生学习&quot;); &#125; /** * 私有的 吃饭方法 */ private String eat(String fan, Integer price) throws IOException, NullPointerException, RuntimeException &#123; return &quot;这是私有的方法，学生吃&quot; + fan + &quot;饭,花了&quot; + price + &quot;元&quot;; &#125;&#125; 三、利用反射获取构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.atlml.reflex;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;import java.util.Arrays;import java.util.List;/** * 利用反射获取构造方法 */public class ReflexDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //通过反射 获取Student 的字节码class对象 Class clazz = Class.forName(&quot;com.atlml.reflex.Student&quot;); //获取 student类中的 构造器 try &#123; Constructor[] declaredConstructors = clazz.getDeclaredConstructors(); //1.获取所有公有的构造器方法 Constructor[] constructors1 = clazz.getConstructors(); System.out.println(Arrays.asList(constructors1)); //[public com.atlml.reflex.Student(), public com.atlml.reflex.Student(java.lang.Integer), public com.atlml.reflex.Student(java.lang.String)] // 2.获取所有构造器，包括私有的 List&lt;Constructor&gt; constructors = Arrays.asList(declaredConstructors); System.out.println(constructors); //[public com.atlml.reflex.Student(), private com.atlml.reflex.Student(java.lang.Integer,java.lang.String), public com.atlml.reflex.Student(java.lang.String), public com.atlml.reflex.Student(java.lang.Integer)] /* 使用Declared 表示当前构造方法是私有的也可以被获取 直接使用 getConstructor() 获取单个构造器，只能是公共的 如果获取的不是公共的，或报错 */ //3.获取单个构造器(空参的) Constructor constructor = clazz.getDeclaredConstructor(); System.out.println(constructor); //public com.atlml.reflex.Student() //4.获取单个构造器，一个参数的 // 参数是 构造器参数是 ，参数类型的字节码 Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class); System.out.println(declaredConstructor); //public com.atlml.reflex.Student(java.lang.String) //5.获取单个构造器，一个参数的 // 参数是 构造器参数是 ，参数类型的字节码 Constructor declaredConstructor1 = clazz.getDeclaredConstructor(Integer.class); System.out.println(declaredConstructor1); //public com.atlml.reflex.Student(java.lang.Integer) //6.获取单个构造器，一个参数的 // 参数是 构造器参数是 ，参数类型的字节码 Constructor declaredConstructor2 = clazz.getDeclaredConstructor(Integer.class, String.class); System.out.println(declaredConstructor2); //private com.atlml.reflex.Student(java.lang.Integer,java.lang.String) /** * 构造方法获取到了，就能获取 构造方法上的所有内容 * 1.权限修饰符 * 2.获取所有形参 * 3.能创建这个类的对象 */ // 7.通过反射来获取 构造方法中的所有内容 //7.获取权限修饰符 int modifiers = declaredConstructor2.getModifiers(); System.out.println(modifiers);//2 // private-&gt; 2 ，public-&gt;1 //8. 获取当前构造函数的所有参数 Parameter[] parameters = declaredConstructor2.getParameters(); System.out.println(Arrays.toString(parameters)); //[java.lang.Integer arg0, java.lang.String arg1] //9. 通过构造方法，创建对象 // 注意：这个方法是private私有的 //临时取消权限的校验,没有下面这句话会报错（暴力反射） declaredConstructor2.setAccessible(true); Student student = (Student) declaredConstructor2.newInstance(23,&quot;张三&quot;); System.out.println(student); //Student&#123;age=23, name=&#x27;张三&#x27;&#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 五、利用反射获取成员变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.atlml.reflex;import java.lang.reflect.Field;import java.util.Arrays;/** * 利用反射获取成员变量 */public class ReflexDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; try &#123; // 获取 反射 字节码文件 Class clazz = Class.forName(&quot;com.atlml.reflex.Student&quot;); //1.返回所有 公共的 成员变量 Field[] fields = clazz.getFields(); System.out.println(Arrays.toString(fields)); //[public java.lang.String com.atlml.reflex.Student.grade, public java.lang.String com.atlml.reflex.Student.gender] // 2.返回所有成员变量对象的数组(公有，私有) Field[] declaredFields = clazz.getDeclaredFields(); System.out.println(Arrays.toString(declaredFields)); //[public java.lang.String com.atlml.reflex.Student.grade, public java.lang.String com.atlml.reflex.Student.gender, private java.lang.Integer com.atlml.reflex.Student.age, private java.lang.String com.atlml.reflex.Student.name] //3.返回单个公共成员变量对象 Field field = clazz.getField(&quot;gender&quot;); System.out.println(field); //public java.lang.String com.atlml.reflex.Student.gender //4.返回单个成员变量对象 Field name = clazz.getDeclaredField(&quot;name&quot;); //5.获取成员变量 修饰符 int modifiers = name.getModifiers(); // 6.获取成员变量 名 String n = name.getName(); // 7.获取成员变量 数据类型 Class&lt;?&gt; type = name.getType(); System.out.println(type);//String System.out.println(n);//name System.out.println(modifiers);// 2 System.out.println(name);//private java.lang.String com.atlml.reflex.Student.name //8.获取成员变量 记录的值 Student s = new Student(12, &quot;张三&quot;); name.setAccessible(true);//临时获取权限 //9.获取 s 这个对象，name记录的值 Object value = name.get(s); System.out.println(value);//张三 //9.修改name成员变量，对象里面记录的值 name.set(s, &quot;王一平&quot;); System.out.println(s); //Student&#123;age=12, name=&#x27;王一平&#x27;&#125; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 六、利用反射获取成员方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atlml.reflex;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Parameter;import java.util.Arrays;/** * 利用反射 获取 成员方法 */public class ReflexDemo3 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Class clazz = Class.forName(&quot;com.atlml.reflex.Student&quot;); //1.返回所有 公共成员方法 的数组，包括继承的 Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; System.out.println(method); &#125; System.out.println(&quot;----------------------------------------------&quot;); //2.返回所有 成员方法 的数组，不包括继承的 Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) &#123; System.out.println(declaredMethod); &#125; System.out.println(&quot;----------------------------------------------&quot;); //3.返回单个公共成员方法对象(这个方法必须是公有的) // 参数一：方法的名字， // 参数二、方法的形参类型，可以是多个（为了方法的重载） Method lookbook = clazz.getMethod(&quot;lookbook&quot;, String.class); System.out.println(lookbook); //public static void com.atlml.reflex.Student.lookbook(java.lang.String) // 运行当前的方法 Student student = new Student(); //参数1：是哪个学生对象，调用方法的形参是什么 Object a = lookbook.invoke(student, &quot;鲁宾孙漂流记&quot;); System.out.println(a);//没有返回值 null System.out.println(&quot;----------------------------------------------&quot;); //4.返回单个成员方法对象(私有的，公有的都能获取) // 参数一：方法的名字， // 参数二、方法的形参类型，可以是多个（为了方法的重载） //eat 是私有的 Method eat = clazz.getDeclaredMethod(&quot;eat&quot;,String.class,Integer.class); System.out.println(eat); //4.1获取当前方法的权限修饰 int modifiers = eat.getModifiers(); System.out.println(modifiers); //2 私有的 //4.2 获取方法名 String name = eat.getName(); System.out.println(name); //eat //4.3 获取方法的形参,这里两个参数 Parameter[] parameters = eat.getParameters(); System.out.println(Arrays.toString(parameters)); // [java.lang.String arg0, java.lang.Integer arg1] //4.4 获取方法的抛出的异常 Class&lt;?&gt;[] exceptionTypes = eat.getExceptionTypes(); for (Class&lt;?&gt; exceptionType : exceptionTypes) &#123; System.out.println(exceptionType); &#125; //class java.io.IOException //class java.lang.NullPointerException //class java.lang.RuntimeException //4.5 运行当前方法 Student student1 = new Student(&quot;小明&quot;); eat.setAccessible(true);//临时获取访问权限（eat是私有的方法） String result = (String) eat.invoke(student1, &quot;鱼香肉丝&quot;,18); System.out.println(result);//这是私有的方法，学生吃鱼香肉丝饭,花了18元 &#125;&#125; 七、反射的作用获取一个类里面所有的信息，获取到了之后，再执行其他的业务逻辑结合配置文件，动态的创建对象并调用方法练习1：对于任意一个对象，都可以把对象所有的字段名和值，保存到文件中去12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atlml.reflex;import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Field;/** * 练习1 * 对于任意一个对象，都可以 * 把对象所有的字段名和值， * 保存到文件中去 */public class Practice1 &#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, IOException &#123; Student student = new Student(&quot;小A&quot;, 23, &#x27;女&#x27;, 167.5, &quot;睡觉&quot;); Teacher teacher = new Teacher(&quot;波妞&quot;, 10000); // 思路// 利用反射，来获取某个对象中的私有成员变量 信息 saveToFile(student); saveToFile(teacher); &#125; /** * 将 对象 中的信息 保存到本地文件中 */ public static void saveToFile(Object o) throws NoSuchMethodException, IllegalAccessException, IOException &#123; Class&lt;?&gt; aClass = o.getClass(); /* //获取构造方法数组 Constructor[] declaredConstructors = aClass.getDeclaredConstructors(); for (Constructor declaredConstructor : declaredConstructors) &#123; System.out.println(declaredConstructor); &#125;*/ //写到本地文件中 BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(new File(&quot;javabasis\\\\aaa\\\\ObjectMemberVariable.txt&quot;), true));//追加 //获取所有的 成员变量（公有，私有都存在） Field[] declaredFields = aClass.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; //临时取消私有权限 declaredField.setAccessible(true); String name = declaredField.getName(); //name Object value = declaredField.get(o);//value //成员变量值，每个值都拿出来 System.out.println(name + &quot;=&quot; + value.toString()); bufferedWriter.write(name + &quot;=&quot; + value.toString()); bufferedWriter.newLine();//换一行 &#125; bufferedWriter.close(); &#125;&#125; 练习2：反射可以跟配置文件结合的方式，动态的创建对象，并调用方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atlml.reflex;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;/** * * 练习二 * 反射可以跟配置文件结合的方式，动态的创建对象，并调用方法 */public class Practice2 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; //1.将配置文件加载到内存中 // Properties 的父类是一个map集合 Properties properties = new Properties(); properties.load(new FileInputStream(new File(&quot;javabasis\\\\src\\\\main\\\\resources\\\\properties.properties&quot;))); System.out.println(properties);//&#123;classname=com.atlml.reflex.Student, method=study&#125; //2.输出配置文件中的内容 //3.根据配置文件中的全限定类名，反射创建对象，调用方法 Class clazz = Class.forName(properties.getProperty(&quot;classname&quot;)); //获取构造函数 Constructor declaredConstructor = clazz.getDeclaredConstructor(); declaredConstructor.setAccessible(true);//创建对象 Student student = (Student) declaredConstructor.newInstance(); System.out.println(student); //获取成员方法,并调用。从配置文件中拿到方法名 Method study = clazz.getDeclaredMethod(properties.getProperty(&quot;method&quot;)); Object invoke = study.invoke(student);//这是公有的方法，学生正在学习 &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"57.多线程","slug":"57.多线程","date":"2019-09-28T01:38:00.000Z","updated":"2024-07-20T14:58:48.429Z","comments":true,"path":"2019/09/28/57.多线程/","link":"","permalink":"https://protonlml.github.io/2019/09/28/57.%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"多线程 一、多线程 多线程： 一个软件运行了，就相当于一个“进程”，然后软件中，有很多独立的功能，多个功能就是多个线程。 比如：腾讯电脑管家运行了，他是一个进程，里面的“病毒查杀”“垃圾清理”“电脑加速”等功能分别是多个线程，他们可以同时在这个“电脑管家”进程中，同步进行。并列执行。这就是多线程 （比如：手机启动游戏的时候，有线程是加载本地文件，有的线程是加载背景音乐，有的线程是加载动态背景图，多个线程并行运行） 开发中，需要用到多线程的时候，当前模块项目就是一个进程，里面有很多独立的业务流程，他们是可以并行执行的。不一定都是单线程的，执行了这个功能，需要等待执行完才能执行下一个功能。这样是很慢的。所以需要多线程。当业务代码中需要多线程的时候，我们用代码手动创建另一个或者多个线程，将不同的业务代码流程，分别写在多个线程内部。当执行这个软件的时候，执行到此部分多线程业务时，会自动的开多线程并行执行多个业务功能，同时产生结果，最终返回给主线程。、项目主业务流程都是在，main中开始的线程，就是主线程。当需要执行其他的业务流程时，需要从main其中开启其他线程的。（比如：手机启动游戏的时候，有线程是加载本地文件，有的线程是加载背景音乐，有的线程是加载动态背景图，多个线程并行运行）&#x2F;&#x2F;一般java中有线程池，我们使用线程池来拿线程就行了，然后进行使用。目的是：线程也是资源，每次都要创建需要耗费时间，如果某个线程一直不释放，就会占用很长时间的资源内存。所以我们写代码时，不要自己创建，java已经给创建好了，我们只需要从线程池中拿线程对象来开启新线程。并且java也会自动管理这个线程。&#x2F;&#x2F; CPU 执行多个线程，单核cpu就是，执行1线程，然后又去执行2线程，执行3线程，多个线程交替执行，由于cpu速度非常快，感觉几个线程是，同时并行执行的，其实不是。CPU多核多线程，如4核8线程，指的是CPU能够同时一下8个线程同时并行执行，每个线程都是独立的，速度更快。如果此时开启了16个线程，那么它也是8个线程，和另8个线程交替执行。 并发：在同一时刻，多个指令在单个CPU上交替执行。并行：在同一时刻。有多个指令在多个CPU上同时执行。二、多线程三种实现方式 第一种 第二种 第三种 三、Thread中常见的成员方法 线程的优先级 设置线程 的优先级，线程默认的优先级是5，主线程main线程默认的也是5，如果设置的优先级越高，线程抢到Cpu的概率就越高 守护线程 线程设置为守护线程（备胎线程），当其他的非守护线程执行完毕，守护线程会陆续结束。 例如：线程1是正常线程，线程2是守护线程，（线程1，线程2并行，同时抢占CPU线程）如果线程1中的要执行的业务结束了，那么线程2也会慢慢的结束掉自己的线程。线程2不是立马结束的。 应用场景 qq聊天，同时传输完毕，聊天是线程1，传输文件是线程2，聊天窗口结束了，传输文件也没必要存在了，会陆续结束 出让线程 出让当前线程的执行权，当前线程抢到了cpu资源，执行完线程中的代码，最下面可以出让当前cpu资源，这样就尽可能的保证每个线程都运行均匀的，每个线程执行是平均的（了解） 插入线程 将其他线程，插入到当前线程。（了解） 四、线程的生命周期 五、线程安全问题： 1.出现线程安全的例子 比如，卖100张票，创建了3个线程假设为3个窗口，3个线程中执行的业务代码是一样的，3个线程都要对这同100张票进行售卖。 这里100张票，属于3个线程的共享数据，共享数据只能有一份。某个线程对这个共享数据进行修改了，都会影响到其他线程中使用这个数据。 这里static 修饰的ticket变量作为“电影票变量” 在 线程任务对象中，只有一份，不管创建几个同种任务对象，都共享这个变量的值ticket,因为其是static的，属于类，类加载就加载了在方法区，只有一份。以后每次new的任务对象都在堆中，所以可以共享。（静态变量可以作数据共享，如所有学生对象，有同一个静态变量老师） 但是，在每个线程中，操作共享数据的代码，每个线程是抢夺cpu调度的，也就是说，线程1在操作这个共享ticket数据时，刚改完，线程2可能就抢到了cpu调度，线程2又把这个共享ticket数据给改了，那就会导致最终的共享数据是错误的。 2.解决办法 就是，将线程中，操作共享数据的这部分代码，给锁起来。如：线程1抢到了cpu调度时，执行操作共享数据这部分代码时，给包裹起来，此时只有线程1能执行它线程中这部分代码。其他线程都得等线程1执行完共享数据的操作，开锁了。其他线程才可以抢cpu调度 {执行操作共享数据的代码}。 这样就保证了，多线程共享数据的安全性，只有当某个线程全部操作完共享数据的代码，就是改完了确定改好了，才让其他线程去改。 这个锁就是同步代码块，让同步代码块里面的代码是线程轮流执行的 3.同步代码块 示例 4.同步方法 我们想要把一个方法中所有的代码都锁起来，直接在方法上加关键字synchronized 字符串拼接的时候StringBuffer 是线程安全的 StringBuffer 是线程安全的，它的所有方法，都是synchronized修饰的，同步方法，所以它线程安全（一个线程执行当前方法，其他任何线程只能等着我当前线程执行完毕，才释放）这种运行慢 StringBuilder 是线程不安全的 六、Lock锁 七、死锁是一个错误 以后在写锁得时候，千万千万不能让几个锁嵌套在一起了，之所以出现死锁是因为将，锁嵌套的写了。 八、等待唤醒机制（生产者，消费者) 8.1.（使用阻塞队列）实现消息唤醒 连接生产者与消费者之间的管道 厨师往队列中放一个，吃货从队列中吃一个 九、线程的6种状态 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"56.zip文件的导入导出","slug":"56.zip文件的导入导出","date":"2019-09-26T03:40:00.000Z","updated":"2024-07-20T14:53:41.462Z","comments":true,"path":"2019/09/26/56.zip文件的导入导出/","link":"","permalink":"https://protonlml.github.io/2019/09/26/56.zip%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"zip文件的导入导出 一、 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"55.压缩、解压缩流","slug":"55.压缩，解压缩流","date":"2019-09-26T02:40:00.000Z","updated":"2024-07-21T16:01:09.472Z","comments":true,"path":"2019/09/26/55.压缩，解压缩流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/55.%E5%8E%8B%E7%BC%A9%EF%BC%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%B5%81/","excerpt":"","text":"压缩、解压缩流 一、体系 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"54.字节打印流&字符打印流","slug":"54.字节打印流&字符打印流","date":"2019-09-26T01:50:00.000Z","updated":"2024-07-21T15:59:59.222Z","comments":true,"path":"2019/09/26/54.字节打印流&字符打印流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/54.%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81&%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81/","excerpt":"","text":"字节打印流&字符打印流 一、打印流不能读，只能写，他只有输出流 一、字节打印流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.atlml.io_stream.myprintstream;import java.io.FileNotFoundException;import java.io.PrintStream;import java.util.Date;public class PrintStreamDemo2 &#123; public static void main(String[] args) throws FileNotFoundException &#123; PrintStream ps = new PrintStream(&quot;a.txt&quot;); //% n表示换行 ps.printf(&quot;我叫%s %n&quot;, &quot;阿玮&quot;); ps.printf(&quot;%s喜欢%s %n&quot;, &quot;阿珍&quot;, &quot;阿强&quot;); ps.printf(&quot;字母H的大写：%c %n&quot;, &#x27;H&#x27;); ps.printf(&quot;8&gt;3的结果是：%b %n&quot;, 8 &gt; 3); ps.printf(&quot;100的一半是：%d %n&quot;, 100 / 2); ps.printf(&quot;100的16进制数是：%x %n&quot;, 100); ps.printf(&quot;100的8进制数是：%o %n&quot;, 100); ps.printf(&quot;50元的书打8.5折扣是：%f元%n&quot;, 50 * 0.85); ps.printf(&quot;计算的结果转16进制：%a %n&quot;, 50 * 0.85); ps.printf(&quot;计算的结果转科学计数法表示：%e %n&quot;, 50 * 0.85); ps.printf(&quot;计算的结果转成指数和浮点数，结果的长度较短的是：%g %n&quot;, 50 * 0.85); ps.printf(&quot;带有百分号的符号表示法，以百分之85为例：%d%% %n&quot;, 85); ps.println(&quot;---------------------&quot;); double num1 = 1.0; ps.printf(&quot;num: %.4g %n&quot;, num1); ps.printf(&quot;num: %.5g %n&quot;, num1); ps.printf(&quot;num: %.6g %n&quot;, num1); float num2 = 1.0F; ps.printf(&quot;num: %.4f %n&quot;, num2); ps.printf(&quot;num: %.5f %n&quot;, num2); ps.printf(&quot;num: %.6f %n&quot;, num2); ps.println(&quot;---------------------&quot;); ps.printf(&quot;数字前面带有0的表示方式：%03d %n&quot;, 7); ps.printf(&quot;数字前面带有0的表示方式：%04d %n&quot;, 7); ps.printf(&quot;数字前面带有空格的表示方式：% 8d %n&quot;, 7); ps.printf(&quot;整数分组的效果是：%,d %n&quot;, 9989997); ps.println(&quot;---------------------&quot;); //最终结果是10位，小数点后面是5位，不够在前面补空格，补满10位 //如果实际数字小数点后面过长，但是只规定两位，会四舍五入 //如果整数部分过长，超出规定的总长度，会以实际为准 ps.printf(&quot;一本书的价格是：%2.5f元%n&quot;, 49.8); ps.printf(&quot;%(f%n&quot;, -76.04); //%f，默认小数点后面7位， //&lt;，表示采取跟前面一样的内容 ps.printf(&quot;%f和%3.2f %n&quot;, 86.04, 1.789651); ps.printf(&quot;%f和%&lt;3.2f %n&quot;, 86.04, 1.789651); ps.println(&quot;---------------------&quot;); Date date = new Date(); // %t 表示时间，但是不能单独出现，要指定时间的格式 // %tc 周二 12月 06 22:08:40 CST 2022 // %tD 斜线隔开 // %tF 冒号隔开（12小时制） // %tr 冒号隔开（24小时制） // %tT 冒号隔开（24小时制，带时分秒） ps.printf(&quot;全部日期和时间信息：%tc %n&quot;, date); ps.printf(&quot;月/日/年格式：%tD %n&quot;, date); ps.printf(&quot;年-月-日格式：%tF %n&quot;, date); ps.printf(&quot;HH:MM:SS PM格式(12时制)：%tr %n&quot;, date); ps.printf(&quot;HH:MM格式(24时制)：%tR %n&quot;, date); ps.printf(&quot;HH:MM:SS格式(24时制)：%tT %n&quot;, date); System.out.println(&quot;---------------------&quot;); ps.printf(&quot;星期的简称：%ta %n&quot;, date); ps.printf(&quot;星期的全称：%tA %n&quot;, date); ps.printf(&quot;英文月份简称：%tb %n&quot;, date); ps.printf(&quot;英文月份全称：%tB %n&quot;, date); ps.printf(&quot;年的前两位数字(不足两位前面补0)：%tC %n&quot;, date); ps.printf(&quot;年的后两位数字(不足两位前面补0)：%ty %n&quot;, date); ps.printf(&quot;一年中的第几天：%tj %n&quot;, date); ps.printf(&quot;两位数字的月份(不足两位前面补0)：%tm %n&quot;, date); ps.printf(&quot;两位数字的日(不足两位前面补0)：%td %n&quot;, date); ps.printf(&quot;月份的日(前面不补0)：%te %n&quot;, date); System.out.println(&quot;---------------------&quot;); ps.printf(&quot;两位数字24时制的小时(不足2位前面补0):%tH %n&quot;, date); ps.printf(&quot;两位数字12时制的小时(不足2位前面补0):%tI %n&quot;, date); ps.printf(&quot;两位数字24时制的小时(前面不补0):%tk %n&quot;, date); ps.printf(&quot;两位数字12时制的小时(前面不补0):%tl %n&quot;, date); ps.printf(&quot;两位数字的分钟(不足2位前面补0):%tM %n&quot;, date); ps.printf(&quot;两位数字的秒(不足2位前面补0):%tS %n&quot;, date); ps.printf(&quot;三位数字的毫秒(不足3位前面补0):%tL %n&quot;, date); ps.printf(&quot;九位数字的毫秒数(不足9位前面补0):%tN %n&quot;, date); ps.printf(&quot;小写字母的上午或下午标记(英)：%tp %n&quot;, date); ps.printf(&quot;小写字母的上午或下午标记(中)：%tp %n&quot;, date); ps.printf(&quot;相对于GMT的偏移量:%tz %n&quot;, date); ps.printf(&quot;时区缩写字符串:%tZ%n&quot;, date); ps.printf(&quot;1970-1-1 00:00:00 到现在所经过的秒数：%ts %n&quot;, date); ps.printf(&quot;1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ %n&quot;, date); ps.close(); &#125;&#125; 二、字符打印流 字符打印流，它是带有缓冲区的，打印效率更高一点 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"53.序列化流反序列化流","slug":"53.序列化流反序列化流","date":"2019-09-26T01:40:00.000Z","updated":"2024-07-21T14:25:50.380Z","comments":true,"path":"2019/09/26/53.序列化流反序列化流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/53.%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/","excerpt":"","text":"序列化流反序列化流 序列化流（对象操作输出流） 一、可以把java中的对象写到本地文件中 写到本地文件中的对象信息，我们是看不懂的，需要进行反序列化，读取到内存中，即可成为对象 二、为什么不直接将对象属性值，给保存到本地文件中呢，非得使用序列化给序列到本地文件中，还是看不懂的？ 比如游戏中的关键信息，不使用序列化的话，在本地直接明文展示，那就会被修改了，游戏中的属性也就被修改了 三、序列化流的细节 使用对象输出流将对象保存到文件时会出现NotSerializableException异常 解决方案：需要让javabean类实现Serializable接口,同时自动生成版本号UID 反序列化流一、本地文件中的序列化对象，反序列化到内存 细节： 一个对象实现了Serializable接口，说明这个类的对象可以被序列化的 java底层会根据这个类的成员变量，静态变量，构造方法，成员方法，简单的说就是根据这个类中的所有内容计算出一个long类型的序列号。这个序列号，就是这个类的版本号。 在将对象序列化，以及反序列化的时候，使用的UID是唯一的 练习 将多个对象序列化到本地，再反序列化到内存 使用ArrayList集合来装多个对象，然后再进行序列化和反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.atlml.Serialized_stream;import java.io.Serial;import java.io.Serializable;/** * 小狗类 */public class Dog implements Serializable &#123; @Serial private static final long serialVersionUID = 5061231638733610552L; private Integer age; private String name; public Dog() &#123; &#125; public Dog(Integer age, String name) &#123; this.age = age; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.atlml.Serialized_stream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.util.ArrayList;/** * 将多个自定义对象序列化到文件中，但是由于对象的个数不确定，反序列化流该如何读取呢？ */public class SerializedStream2 &#123; public static void main(String[] args) throws IOException &#123; /** * 如果在代码中，一次需要将多个对象序列化到本地文件中， * 我们一般会采用，将多个对象放在集合当中 * 我们将这个集合给序列化到本地文件中 * 取得时候，也是直接取一个集合。 * 然后再遍历 */ Dog bozai = new Dog(5, &quot;波仔&quot;); Dog keji = new Dog(3, &quot;柯基&quot;); Dog tudou = new Dog(1, &quot;土豆&quot;); ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); dogs.add(bozai); dogs.add(keji); dogs.add(tudou); //序列化流，将多个对象 序列化到 本地文件中去 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;javabasis\\\\aaa\\\\myio\\\\a.txt&quot;)); objectOutputStream.writeObject(dogs);//序列化集合 objectOutputStream.close(); &#125; &#125; 123456789101112131415161718192021222324252627282930package com.atlml.Serialized_stream;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.util.ArrayList;/** * 反序列化， * 将保存在本地的 对象。 反序列化到程序中 * 这里是将 ArrayList 集合反序列化到内存中 * List集合中，存放了多个对象 */public class SerializedStream3 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //反序列化一个集合 ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;javabasis\\\\aaa\\\\myio\\\\a.txt&quot;)); ArrayList doglist = (ArrayList) objectInputStream.readObject(); doglist.forEach(d-&gt; System.out.println(d)); //Dog&#123;age=5, name=&#x27;波仔&#x27;&#125; //Dog&#123;age=3, name=&#x27;柯基&#x27;&#125; //Dog&#123;age=1, name=&#x27;土豆&#x27;&#125; &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"52.IO流-转换流","slug":"52.IO流-转换流","date":"2019-09-26T01:38:00.000Z","updated":"2024-07-20T14:51:34.625Z","comments":true,"path":"2019/09/26/52.IO流-转换流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/52.IO%E6%B5%81-%E8%BD%AC%E6%8D%A2%E6%B5%81/","excerpt":"","text":"IO流-转换流 一、转换流 转换流：是字节流，与字符流之间的桥梁 练习 转换文件编码 需求1：手动创建一个GBK的文件，把文件中的中文读取到内存中，不能出现乱码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atlml.io_stream;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.nio.charset.Charset;/** * 输入 转换流 */public class InputStreamReadDemo extends ConversionFlowTest &#123; public static void main(String[] args) throws IOException &#123; /** * 需求1：手动创建一个GBK的文件，把文件中的中文读取到内存中，不能出现乱码 * 了解 一下， 这种方式在JDK11时 被淘汰了 * */ // gbkcsb.txt 文件在本地就是GBK编码 /* InputStreamReader gbk = new InputStreamReader(new FileInputStream(&quot;javabasis/aaa/gbkcsb.txt&quot;),&quot;GBK&quot;); int len; char[] chars = new char[8192]; while ((len=gbk.read(chars))!=-1)&#123; for (char aChar : chars) &#123; System.out.print(aChar); &#125; &#125; gbk.close(); */ /** * 替代方案 * 直接使用 FileReader 来指定 编码读取文本 */ FileReader fr = new FileReader(&quot;javabasis/aaa/gbkcsb.txt&quot;, Charset.forName(&quot;GBK&quot;)); BufferedReader bfr = new BufferedReader(fr); String line; while ((line = bfr.readLine()) != null) &#123; System.out.println(line); &#125; bfr.close(); &#125;&#125; 需求2：把一段中文按照GBK的方式写到本地文件1234567891011121314151617181920212223242526package com.atlml.io_stream;import java.io.BufferedWriter;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;/** * 输出 转换流 */public class OutPutStreamWriteDemo extends ConversionFlowTest &#123; public static void main(String[] args) throws IOException &#123; /** * 需求2：把一段中文按照GBK的方式写到本地文件 * 这里是追加到 gbkcsb.txt文本文件后面 */ OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;javabasis/aaa/gbkcsb.txt&quot;, true), &quot;GBK&quot;); BufferedWriter bufferedWriter = new BufferedWriter(osw);//使用字符缓冲流包一下 bufferedWriter.newLine();//可以使用 换行 bufferedWriter.write(&quot;出师表，诸葛亮，躬耕南阳，采菊东篱&quot;); bufferedWriter.close(); osw.close(); &#125;&#125; 需求3：将本地文件中的GBK文件，转成UTF-8123456789101112131415161718192021222324252627282930313233343536373839404142package com.atlml.io_stream;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.nio.charset.Charset;public class EncodingConversion extends ConversionFlowTest &#123; public static void main(String[] args) throws IOException &#123; /** * 需求3：将本地文件中的GBK文件，转成UTF-8 */ // 1.JDK11之前的写法 /*BufferedReader bfr = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;javabasis/aaa/gbkcsb.txt&quot;), &quot;GBK&quot;)); BufferedWriter bfw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;javabasis/aaa/utf-8csb.txt&quot;), &quot;UTF-8&quot;)); String line; while ((line=bfr.readLine())!=null)&#123; bfw.newLine(); bfw.write(line); &#125; bfw.close(); bfr.close(); */ // JDK11之后的写法 BufferedReader bfr = new BufferedReader(new FileReader(&quot;javabasis/aaa/gbkcsb.txt&quot;, Charset.forName(&quot;GBK&quot;))); BufferedWriter bfw = new BufferedWriter(new FileWriter(&quot;javabasis/aaa/utf-8csb.txt&quot;, Charset.forName(&quot;UTF-8&quot;))); String line; while ((line = bfr.readLine()) != null) &#123; bfw.write(line); bfw.newLine(); &#125; bfw.close(); bfr.close(); &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"51.IO流-字节缓冲流与字符缓冲流","slug":"51.IO流-字节缓冲流与字符缓冲流","date":"2019-09-26T01:35:00.000Z","updated":"2024-07-08T17:33:11.722Z","comments":true,"path":"2019/09/26/51.IO流-字节缓冲流与字符缓冲流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/51.IO%E6%B5%81-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81/","excerpt":"","text":"IO流-字节缓冲流与字符缓冲流 一、字节缓冲流与字符缓冲流体系 1.为什么使用缓冲流 缓冲流底层自带了一个数组8192个字节，一次能读8192个字节。到缓冲区 所以，为了提高读取和写出的效率，使用缓冲流 2.怎么使用 直接包在字节流，或者字符流的外面就行了 虽然“字符流”已经有了缓冲区，包与不包读取写出区别不大，但是它中有特有方法，可以对纯文本文件更好的操作，所以说也有包的必要 二、字节缓冲流提高效率的原理 三、实操 四、字符缓冲流 特殊方法的使用 readLine()方法的细节 readLine方法在读取的时候，一次读一整行，遇到回车换行结束 但是他不会把回车换行读到内存当中 总结 练习1234567891011121314151617181920212223242526272829303132333435363738394041package com.atlml.io_stream;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Map;import java.util.Set;import java.util.TreeMap;public class Test01 &#123; public static void main(String[] args) throws IOException &#123; /** * 将出师表csb.txt文章中的顺序恢复 */ BufferedReader br = new BufferedReader(new FileReader(&quot;javabasis/aaa/csb.txt&quot;)); TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;(); //使用treeMap 排序 String line; while ((line=br.readLine())!=null)&#123; String[] strs = line.split(&quot;\\\\.&quot;); //读取一行，进行排序 map.put(Integer.parseInt(strs[0]),strs[1]); &#125; System.out.println(map); br.close(); //写出到本地文件中 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;javabasis/aaa/result.txt&quot;)); Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;Integer, String&gt; entry : entries) &#123; bw.write(entry.getValue()); bw.newLine(); &#125; bw.close(); &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"50.IO（字节流&字符流）","slug":"50.IO（字节流&字符流）","date":"2019-09-26T01:31:00.000Z","updated":"2024-07-08T17:28:30.086Z","comments":true,"path":"2019/09/26/50.IO（字节流&字符流）/","link":"","permalink":"https://protonlml.github.io/2019/09/26/50.IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81&%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/","excerpt":"","text":"IO（字节流&字符流） 一、什么是IO流？ 存储和读取数据的解决方案 只要项目中，需要对本地文件进行读取和写入操作，肯定是需要用到IO流处理 二、IO流体系 IO流的使用原则 随用随创建 什么时候不用，什么时候关闭 切记，不要上来就把所有的流都创建在代码的最上面。 1.字节流 1. 字节输出流 FileOutputStream 操作本地文件的字节输出流，可以把程序中的数据写到本地文件中。 续写： 2. 字节输入流 FileInputStream 操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来。 这里面要记住，循环读取的套路书写方法 一次读一个字节，效率太慢了，一次读多个字节？ 注意：一次读一个字节数组的数据，每次读取会尽可能把数组装满。 (循环读，就能读取本地文件中的所有内容) 练习 拷贝文件 拷贝大文件 注意： 字节流读取文件的时候，文件中不要有中文 使用字节流读取纯文本文件时，内容中有 “汉字” 读取到系统内存之后，会有乱码。 因为：字节流 FileinputStream的read方法，读取文件时，是一个字节一个字节读取的，而一个汉字，在计算机中占用3个字节，Unicode组织制定的（GBK是2个字节），有可能读取的时候，字节没有读取完整。 但是拷贝纯文本文件没有问题，因为是全部字节循环读取，最终都会被读取完毕，再写到目标文件中也是完整的。 字节流：一次只能读取一个字节 在计算机中，一个字母正好是一个字节（不管是ASCII 还是Unicode字符集） 但是在Unicode字符集中，规定一个汉字占用了3个字节。（Unicode组织制定的，全世界通用） 在GBK字符集中，一个汉字占用了两个字节（我国自己指定的） 所以使用字节流来读取文本文件(内部是汉字)会出现乱码，因为一次只读取了一个字节。 在系统中使用的Unicode字符集，是通用的，需要使用UTF-8来编解码。 2. 字符流 字符流，最适合操作纯文本文件，遇到中文也不会出现乱码 2.1 字符输入流FileReader 就是从本地文件中，读取内容 字符输入流，就是从本地文件中读取文本内容到系统中。 原理是，在创建字符输入流的时候，它会在底层创建一个字节数组长度为8192，read一次就会尽可能的将这个字节数组给填满。（他就是缓冲区）。下一次读，就会直接在缓冲区中读，缓冲区中读取完了，再将本地文本再次加载到缓冲区。（提高读取文件的效率） 字节输入流，没有这个缓冲区 2.2 字符输出流 FileWriter 就是将程序中的数据，写出到本地文件中。（write的两种方式） 字符流的底层原理（有缓冲区） 字符输入流的底层原理 字符输出流的底层原理 使用场景 练习拷贝文件夹中的所有文件（包括子文件夹） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.atlml.io_stream;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * 练习一： * &lt;p&gt; * 拷贝： * 拷贝一个文件夹，考虑子文件夹 */public class Practice1 &#123; public static void main(String[] args) throws IOException &#123; /** * 将一个文件夹中的所有 内容拷贝 * */ //源文件路径 File src = new File(&quot;javabasis\\\\aaa&quot;); // 目标文件路径 File to = new File(&quot;javabasis\\\\copy_directorys&quot;); //拷贝就想 使用 字节流 来操作 long l = System.currentTimeMillis(); copyDirectorys(src, to); long l1 = System.currentTimeMillis(); System.out.println(&quot;拷贝完成用时&quot; + (l1 - l) + &quot;豪秒&quot;); &#125; /** * @param src 文件夹源路径 * @param to 目标路径 * @return 是否成功 */ private static void copyDirectorys(File src, File to) throws IOException &#123; //由于目的地文件夹如果不存在，会报错。所以先创建。即使目的文件夹有，也没关系不报错 to.mkdir(); // src 从源文件夹中 拿出所有的文件包括文件夹 File[] files = src.listFiles(); if (files != null) &#123; for (File file : files) &#123; if (file.isFile()) &#123; FileInputStream fis = new FileInputStream(file); //使用缓冲流包一下，目的是流 读到 缓冲区，再从缓冲区往外写 效率速度提高 BufferedInputStream bfis = new BufferedInputStream(fis); // FileOutputStream fos = new FileOutputStream(new File(to, file.getName())); //使用缓冲流包一下，目的是流先 写到缓冲区，再从缓冲区写到文本中 效率速度提高 BufferedOutputStream bfos = new BufferedOutputStream(fos); //是文件直接拷贝 /** * 一个字节，一个字节的读，一个字节一个字节的写 * 非常慢 * 等了好久也没结束 */ /*int b; while ((b = fis.read()) != -1) &#123; fos.write(b); //读多少就写多少 &#125; fos.close(); fis.close();*/ /*-----------------------------------------*/ /* * 使用字节数组，指定一次读取 0.5M * * 因为都是小文件，中间的容器创建太大，导致空间浪费，速度反而慢 * * 最终 拷贝完成用时 577~668豪秒 */ /*int len; byte[] b = new byte[1024 * 1024 * 1/2]; //0.5M大小 while ((len = fis.read(b)) != -1) &#123; fos.write(b, 0, len); //读多少就写多少 &#125; fos.close(); fis.close();*/ /*-----------------------------------------*/ /** * 使用缓冲流包一下，速度快了一点 * * 最终 拷贝完成用时797豪秒 */ /* int b; while ((b=bfis.read())!=-1)&#123; bfos.write(b); &#125; bfos.close(); bfis.close(); */ /*-----------------------------------------*/ /** * 使用缓冲流， * 同时加上 还指定一次读0.5M数组 * 更快 * * 最终：拷贝完成用时 511~616 豪秒 * * 最快的 */ int len; byte[] b = new byte[1024 * 1024 * 1 / 2]; //一次读取 0.5M 大小到数组中 while ((len = bfis.read(b)) != -1) &#123; bfos.write(b, 0, len);//一次写出 0.5M 到本地文件中 &#125; bfos.close(); bfis.close(); &#125; else &#123; //是文件夹，进入再拷贝 copyDirectorys(file, new File(to, file.getName())); &#125; &#125; &#125; &#125;&#125; 二、文件加密 利用(^异或) （如：100^10&#x3D;110；110^10&#x3D;100） 一个十进制数异或同一个数字两次，可以得到原数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atlml.io_stream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class Practice2 &#123; public static void main(String[] args) throws IOException &#123; /** * 对文件进行加密 * * 将一个文件读出来之后，对其字节进行操作 * 字节流 */ File src = new File(&quot;javabasis\\\\aaa\\\\aaa.mp4&quot;); File ency = new File(&quot;javabasis\\\\aaa\\\\bbbbbbbb.mp4&quot;); //文件加密 存到 本地 fileEncryption(src,ency); //文件解密 // fileEncryption(ency,src); &#125; /** * 加密/解密 * @param src * @param ency * @throws IOException */ private static void fileEncryption(File src,File ency) throws IOException &#123; FileInputStream fileInputStream = new FileInputStream(src); FileOutputStream fileOutputStream = new FileOutputStream(ency); byte[] b = new byte[1024*1024/2]; //0.5M 的 转移 容器 int len;//每次转移的字节数量 byte myb=10; //声明一个字节默认值是 10 while ((len=fileInputStream.read(b))!=-1)&#123; for (int i = 0; i &lt;len; i++) &#123; b[i]= (byte) (b[i]^myb);//将每个字节异或操作后，在存到字节数组中（加密） &#125; fileOutputStream.write(b,0,len); &#125; fileOutputStream.close(); fileInputStream.close(); &#125;&#125; 三、文件排序123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws IOException &#123; /* * * 文本文件中有以下的数据： * 2-1-9-4-7-8 * 将文件中的数据进行排序，变成以下的数据： * 1-2-4-7-8-9 */ File file = new File(&quot;javabasis\\\\aaa\\\\num.txt&quot;); FileReader fr = new FileReader(file);//字符输入流 FileWriter fw = new FileWriter(&quot;javabasis\\\\aaa\\\\numSort.txt&quot;); ArrayList&lt;String&gt; str = new ArrayList&lt;&gt;(); char[] ch = new char[2]; int len; while ((len = fr.read(ch)) != -1) &#123; for (int i = 0; i &lt; len; i++) &#123; String s = String.valueOf(ch[i]); if (!&quot;-&quot;.equals(s)) &#123; str.add(s); //不是&quot;-&quot;横线 &#125; &#125; &#125; Collections.sort(str);//从小到大排序 StringJoiner stringJoiner = new StringJoiner(&quot;-&quot;, &quot;&quot;, &quot;&quot;); for (String s : str) &#123; stringJoiner.add(s); &#125; fw.write(stringJoiner.toString()); fw.close(); fr.close(); &#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"49.File类","slug":"49.File","date":"2019-09-26T00:31:00.000Z","updated":"2024-07-03T09:07:14.962Z","comments":true,"path":"2019/09/26/49.File/","link":"","permalink":"https://protonlml.github.io/2019/09/26/49.File/","excerpt":"","text":"File类 一、File 对File的理解 File 出现，new出来肯定是带（绝对路径的，已经存在的） 1.形参中是文件的绝对路径（此时就表示一个文件） 2.形参中是文件夹的绝对路径（此时就表示一个文件夹） new File(形参) 是 不存在的路径，就表示一个路径而已，使用File中的方法来创建实际文件或者文件夹。 为什么要用File类，就是为了表述系统中的文件，使用File类中的方法，对当前File进行操作。 二、File 的方法 练习1.file获取文件名f.getName()带后缀名1234567891011121314151617181920212223242526272829/** * 定义一个方法找某一个文件夹中，是否有以 avi 结尾的电影。 * （暂时不需要考虑子文件夹） */public class FileDemo4 &#123; public static void main(String[] args) &#123; File file = new File(&quot;C:\\\\Users\\\\lml\\\\Downloads\\\\aaa&quot;); boolean b = existAvi(file); System.out.println(b); &#125; public static boolean existAvi(File file)&#123; // C:\\Users\\lml\\Downloads\\aaa 文件夹 File[] files = file.listFiles(); for (File f : files) &#123; // 遍历aaa文件夹下的 文件夹以及文件的路径 if(f.isFile()&amp;&amp;f.getName().endsWith(&quot;.avi&quot;))&#123; return true; &#125; &#125; return false; &#125; &#125; 2.涉及到多级文件夹，需要递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.atlml.file_demo;import java.io.File;/** * 找到电脑中所有以avi结尾的电影。 * (需要考虑子文件夹） * * * 思想：把大问题拆分，拆到某一个文件夹中不包含其他文件夹为止 * * 递归思想，就是将大的问题，拆成小的问题去解决 * * 凡事要考虑文件夹里面的内容了，就使用下面的套路 * 写递归方法的套路 * 套路： * 1.进入文件夹 * 2.遍历数组 * 2.1.遍历内部：判断，如果是文件 就执行题目的业务逻辑 * 2.2.遍历内部：判断，如果不是文件，他就是文件夹，继续调用当前方法，递归 * */public class FileDemo5 &#123; public static void main(String[] args) &#123; /* File file = new File(&quot;C:\\\\&quot;); //C盘 findAVI(file);*/ findAVI(); &#125; /** * 查询电脑上 所有盘符 中 avi文件的路径 */ public static void findAVI()&#123; File[] files = File.listRoots(); //获取系统中所有的盘符 for (File file : files) &#123; findAVI(file); &#125; &#125; /** * 递归方法 * 递归查询 指定文件夹 中的内容 */ public static void findAVI(File file)&#123; //1.进入文件夹,找到当前文件夹下面 所有的路径 // 包含当前文件夹下的 所有文件夹，文件 File[] files = file.listFiles(); //注意细节：file可能为null 因为盘符有权限可能进不去 if(files!=null)&#123; //2.遍历数组 for (File src : files) &#123; //3.判断，如果是文件就执行题目的业务逻辑 if(src.isFile())&#123; if(src.getName().endsWith(&quot;.avi&quot;))&#123; System.out.println(src); &#125; &#125;else &#123; //4.判断，如果不是文件，他就是文件夹，继续调用当前方法，递归 // 注意 src 一定是 file 的下级目录 findAVI(src); &#125; &#125; &#125; &#125;&#125; 3.删除多级文件夹1234567891011121314151617181920212223242526272829303132/** * 删除多级文件夹 */public class FileDemo6 &#123; public static void main(String[] args) &#123; /** * 先思考删除一个文件夹内的内容怎么删 * 如果 当前文件夹下面 还有文件夹 再调用 */ File file = new File(&quot;C:\\\\Users\\\\lml\\\\Downloads\\\\aaa\\\\eee&quot;); deleteMultilevelDirectory(file); &#125; /** * @param src 文件夹地址 * @return 删除成功与否 */ public static void deleteMultilevelDirectory(File src) &#123; File[] files = src.listFiles(); if (files != null) &#123; for (File file : files) &#123; if(file.isFile())&#123; //是文件直接删除 file.delete(); &#125;else &#123; //是文件夹，且文件夹不是空的 递归 deleteMultilevelDirectory(file); &#125; &#125; &#125; // 自己也删 src.delete(); &#125; 4.递归多级目录，递归方法中的局部变量怎么统计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹） * &lt;p&gt; * ① 打印格式如下： * ② txt：3个 * ③ doc：4个 * ④ jpg：6个 * 。。。。 */public class FileDemo7 &#123; public static void main(String[] args) &#123; File file = new File(&quot;C:\\\\Users\\\\lml\\\\Downloads\\\\aaa&quot;); Map&lt;String, Integer&gt; count = getCount(file); System.out.println(count); //&#123;jpg=9, txt=4, xlsx=1, avi=1, doc=4&#125; &#125; /** * 统计文件夹下面的 各种文件格式 个数 * 并打印 * * 使用了 map 的统计思想 * * 因为是递归方法， * 所以其中的 局部变量怎么能产生关系? * * 就是在调用递归之后，回到当前方法，把递归的值，返回给当前 * */ public static Map&lt;String, Integer&gt; getCount(File src) &#123; HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;(); File[] files = src.listFiles(); if (files != null) &#123; for (File file : files) &#123; if (file.isFile()) &#123; //如果当前是文件，判断文件的 格式 并记录 String name = file.getName(); //注意这里的截取 点 要加 双反斜线 String[] split = name.split(&quot;\\\\.&quot;); if (split.length &gt;= 2) &#123; //这里是有后缀名的文件才进行统计 //a.txt 统计 //a.a.b,txt 统计 // aaa无后缀名 不统计 //利用Map 进行统计 String suffix = split[split.length - 1]; //后缀 if (hm.containsKey(suffix)) &#123; //map中已经存在这个 格式 如：txt Integer count = hm.get(suffix); count++; hm.put(suffix, count); &#125; else &#123; //第一次添加 hm.put(suffix, 1); &#125; &#125; &#125; else &#123; //不是文件，是文件夹（递归）结果是子文件夹的统计 // hm &#123;txt=3,doc=4,jpg=1 &#125; // map&#123;txt=1,doc=1,jpg=1,xlsx=1&#125; Map&lt;String, Integer&gt; map = getCount(file); //走到这一步，下面就先不看，再旁边想象新的方法，结果放在这里 //遍历map map.forEach((k, v) -&gt; &#123; if (hm.containsKey(k)) &#123; Integer count = hm.get(k); // 说明已经有 这个后缀 hm.put(k, v + count); &#125; else &#123; //这里表示hm中不存在的 key格式值 hm.put(k, v); &#125; &#125;); &#125; &#125; &#125; return hm; &#125;&#125; 5.递归方法中的局部变量怎么处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 统计一个文件夹内所有文件的总大小 */public class FileDemo8 &#123; public static void main(String[] args) &#123; /** * * 1.先路径定义到 这个文件夹 * 2. 将文件夹展开 * 如果是文件直接统计大小 * 如果是文件夹，继续递归第2步 * 最终将所有的文件大小加在一起 * 3.返回统计值 * * */ //这里统计 aaa文件夹总大小 File file = new File(&quot;C:\\\\Users\\\\lml\\\\Downloads\\\\aaa&quot;); Long size = countTotalSize(file); System.out.println(size); &#125; private static Long countTotalSize(File src) &#123; //注意这个length是局部变量，第二次递归的时候，这个值就又变成了0 // 怎么解决？把递归的结果加在第一次执行时length上面。 // 执行到递归时，就想旁边有一个一模一样的方法，它的计算和 当前方法执行 没有关系 long length = 0; File[] files = src.listFiles(); if (files != null) &#123; for (File file : files) &#123; if (file.isFile()) &#123; //如果是文件，直接算出大小 length = length + file.length(); &#125; else &#123; length = length + countTotalSize(file); &#125; &#125; &#125; return length; &#125; &#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"47.方法引用","slug":"47.方法引用","date":"2019-09-26T00:30:00.000Z","updated":"2024-07-02T07:48:13.556Z","comments":true,"path":"2019/09/26/47.方法引用/","link":"","permalink":"https://protonlml.github.io/2019/09/26/47.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"方法引用 一、方法引用 二、方法引用的分类 1.引用静态方法 例： 2.引用成员方法 3.引用构造方法 三、方法引用的理解 （大小写转换） 四、数组构造器引用 以后stream流收集为Array数组的时候，就可以使用”数组的构造器引用” 练习创建一个student类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.atlml.stream_demo;public class Student &#123; private String name; private Integer age; public Student() &#123; &#125; /** * 自定义构造器 * @param str */ public Student(String str) &#123; this.name = str.split(&quot;,&quot;)[0]; this.age = Integer.parseInt(str.split(&quot;,&quot;)[1]); &#125; public Student(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; /** * 拼接数据 * 把姓名和年龄拼接成：张三-23的字符串 * @return */ public static String splicing(Student student)&#123; return student.getName()+&quot;-&quot;+student.getAge(); &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 使用Student构造器方法引用123456789101112131415161718192021222324public static void main(String[] args) &#123; /** * 集合中存储一些字符串的数据，比如：张三，23。 * 收集到Student：类型的数组当中（使用方法引用完成） */ ArrayList&lt;String&gt; manName = new ArrayList&lt;&gt;(); Collections.addAll(manName, &quot;蔡徐坤,23&quot;, &quot;吴京,29&quot;, &quot;林根锡,15&quot;, &quot;顾佳,66&quot;, &quot;叶问,54&quot;, &quot;洪金宝,32&quot;); Student[] students = manName.stream() // 下面这句话怎么理解， 就是stream上的 每个元素，都调用了，new Student() 方法，并且又将结果返回给 stream流上。 // map处理过后，stream流上面全是student对象 .map(Student::new) //使用 student的构造器方法 引用 .toArray(Student[]::new);// 使用student 数组构造引用 for (Student student : students) &#123; System.out.println(student); &#125; &#125; 使用Student中成员方法引用1234567891011121314151617181920public static void main(String[] args) &#123; /** * 创建集合添加学生对象，学生对象属性：name,age * 只获取姓名并放到数组当中（使用方法引用完成） * &quot;蔡徐坤,23&quot;, &quot;吴京,29&quot;, &quot;林根锡,15&quot;, &quot;顾佳,66&quot;, &quot;叶问,54&quot;, &quot;洪金宝,32&quot; */ ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); students.add(new Student(&quot;蔡徐坤&quot;,23)); students.add(new Student(&quot;吴京&quot;,29)); students.add(new Student(&quot;林根锡&quot;,15)); students.add(new Student(&quot;顾佳&quot;,66)); students.add(new Student(&quot;叶问&quot;,54)); String[] names = students.stream() .map(Student::getName) .toArray(String[]::new); Arrays.stream(names).forEach(n-&gt; System.out.println(n)); &#125; 使用Student中静态方法引用1234567891011121314151617181920public static void main(String[] args) &#123; /** *创建集合添加学生对象，学生对象属性：name,age * 把姓名和年龄拼接成：张三-23的字符串，并放到数组当中（使用方法引用完成） */ ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); students.add(new Student(&quot;蔡徐坤&quot;,23)); students.add(new Student(&quot;吴京&quot;,29)); students.add(new Student(&quot;林根锡&quot;,15)); students.add(new Student(&quot;顾佳&quot;,66)); students.add(new Student(&quot;叶问&quot;,54)); String[] students1 = students.stream() .map(Student::splicing) .toArray(String[]::new); String s = Arrays.toString(students1); System.out.println(s);//[蔡徐坤-23, 吴京-29, 林根锡-15, 顾佳-66, 叶问-54] &#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"48.异常体系","slug":"48.异常体系","date":"2019-09-26T00:30:00.000Z","updated":"2024-07-02T09:48:48.069Z","comments":true,"path":"2019/09/26/48.异常体系/","link":"","permalink":"https://protonlml.github.io/2019/09/26/48.%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/","excerpt":"","text":"异常体系 一、异常体系 二、捕获异常 在代码中将可能存在异常的部分，使用 try-catch包裹住，在catch中捕获异常，并进行处理（可以记录到日志） 目的：当代码出现异常时，可以让程序继续往下执行，而不是交给虚拟机默认处理，给系统停止了 三、异常类中的常见方法 四、异常的抛出处理 例如： 五、自定义异常类（类名要见名知意） 意义：就是为了让控制台的报错信息更加见名知意 目的是：在Java中，没有一个异常能够完美 表示 当前出现的问题 自定义一个异常类，表示当前出现问题的异常类 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"46.stream流","slug":"46.stream流","date":"2019-09-26T00:22:00.000Z","updated":"2024-07-02T08:28:17.181Z","comments":true,"path":"2019/09/26/46.stream流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/46.stream%E6%B5%81/","excerpt":"","text":"stream流 一、流的思想 二、为什么要用stream流 目的是为了，简化 集合、数组的操作（配合Lambda表达式使用） 三、获取Stream流 这个stream流，一般就是用来简化集合的操作的，所以它和集合是分不开的，使用集合可以直接调用stream方法，来上流 实现 四、Stream流的中间方法 具体实现 五、Stream流中的终结方法 收集到集合当中（List集合，以及Map集合） 练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.atlml.stream_demo;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class StreamDemo5 &#123; public static void main(String[] args) &#123; /** * 现在有两个ArrayList集合， * 第一个集合中：存储6名男演员的名字和年龄。 * 第二个集合中：存储6名女演员的名字和年龄。 * * 姓名和年龄中间用逗号隔开。比如：张三,23 * 要求完成如下的操作： * 1，男演员只要名字为 3个字的 前两人 * 2，女演员只要姓杨的，并且不要第一个 * 3，把过滤后的男演员姓名和女演员姓名合并到一起 * 4，将上一步的演员信息封装成Actor对象。 * 5，将所有的演员对象都保存到List集合中。 * 备注：演员类Actor，属性有：name,age */ ArrayList&lt;String&gt; manName = new ArrayList&lt;&gt;(); Collections.addAll(manName, &quot;蔡徐坤,23&quot;, &quot;吴京,29&quot;, &quot;林根锡,15&quot;, &quot;顾佳,66&quot;, &quot;叶问,54&quot;, &quot;洪金宝,32&quot;); ArrayList&lt;String&gt; girlName = new ArrayList&lt;&gt;(); Collections.addAll(girlName, &quot;杨幂,20&quot;, &quot;刘诗诗,28&quot;, &quot;赵丽颖,22&quot;, &quot;高圆圆,29&quot;, &quot;张甜甜,33&quot;, &quot;杨政馨,46&quot;); List&lt;String&gt; list1 = manName.stream() .filter(s -&gt; (s.split(&quot;,&quot;)[0]).length() == 3) .limit(2) .collect(Collectors.toList()); List&lt;String&gt; list2 = girlName.stream() .filter(s -&gt; s.startsWith(&quot;杨&quot;)) .skip(1) .collect(Collectors.toList()); /* ArrayList&lt;Actor&gt; actors = new ArrayList&lt;&gt;(); Stream.concat(list1.stream(), list2.stream()) .forEach(l -&gt; &#123; String[] split = l.split(&quot;,&quot;); String name = split[0]; int age = Integer.parseInt(split[1]); actors.add(new Actor(name, age)); &#125;);*/ List&lt;Actor&gt; actors = Stream.concat(list1.stream(), list2.stream()) .map(s -&gt; new Actor(s.split(&quot;,&quot;)[0], Integer.parseInt(s.split(&quot;,&quot;)[1]))) .collect(Collectors.toList()); System.out.println(actors);//[Actor&#123;name=&#x27;蔡徐坤&#x27;, age=23&#125;, Actor&#123;name=&#x27;林根锡&#x27;, age=15&#125;, Actor&#123;name=&#x27;杨政馨&#x27;, age=46&#125;] &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"50.字符集详解","slug":"50.字符集详解","date":"2019-09-25T19:00:00.000Z","updated":"2024-07-05T17:28:06.085Z","comments":true,"path":"2019/09/26/50.字符集详解/","link":"","permalink":"https://protonlml.github.io/2019/09/26/50.%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"字符集详解 java中的编解码 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"45.集合进阶-12-TreeMap","slug":"45.集合进阶-12-TreeMap","date":"2019-09-25T00:22:00.000Z","updated":"2024-06-28T09:05:07.988Z","comments":true,"path":"2019/09/25/45.集合进阶-12-TreeMap/","link":"","permalink":"https://protonlml.github.io/2019/09/25/45.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-12-TreeMap/","excerpt":"","text":"TreeMap 1.第一种排序规则 2.第二种排序规则 练习使用Map 来进行统计 这里使用TreeMap因为结果有 字母升序排列 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"44.集合进阶-11-LinkedHashMap","slug":"44.集合进阶-11-LinkedHashMap","date":"2019-09-25T00:20:00.000Z","updated":"2024-06-28T08:35:55.935Z","comments":true,"path":"2019/09/25/44.集合进阶-11-LinkedHashMap/","link":"","permalink":"https://protonlml.github.io/2019/09/25/44.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-11-LinkedHashMap/","excerpt":"","text":"LinkedHashMap © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"43.集合进阶-10-HashMap","slug":"43.集合进阶-10-HashMap","date":"2019-09-25T00:18:00.000Z","updated":"2024-06-28T08:31:56.325Z","comments":true,"path":"2019/09/25/43.集合进阶-10-HashMap/","link":"","permalink":"https://protonlml.github.io/2019/09/25/43.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-10-HashMap/","excerpt":"","text":"HashMap © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"42.集合进阶-09-双列集合Map、常用API、三种遍历方式","slug":"42.集合进阶-09-Map特点、常用API、三种遍历方式","date":"2019-09-25T00:10:00.000Z","updated":"2024-06-28T08:21:57.091Z","comments":true,"path":"2019/09/25/42.集合进阶-09-Map特点、常用API、三种遍历方式/","link":"","permalink":"https://protonlml.github.io/2019/09/25/42.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-09-Map%E7%89%B9%E7%82%B9%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%81%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/","excerpt":"","text":"双列集合Map 一、双列集合的特点 二、Map中常见的API 三、Map的三种遍历方式 1.键找值 2.键值对Entry对象 3.Lambda表达式遍历 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"34.Hutool工具包","slug":"34.Hutool工具包","date":"2019-09-24T23:32:00.000Z","updated":"2024-07-09T18:35:33.839Z","comments":true,"path":"2019/09/25/34.Hutool工具包/","link":"","permalink":"https://protonlml.github.io/2019/09/25/34.Hutool%E5%B7%A5%E5%85%B7%E5%8C%85/","excerpt":"","text":"Hutool工具包 Hutool🍬官网Hutool工具包操作文档API文档 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"33.commons-io工具类","slug":"33.commons-io工具类","date":"2019-09-24T23:30:00.000Z","updated":"2024-07-09T18:17:19.288Z","comments":true,"path":"2019/09/25/33.commons-io工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/25/33.commons-io%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"commons-io工具类 Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。作用：提高IO流的开发效率。 1，IOUtils（数据相关）拷贝方法：copy方法有多个重载方法，满足不同的输入输出流 IOUtils.copy(InputStream input, OutputStream output) IOUtils.copy(InputStream input, OutputStream output, int bufferSize)&#x2F;&#x2F;可指定缓冲区大小 IOUtils.copy(InputStream input, Writer output, String inputEncoding)&#x2F;&#x2F;可指定输入流的编码表 IOUtils.copy(Reader input, Writer output) IOUtils.copy(Reader input, OutputStream output, String outputEncoding)&#x2F;&#x2F;可指定输出流的编码表 拷贝大文件的方法：&#x2F;&#x2F; 这个方法适合拷贝较大的数据流，比如2G以上 IOUtils.copyLarge(Reader input, Writer output) &#x2F;&#x2F; 默认会用1024*4的buffer来读取 IOUtils.copyLarge(Reader input, Writer output, char[] buffer)&#x2F;&#x2F;可指定缓冲区大小 将输入流转换成字符串IOUtils.toString(Reader input) IOUtils.toString(byte[] input, String encoding) IOUtils.toString(InputStream input, Charset encoding) IOUtils.toString(InputStream input, String encoding) IOUtils.toString(URI uri, String encoding) IOUtils.toString(URL url, String encoding) 将输入流转换成字符数组IOUtils.toByteArray(InputStream input) IOUtils.toByteArray(InputStream input, int size) IOUtils.toByteArray(URI uri) IOUtils.toByteArray(URL url) IOUtils.toByteArray(URLConnection urlConn) IOUtils.toByteArray(Reader input, String encoding) 字符串读写IOUtils.readLines(Reader input) IOUtils.readLines(InputStream input, Charset encoding) IOUtils.readLines(InputStream input, String encoding) IOUtils.writeLines(Collection&lt;?&gt; lines, String lineEnding, Writer writer) IOUtils.writeLines(Collection&lt;?&gt; lines, String lineEnding, OutputStream output, Charset encoding) IOUtils.writeLines(Collection&lt;?&gt; lines, String lineEnding, OutputStream output, String encoding) 从一个流中读取内容IOUtils.read(InputStream input, byte[] buffer) IOUtils.read(InputStream input, byte[] buffer, int offset, int length) IOUtils.read(Reader input, char[] buffer) IOUtils.read(Reader input, char[] buffer, int offset, int length) 把数据写入到输出流中IOUtils.write(byte[] data, OutputStream output) IOUtils.write(byte[] data, Writer output, Charset encoding) IOUtils.write(byte[] data, Writer output, String encoding) IOUtils.write(char[] data, Writer output) IOUtils.write(char[] data, OutputStream output, Charset encoding) IOUtils.write(char[] data, OutputStream output, String encoding) IOUtils.write(String data, Writer output) IOUtils.write(CharSequence data, Writer output) 从一个流中读取内容，如果读取的长度不够，就会抛出异常IOUtils.readFully(InputStream input, int length) IOUtils.readFully(InputStream input, byte[] buffer) IOUtils.readFully(InputStream input, byte[] buffer, int offset, int length) IOUtils.readFully(Reader input, char[] buffer) IOUtils.readFully(Reader input, char[] buffer, int offset, int length) 比较IOUtils.contentEquals(InputStream input1, InputStream input2) &#x2F;&#x2F; 比较两个流是否相等 IOUtils.contentEquals(Reader input1, Reader input2) IOUtils.contentEqualsIgnoreEOL(Reader input1, Reader input2) &#x2F;&#x2F; 比较两个流，忽略换行符 其他方法IOUtils.skip(InputStream input, long toSkip) &#x2F;&#x2F; 跳过指定长度的流 IOUtils.skip(Reader input, long toSkip) IOUtils.skipFully(InputStream input, long toSkip) &#x2F;&#x2F; 如果忽略的长度大于现有的长度，就会抛出异常 IOUtils.skipFully(Reader input, long toSkip) 2，FileUtils（文件&#x2F;文件夹相关）复制文件夹FileUtils.copyDirectory(File srcDir, File destDir) &#x2F;&#x2F; 复制文件夹（文件夹里面的文件内容也会复制） FileUtils.copyDirectory(File srcDir, File destDir, FileFilter filter) &#x2F;&#x2F; 复制文件夹，带有文件过滤功能 FileUtils.copyDirectoryToDirectory(File srcDir, File destDir) &#x2F;&#x2F; 以子目录的形式将文件夹复制到到另一个文件夹下 复制文件FileUtils.copyFile(File srcFile, File destFile) &#x2F;&#x2F; 复制文件 FileUtils.copyFile(File input, OutputStream output) &#x2F;&#x2F; 复制文件到输出流 FileUtils.copyFileToDirectory(File srcFile, File destDir) &#x2F;&#x2F; 复制文件到一个指定的目录 FileUtils.copyInputStreamToFile(InputStream source, File destination) &#x2F;&#x2F; 把输入流里面的内容复制到指定文件 FileUtils.copyURLToFile(URL source, File destination) &#x2F;&#x2F; 把URL 里面内容复制到文件(可以下载文件) FileUtils.copyURLToFile(URL source, File destination, int connectionTimeout, int readTimeout) 把字符串写入文件FileUtils.writeStringToFile(File file, String data, String encoding) FileUtils.writeStringToFile(File file, String data, String encoding, boolean append) 把字节数组写入文件FileUtils.writeByteArrayToFile(File file, byte[] data) FileUtils.writeByteArrayToFile(File file, byte[] data, boolean append) FileUtils.writeByteArrayToFile(File file, byte[] data, int off, int len) FileUtils.writeByteArrayToFile(File file, byte[] data, int off, int len, boolean append) 把集合里面的内容写入文件&#x2F;&#x2F; encoding：文件编码，lineEnding：每行以什么结尾 FileUtils.writeLines(File file, Collection&lt;?&gt; lines) FileUtils.writeLines(File file, Collection&lt;?&gt; lines, boolean append) FileUtils.writeLines(File file, Collection&lt;?&gt; lines, String lineEnding) FileUtils.writeLines(File file, Collection&lt;?&gt; lines, String lineEnding, boolean append) FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines) FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines, boolean append) FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines, String lineEnding) FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines, String lineEnding, boolean append) 往文件里面写内容FileUtils.write(File file, CharSequence data, Charset encoding) FileUtils.write(File file, CharSequence data, Charset encoding, boolean append) FileUtils.write(File file, CharSequence data, String encoding) FileUtils.write(File file, CharSequence data, String encoding, boolean append) 文件移动FileUtils.moveDirectory(File srcDir, File destDir) &#x2F;&#x2F; 文件夹在内的所有文件都将移动FileUtils.moveDirectoryToDirectory(File src, File destDir, boolean createDestDir) &#x2F;&#x2F; 以子文件夹的形式移动到另外一个文件下 FileUtils.moveFile(File srcFile, File destFile) &#x2F;&#x2F; 移动文件 FileUtils.moveFileToDirectory(File srcFile, File destDir, boolean createDestDir) &#x2F;&#x2F; 以子文件的形式移动到另外一个文件夹下 FileUtils.moveToDirectory(File src, File destDir, boolean createDestDir) &#x2F;&#x2F; 移动文件或者目录到指定的文件夹内 清空和删除文件夹FileUtils.deleteDirectory(File directory) &#x2F;&#x2F; 删除文件夹，包括文件夹和文件夹里面所有的文件 FileUtils.cleanDirectory(File directory) &#x2F;&#x2F; 清空文件夹里面的所有的内容 FileUtils.forceDelete(File file) &#x2F;&#x2F; 删除，会抛出异常 FileUtils.deleteQuietly(File file) &#x2F;&#x2F; 删除，不会抛出异常 创建文件夹FileUtils.forceMkdir(File directory) &#x2F;&#x2F; 创建文件夹(可创建多级) FileUtils.forceMkdirParent(File file) &#x2F;&#x2F; 创建文件的父级目录 获取文件输入&#x2F;输出流FileUtils.openInputStream(File file) FileUtils.openOutputStream(File file) 读取文件FileUtils.readFileToByteArray(File file) &#x2F;&#x2F; 把文件读取到字节数组 FileUtils.readFileToString(File file, Charset encoding) &#x2F;&#x2F; 把文件读取成字符串 FileUtils.readFileToString(File file, String encoding) FileUtils.readLines(File file, Charset encoding) &#x2F;&#x2F; 把文件读取成字符串集合 FileUtils.readLines(File file, String encoding) 测试两个文件的修改时间FileUtils.isFileNewer(File file, Date date) FileUtils.isFileNewer(File file, File reference) FileUtils.isFileNewer(File file, long timeMillis) FileUtils.isFileOlder(File file, Date date) FileUtils.isFileOlder(File file, File reference) FileUtils.isFileOlder(File file, long timeMillis) 文件&#x2F;文件夹的迭代FileUtils.iterateFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) FileUtils.iterateFiles(File directory, String[] extensions, boolean recursive) FileUtils.iterateFilesAndDirs(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) FileUtils.lineIterator(File file) FileUtils.lineIterator(File file, String encoding) FileUtils.listFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) FileUtils.listFiles(File directory, String[] extensions, boolean recursive) FileUtils.listFilesAndDirs(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) 其他FileUtils.isSymlink(File file) &#x2F;&#x2F; 判断是否是符号链接 FileUtils.directoryContains(File directory, File child) &#x2F;&#x2F; 判断文件夹内是否包含某个文件或者文件夹 FileUtils.sizeOf(File file) &#x2F;&#x2F; 获取文件或者文件夹的大小 FileUtils.getTempDirectory()&#x2F;&#x2F; 获取临时目录文件 FileUtils.getTempDirectoryPath()&#x2F;&#x2F; 获取临时目录路径 FileUtils.getUserDirectory()&#x2F;&#x2F; 获取用户目录文件 FileUtils.getUserDirectoryPath()&#x2F;&#x2F; 获取用户目录路径 FileUtils.touch(File file) &#x2F;&#x2F; 创建文件 FileUtils.contentEquals(File file1, File file2) &#x2F;&#x2F; 比较两个文件内容是否相同 FilenameUtils（文件名&#x2F;后缀名相关）FilenameUtils.concat(String basePath, String fullFilenameToAdd) &#x2F;&#x2F; 合并目录和文件名为文件全路径 FilenameUtils.getBaseName(String filename) &#x2F;&#x2F; 去除目录和后缀后的文件名 FilenameUtils.getExtension(String filename) &#x2F;&#x2F; 获取文件的后缀 FilenameUtils.getFullPath(String filename) &#x2F;&#x2F; 获取文件的目录 FilenameUtils.getName(String filename) &#x2F;&#x2F; 获取文件名 FilenameUtils.getPath(String filename) &#x2F;&#x2F; 去除盘符后的路径 FilenameUtils.getPrefix(String filename) &#x2F;&#x2F; 盘符 FilenameUtils.indexOfExtension(String filename) &#x2F;&#x2F; 获取最后一个.的位置 FilenameUtils.indexOfLastSeparator(String filename) &#x2F;&#x2F; 获取最后一个&#x2F;的位置 FilenameUtils.normalize(String filename) &#x2F;&#x2F; 获取当前系统格式化路径 FilenameUtils.removeExtension(String filename) &#x2F;&#x2F; 移除文件的扩展名 FilenameUtils.separatorsToSystem(String path) &#x2F;&#x2F; 转换分隔符为当前系统分隔符 FilenameUtils.separatorsToUnix(String path) &#x2F;&#x2F; 转换分隔符为linux系统分隔符 FilenameUtils.separatorsToWindows(String path) &#x2F;&#x2F; 转换分隔符为windows系统分隔符 FilenameUtils.equals(String filename1, String filename2) &#x2F;&#x2F; 判断文件路径是否相同，非格式化 FilenameUtils.equalsNormalized(String filename1, String filename2) &#x2F;&#x2F; 判断文件路径是否相同，格式化 FilenameUtils.directoryContains(String canonicalParent, String canonicalChild) &#x2F;&#x2F; 判断目录下是否包含指定文件或目录 FilenameUtils.isExtension(String filename, String extension) &#x2F;&#x2F; 判断文件扩展名是否包含在指定集合(数组、字符串)中 FilenameUtils.wildcardMatch(String filename, String wildcardMatcher) &#x2F;&#x2F; 判断文件扩展名是否和指定规则匹配 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"41.集合进阶-08-TreeSet详解","slug":"41.集合进阶-08-TreeSet详解","date":"2019-09-24T23:13:00.000Z","updated":"2024-06-28T09:08:59.726Z","comments":true,"path":"2019/09/25/41.集合进阶-08-TreeSet详解/","link":"","permalink":"https://protonlml.github.io/2019/09/25/41.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-08-TreeSet%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"TreeSet详解 一、TreeSet TreeSet集合，底层是红黑树结构 ★★★存入treeSet中的元素，遍历出来，默认就是按照从小到大来排序的。★★★ 1.存数值类型，然后遍历，默认就是从小到大遍历出来的。 2.存字符串，是按照字符在ASCII码表中的数字升序进行排序的 如果说字符串中的字符比较多，它是从字符串首字母按个比较的，此时和字符串的长度没有关系。例如”aaa”,”ab”,”aba” 从小到大遍历出来。它相比较前两个字符串的首字母a,一样就 再比较第二位的字母，b&gt;a 直接确定了大小关系，后面所有字母不再看了。随后进行第二个字符串和第三个字符串的比较。 3.存入自定义对象类型，该怎么比较呢？ 因为treeSet集合底层是红黑树，所以其内部自定义对象，不用再重写hashCode和equals方法。用不到哈希值。 但是，要比较两个自定义对象，得指定某个属性来比较。 TreeSet的两种比较方式 第一种 自定义类 实现Comparable接口：指定比较规则 第二种 比较器排序 使用原则：默认使用第一种，如果第一种不能满足当前需求，就是用第二种。练习123456789101112/** *学生的比较规则 *按照总分从高到低输出到控制台 *如果总分一·样，按照语文成绩排 *如果语文一样，按照数学成绩排 *如果数学成绩一样，按照英语成绩排 *如果英文成绩一样，按照年龄排 * 如果年龄一样，按照姓名的字母顺序排 *如果都一样，认为是同一个学生，不存。 * * */ © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"40.集合进阶-07-HashSet、LinkedHashSet详解","slug":"40.集合进阶-07-HashSet、LinkedHashSet详解","date":"2019-09-24T23:12:00.000Z","updated":"2024-06-26T06:33:52.102Z","comments":true,"path":"2019/09/25/40.集合进阶-07-HashSet、LinkedHashSet详解/","link":"","permalink":"https://protonlml.github.io/2019/09/25/40.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-07-HashSet%E3%80%81LinkedHashSet%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"HashSet、LinkedHashSet详解 HashSet、LinkedHashSet详解 哈希值 什么是哈希值？ 在java中，对象的整数表现形式，就是将对象进行计算得出来一个整数值 。 哈希值根据什么计算？ 哈希值可以用来判断两个对象是否相等，（不是地址值是否相等，而是对象中的属性值是否相等） 一般两个对象，即使是其属性完全相同，由于是两个对象，他们的地址值肯定不同，他们也必然不可能是同一个对象。 比较两个对象，它们都没有重写Object中的 hashCode方法，那么他们的哈希值就是通过他们的地址值计算得来，肯定是不相同的哈希值。即使是他么的属性值完全相同，他们也不能相等。 所以我们在比较两个对象的时候，在对象里面要重写hashCode方法，使用对象属性来计算哈希值，只要是两个对象的属性值相同，那么他们的哈希值就相等，他们也被判定为相等。（地址值不一样） HashSet底层原理（哈希表） ★★★重写hashCode的目的是：想通过对象的属性值来计算哈希值，而不是地址值计算哈希值★★★ 用来确定对象存放在数组的哪个位置 ★★★重写equals的目的是：想要对象比较的时候，比的也是对象中的属性，而不是对象地址值★★★ 确定了对像的位置，比较对象属性 ★★★只要记住存入到hashSet集合中的自定义对象，都要重写hashCode和equals方法★★★ 因为：Set 是一个不允许重复元素的集合，它使用 hashCode() 和 equals() 方法来判断元素是否相等。如果您不重写这两个方法，Set 将无法正确识别相同内容的自定义对象。 LinkedHashSet © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"39.集合进阶-06-ArrayList源码分析","slug":"39.集合进阶-06-数据结构（红黑树、红黑规则、添加节点处理方案详解）","date":"2019-09-24T23:11:00.000Z","updated":"2024-06-23T09:54:27.246Z","comments":true,"path":"2019/09/25/39.集合进阶-06-数据结构（红黑树、红黑规则、添加节点处理方案详解）/","link":"","permalink":"https://protonlml.github.io/2019/09/25/39.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E8%A7%84%E5%88%99%E3%80%81%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3%EF%BC%89/","excerpt":"","text":"ArrayList源码分析 ArrayList源码分析 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"38.集合进阶-05数据结构（平衡二叉树旋转机制）","slug":"38.集合进阶-05数据结构（平衡二叉树旋转机制）","date":"2019-09-24T23:10:00.000Z","updated":"2024-06-26T02:36:51.792Z","comments":true,"path":"2019/09/25/38.集合进阶-05数据结构（平衡二叉树旋转机制）/","link":"","permalink":"https://protonlml.github.io/2019/09/25/38.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-05%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC%E6%9C%BA%E5%88%B6%EF%BC%89/","excerpt":"","text":"（平衡二叉树旋转机制） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"37.集合进阶-04-数据结构(二叉树,二叉查找树,平衡二叉树)","slug":"37.集合进阶-04-数据结构(二叉树,二叉查找树,平衡二叉树)","date":"2019-09-24T23:09:00.000Z","updated":"2024-06-26T02:36:00.705Z","comments":true,"path":"2019/09/25/37.集合进阶-04-数据结构(二叉树,二叉查找树,平衡二叉树)/","link":"","permalink":"https://protonlml.github.io/2019/09/25/37.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C%E5%8F%89%E6%A0%91,%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91,%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)/","excerpt":"","text":"数据结构(二叉树,二叉查找树,平衡二叉树) 一、二叉树（二叉查找树为了提高查询效率） 二、二叉查找树的添加原理 三、查找节点 四、所有二叉树的遍历方式 1.前序遍历 2.中序遍历 3.后序遍历 4.层序遍历 五、二叉查找树的弊端 因为二叉查找树。有这样的弊端，所以就出现了平衡二叉树 六、平衡二叉树 下列不是平衡二叉树 二叉树结构的演变 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"36.集合进阶-03-泛型类、泛型方法、泛型接口","slug":"36.集合进阶-03-泛型类、泛型方法、泛型接口","date":"2019-09-24T23:08:00.000Z","updated":"2024-06-25T14:22:33.033Z","comments":true,"path":"2019/09/25/36.集合进阶-03-泛型类、泛型方法、泛型接口/","link":"","permalink":"https://protonlml.github.io/2019/09/25/36.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-03-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"泛型类、泛型方法、泛型接口 一、泛型是什么 ArrayList strs&#x3D;new ArrayList&lt;&gt;(); 这里面的尖括号 ,就是指泛型. 说白了，就是用来限定集合中存入数据的类型，不能随便存，只能存泛型指定的类型。 二、为什么要用泛型 因为： 如果我]没有给集合指定类型，默认认为所有的数据类型都是Object类型此时可以往集合添加任意的数据类型。带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。 泛型类 泛型方法 可变形参的写法 泛型接口 泛型的通配符 “?” 泛型的通配符是一个问号： “?” ， © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"35.LIst集合进阶-02-List集合","slug":"35.LIst集合进阶-02-List集合","date":"2019-09-24T23:06:00.000Z","updated":"2024-06-28T02:51:36.275Z","comments":true,"path":"2019/09/25/35.LIst集合进阶-02-List集合/","link":"","permalink":"https://protonlml.github.io/2019/09/25/35.LIst%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-02-List%E9%9B%86%E5%90%88/","excerpt":"","text":"List集合 List接口的实现类一、理解什么是数据结构 数据结构是：计算机存储数据，组织数据的方式 不同的业务场景要选择不同的数据结构（数据多怎么存取，数据少怎么存取） ArrayList 、LinkedList 、Vector 在底层java用到了不同的数据结构，所以说，你不知道数据结构，你根本不知道什么时候用哪种集合。 二、8种数据结构 1. 栈、队列 2. 数组 3.链表 ArrayList 一、ArrayList底层是数组 ArrayList 集合中判断某个元素是否存在 array.contains(元素)； 注意：底层使用的就是equals() 方法,所以在判断自定义对象是否存在，对象要重写equals方法。 包装类 String 和 Integer中都已经重写了equals方法，所以直接拿来用如 indexs.contains(index) LinkedList 迭代器 底层源码 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"34.集合进阶-01-单列集合顶层接口Collection及其遍历方法","slug":"34.集合进阶-01-单列集合顶层接口Collection及其遍历方法","date":"2019-09-24T23:05:00.000Z","updated":"2024-06-26T08:35:17.614Z","comments":true,"path":"2019/09/25/34.集合进阶-01-单列集合顶层接口Collection及其遍历方法/","link":"","permalink":"https://protonlml.github.io/2019/09/25/34.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-01-%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E9%A1%B6%E5%B1%82%E6%8E%A5%E5%8F%A3Collection%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"单列集合顶层接口Collection 单列集合的使用时机： 集合集合分为 ： 单列集合，和双列集合 一、单列集合体系结构 二、collection 集合父接口的通用方法 三、细节 四、Collection这个系列的通用遍历方式（List 系列和Set系列通用的） 1.为什么不能使用之前的普通for循环遍历呢？ 当然List系列集合可以使用for i 循环遍历， 但是set系列集合，没有索引，他就不能通过普通for 来遍历。 2.迭代器遍历 注意点： 通过Collection集合，来获取一个迭代器对象，使用迭代器进行遍历 迭代器不依赖索引的 3.增强for遍历 4.Lambda表达式遍历 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"33.五道经典算法题","slug":"33.五道经典算法题","date":"2019-09-24T23:02:00.000Z","updated":"2024-06-23T09:48:44.874Z","comments":true,"path":"2019/09/25/33.五道经典算法题/","link":"","permalink":"https://protonlml.github.io/2019/09/25/33.%E4%BA%94%E9%81%93%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"","text":"五道经典算法题 五道经典算法题 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"32.Collections 集合 工具类","slug":"32.Collections 集合 工具类","date":"2019-09-24T23:01:00.000Z","updated":"2024-06-27T23:11:10.361Z","comments":true,"path":"2019/09/25/32.Collections 集合 工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/25/32.Collections%20%E9%9B%86%E5%90%88%20%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Collections 集合 工具类 Collections 集合 工具类 binarySearch 的使用细节 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"32.lambda表达式","slug":"32.lambda表达式","date":"2019-09-24T23:01:00.000Z","updated":"2024-06-24T07:02:15.977Z","comments":true,"path":"2019/09/25/32.lambda表达式/","link":"","permalink":"https://protonlml.github.io/2019/09/25/32.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"lambda表达式 一、lambda表达式就是用来（简化匿名内部类的写法） 二、函数式编程 通俗理解：就是代码中，只写实现功能的部分，不new对象，不管创建的对象是谁，只专注于写方法体。 123456789101112** 要记住：出现Lambda 表达式，就是为了简化 匿名内部类的写法** 这个匿名内部类，是有要求的，它是 函数式接口的 匿名内部类。** 函数式接口：指的是只有一个抽象方法的接口。** 为什么只能是一个抽象方法的接口，来实现 Lambda表达式的简化写法?* 因为：（）-&gt;&#123; &#125; Lanbda 表达式 后面的 &#123;&#125; 就表示 方法体。* 这个方法体，如果接口中有两个抽象方法，那么它就不知道* 实现哪一个抽象方法的方法体 三、函数式接口：只有一个抽象方法的接口 四、Lamdba 表达式的 省略写法 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"31.Arrays 数组 工具类","slug":"31.Arrays工具类","date":"2019-09-24T23:00:00.000Z","updated":"2024-06-27T10:10:27.746Z","comments":true,"path":"2019/09/25/31.Arrays工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/25/31.Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Arrays工具类（数组工具类） Arrays工具类（数组工具类） Arrays.asList() 方法的详解 1.要点】该方法是将数组转化成List集合的方法。其长度是不可变的，不能使用add方法 List list &#x3D; Arrays.asList(“a”,”b”,”c”); 注意： （1）该方法适用于对象型数据的数组（String、Integer…） （2）该方法不使用于基本数据类型的数组（byte,short,int,long,float,double,boolean） （3）该方法将数组与List列表链接起来：当更新其一个时，另一个自动更新 （4）不支持add()、remove()、clear()等方法 注意：参数必须是对象或者对象数组Arrays.asList()的参数必须是对象或者对象数组错误做法：使用基础类型 12345int[] it = &#123;1,2,3&#125;;List&lt;int[]&gt; ints = Arrays.asList(it);System.out.println(ints); 输出为[[I@59f95c5d] 正确做法：使用int的包装类Integer 12345Integer[] it = &#123;1,2,3&#125;;List&lt;Integer&gt; ints = Arrays.asList(it);System.out.println(ints); 输出为[1, 2, 3] 2.Arrays.asList()是个坑 用此方法得到的List的长度是不可改变的， 当你向这个List添加或删除一个元素时（例如 list.add(“d”);）程序就会抛出异常（java.lang.UnsupportedOperationException）。 怎么会这样？只需要看看asList()方法是怎么实现的就行了： public static List asList(T… a) {return new ArrayList&lt;&gt;(a);} 当你看到这段代码时可能觉得没啥问题啊，不就是返回了一个ArrayList对象吗？问题就出在这里。 这个ArrayList不是java.util包下的，而是java.util.Arrays.ArrayList 它是Arrays类自己定义的一个静态内部类，这个内部类没有实现add()、remove()方法，而是直接使用它的父类AbstractList的相应方法。 而AbstractList中的add()和remove()是直接抛出java.lang.UnsupportedOperationException异常的！ public void add(int index, E element) { throw new UnsupportedOperationException();} public E remove(int index) {throw new UnsupportedOperationException();} 总结：如果你的List只是用来遍历，就用Arrays.asList()。 如果你的List还要添加或删除元素，还是乖乖地new一个java.util.ArrayList，然后一个一个的添加元素 数组排序 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"30.常见算法05(快速排序)","slug":"30.常见算法05(快速排序)","date":"2019-09-24T14:51:00.000Z","updated":"2024-06-23T09:31:05.524Z","comments":true,"path":"2019/09/24/30.常见算法05(快速排序)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/30.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9505(%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)/","excerpt":"","text":"常见算法05 30.常见算法05(快速排序) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"29.常见算法04(插入排序、递归算法)","slug":"29.常见算法04(插入排序、递归算法)","date":"2019-09-24T14:50:00.000Z","updated":"2024-06-23T09:30:28.058Z","comments":true,"path":"2019/09/24/29.常见算法04(插入排序、递归算法)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/29.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9504(%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95)/","excerpt":"","text":"常见算法04 29.常见算法04(插入排序、递归算法) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"28.常见算法03(冒泡排序、选择排序)","slug":"28.常见算法03(冒泡排序、选择排序)","date":"2019-09-24T14:49:00.000Z","updated":"2024-06-23T09:29:44.510Z","comments":true,"path":"2019/09/24/28.常见算法03(冒泡排序、选择排序)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/28.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9503(%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)/","excerpt":"","text":"常见算法03 常见算法03(冒泡排序、选择排序) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"27. 常见算法02(分块、分块扩展、哈希查找)","slug":"27.常见算法02(分块、分块扩展、哈希查找)","date":"2019-09-24T14:48:00.000Z","updated":"2024-06-23T09:29:39.775Z","comments":true,"path":"2019/09/24/27.常见算法02(分块、分块扩展、哈希查找)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/27.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9502(%E5%88%86%E5%9D%97%E3%80%81%E5%88%86%E5%9D%97%E6%89%A9%E5%B1%95%E3%80%81%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE)/","excerpt":"","text":"常见算法02 常见算法02(分块、分块扩展、哈希查找) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"26.常见算法01(基本、二分、插值、斐波那契查找)","slug":"26.常见算法01(基本、二分、插值、斐波那契查找)","date":"2019-09-24T14:47:00.000Z","updated":"2024-06-23T09:29:34.820Z","comments":true,"path":"2019/09/24/26.常见算法01(基本、二分、插值、斐波那契查找)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/26.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9501(%E5%9F%BA%E6%9C%AC%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E6%8F%92%E5%80%BC%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE)/","excerpt":"","text":"常见算法01 (基本、二分、插值、斐波那契查找) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"25.包装类","slug":"25.包装类","date":"2019-09-24T14:46:00.000Z","updated":"2024-06-23T02:56:06.801Z","comments":true,"path":"2019/09/24/25.包装类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/25.%E5%8C%85%E8%A3%85%E7%B1%BB/","excerpt":"","text":"包装类 包装类一、什么是包装类 二、为什么使用包装类 因为：再java中，万事万物皆对象，方法的参数如果是Object，那么 基本数据类型就不能传进来。有局限性，其次是，多态性。 集合中也只能存储对象，不能存储基本数据类型。 注意点： 自动装箱，自动拆箱： 总结 三、Integer 包装类的 成员方法 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"24.Date时间相关类","slug":"24.时间相关类","date":"2019-09-24T14:43:00.000Z","updated":"2024-06-23T02:13:19.901Z","comments":true,"path":"2019/09/24/24.时间相关类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/24.%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB/","excerpt":"","text":"时间相关类 JDK7以前时间相关类一、Date (时间类) 1.空参创建Date，直接打印 2.有参数创建date，打印指定时间（时间原点） 3.getTime &amp; setTime 二、 SimpleDateFormat SimpleDateFormat 的使用 格式化： 解析： 三、Calendar 日历对象 JDK8新增时间相关类一、 二、JDK8新增的时间类 1. ZoneId 时区类 2.Instant时间戳类 3.ZoneDateTime 带时区的时间类 4.DateTimeFormatter时间格式化和解析 5.LocalDate、LocalTime、LocalDateTime日历类 三个对象的获取方式 判断今天是不是你生日 判断是闰年还是平年 6. Duration、Period、ChronoUnit（时间间隔对象） Period 对象 计算 （年月日）之间的时间间隔（了解） Duration对象 计算 （年月日时分秒）之间的时间间隔（了解） ChronoUnit对象 计算 （两个日期）间隔（掌握常用）所有的都能计算出来 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"23.正则表达式","slug":"23.正则表达式","date":"2019-09-24T14:41:00.000Z","updated":"2024-06-20T00:55:50.778Z","comments":true,"path":"2019/09/24/23.正则表达式/","link":"","permalink":"https://protonlml.github.io/2019/09/24/23.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式 一、校验字符串 工作中怎么使用 1.IDEA中下载插件any-rule 2.在代码中，定义一个字符串，然后右键使用 二、在一段文本中，查找满足要求的内容（爬虫） 使用到两个对象 1.Pattern(正则表达式对象) 2.Matcher（文本匹配器对象） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"22.Biglnteger 和BigDecimal","slug":"22.Biglnteger 和BigDecimal","date":"2019-09-24T14:40:00.000Z","updated":"2024-06-19T22:26:30.654Z","comments":true,"path":"2019/09/24/22.Biglnteger 和BigDecimal/","link":"","permalink":"https://protonlml.github.io/2019/09/24/22.Biglnteger%20%E5%92%8CBigDecimal/","excerpt":"","text":"Biglnteger 和BigDecimal Biglnteger (大整数)（取值范围大）为什么要有BigInteger? 一、BigInteger构造方法创建对象 1. 随机获取一个大整数，构造参数为(num ,random) 结果为[0~ 2^num-1] ![image-20240620031429030](22.Biglnteger 和BigDecimal.assets&#x2F;image-20240620031429030.png) 2.获取一个指定的大整数（常用） 3.获取一个指定进制的大整数（了解） 4.静态方法 获取BigIntegerl的对象,内部有优化（在Long类型范围内常用） 5.对象一旦创建内部的数据不能发生改变 二、BigInteger常见的成员方法（用来计算的） ![image-20240620034732920](22.Biglnteger 和BigDecimal.assets&#x2F;image-20240620034732920.png) BigDecimal（大小数）（取值范围大）为什么要有BigDecimal? 我们为了精确计算，就要使用这个BigDecimal对象 用来表示很大的小数 一、BigDecimal构造方法创建对象 1.使用 参数为double 的 构造方法创建（不推荐） 细节： 这种方式可能是不精确的，所以不建议使用 2.使用参数为string的 构造方法（推荐）非常精确 细节：放心用，非常精确 3. 通过静态方法获取对象 细节： 1.如果要表示的数字不大,没有超出doub1e的取值范围,建议使用静态方法 2.如果要表示的数字比较大,超出了double的取值范围,建议使用String参数的构造方法 3.如果我们传递的是0~10之间的整数,包含0,包含10,那么方法会返回已经创建好的对象,不会重新new ![image-20240620042153353](22.Biglnteger 和BigDecimal.assets&#x2F;image-20240620042153353.png) 二、BigDecimal常见的成员方法（用来计算的） 注意：使用divide 来进行数据的除运算，如果不指定取几位小数，以及舍入模式的话，如果除不整是会报错的。所以我们一般除运算，会给全部参数的。 三、BigDecimal底层存储方式 总结 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"21.Object 和 Objects","slug":"21.Object和Objects","date":"2019-09-24T14:38:00.000Z","updated":"2024-06-19T18:59:45.629Z","comments":true,"path":"2019/09/24/21.Object和Objects/","link":"","permalink":"https://protonlml.github.io/2019/09/24/21.Object%E5%92%8CObjects/","excerpt":"","text":"Object 和 Objects Object Object类是java中所有对象的父亲，每个类都默认继承ObjectObject 中没有属性值，因为定义父类，就是为了抽取子类共有的属性以及方法，所以作为顶级父类，没法写属性值Object 中只有空参构造器，因为其没有属性，所有子类都有空参构造器，就是重写的Object的 内部有隐藏的super();Object 中的tostring() 方法查看源码就是打印的对象地址值。子类要想展示属性，只有在子类内部重写tostring()方法 注意：Object 中的克隆是浅克隆，只要原来的对象中的属性值改变了，则克隆后的对象中属性值也会被改变。总结 Objects © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"19.System工具类","slug":"19.System工具类","date":"2019-09-24T14:36:00.000Z","updated":"2024-06-19T08:47:09.806Z","comments":true,"path":"2019/09/24/19.System工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/19.System%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"System工具类 System 类 拷贝数组，注意的细节 总结 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"20.Runtime工具类","slug":"20.Runtime工具类","date":"2019-09-24T14:36:00.000Z","updated":"2024-06-19T15:12:38.391Z","comments":true,"path":"2019/09/24/20.Runtime工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/20.Runtime%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Runtime工具类 Runtime类需要用到java代码，来监控虚拟机的内存时，使用这个类 表示当前虚拟机的运行环境（它是单例的）外界不能创建多个，只能创建一个。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"18.Math工具类","slug":"18.Math工具类","date":"2019-09-24T14:35:00.000Z","updated":"2024-07-04T14:10:26.614Z","comments":true,"path":"2019/09/24/18.Math工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/18.Math%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Math工具类 Math 类 1.是一个帮助我们用于进行数学计算的工具类 2.类是final 修饰 表示最终类，不能被继承。私有构造方法（在外界不能创建），所有的成员方法都是静态的（外界使用类名调用） 常用方法 int 的 取值范围 -2147483648~2147483647 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"17.内部类","slug":"17.内部类","date":"2019-09-24T14:30:00.000Z","updated":"2024-06-18T14:16:00.101Z","comments":true,"path":"2019/09/24/17.内部类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/17.%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"内部类 一、概念 一、成员内部类1.成员内部类的代码如何书写（如下和成员变量是一个级别的） 2.如何创建成员内部类的对象 3.成员内部类如何获取外部类的成员变量 二、静态内部类 静态内部类只能访问外部类中的静态变量和静态方法, 静态内部类,其里面如果想要访问外部类中的非静态,需要在内部创建外部类对象 总结 三、局部内部类 四、匿名内部类 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"15.抽象类","slug":"15.抽象类","date":"2019-09-24T14:00:00.000Z","updated":"2024-06-18T06:10:52.145Z","comments":true,"path":"2019/09/24/15.抽象类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/15.%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"抽象类 一、概念1.把子类共性的方法，抽取到父类中之后，但是每个子类执行这个方法的方法体内容又是不一样的，（方法体不能确定）之前是每个子类重写这个方法，实现功能，有弊端，子类不重写这个方法也能调用就可能产生错误。2.所以我们将抽取到父类中的共性方法，只定义方法名，不写方法体，这个就是抽象方法。3.抽象方法，所在的类，就叫抽象类4.在继承父类之后的子类，必须实现抽象方法，不实现会报错。 二、抽象类的定义 三、注意事项 总结：父类中的抽象方法，强制了在子类创建时，用统一的格式来重写这个抽象方法，目的是，让每个子类的这个方法都是统一的，在调用的时候很方便，不用再去每个子类中，找每个此功能方法的名称。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"16.接口","slug":"16.接口","date":"2019-09-24T14:00:00.000Z","updated":"2024-07-06T16:01:20.651Z","comments":true,"path":"2019/09/24/16.接口/","link":"","permalink":"https://protonlml.github.io/2019/09/24/16.%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口 一、概念 接口就是将行为抽象出去，所有的类都可以实现其中的方法，好比游泳这个行为，人可以游，动物也可以游泳。可以多实现而抽象类，是同一种类别的对象，将共同方法抽象到父类抽象类中。只能单继承。 抽象类，都是指父类，抽取子类共同的方法，定义为抽象方法。子类实现重写。抽象方法所在的类就是抽象类接口：就是一种规则，它把一些方法抽象出去，谁要用，谁就来实现这个接口，对其内部的方法进行重写接口：其实也是对方法名进行规范，项目中有很多类，都可以去实现接口，每个类实现了接口中的方法，名称是一样的，将来不管是哪个对象来调用（这个接口任意的实现类，的实现方法，名称都是统一的。） 二、接口的定义和使用 三、接口中成员的特点 四、接口和类之间的关系 接口拓展一、JDK8开始接口中新增的方法、 1.默认方法 为什么要在接口中定义 默认方法因为：接口会有升级，在后续的开发中，接口中的抽象方法会越来越多，只要接口中发生了变化，那么所有的实现类就不得不来跟着去改变。对于已经实现的很多实现类，都要修改无疑是很麻烦的事情。所以：在接口中定义一个默认方法，其所有的实现类，都可以直接调用，不需要重写。 2.静态方法 接口中的静态方法，只与当前接口有关系，是不能够被其实现类重写的，调用也是通过接口来调用的 3.JDK9在接口中可以写私有方法 a.接口中为什么会有私有方法？ 起因：在接口中，我们定义了一些默认的方法，但是有些默认方法中有重复代码，我们就想在接口中提取出来一个方法来写这些重发代码。这些重复代码又仅仅是接口内部为default修饰的默认方法服务的。不想被外界使用。所以加了个private 修饰 b.私有方法有两种： 私有方法 静态私有方法 二、接口的应用 总结 三、适配器设计模式 总结 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"14.面向对象细节性的知识点","slug":"14.面向对象细节性的知识点","date":"2019-09-24T13:50:00.000Z","updated":"2024-06-18T05:21:21.280Z","comments":true,"path":"2019/09/24/14.面向对象细节性的知识点/","link":"","permalink":"https://protonlml.github.io/2019/09/24/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%86%E8%8A%82%E6%80%A7%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"面向对象细节性的知识点 面向对象细节性的知识点 1.对象总结：在java中，一个java文件，一般就写一个class类，一个类就代表一类对象。 2.类中有成员变量，成员方法，以及构造器。 3.有两种类： 一般javaBen 这种类，只是为了描述对象使用，内部不会使用static来修饰成员变量，或者成员方法。 另一种类，就是工具类，里面的成员方法比较多，而且是static修饰的，目的是方便用类进行调用 static 修饰的成员方法，或者成员变量，都是与类相关，随着类加载而加载。 4.类与类之间，可以实现单继承，多层继承。 子类继承父类中所有公有的成员变量以及成员方法，子类都可以使用。子类还有自己的方法，这样子类的功能就变强大了。 子类中，如果定义了与父类中相同的方法，那么就称子类中，对该方法进行了重写。（这就是方法重写）目的是个性化子类当前方法功能 5.有了继承，那么就有很多类，共同继承同一个父类，此时就形成一种关系叫做多态 多态：目的是，在某个方法形式参数中，使用一类对象，来进行调用。参数可以使用父类来充当。只要继承了当前这个父类，那么其子类都能赋值于这某个方法形参上面进行使用 包一、什么是包 二、总结 final关键字一、final 修饰，方法，类，变量 权限修饰符 代码块代码块：局部代码块，构造代码块，静态代码块一、局部代码块（淘汰了，了解） 1.局部代码就是写在方法里面的一对单独的 { } 2.本质的作用就是节约内存 二、构造代码块（淘汰了，了解） 1.构造代码块，就是在类中，写在成员位置的代码块，当我们创建本类对象时，会优先于构造方法执行。 2. 将多个构造方法中，重复的代码，写在构造代码块中（弊端：每次创建本类对象，都会执行一次，有局限性） 三、静态代码块 当一个类被加载时，静态代码块会被执行。这个过程通常在首次创建类的实例之前发生，或者在访问类的静态成员变量或静态方法之前发生。静态代码块可以用来初始化静态成员变量，执行静态方法，加载静态资源，或者进行其他静态的初始化操作。 静态代码块的特点 执行顺序：静态代码块在类被加载时执行，按照它们在类中出现的顺序执行。如果一个类中有多个静态代码块，它们会按照在源代码中的顺序依次执行。 只执行一次：静态代码块只会执行一次，即使类被加载多次也是如此。这意味着静态代码块中的代码在整个应用程序的生命周期中只会执行一次。 访问权限：静态代码块可以访问类的静态成员变量和静态方法，但是不能直接访问非静态成员变量和非静态方法。非静态成员变量和非静态方法只有在类的实例被创建后才能被访问。 异常处理：静态代码块中的异常可以通过捕获并处理来防止类加载失败。如果静态代码块中发生了异常，并且没有被处理，类加载过程将被终止，导致类加载失败。 总结： © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"13.多态","slug":"13.多态","date":"2019-09-24T13:40:00.000Z","updated":"2024-06-18T08:57:53.199Z","comments":true,"path":"2019/09/24/13.多态/","link":"","permalink":"https://protonlml.github.io/2019/09/24/13.%E5%A4%9A%E6%80%81/","excerpt":"","text":"多态 面向对象三大特征封装 继承 多态 一、什么是多态 多态：父类的引用，指向子类的对象 二、多态调用成员的特点 三、多态的优势与弊端 多态的弊端 就是 不能使用子类中特有的方法（因为使用的是父类的引用，创建的子类对象，调用方法时，用的是父引用 在父类中找成员变量，和找 子类重写的成员方法） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"12.继承","slug":"12.继承","date":"2019-09-24T13:30:00.000Z","updated":"2024-06-18T08:59:05.889Z","comments":true,"path":"2019/09/24/12.继承/","link":"","permalink":"https://protonlml.github.io/2019/09/24/12.%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承 面向对象三大特征封装 继承 多态 一、封装 二、什么时继承，继承有哪些好处 注意： 三、继承的特点 注意：一个父类中所有的子类，需要是同一种事物 四、子类到底能继承父类中的哪些内容 五、继承中：成员变量的访问特点 六、继承中：成员方法的访问特点 七、方法的重写&#x3D;&#x3D;当父类方法，不能满足子类现在的需求时，需要进行方法重写&#x3D;&#x3D; 八、继承中：构造方法的访问特点 创建对象的时候，给其属性设置默认值（使用构造器来设置） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"11.static静态关键字","slug":"11.static静态变量","date":"2019-09-24T12:30:00.000Z","updated":"2024-07-04T17:15:15.229Z","comments":true,"path":"2019/09/24/11.static静态变量/","link":"","permalink":"https://protonlml.github.io/2019/09/24/11.static%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/","excerpt":"","text":"static静态关键字 一、在类中，对成员变量进行修饰（静态变量） 例如： 学生对象，创建student的类时，可以将 teacherName 设置为 静态的，因为其所有的student的teacherName 是一样的 在Java中，静态成员变量（也称为类变量）是属于类的，而不是任何特定实例的。这意味着无论创建了多少个类的实例（或对象），静态变量只有一份副本，所有的实例都共享这个变量。 这是因为静态变量在类加载时就被初始化，存储在Java的方法区内，而不是与类的每个实例一起存储在堆内存中。因此，无论创建多少个对象，静态变量都只占用一份内存空间，所有对象都可以访问它。 这就是为什么Java类中的静态成员变量是所有对象共享的原因。这种特性使得静态变量非常适合在需要所有对象共享相同信息的情况下使用，例如计数器、常量或配置信息等。但是，需要注意的是，由于所有对象共享静态变量，所以一个对象对静态变量的修改会影响到所有其他对象。因此，在使用静态变量时需要谨慎处理。 二、在类中，对成员方法进行修饰（静态方法）static修饰的成员变量，或者成员方法，因为其都使用了static 关键字修饰，随着类加载而加载，和某个new出来的对象无关 三、一般我们在javaBen中很少用static修饰，工具类或者测试类中，使用的较多 四、重新认识main方法 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"10.集合","slug":"10.集合","date":"2019-09-24T12:00:00.000Z","updated":"2024-06-22T02:34:26.384Z","comments":true,"path":"2019/09/24/10.集合/","link":"","permalink":"https://protonlml.github.io/2019/09/24/10.%E9%9B%86%E5%90%88/","excerpt":"","text":"集合 一、集合和数组都是存数据的容器 1.集合和数组的区别 数组：长度是固定的，可以存储基本数据类型，也可以存储引用数据类型 集合： 长度是可变的，只能存储引用数据类型。 二、集合的基本操作（增删改查） 对容器类的对象的操作，基本上就是增删改查 1.创建集合对象（&lt;&gt; 中表示泛型） 三、基本数据类型对应的包装类 四、集合综合练习 五、知识点（标号的使用） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"9.字符串综合练习","slug":"9.字符串综合练习","date":"2019-09-24T11:00:00.000Z","updated":"2024-06-16T15:08:20.268Z","comments":true,"path":"2019/09/24/9.字符串综合练习/","link":"","permalink":"https://protonlml.github.io/2019/09/24/9.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/","excerpt":"","text":"字符串综合练习 一、转换罗马数字 使用到了 string 字符串 转 char[] :方法是toCharArray() 使用到将 char[i] 某个char字符，转为 数字 ：方法使用 Character.getNumericValue(chars[i]); 使用jdk12中 的 switch的写法进行匹配 二、调整字符串 1. © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"8.String字符串","slug":"8.字符串","date":"2019-09-23T08:00:00.000Z","updated":"2024-07-10T14:46:12.113Z","comments":true,"path":"2019/09/23/8.字符串/","link":"","permalink":"https://protonlml.github.io/2019/09/23/8.%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"String字符串 一、字符串构造方法 二、字符串创建方式 0.直接赋值（最常用），这种赋值后，字符串会放在“字符串常量池”，再次声明这个字符串，可以直接复用，节省内存 1.使用字符数组作为参数，构建String 字符串 2.使用，字节码数组作为构造参数 三、字符串的操作 1.字符串的比较（”&#x3D;&#x3D;” 比较的是地址值，”equals”比较的是内容） 注意点：通过Scanner对象，从键盘录入的字符串是 new出来的，放在堆里 2.字符串，提取指定的字符charAt( )方法 3.字符串的截取 subString() 4.字符串转数字（要注意字符串转为数字后的范围大不大） parseInt() 5.判断字符串是不是空字符串 isEmpty() 6. 字符串的替换 replace() 7.contains(“-“)判断字符中存不存在这个“-”字符 7. indexOf(“-“) 找到这个“-”字符的下标 7.substring(0, str2.indexOf(“-“)) 截取从[0,-角标) ：截取0到“-所在角标” 之前的字符串 1234567截取字符串 判断为空，就完美解决了，例如：String str2 = &quot;SJ202203071007&quot;;if (str2.contains(&quot;-&quot;)) &#123; String str3 = str2.substring(0, str2.indexOf(&quot;-&quot;)); System.out.println(&quot;str3=&quot;+ str3);&#125;System.out.println(&quot;str2直接输出=&quot;+ str2); 四、StringBuilder的使用 为什么使用Stringbuilder 只要涉及到字符串的 “拼接”，“替换”，“反转” 就要想到StringBuilder， 而字符串的 “截取subString”，“获取某个字符使用 charAt()”，都是String自身可以做到 五、StringJoiner（拼接字符串使用） 六、总结 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"7.封装","slug":"7.封装","date":"2019-09-23T02:30:00.000Z","updated":"2024-06-17T07:22:38.471Z","comments":true,"path":"2019/09/23/7.封装/","link":"","permalink":"https://protonlml.github.io/2019/09/23/7.%E5%B0%81%E8%A3%85/","excerpt":"","text":"对象的封装 面向对象三大特征封装 继承 多态 一、对象封装 二、对象中 “成员变量”,”成员方法”. 类中的方法叫做成员方法，类中方法外的变量叫做成员变量。类中方法内的变量，是局部变量。 this 关键字 作用：就是用来区分成员变量，与局部变量重名的。 三、构造方法，构造器 四、构造函数私有化 构造方法，被private修饰，进行私有化，那么标志这个类，在外部是不能够被new 出来的。一般的工具类构造函数都是私有化的，为了防止在外部被创建。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"4.四舍五入","slug":"4.四舍五入","date":"2019-09-22T11:00:00.000Z","updated":"2024-06-19T21:31:50.764Z","comments":true,"path":"2019/09/22/4.四舍五入/","link":"","permalink":"https://protonlml.github.io/2019/09/22/4.%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/","excerpt":"","text":"四舍五入 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"}],"author":"𝚲𝚳𝚲"},{"title":"7.可变参数","slug":"7.可变参数","date":"2019-09-22T07:08:00.000Z","updated":"2024-06-28T09:15:57.824Z","comments":true,"path":"2019/09/22/7.可变参数/","link":"","permalink":"https://protonlml.github.io/2019/09/22/7.%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/","excerpt":"","text":"可变参数 案例1234567891011121314151617181920212223242526272829303132333435public class ArgsDemo &#123; public static void main(String[] args) &#123; /** * 求 一堆数的 和 * 使用可变形参 * 格式：(类型...) */ int i1 = sumMethod(1, 2, 3, 4, 5, 6, 7, 8); System.out.println(i1); //可变形参的参数，也可以直接传一个数组 int[] a = &#123;2,3,4,56,8,76,1,97,5&#125;; int i2 = sumMethod(a); System.out.println(i2); &#125; // 注意形参的位置，只能写一个 可变形参// public static int sumMethod(int... a,int... b) 这是错的 // 如果有多个参数，要把可变形参写在最后面// public static int sumMethod(String a, int... args) public static int sumMethod(int... args)&#123; int sum=0; // int... 底层就是数组，这里的形参是可变形参 for (int arg : args) &#123; sum=sum+arg; &#125; return sum; &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"}],"author":"𝚲𝚳𝚲"},{"title":"8.java中概率怎么体现","slug":"8.java中概率怎么体现","date":"2019-09-22T07:08:00.000Z","updated":"2024-06-28T09:48:24.716Z","comments":true,"path":"2019/09/22/8.java中概率怎么体现/","link":"","permalink":"https://protonlml.github.io/2019/09/22/8.java%E4%B8%AD%E6%A6%82%E7%8E%87%E6%80%8E%E4%B9%88%E4%BD%93%E7%8E%B0/","excerpt":"","text":"概率怎么体现 我们可以想象成 在一个盒子里面，放7个标号为1的小球，放3个标号为0的小球 然后摇晃盒子，将里面的小球打乱 现在，从里面 随机 取出一个标号小球 那么现在：if 如果(取出的小球标号为1)，{ 那么表明这个事的概率就是70%，在这里面做 70%概率的事情 } 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ProbabilityListDemo &#123; public static void main(String[] args) &#123; int a=0; int b=0; for (int i = 0; i &lt; 100; i++) &#123; //假如执行100次 //怎么来形容 70% 概率 这件事 // 在一个盒子里面，放7个标号为1的小球，放3个标号为0的小球 Integer[] box=&#123;1,1,1,1,1,1,1,0,0,0&#125;; ArrayList&lt;Integer&gt; balls = new ArrayList&lt;&gt;(); Collections.addAll(balls,box); //System.out.println(balls); //然后摇晃盒子，将里面的小球打乱 Collections.shuffle(balls); //现在，从里面 随机 取出一个标号小球 int index = new Random().nextInt(balls.size()); Integer ball = balls.get(index); //判断标号，来执行 需要概率执行的代码 if(ball==1)&#123; a++; //这里面被执行的概率是 70% System.out.println(&quot;这里面被执行的概率是 70%&quot;); &#125;else &#123; b++; //这里面被执行的概率是 30% System.out.println(&quot;这里面被执行的概率是 30%&quot;); &#125; &#125; System.out.println(&quot;a=&quot;+a);//71 System.out.println(&quot;b=&quot;+b);//29 &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"}],"author":"𝚲𝚳𝚲"},{"title":"9.不可变集合的创建","slug":"9.不可变集合的创建","date":"2019-09-22T07:08:00.000Z","updated":"2024-07-01T06:26:01.350Z","comments":true,"path":"2019/09/22/9.不可变集合的创建/","link":"","permalink":"https://protonlml.github.io/2019/09/22/9.%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"不可变集合的创建 注意： 不可变Map集合中的元素也是不可重复的 Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对 解决办法： 1.使用ofEntries方法（jdk10以下版本） 2.使用copOf()方法(可以存很多entry对象，jdk10及其以上)， © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"}],"author":"𝚲𝚳𝚲"},{"title":"6.switch-case的使用","slug":"6.switch-case的使用","date":"2019-09-22T07:01:00.000Z","updated":"2024-06-27T08:50:46.562Z","comments":true,"path":"2019/09/22/6.switch-case的使用/","link":"","permalink":"https://protonlml.github.io/2019/09/22/6.switch-case%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"switch-case的使用 一、有限选择情况下使用 默认格式 使用jdk12中 的 switch的写法进行匹配 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"}],"author":"𝚲𝚳𝚲"},{"title":"5.统计思想","slug":"5.统计思想","date":"2019-09-22T07:00:00.000Z","updated":"2024-06-27T08:38:02.969Z","comments":true,"path":"2019/09/22/5.统计思想/","link":"","permalink":"https://protonlml.github.io/2019/09/22/5.%E7%BB%9F%E8%AE%A1%E6%80%9D%E6%83%B3/","excerpt":"","text":"统计思想 一、计数器思想 1.定义一个变量充当计数器（比如求和sum） 有弊端：如果我们要统计的东西比较多，非常的不方便。要定义很多计数器 二、新的统计思想 利用Map集合进行统计 键：存放要统计的内容 值：表示统计的次数 原因是：Map集合中，可以使用put方法进行添加键值对Entry，还可以覆盖已经存在的key，值就可以更新。利用循环来不停的put 注意：如果题目中没有要求对结果进行排序，默认使用HashMap（效率快） 如果题目中要求对结果进行排序，请使用 TreeMap （TreeMap的遍历出来默认是从大到小排序的） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"}],"author":"𝚲𝚳𝚲"},{"title":"6.面向对象","slug":"6.面向对象","date":"2019-09-22T06:00:00.000Z","updated":"2024-06-16T02:44:42.211Z","comments":true,"path":"2019/09/22/6.面向对象/","link":"","permalink":"https://protonlml.github.io/2019/09/22/6.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象 一、 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"经验3","slug":"经验3","date":"2019-09-22T06:00:00.000Z","updated":"2024-06-15T06:14:53.348Z","comments":true,"path":"2019/09/22/经验3/","link":"","permalink":"https://protonlml.github.io/2019/09/22/%E7%BB%8F%E9%AA%8C3/","excerpt":"","text":"模板 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"}],"author":"𝚲𝚳𝚲"},{"title":"4.二维数组","slug":"4.二维数组","date":"2019-09-22T05:00:00.000Z","updated":"2024-06-16T02:56:51.375Z","comments":true,"path":"2019/09/22/4.二维数组/","link":"","permalink":"https://protonlml.github.io/2019/09/22/4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","excerpt":"","text":"二维数组 一、二维数组的静态初始化 二、获取二维数组中的某个值 三、二维数组遍历 四、二维数组动态初始化 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"5.方法与数据类型","slug":"5.方法","date":"2019-09-22T05:00:00.000Z","updated":"2024-06-16T02:44:04.540Z","comments":true,"path":"2019/09/22/5.方法/","link":"","permalink":"https://protonlml.github.io/2019/09/22/5.%E6%96%B9%E6%B3%95/","excerpt":"","text":"方法与数据类型 一、方法 二、数据类型1.基本数据类型（变量中存储的是真实的数据）在栈中 四类八种 整数数据类型 （bat , short , int , long ） 浮点数据类型(float , double) 布尔数据类型（char ） 字符数据类型( boolean) 2.引用数据类型（只要是new出来的都是引用数据类型）在堆中 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"3.数组","slug":"3.数组","date":"2019-09-22T04:00:00.000Z","updated":"2024-06-16T02:40:50.332Z","comments":true,"path":"2019/09/22/3.数组/","link":"","permalink":"https://protonlml.github.io/2019/09/22/3.%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组 一、什么是数组 二、数组的静态初始化 三、数组的动态初始化 数组默认初始化值的规律 整数类型:默认初始化值 0 小数类型:默认初始化值 0.0 字符类型:默认初始化值 ‘\\u0000’ 空格 布尔类型:默认初始化值 false 引用数据类型: 默认初始化值 null (引⽤数据类型包括：类、接⼝类型、数组类型、枚举类型、注解类型，字符串型) 四、数组的静态初始化和动态初始化的区别 五、索引 数组元素访问 数组元素访问的格式为：数组名[ 索引]； 索引：也叫做下标，角标； 索引特点：从0开始，逐个+1增长，连续不间断 （我们可以通过索引把数组中的元素拿出来用，也可以把元素添加到数组当中去） 六、数组角标越界异常 访问了数组不存在索引，就会引发数组角标越界异常 避免：知道索引的范围 七、数组常见操作 1.求最值 2.求和 3.交换数据 4.打乱数据 5.冒泡排序 6.数组拷贝 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"2.判断和循环","slug":"2.判断和循环","date":"2019-09-21T04:00:00.000Z","updated":"2024-06-16T02:37:32.559Z","comments":true,"path":"2019/09/21/2.判断和循环/","link":"","permalink":"https://protonlml.github.io/2019/09/21/2.%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"一、判断if语句 switch语句1234/** * 如果说，要对一个范围进行判断，则需要使用if * 如果对，有限个结果，一一列举出来，任选其一，则需要使用switch */ 注意 1.switch正常执行流程 执行流程 首先还是会拿着小括号中表达式的值跟下面每一个case进行匹配.如果匹配上了,就会执行对应的语句体,如果此时发现了break,那么结束整个switch语句:如果没有发现break,那么程序会继续执行下一个case的语句体,一直遇到break.或者右大括号为止.使用场景:如果多个case的语句体重复了,那么我们考虑利用case穿透去简化代码 2.switch新特性（JDK12） 3.case穿透 就是语句体中没有写break导致的: 应用场景 4. default的位置和省略 位置:default 不一定是写在最下面的 ,我们可以写在任意位置.只不过习惯会写在最下面 省略:default可以省略,语法不会有问题,但是不建议省略. 二、循环 在实际开发中，我们需要重复的执行某段代码，会选择循环来实现 1.for循环 2.while循环 3.for 和while的区别 4.无限循环 循环一直停不下来 注意事项 在无限循环的下面，不能再写其他代码了，因为循环永远停不下来，那么下面的代码永远执行不到 5.跳转控制语句 1.continue:跳过本次循环,继续执行下次循环. 2. break:结束整个循环. © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"1.运算符以及类型转换","slug":"1.运算符以及类型转换","date":"2019-09-21T03:00:00.000Z","updated":"2024-07-03T09:15:31.300Z","comments":true,"path":"2019/09/21/1.运算符以及类型转换/","link":"","permalink":"https://protonlml.github.io/2019/09/21/1.%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"计算机中 能够存的数据的最小单位是 “字节” 1个字节是8个bit位1024个字节是1kb1024kb是1M1024M是1G 一、算数运算符 二、类型转换1.隐式转换 隐式转换的两种提升规则 取值范围小的,和取值范围大的进行运算,小的会先提升为大的,再进行运算 byte short char三种类型的数据在运算的时候,都会直接先提升为int,然后再进行运算 2.隐式转换小结 取值范围 byte&gt;short&gt;int&gt;long&gt;float&gt;double 什么时候转换 数据类型不一样，不能进行计算，需要转换成一样的才可以计算 转换规则1： 取值范围小的，和取值范围大的进行运算，小的会先提升为大的在进行计算 转换规则2 byte short char 三种类型的数据在运算的时候，都会直接提升为int ，然后再进行运算 三、强制转换 如果把一个取值范围大的数值，赋值给取值范围小的变量。是不允许直接赋值的。如果一定要这么做就需要加入强制转换 格式：目标数据类型 变量名&#x3D;(目标数据类型)被强转的数据 四、+ 加号运算符 “字符+字符”当”+”操作中出现字符串时,这个”+”是字符串连接符,而不是算术运算符了.会将前后的数据进行拼接,并产生一个新的字符串. “字符+数字”时,会把字符通过ASC川码表查询到对应的数字再进行计算. 五、自增自减运算符 六、赋值运算符 七、关系运算符 八、逻辑运算符 九、短路逻辑运算符 十、三元运算符 条件（三元）运算符是 Java 唯一使用三个操作数的运算符：一个条件后跟一个问号（?），如果条件为[真值]，则执行冒号（:）前的表达式；若条件为[假值]，则执行最后的表达式。该运算符经常当作 [if...else]语句的简捷形式来使用。 十一、运算符的优先级 只用记住一点“小括号( )”优先于所有，想要先算谁，就用小括号将其括上 十二、原码，反码，补码 计算机中，最小的存储单元是“一个字节” 它占8个bit位。范围从1000 0000 ~ 0111 1111 （-128~127） &#x3D;&#x3D;计算机中，数字的存储，以及运算都是以补码的形式来操作的。&#x3D;&#x3D; 理解了原码，反码，补码，的基本概念，就可以深入了解以下的内容了。 1.理解同一个数字在不同数据类型下到底有什么区别呢？bit位 &#x3D;&#x3D;就是在前面的位置“补0”&#x3D;&#x3D; 2.理解隐式转换 3.理解强制转换 4.理解数字之间使用“运算符” © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"运算符","slug":"运算符","permalink":"https://protonlml.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客（六）本地hexo博客恢复","slug":"搭建个人博客（六）本地hexo博客恢复","date":"2019-09-19T07:00:00.000Z","updated":"2024-06-16T01:38:22.286Z","comments":true,"path":"2019/09/19/搭建个人博客（六）本地hexo博客恢复/","link":"","permalink":"https://protonlml.github.io/2019/09/19/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%85%AD%EF%BC%89%E6%9C%AC%E5%9C%B0hexo%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/","excerpt":"","text":"搭建个人博客（六）本地hexo博客恢复一、使用SourceTree软件，拉取远程仓库中的博客blog 删除这个文件夹 在本地blog文件夹中,使用Git Bath 运行1234npm install hexonpm installhexo ghexo s 继续编写博客，进行hexo d 上传上传失败执行12npm install hexo-deployer-git --save 之后再上传hexo d 上传 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客(五)：编写博客文章以及上传和备份","slug":"搭建个人博客(五)：编写博客以及上传和备份","date":"2019-09-19T03:00:00.000Z","updated":"2024-06-16T01:41:08.271Z","comments":true,"path":"2019/09/19/搭建个人博客(五)：编写博客以及上传和备份/","link":"","permalink":"https://protonlml.github.io/2019/09/19/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E4%BA%94)%EF%BC%9A%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8A%E4%B8%8A%E4%BC%A0%E5%92%8C%E5%A4%87%E4%BB%BD/","excerpt":"","text":"搭建个人博客(五)：Typora编写博客以及上传和备份一、编写博客 1.在\\blog\\source\\ _posts目录中创建md文件 2.添加博文分类和博文标签的相关配置123456# 通过如下字段,Hexo会自动添加博文分类和博文标签的相关配置---title: title # 添加博文标题categories: categories # 添加博文分类tags: tags # 添加博文标签--- 3.博客标题，以及md文档名要一致 二、本地查看效果123hexo cleanhexo ghexo s 三、上传 按Ctrl+C暂停，随后使用命令 hexo d 推送到远程仓库的 hexo默认分支 上去了。 四、备份 通过Sourcetree备份master分支 这样做的目的是，当我们在本地blog的源文件被误删除了，我们还可以直接拉取仓库中master分支到本地，继续使用。 在Sourcetree上，只用检出master分支就行了 （我们一直都在master分支上操作） 五、每次推送后，都要对Gitee Pages 点击更新 每次推送后，都要对Gitee Pages 点击更新，然后清空浏览器缓存，访问才生效。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床","slug":"Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床","date":"2019-09-18T10:00:00.000Z","updated":"2024-06-16T14:55:42.643Z","comments":true,"path":"2019/09/18/Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床/","link":"","permalink":"https://protonlml.github.io/2019/09/18/Docker-Alist%E5%AE%B9%E5%99%A8+PicGoApp+%E5%A4%B8%E5%85%8B%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床 前言：在搭建自己的博客时，我们会把博文的图片上传到如：七牛云，阿里云oss，腾讯云等。这些第三方云图床上面，优点方便快捷安全。其次是使用“Typora+PicGoApp+gitee”实现远程仓库管理图片。但是作为图片的仓库是公开的，没法实现图片私密。再者就是现在自己搭建图床。 Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床，这里服务端我使用的是自己电脑中的虚拟机，当然自己搭建服务器，或者搭建Nas以及购买第三方服务器都行。 一、准备工作 1.本地安装PicGOApp并且关联了Typora 具体可查看文章搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床 2.PicGo下载alist插件 3.远程服务器上面安装Alist Alist所有操作参照 AList文档 (nn.ci) 这里使用本地虚拟机Docker安装Alist，使用VSCode连接远程服务器，在bash终端使用docker命令下载镜像 1docker run -d --restart=unless-stopped -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=&quot;alist&quot; xhofe/alist:latest Alist容器运行起来，同时也下载了。使用命令查看 1docker ps 生成登陆密码，并且修改登陆密码 1234# 先随机生成一个密码docker exec -it alist ./alist admin random# 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码docker exec -it alist ./alist admin set NEW_PASSWORD 4.浏览器中访问Alist客户端 端口是5244 192.168.56.30:5244 这里我是本地服务器地址 二、挂载网盘 1.登陆Alist添加存储（将夸克网盘挂载到Alist上） 2.添加一个新的驱动，驱动选择“夸克”。挂载路径和序号根据自己需求填写，缓存过期时间填0。Webdav策略选择“本地代理”。 我们需要获取Cookie 打开电脑浏览器（使用Chrome浏览器）并登录夸克网盘账号(用网页版登录)，然后按键盘上的F12，进入开发者模式。点击上方的Network(网络)选项卡，在左侧的Name(名称)中找到“sort?pr&#x3D;u”开头的条目并选中(如果该条目没刷新出来，需要稍等几秒钟)，然后在右侧的Request Headers中，找到Cookie值并复制： 将复制的Cookie值填入alist设置页面，其他选项全部保持默认，然后点击添加即可。 3.Alist两个设置 关闭签名所有 复制令牌 7.夸克网盘挂载成功。 三、PicGo关联alist 设置配置 四、在Typora中复制一张图片测试上传 注意要将 alist设置为 默认图床 参考链接 Typora+PicGo+Alist 私人图床教程_alist 图床-CSDN博客 轻松打造智能家庭数据中心——袋鼠叔叔带你玩转绿联DX4600 (篇3—Docker中搭建Alist本地挂载阿里&#x2F;百度&#x2F;夸克网盘小白保姆教程) (zhihu.com) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"搭建图床","slug":"搭建图床","permalink":"https://protonlml.github.io/categories/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://protonlml.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Picgo","slug":"Picgo","permalink":"https://protonlml.github.io/tags/Picgo/"},{"name":"Alist","slug":"Alist","permalink":"https://protonlml.github.io/tags/Alist/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床","slug":"搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床","date":"2019-09-18T07:00:00.000Z","updated":"2024-06-16T01:40:31.188Z","comments":true,"path":"2019/09/18/搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床/","link":"","permalink":"https://protonlml.github.io/2019/09/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89Typora+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%BA%91%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"搭建个人博客（四）Typora+Picgo+Gitee搭建云图床实现图床的方式有很多种 例如： 使用Typora+PicGo+阿里云 搭建图床 - 知乎 (zhihu.com) 这里提供一种 在编写博文的时候，需要进行插入图片，但是此时的图片是在本地的，我们要使用Typora+Picgo+Gitee实现云图床将图片放在gitee仓库中，在线访问就可以查看到。 一、创建一个仓库 初始化同时创建imgs文件夹 二、生成私人令牌 生成仓库后，点击右上角的头像-&gt;设置-&gt;私人令牌-&gt;生成私人令牌-&gt;复制-&gt;确认，保存好 三、安装PicGo软件1https://picgo.github.io/PicGo-Doc/zh/ 安装PicGo软件后，插件设置中搜索gitee-uploader安装插件 设置PicGo-Server确定一下 设置时间戳重命名，保证文件名中没有中文避免线上不显示 设置图床gitee为默认图床 设置gitee图床连接 至此PicGo设置完毕 四、关联Typora和PicGo软件 打开Typora，偏好设置-图像，关联PicGo 使用Typora编写博客的时候，复制了图片到当前文章当中，直接点击上传 在仓库文件夹中就能看到了 五、说明1.为什么不使用PicGo-Core(command line) gitee上传设置命令的的上传方式，配置了配置文件，有时候也会上传不成功出现错误。如果你已经下载了PicGo-Core(command line)插件，然后又下载了PicGoApp上传，也有可能会出现错误。解决办法：将Typora软件卸载重新安装重新配置。 Typora软件需要激活，这里提供Typora旧版本免激活使用 2.下拉框“复制图片到.&#x2F;${filename}.assests文件夹”选项说明： 复制图片到.&#x2F;${filename}.assests文件夹：以后在C:\\working\\blog\\source\\ _posts 中创建博客文章，先创建md文件，然后写博文在每次往md插入图片时，都会自动在同级目录生成assests文件夹将插入的图片拷贝一份在里面存放，这样以后拷贝文件将assests和md文件一起拷贝，就一直有效了。 上传图片：每次往md插入图片时，都会将图片上传到gitee仓库，图片名自动改为gitee仓库图片地址 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"搭建图床","slug":"搭建图床","permalink":"https://protonlml.github.io/categories/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://protonlml.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Picgo","slug":"Picgo","permalink":"https://protonlml.github.io/tags/Picgo/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客(三)：主题pure使用指南","slug":"搭建个人博客(三)：主题pure使用指南","date":"2019-09-17T05:00:00.000Z","updated":"2024-06-16T14:58:18.471Z","comments":true,"path":"2019/09/17/搭建个人博客(三)：主题pure使用指南/","link":"","permalink":"https://protonlml.github.io/2019/09/17/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E4%B8%89)%EF%BC%9A%E4%B8%BB%E9%A2%98pure%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"搭建个人博客(三)：主题pure使用指南Hexo-theme-pures是一个Hexo的主题框架 一、安装pure主题1. 在hexo根目录中的themes文件夹下克隆pure主题 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 下载完毕，删除文件夹中所有.git相关的文件 2.修改配置文件 在 Hexo 中主要有两份配置文件，其名称都是 _config.yml。 一份位于博客根目录下，主要包含 Hexo 本身的配置；另一份位于主题根目录下，主要用于配置主题相关的选项。 （1.）打开博客根目录配置文件_config.yml，做如下修改: 12language: zh-CN //设置主题为中文版，若使用英文版则不修改theme: pure //修改hexo主题 （2）在博客文件夹下打开git bash命令行窗口依次使用如下指令: 12hexo cleanhexo s 启动服务后：进入本地浏览器输入:http://localhost:4000/，如下图 3.安装pure插件在博客文件夹下打开git bash命令行窗口依次使用如下指令： 123456npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-deployer-git --save 二、配置pure主题1. 复制_source文件夹中的内容将主题目录中 &#x2F;theme&#x2F;_source&#x2F; 下的所有东西复制进博客根目录的source文件夹中 2. pure配置文件的修改： 打开主题根目录下的_config.yml配置文件： （1）配置站点左边的主目录: 1234567891011# menumenu: Home: . Archives: archives # 归档 # categories指代博客根目录的source下的categories文件夹,可进行相关配置,下同 Categories: categories # 分类 Tags: tags # 标签 Repository: repository # github repositories #Books: books # 豆瓣书单 Links: links # 友链 About: about # 关于 单个目录界面的相关配置可在博客根目录的source下的同名文件夹中进行配置 （2）配置站点标题: 1234567891011# Sitesite: logo: enabled: true width: 40 height: 40 url: ../images/logo.png title: 𝚲𝚳𝚲的博客 # 页面title favicon: ../favicon.ico board: &lt;p&gt;欢迎交流与分享经验!&lt;/p&gt; # 站点公告 copyright: true # 底部版权信息 （3）配置主题颜色: 1234567891011# configconfig: skin: theme-black # 主题颜色 theme-black theme-blue theme-green theme-purple layout: main-center # 布局方式 main-left main-center main-right toc: true # 是否开启文章章节目录导航 menu_highlight: false # 是否开启当前菜单高亮显示 thumbnail: false # 缩略图 ，enable posts thumbnail, options: true, false excerpt_link: Read More #New isNewTabLinks: false #是否链接打开新标签页 autoUnfold: true # 默认展开文章目录 （4）配置页码信息: 123456789# Paginationpagination: number: true prev: alwayShow: true next: alwayShow: true midSize: 2 # 当前页码左右到省略号显示的页码数，默认2，表现为 1 ... 4 5 6 7 8 ... 10 showContent: true # 页面文章小于2篇时显示文章内容 （5）配置页面右侧栏目 123456789# Sidebar 页面右侧栏目设置sidebar: rightwidgets: - board - category - tag # - tagcloud #隐藏“标签云” - archive - recent_posts （6）配置打赏信息 1234567891011# Donatedonate: enable: true # 微信打赏 wechatpay: qrcode: images/donate/wechatpayimg.png # 在主题目录的source文件夹中进行图片的设定 title: 微信支付 # 支付宝打赏 alipay: qrcode: images/donate/alipayimg.png # 在主题目录的source文件夹中进行图片的设定 title: 支付宝 （7）配置是否启用分享功能 123456# Share# weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedinshare: enable: false # true是否启用分享 sites: weibo,qq,wechat,facebook,twitter # PC端显示的分享图标 mobile_sites: weibo,qq,qzone # 移动端显示的分享图标 （7）开启搜索功能 1234# Searchsearch: insight: true # 内置搜索功能, baidu: false # 百度搜索功能,不可以同时使用 **（8）配置“项目”导航栏 ** 12345# Repository Info (This will override &#x27;github&#x27; option)# 项目仓库信息（将会覆盖 github 项）repository: platform: gitee # 托管平台（github | gitee） username: lmlpla # 用户名 （9）关闭评论功能 Valine一个无后端的评论框工具，其依赖于 Leancloud 开发，所以使用前需要先注册 Leancloud 账号Valine配置 12345678910111213141516comment: # type: valine # 启用哪种评论系统 valine: # Valine官方地址: https://valine.js.org appid: # 你的 leancloud 应用 appid appkey: # 你的 leancloud 应用 appkey notify: true # 是否开始评论邮件提醒, 教程: https://github.com/xCss/Valine/wiki verify: false # 是否开始验证码功能, 开始邮件提醒会自动开启验证码功能 placeholder: 说点什么... # 输入框默认内容 avatar: mm # 头像展示方式, 具体设置项教程: https://valine.js.org/configuration.html#avatar meta: nick,mail,link # 自定义评论信息 pageSize: 10 # 评论列表分页 lang: zh-cn, # 多语言支持 zh-cn | en visitor: true # 文章阅读量统计: https://valine.js.org/visitor.html highlight: true # 代码高亮 recordIP: true # 记录评论者的IP (10) 开启文章字数统计以及阅读时长预计 12345# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 （11）文章下面的个人信息修改 1234567891011# profileprofile: enabled: true # Whether to show profile bar articleSelfBlock: false # 关闭文章下方的自我介绍 avatar: images/avatar.jpg gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: 𝚲𝚳𝚲 #𝓵𝓶𝓵 author_title: ◙ author_description: 业精于勤，荒于嬉；行成于思，毁于随！ location: Shenzhen, China follow: （12）左下角链接设置 123456789101112# Social Links 左下角链接 social: links: gitee: https://gitee.com/lmlpla #github: https://github.com/cofess #weibo: http://weibo.com/cofess #twitter: https://twitter.com/iwebued # facebook: / # dribbble: / #behance: https://www.behance.net/cofess rss: atom.xml link_tooltip: true # enable the social link tooltip, options: true, false （13）“关于”导航页面的右侧栏目设置 12345678910# My Skills 技能 skills: Git: ★★☆☆☆ Java: ★★★☆☆ Javascript: ★☆☆☆☆ Vue: ★★☆☆☆ #HTML+CSS: ★★★☆☆ #Bootstrap: ★★★☆☆ #ThinkPHP: ★★★☆☆ #平面设计: ★★★☆☆ （14）“关于”导航页面的右侧栏目设置 1234567# My Personal Links 联系我链接 links: Gitee: https://gitee.com/lmlpla Blog: https://lmlpla.gitee.io/blog/ #微博: http://weibo.com/cofess #花瓣: http://huaban.com/cofess #Behance: https://www.behance.net/cofess （15）“关于”导航页面的右侧栏目设置 1234567# My Personal Labels 打标签 labels: - 音乐街舞 - 摄影生活 - - - （16）关闭不需要的设置 123456789# My Personal Works #works: # name: # link: http://www.example.com # date: 2016 # My Personal Projects #projects: # cofess/gulp-startpro: https://github.com/cofess/gulp-startpro #cofess/hexo-theme-pure: https://github.com/cofess/hexo-theme-pure （17）添加背景动画背景动画基于canvas，在themes&#x2F;pure&#x2F;layout&#x2F;layout.ejs的中面添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; （18）修改左下角的站点创建时间（直接用VS Code打开，在主题目录中搜索 publishby） （19）友情链接的配置: 选择博客根目录下 &#x2F;source&#x2F;_data&#x2F; 中的links.yml配置文件，可仿照其中样例进行配置 1234gentryhuang: link: https://gentryhuang.com/ avatar: ../images/gentryhuang-logo.png desc: 脚踏实地,步步为营 (20) 修改关于页面 找到\\blog\\source\\about\\index.md文件，添加样式 1234567891011121314151617181920212223242526272829---title: 关于我description: 集齐龙珠，召唤神兽！layout: aboutcomments: falsesidebar: custom---​```txt/**** * ┏┓ ┏┓ * ┃ ┃ + +* ┃ ━ ┃ ++ + + +* ████━████┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问我的博客* ┃ ┃ + * ┃ ┻ ┃ + + * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽护体，永无bug * ┃ ┃ +* ┃ ┗━━━┓+* ┃ ┣┓ 📬 联系我：lmle_mail@163.com* ┃ ┏┛ + + * ┗┓┓┏━┳┓┏┛ +* ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */​``` 三、更新站点，查看效果 在博客文件夹下打开git bash命令行窗口依次使用如下指令： 123hexo cleanhexo ghexo s 启动服务后：进入本地浏览器输入:http://localhost:4000/ 进行查看 四、效果𝚲𝚳𝚲的博客 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客（二）：Hexo部署到 Gitee","slug":"搭建个人博客（二）：Hexo部署到 Gitee","date":"2019-09-17T04:00:00.000Z","updated":"2024-06-16T01:37:21.407Z","comments":true,"path":"2019/09/17/搭建个人博客（二）：Hexo部署到 Gitee/","link":"","permalink":"https://protonlml.github.io/2019/09/17/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AHexo%E9%83%A8%E7%BD%B2%E5%88%B0%20Gitee/","excerpt":"","text":"搭建个人博客（二）：Hexo部署到 Gitee一、新建 Gitee 仓库 新建的仓库，先不要初始化，同时仓库名要和本地博客所在文件夹名称相同。 没有初始化的仓库有命令提示 二、本地博客文件夹中使用git命令，将本地文件推送到远程仓库 1. 本地文件夹内删除已有的 .gite文件 使用Gitbash窗口 运行 如下命令，将本地文件夹绑定到远程仓库上去 12345git init git add .git commit -m &quot;first commit&quot;git remote add origin https://gitee.com/lmlpla/xxxx.git # xxxx指远程仓库名字git push -u origin &quot;master&quot; 刷新远程仓库，就可以看见本地博客文件被推送到仓库中去了 2.远程仓库创建新的分支hexo 3.设置hexo分支为默认分支 （目的是为了保存hexo博客的源文件，迁移主机，随时拉取就可以使用，再master分支上进行hexo d 命令推送编译后的文件会默认到hexo分支上） 4.使用Sourcetree管理本地博客 三、在 Gitee 中添加 SSH 公钥 使用SSH公钥可以让你在你的电脑和 Gitee 通讯的时候使用安全连接（Git的Remote要使用SSH地址） &#x3D;&#x3D;如果之前gitee上面已经添加过，就跳过第三步&#x3D;&#x3D; 检查本地电脑上是否已有 SSH，在本地打开 git bash 命令行窗口，输入以下命令1cd ~/.ssh 如果没有，显示1bash: cd: /c/Users/Administrator/.ssh: No such file or directory 如果有的话，标识本地已经有创建过的 SSH key 了 1.如果本地没有就创建 SSH key 运行如下命令 最后一个参数替换为自己的 注册Gitee时使用的邮箱，然后直接回车两次1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 2.找到生成的.ssh文件，打开将内部的公钥复制下来 3.测试 SSH 连接 输入命令 1ssh -T git@gitee.com 会得到如下输出，询问是否确认连接，输入yes回车确认 123The authenticity of host &#x27;gitee.com (180.97.125.228)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc.Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 最后连接成功会看到如下输出 12Warning: Permanently added &#x27;gitee.com,180.97.125.228&#x27; (ECDSA) to the list of known hosts.Hi dulily! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access. 在 Gitee 中添加 SSH 公钥 先在 C 盘指定目录中找到 id_rsa_pub 文件，复制内容然后打开 gitee 个人设置里面的 安全设置 - SSH公钥，标题可以随便取，把粘贴的内容复制到公钥里面，点击确定就可以 四、本地修改 _config.yml 修改hexo博客根目录中的配置文件_config.yml 安装 hexo-deployer-git（master分支操作）1npm install hexo-deployer-git --save 推送博客目录到远程 Gitee（master分支操作）12hexo g hexo d 这时候，远程仓库的 blog 目录下的文件(并且在hexo分支上会被更新一遍) 五、开启 Gitee Pages 服务 后期，如果更新了文章，使用 hexo g -d 命令就可以直接推送到远程hexo分支了，然后再更新一下就可以访问到新的博客文章 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客(一)：Hexo本地的使用和配置","slug":"搭建个人博客(一)：Hexo本地的使用和配置","date":"2019-09-17T03:00:00.000Z","updated":"2024-06-15T06:14:53.274Z","comments":true,"path":"2019/09/17/搭建个人博客(一)：Hexo本地的使用和配置/","link":"","permalink":"https://protonlml.github.io/2019/09/17/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E4%B8%80)%EF%BC%9AHexo%E6%9C%AC%E5%9C%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"搭建个人博客(一)：Hexo本地的使用和配置一，准备工作1.了解hexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2. 搭建博客之前,需要安装几个工具 2.1 git版本控制工具 Git是一个免费的、开源的版本控制软件。在Windows上安装git，一般为msysgit，官方下载地址 :http://code.google.com/p/msysgit/downloads/list安装步骤下一步即可…最后在-shell窗口中输入命令 git --version 检查安装是否成功 2.2 Node.js环境 安装nodejs在官网上面，下载绿色的zip包 最好安装node-v18.16.1-win-x64.7z 详情请看本站文章“nodejs安装教程” 𝚲𝚳𝚲的博客 (gitee.io) 3.安装hexo,下载hexo 搭建博客 创建一个 Blog文件夹，在这个文件夹中,使用Git窗口,依次执行下面的命令 12345npm install -g hexo-cli # 安装hexo客户端hexo init #初始化hexonpm i #安装npm工具 hexo g # 生成hexo s # 启动服务 &#x3D;&#x3D;（注意：下载后文件夹中有.git文件夹，给删除掉，后面要上传到自己的远程仓库，进行版本控制。）&#x3D;&#x3D; 二、启动后存在的问题 1.启动hexo 创建成功后 ，浏览器 “localhost 已拒绝连接。” 不是端口问题，4000端口打不开,是因为你是从git窗口里复制的,或者直接点击的。 在url地址栏里面重新敲 localhost:4000 就行了，或者 127.0.0.1:4000 2.启动后能正常访问，访问发现白屏了，什么也没有 主要原因是 nodejs版本不兼容 导致在public文件夹下index.html文件是空白的。 重新安装nodejs 推荐node-v16.19.1-win-x64-&gt;nodejs安装教程：𝚲𝚳𝚲的博客 (gitee.io) 然后在本地启动查看结果。localhost:4000查看能不能访问, Ctrl+C 停止本地服务 重启本地服务,要先 hexo clean 清理缓存 hexo g 生成 hexo s 启动本地服务查看本地,能不能将这个项目跑起来 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"UML类图","slug":"UML类图","date":"2019-09-10T03:00:00.000Z","updated":"2024-06-16T02:17:59.887Z","comments":true,"path":"2019/09/10/UML类图/","link":"","permalink":"https://protonlml.github.io/2019/09/10/UML%E7%B1%BB%E5%9B%BE/","excerpt":"","text":"UML类图用于表示类、接口、实例等之间相互的静态关系。虽然名字叫类图，但类图中并不只有类，还可能包括权限、属性、方法等 2.1 类图关系 设计模式中的对象关系: 依赖关系 虚线箭头，箭头方向指向被依赖的部分 组合关系 实心菱形 聚合关系 空心菱形（想象成盘子，盛东西，盘子的多，另一方少） 关联关系 实线箭头，箭头指向被关联的部分 类与类的连接，（它使一个类知道另一个类的属性和方法，关联关 系一般用成员变量实现） 继承 空心三角形实线 实现 空心三角形虚线 注意： 实现接口有两种方式，一种是棒棒糖的形式，另一种是虚线空心三角形的方式 &#x3D;&#x3D; UML记忆&#x3D;&#x3D; 1. uml箭头：从子类指向父类，只有知道对方信息时才能指向对方方向2. 空心三角箭头：继承或实现，实线-继承：积极的，强关联，关联，通常一个类中有一个类的对象做属性；虚线-实现：消极的，弱关联，依赖3. 空心菱形：聚合，（注：可以看作一个盘子，可以放很多相同的东西（箭头方向所指的类），聚在一起。是has a的关系）弱关联4. 实心菱形：组合，（注：代表器皿里有实体结构存在，组合起来成为一个。是contains-a的关系）强关联 1.uml箭头：从子类指向父类，定义子类时需要通过extends关键字指定父类，只有知道对方信息时才能指向对方方向实线-继承虚线-实现 2.空心菱形-聚合(可以看作一个盘子，可以放很多相同的东西（箭头方向所指的类），聚在一起。是has a的关系）弱关联) 3.实心菱形-组合 4.组合关系中常见的数字表达 ◆常见数字表达及含义，假设有A类和B类，数字标记在A类侧◆0..1：0或1个实例 在系统某一时刻，b的实例可以与0个或1个A实例相关◆0..*：0或多个实例 在系统某一时刻，b的实例可以与0个或多个A实例相关◆1..1：1个实例. b的实例可以和1个A实例相关◆1只能有一个实例. b的实例可以和1个A实例相关◆1..*：至少有一个实例. b实例可以与一个或多个A实例相关 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"UML类图","slug":"UML类图","permalink":"https://protonlml.github.io/tags/UML%E7%B1%BB%E5%9B%BE/"}],"author":"𝚲𝚳𝚲"},{"title":"nodejs安装教程","slug":"nodejs安装教程","date":"2019-09-07T01:00:00.000Z","updated":"2024-06-16T14:59:49.365Z","comments":true,"path":"2019/09/07/nodejs安装教程/","link":"","permalink":"https://protonlml.github.io/2019/09/07/nodejs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"一、下载nodejs Node.js 中文网 (nodejs.com.cn) 下载zip包，直接解压无须安装，node-v18.16.1-win-x64.7z 解压到C:\\Program Files\\nodejs 目录下 同时创建node_global和node_cach两个文件夹。 二、配置环境变量 1.系统变量下新建NODE_PATH 1C:\\Program Files\\nodejs\\node_global\\node_modules 2.系统变量path中添加如下 123%NODE_PATH%C:\\Program Files\\nodejsC:\\Program Files\\nodejs\\node_global 3.更改用户path变量 这里我们需要将其中默认的C:\\Users\\用户名\\AppData\\Roaming\\npm更改为： 1C:\\Program Files\\nodejs\\node_global 三、修改配置在nodejs文件夹下使用GitBash进行命令配置 1.关闭代理以及配置淘宝镜像123npm config set proxy nullnpm config set https-proxy nullnpm config set registry https://registry.npmmirror.com 查看是否修改成功 1npm config get registry 2.配置默认目录12npm config set prefix &quot;C:\\Program Files\\nodejs\\node_global&quot;npm config set cache &quot;C:\\Program Files\\nodejs\\node_cache&quot; 3.设置权限1npm config set strict-ssl false 4.查看所有设置1npm config ls 四、查看安装版本12node -v npm -v 五、测试是否配置成功 安装vue插件 1npm install -g vue 六、npm install安装失败常见问题的解决办法小结 有时候前端安装npm install 安装包总是安装不上,下面这篇文章主要给大家介绍了关于npm install安装失败常见问题的解决办法,文中通过实例代码介绍的非常详细,需要的朋友可以参考下 显示当前的镜像地址1npm get registry 1. 安装cnpm 1npm install -g cnpm --registry=http://registry.npmmirror.com 安装完之后可以通过cnpm -v 检验是否安装成功。 2.cnpm install安装依赖1cnpm install 在运行cnpm install中,你可以会遇到cnpm:无法加载文件C:Users\\57883 AppData\\Roaming\\npm\\cnpm.ps:因为在此系统上禁止运行脚本的错误.解决方法: 在系统中搜索框输入Windos PowerShell 点击”管理员身份运行” ·输入”set-ExecutionPolicy RemoteSigned’”▣车 ·根据提示,输入A,回车 ·再次回到cnpm-v执行成功. ps:不只是cnpm命令,包括pnpm、yarn等这些命令,如果执行时,报这样的错误,都可以通过此方法解决.前提是,如果是用npm命令来安装这些CLI命令工具,必须安装到全局环境中,才能生效. npm install node-sass 报错如何解决呢? node 与node-sass版本不兼容导致安装依赖失败 解决办法： &#x2F;&#x2F;查看node版本 node-v &#x2F;&#x2F; –save-dev自动将node-sass加入到项目文件夹下的package.json中。 cnpm install –save-dev node-sass 附：npm install命令一直失败的坑执行npm install命令一直失败，报错主要原因如下：reason: getaddrinfo EAI_AGAIN registry.npmjs.org 异常分析 1.解决代理问题123npm config set proxy nullnpm config set https-proxy nullnpm config set registry https://registry.npmmirror.com 2.所以大家可以把上面语句执行一遍试一下，还有要把权限执行下面语句1npm config set strict-ssl false 3.如果还不行，建议大家更换vscode，node版本，我使用的是：12node-v10.12.0-x64VSCodeUserSetup-x64-1.54.3 换网络改为移动网络试试 参考：npm install安装失败常见问题的解决办法小结_node.js_脚本之家 (jb51.net) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://protonlml.github.io/categories/nodejs/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"npm","slug":"npm","permalink":"https://protonlml.github.io/tags/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"https://protonlml.github.io/tags/nodejs/"}],"author":"𝚲𝚳𝚲"}],"categories":[{"name":"新年快乐","slug":"新年快乐","permalink":"https://protonlml.github.io/categories/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"},{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"},{"name":"maven","slug":"java/maven","permalink":"https://protonlml.github.io/categories/java/maven/"},{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"},{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"},{"name":"搭建图床","slug":"搭建图床","permalink":"https://protonlml.github.io/categories/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"},{"name":"nodejs","slug":"nodejs","permalink":"https://protonlml.github.io/categories/nodejs/"}],"tags":[{"name":"春节挂件","slug":"春节挂件","permalink":"https://protonlml.github.io/tags/%E6%98%A5%E8%8A%82%E6%8C%82%E4%BB%B6/"},{"name":"技巧优化","slug":"技巧优化","permalink":"https://protonlml.github.io/tags/%E6%8A%80%E5%B7%A7%E4%BC%98%E5%8C%96/"},{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"matery主题","slug":"matery主题","permalink":"https://protonlml.github.io/tags/matery%E4%B8%BB%E9%A2%98/"},{"name":"maven","slug":"maven","permalink":"https://protonlml.github.io/tags/maven/"},{"name":"项目自动化构建工具","slug":"项目自动化构建工具","permalink":"https://protonlml.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"},{"name":"javaScript","slug":"javaScript","permalink":"https://protonlml.github.io/tags/javaScript/"},{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"},{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"运算符","slug":"运算符","permalink":"https://protonlml.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"},{"name":"图床","slug":"图床","permalink":"https://protonlml.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Picgo","slug":"Picgo","permalink":"https://protonlml.github.io/tags/Picgo/"},{"name":"Alist","slug":"Alist","permalink":"https://protonlml.github.io/tags/Alist/"},{"name":"UML类图","slug":"UML类图","permalink":"https://protonlml.github.io/tags/UML%E7%B1%BB%E5%9B%BE/"},{"name":"npm","slug":"npm","permalink":"https://protonlml.github.io/tags/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"https://protonlml.github.io/tags/nodejs/"}]}