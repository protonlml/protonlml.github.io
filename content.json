{"meta":{"title":"Hexo","subtitle":"","description":"","author":"𝚲𝚳𝚲","url":"https://protonlml.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-06-15T06:14:52.776Z","updated":"2024-06-15T06:14:52.776Z","comments":false,"path":"/404.html","permalink":"https://protonlml.github.io/404.html","excerpt":"","text":""},{"title":"关于我","date":"2024-06-15T06:14:53.350Z","updated":"2024-06-15T06:14:53.350Z","comments":false,"path":"about/index.html","permalink":"https://protonlml.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718/** ┏┓ ┏┓ * ┃ ┃ + +* ┃ ━ ┃ ++ + + +* ████━████┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问我的博客* ┃ ┃ + * ┃ ┻ ┃ + + * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽护体，永无bug * ┃ ┃ +* ┃ ┗━━━┓+* ┃ ┣┓ 📬 联系我：lmle_mail@163.com* ┃ ┏┛ + + * ┗┓┓┏━┳┓┏┛ +* ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */"},{"title":"书单","date":"2024-06-15T06:14:53.352Z","updated":"2024-06-15T06:14:53.352Z","comments":false,"path":"books/index.html","permalink":"https://protonlml.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-06-15T06:14:53.353Z","updated":"2024-06-15T06:14:53.353Z","comments":false,"path":"categories/index.html","permalink":"https://protonlml.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-06-15T06:14:53.360Z","updated":"2024-06-15T06:14:53.360Z","comments":false,"path":"repository/index.html","permalink":"https://protonlml.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-06-15T06:14:53.358Z","updated":"2024-06-15T06:14:53.358Z","comments":true,"path":"links/index.html","permalink":"https://protonlml.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-06-15T06:14:53.362Z","updated":"2024-06-15T06:14:53.362Z","comments":false,"path":"tags/index.html","permalink":"https://protonlml.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码","slug":"挂年兽","date":"2024-01-01T03:00:00.000Z","updated":"2024-06-16T01:41:24.580Z","comments":true,"path":"2024/01/01/挂年兽/","link":"","permalink":"https://protonlml.github.io/2024/01/01/%E6%8C%82%E5%B9%B4%E5%85%BD/","excerpt":"","text":"换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码 摘要 这篇文章介绍了一个在博客网站右上角添加悬挂年兽的方法。通过在CSS代码中插入相应的素材链接，可以实现在网站右上角挂上一个龙的效果。对于自定义主题的网站，可以将相关的CSS和HTML代码添加到自定义头部中。对于全屏网站，建议在CSS代码的16行左右插入一行代码以实现相应效果。 一、简介-教程 换新颜新气象，给网站右上角挂一个龙，吸吸龙气 css第6行放入下面素材链接（本站开了防盗所以给你也无用就放下面了） 如果你的主题是自定义，那就是主题设置自定义里面 自定义css 1234567891011121314151617181920212223242526@media screen and (min-width: 850px)&#123; .NewYear &#123; width: 260px; height: 300px; display: inline-block; background: url(https://img.ly522.com/LY/uploads/2023/12/longgyaj.gif) no-repeat 50%/100%; vertical-align: middle; position: fixed; left: 85.8%; top: 55px; z-index: 50; cursor: pointer; animation: new-year 1.2s ease-in-out 0s infinite alternate; margin-left: -1px; transform-origin: 50% 0; pointer-events: none; &#125; &#125; @keyframes new-year&#123; 0% &#123; transform: rotate(10deg); &#125; 100%&#123; transform: rotate(-10deg); &#125; &#125; html放到你的自定义头部html即可！！ 1&lt;div class=&quot;NewYear&quot;&gt;&lt;/div&gt; 注意：如果你的是全屏网站建议在pointer-events: none;下面加一行。即css代码16行左右哪里加 1z-index: 999; 演示图 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！ ​","categories":[{"name":"新年快乐","slug":"新年快乐","permalink":"https://protonlml.github.io/categories/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"}],"tags":[{"name":"春节挂件","slug":"春节挂件","permalink":"https://protonlml.github.io/tags/%E6%98%A5%E8%8A%82%E6%8C%82%E4%BB%B6/"},{"name":"技巧优化","slug":"技巧优化","permalink":"https://protonlml.github.io/tags/%E6%8A%80%E5%B7%A7%E4%BC%98%E5%8C%96/"}],"author":"𝚲𝚳𝚲"},{"title":"matery主题的使用","slug":"matery主题的使用","date":"2020-03-17T03:00:00.000Z","updated":"2024-06-16T02:11:38.377Z","comments":true,"path":"2020/03/17/matery主题的使用/","link":"","permalink":"https://protonlml.github.io/2020/03/17/matery%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"matery主题的使用一、下载matery主题 1.GitHub源项目 GitHub - blinkfox&#x2F;hexo-theme-matery: 一个基于材料设计和响应式设计而成的全面、美观的Hexo主题。 2.在本地clone下来 1git clone https://github.com/blinkfox/hexo-theme-matery.git 二、配置hexo根yml文件 三、自定义主题 1.修改导航名称和路径图标 添加导航二级菜单的写法（如下是“关于”一级菜单修改） 注意：1.菜单导航名称可以是中文也可以是英文(如：Index或主页) ​ 2.图标icon 可以在Font Awesome 中查找 ,线上的 1234567891011About: url: /about # icon: fas fa-user-circle 注释掉原来的，加上下面这一段 icon: fas fa-list children: - name: 爱的颜色 url: /love icon: fas fa-heart - name: 生日快乐 url: /birthday icon: fas fa-cake 2.手机二级菜单配置123navMenu: mleft: true # 二级侧栏子菜单是否对齐左边 bgColor: &quot; &quot; # 二级侧栏子菜单背景颜色,留空即为全局背景色 3.首页中间右侧 banner1234githubLink: enable: true # 是否开启 url: https://github.com/sitoi/sitoi.github.io # GitHub 仓库地址 title: Fork Me # 显示文字 4.首页轮播图相关配置123456cover: showPrevNext: false # 是否显示左右切换按钮 showIndicators: false # 是否显示指示器 autoLoop: false # 是否自动轮播 duration: 120 # 切换延迟时间，默认单位 秒 intervalTime: 5000 # 自动切换下一张的间隔时间 参考： Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐 (blinkfox.github.io) 基于 Hexo GitHub 从零开始搭建个人博客（三）：Matery 主题（DIY 版）详细配置教程，附博客源码 | Sitoi (๑•̀ㅂ•́) ✧被发现了～ (sunhwee.com) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"matery主题","slug":"matery主题","permalink":"https://protonlml.github.io/tags/matery%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"3.git初始化仓库的两种方式","slug":"3.git初始化仓库的两种方式","date":"2019-10-10T06:00:00.000Z","updated":"2024-06-16T02:42:05.104Z","comments":true,"path":"2019/10/10/3.git初始化仓库的两种方式/","link":"","permalink":"https://protonlml.github.io/2019/10/10/3.git%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"git初始化仓库的两种方式 一、当远程仓库有内容，本地文件夹没内容。 1. 在本地创建一个文件夹，名称和远程仓库名称相同 在文件夹内，直接使用 Git Bash 来克隆远程仓库的内容 git clone 二、将”本地仓库（本地仓库是已有项目，要交给远程仓库管理）”，给绑定到GitHub上的 “远程仓库”上面 1.首先在本地创建了本地仓库** git init (仓库中必须有内容) 2.要在 GitHub上面创建一个空的仓库，是没有初始化的。 git remote add origin https://gitee.com/lmlpla/blog.git**（已有远程仓库情况绑定仓库）** 3.在本地Git窗口中，使用命令进行绑定远程仓库。 先在（项目根目录）下面，添加 .gitignore文件。 然后在 git init （git初始化） git add . (注意这有个空格) &#x2F;&#x2F;(git status 查看当前提交状态) git commit -m ‘first commit init project’ git remote add origin &#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#101;&#x65;&#x2e;&#99;&#x6f;&#109;:plalml&#x2F;thefields.git (绑定远程仓库) git push -u origin master （推送本地仓库master分支到远程仓库的master分支） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"}],"author":"𝚲𝚳𝚲"},{"title":"Maven","slug":"Maven","date":"2019-10-10T03:00:00.000Z","updated":"2024-06-16T02:15:54.402Z","comments":true,"path":"2019/10/10/Maven/","link":"","permalink":"https://protonlml.github.io/2019/10/10/Maven/","excerpt":"","text":"Maven 一、Maven的一些理解 1.项目的构建，是指项目的“打包”，“编译”，“部署”，“运行”等一系列操作。 2.用Maven就可以使我们的项目，能够自动化构建。 3.maven是java项目的自动化构建工具。 4.Maven可以，将一个大型的项目的不同功能，拆分成多个模块，分别进行开发管理。 5.Maven可以，通过配置poom文件，来导入某个技术的jar包，同时会自动的导入这个jar包的相关依赖jar包。 二、Maven程序的执行原理 maven核心程序指的是，解压后的maven程序目录。也是maven软件的目录里面的内容。 Maven在自动构建项目的时候，使用插件会在本地仓库中找，使用依赖jar包也在本地仓库中找。本地找不到就到中央仓库中下载。 怎么使用maven？（不用开发工具） 创建一个maven规定的项目目录结构，在有poom.xml文件的目录下面，执行maven命令 当我们执行的Maven命令需要用到某些插件的时候，Maven核心程序会首先到本地仓库中查找 本地仓库的默认位置：[系统当前用户的家目录].m2\\repository(Maven找插件的时候，自动创建) Maven核心程序如果在本地仓库中找不到需要的插件的时候，那么它会自动联网，到中央仓库中下载。 Maven的生命周期就是指的是“项目的构建过程”，项目的构建是有顺序的，执行的任何一个Maven命令都是从生命周期的头开始。 Maven构建项目完成之后，生成的“产品”就放在“项目src所在目录”中的“target”目录中。 Pom 【1】含义：project Object Model 项目对象模型。 pom.xml对于Maven工程师核心配置文件，与构建过程相关的一切设置都在这个文件中进行 Maven坐标类比一下： 数学中可以用（x,yz）三个项量来确定一个空间的点。 Maven的pom文件中，也是使用三个项量，来在仓库中唯一定位一个Maven工程 [1]：groupid：公司或组织域名倒序+项目名 1&lt;groupId&gt;cn.itcast&lt;/groupId&gt; [2]：artifactid：模块名 [3]：version：版本 只要讲“gav”就讲的是Maven的坐标。 [4] :Maven工程的坐标与仓库中的路径对应关系。 在Maven仓库里面。每一个Maven工程，他的坐标一定是不重复的，即标识了这个Maven工程信息，同时也决定了他在仓库中存放的目录是什么。 仓库中保存的内容：宽泛的说就是（Maven工程项目） 主要有3大块： -[1]：Maven核心软件，自身所需要的一些插件 [2]：第三方框架或工具的jar包(其实就是第三方项目，打成了jar包) [3]：我们自己开发的工程。Maven将“插件”、“框架jar包”、“我们自己的项目”都用统一的目录结构，放在了仓库中，这样就方便Maven核心程序的管理和使用。 pom.xml文件解析。 创建的Maven项目中有pom.xml文件，他是Maven项目的核心配置文件。 【1】.除了上面三个坐标用来，定位当前项目用Maven核心程序安装在仓库中的位置。 2】.中间部分是“依赖部分”，就是指当前项目，所使用的到的“其他模块项目和jar包”，在Maven仓库中的坐标。如果仓库中没有指定的依赖jar包，就会自动从私服上面下载，私服上面没有就会到中央仓库中下载。 但是如果当前项目，用到我们自己写的模块，这时候就需要将，要使用的模块项目给“安装”到仓库中，用“ mvn install”命令进行安装。是不可能从网上下载的，因为这是我们自己写的，不是第三方jar包项目。这样我们就可以将一个大的项目，进行拆分成很多小的模块，然后各个模块之间用“依赖坐标”，来互相关联。 【3】最下面是“插件”部分。 依赖 ①Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。 对于我们自己开发的Maven工程，使用mvn install命令安装后就可以进入仓库。 ②依赖的范围 【1】在pom.xml文件中依赖的范围 依赖的范围一般常用的有三个：compile，test、provided三个。 依赖范围：意思就是，当前项目所依赖的这个“依赖”，在编译，测试，打包。过程当中时候有效。 [1]compile范围的“依赖”（编译范围） 对主程序是否有效：有效 对测试程序是否有效：有效 是否参与打包：参与 是否 参与部署：参与 [2]test范围的“依赖”（测试范围） 对主程序是否有效：无效 对测试程序是否有效：有效 是否参与打包：不参与 是否参与部署：不参与 典型例子：“junit依赖”它就是测试依赖，这个jar包，不参与打包，在主程序中没有。 [3]provided范围的“依赖”，通常是为web工程来添加的（不参与部署的范围）。 说明只要加了provided范围的“依赖”，web容器中都有。比如：servlet的这个依赖，部署的时候就不需要，因为Tomcat服务器本身就有servlet的jar包。 对主程序是否有效：有效 对测试程序是否有效：有效 是否参与打包：不参与 是否参与部署：不参与 典型例子：servlet-api.jar maven命令是什么？ maven这个程序，用来构建项目所使用的命令。（这些命令的顺序，就是生命周期的顺序） 比如【1】清理：mvn clean 【2】：编译主程序：mvn compile 【3】：编译测试程序：mvn test-compile 【4】：执行测试：mvn test 【5】：打包：mvn package 【6】：安装：mvn install 【7】：生成站点：mvn site这些命令，构成了Maven构建项目时的，不同生命周期， 12.Maven的生命周期 【1】意思：就是Maven构建项目的的，各个构建环节执行的顺序。：不能打乱顺序，必须按照既定的正确顺序来执行，是生命周期的各个阶段的命令来实现的。 【2】生命周期是在Maven的核心程序中定义了，抽象的生命周期。 生命周期中各个阶段的具体任务是由插件来完成的。 【3】有三套独立的生命周期： ①Clean Lifecycle（清理生命周期）在进行，在真正的构建一个项目之前，必须先进行一些清理工作。 ②Default lifecycle（默认的生命周期）构建的核心部分，编译，测试，打包，安装，部署等等。 ③Site Lifecycle（生成站点生命周期）生成项目报告，站点，发布站点。 【4】每个生命周期的具体实现 比如：只执行“mvn clean 清理命令”就会进行清理生命周期。 执行“mvn install 安装命令”就会进行Maven构建项目的默认生命周期，此时Maven核心程序，会从头开始执行“clean清理”,“compile 编译”，“test-compile 编译测试”，“test 执行测试”，“package 打包”，“install 安装”这一系列的过程。 执行“site 生成站点”，也会从头开始，将所有过程进行一边。这是生成站点生命周期 Maven核心程序为了更好的实现自动化构建，按照这一的特点执行生命周期中的各个阶段：不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行。 【5】生命周期的各个阶段仅仅定义了要执行的任务是什么（命令）完成这个命令，是由特定的Maven插件来完成的。 创建Maven工程之前，需要将IDEA编辑器，和本地下载的Maven程序，进行关联配置。具体操作，见文末。 三、使用IDEA创建普通的javaMaven工程 四、.使用IDEA创建webMaven工程（Maven要聚合模块的做法） 【1】必须先创建一个空的工程。在空的工程中添加模块。（每次添加模块都要使用快捷键“ctrl+alt+shift+s”来调出Project Structure窗口，在这个窗口中添加模块，不能直接在模块上面右键添加模块。（在模块上右键模块会添加到“模块里面”）） 【标准的Maven工程，分模块的大型web项目，目录结构】 说明 我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。 五、依赖 依赖的传递性： 【1】依赖的传递性是指，如果在一个大型的项目当中，各个模块相互依赖，那么在“最下面的模块（依赖关系最下面，这个模块只是被依赖，不去依赖别的模块）”中，pom.xml文件里面，配置的compile”范围的依赖jar包，其他模块的pom.xml文件虽然没有声明一样的compile”范围的依赖jar包，但是也可以使用这个依赖。 【2】前提是“compile”范围的依赖才能传递，“test”“provided”范围的依赖不能传递。所以在各个工程模块中，能够传递的依赖，只在“最下面”模块中声明一次就可以了，不能够传递的“test”“provided”范围的依赖就得各个模块中重复声明依赖。比如：servlet的依赖，他就是“provided范围的模块”，需要在每一个项目模块pom.xml文件中，都要重复声明。 【3】我们在开发项目的时候，会有一个专门的模块来负责维护这些框架jar包的依赖信息的。在这个模块中，全部都写“compile”范围的依赖”，让其他功能模块，来依赖这个“专门模块”，就可以实现“compile”范围的依赖”通用。 【4】子类继承了父类模块，也可以实现依赖传递，默认就是依赖的，不需要再在子类中，重新声明依赖父类，只在子类中声明父类就可以了。 依赖的排除： 依赖的排除，在哪个工程里面排除的，就在哪个工程里面生效。 【1】当我们导入某些依赖jar包的时候，Maven会自动将这个jar的其他依赖jar包也一起导入到工程当中，这个时候，如果不需要这个额外的jar包，就可以用“排除依赖”来进行排除。 【2】找到要排除的依赖的ID（假如spring-jcl依赖要被排除） 3】添加 标签 依赖原则： 解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决） 前提是因为“依赖的传递性”导致的jar包冲突问题。 冲突情景： properties标签配合自定义标签声明数据的配置并。(可以利用这个标签，实现在一个页面上，同种类型的框架jar包，版本号相同，)在父模块中就更简便了 123456789101112131415161718&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;!--不是只能用于声明依赖的版本号。凡是需要统一声明后再引用的场合都可以使用。--&gt;&lt;/properties&gt;&lt;!--spring-core依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring-core依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 六、Mavne继承（pom文件的继承） 存在的问题：我们都知道在一个“模块项目1”中配置了“compile”范围的依赖jar包”，“其他模块项目”来依赖这个“模块项目1”的时候，“其他模块项目”中会自动的存在了“项目模块1的”“compile”范围的依赖jar包”。这是依赖的传递性。只用在“模块项目1”中声明一份就可以了。 但是：如果是““test”“provided”范围的依赖是不能传递的”，需要在每一个模块中都要，重复的手动添加““test”“provided”范围的依赖”，比如“junit依赖”，他就是“test范围的依赖”。（不能够传递的依赖，他就是零散的分散在各个模块当中，就很容易造成各个模块工程之间的版本不一致）。 这就存在一个问题，开发一个大型项目的时候，各个模块是不同开发组来开发的，使用“junit这种依赖”的时候，可能版本号就会不相同，导致各个模块之间不统一。 解决办法：使用Maven的继承，统一成同一个版本。（以junit依赖为例） 【1】专门创建一个模块是所有模块的“父模块”，可以用作““compile”范围的依赖jar包”传递依赖。也可以用作““test”“provided”范围的依赖”的版本管理。 【2】解决思路：将junit依赖统一提取到“父”工程中，在子工程中声明junit依赖时不指定版本，以父工程中统一设定的为准。同时也便于修改。 【3】操作步骤 [1]创建一个Maven工程作为父工程。注意：打包的方式pom 1234&lt;groupId&gt;com.atlml.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; [2]在子工程中声明对父工程的引用（认干爹的一个仪式） 123456789&lt;!--子工程中声明父工程--&gt;&lt;parent&gt; &lt;groupId&gt;com.atlml.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--以当前pom文件为基准的,找父工程pom.xml文件的相对路径--&gt; &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; [3]在父工程中统一管理junit的依赖 1234567891011121314&lt;!--依赖管理，这里专门用来管理，不能够传递的依赖，进行版本号控制--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- junit是“test”范围的依赖，不能够传递，在这里面统一管理版本号--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; [4]在子工程中删除junit依赖的版本号部分 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--&lt;version&gt;4.11&lt;/version&gt;--&gt; 删除掉 &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; [5]实现效果 [6]：父模块的Pom.xml文件的配置。 七、Maven的聚合： （聚合就是Maven中，各个模块的一键安装。） 注意：配置了继承的模块，在执行安装命令（ install）的时候，要先安装 “父模块”再安装其他模块才能成功。 Maven中的一件安装，就可以自动的按顺序，将每个模块都按依赖顺序进行安装。 实现一件安装步骤： 【1】创建一个“总的聚合工程”，（一般把“父模块”作为“总的聚合工程”，大的情况下也是将，聚合的配置，也配在父模块内） 【2】在一个”总的聚合工程”的pom.xml文件中，配置各个參与聚合的模块 123456&lt;!--配置聚合--&gt;&lt;modules&gt; &lt;!--指定各个子工程的相对路径--&gt; &lt;module&gt;../Hellow&lt;/module&gt; &lt;module&gt;../HellowFriend&lt;/module&gt;&lt;/modules&gt; 八、Maven仓库地址 Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com) 仓库服务 (aliyun.com) 九、IDEA中Maven配置IDEA配置Maven的超详细步骤_java_脚本之家 (jb51.net) IDEA配置Maven（详细版）_idea maven-CSDN博客 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"},{"name":"maven","slug":"java/maven","permalink":"https://protonlml.github.io/categories/java/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://protonlml.github.io/tags/maven/"},{"name":"项目自动化构建工具","slug":"项目自动化构建工具","permalink":"https://protonlml.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}],"author":"𝚲𝚳𝚲"},{"title":"javaScript","slug":"javascript","date":"2019-10-01T04:00:00.000Z","updated":"2024-06-16T02:11:23.105Z","comments":true,"path":"2019/10/01/javascript/","link":"","permalink":"https://protonlml.github.io/2019/10/01/javascript/","excerpt":"","text":"javaScript 静态网页资源的三剑客：HTML（文本），CSS（样式），JavaScript（行为）。把后面两个效果，加在HTML文本上，就会呈现出很好看的网页界面。 程序设计有两种架构：1 c&#x2F;s架构，是客户端和服务器端，要开发两个程序。2 b&#x2F;s架构，是浏览器和服务端。只用浏览器来申请服务器端的资源，再展示出来就好了。只用开发服务器端一个软件。 javaWeb开发，是B&#x2F;S架构的。 事件：事件是什么意思？通俗的理解，HTML中的元素组件，被某个动作（事件的属性），触动后，会发生一定的变化。（执行了另一个js代码）。 将HTML，CSS，JavaScript分别独立出来，可以降低耦合度， javaScript最初被设计用于浏览器中，他和java语言没有关系，他是客户端脚本语言 javaScript语言运行出错，要在浏览器控制台上面查看。F12打开控制台。 - 一、javaScript 注意：在一个html的页面中，可以定义多个script的标签，而且存放的位置是任意的，但是会影响运行的先后顺序，一般都是等html页面元素全部加载完毕，再运行js代码，并且是一种等待状态。当在html中的某个位置，触发了某个事件，此时对应的js等待代码，就会执行。从而产生行为效果 1.javascript与HTML的关联方式： 内部关联 外部关联 2.javascript的数据类型 原始数据类型： 1. number：数字 。 整数/小数/ NAN （not a number 一个不是数字的数字类型） 2. string ：字符串。字符串 &quot;abc&quot; &quot;a&quot; &#39;abc&#39; 3. boolean：true 和 false 4. null：一个对象为空的占位符 5. undefined：未定义，如果一个变量没有给他初始化值，则会被默认赋值为undefined 注意：NaN是number类型，他是（不是数字的数字）。在js当中，运算符，后面的运算数，不是运算符要求的类型，js就会自动的将运算数进行类型转换。比如：numb&#x3D; +”abc”;此时：number根据”+”运算符，如果是数字，就会直接转换成数字，但是转换符后面跟的不是数字类型，则会转换成不是数字的数字类型。值为NaN. 3.JavaScript的变量 什么是变量：变量就是内存空间中的一小片区域。有类型，有名称，有值。比如：int a&#x3D;3; JavaScript的变量是弱类型的，什么叫弱类型，就是不管定义什么类型的变量，都用var开头。 而java中定义整型用int，定义字符型用char 。所以java是强类型的。 ☆ 通过typeof(变量名)可以得到变量的类型 注释:你也许会问,为什么typeof运算符对于nul值会返回”object”.这实际上是javaScript最初实现中的个错误,然后被ECMAScript沿用了,现在,null被认为是 对象的占位符,从而解释了这一矛盾,但从技求上来说,它仍是原始值。 4.javascript中的运算符 ①一元运算符：就是只有一个运运算数的运算符。 ++ 、–、+（正号）、-（负号） “++（–）”在前，先自增（自减），再运算。 “++（–）”在后，先运算，再自增（自减）。 +（-）（正负号） ②算数运算符：“+”，“-”，“* ”，“&#x2F;” ，“%”（和java中使用方法相同） ③赋值运算符：“+&#x3D;”，“-&#x3D;”“&#x3D;”（和java中使用方法相同） ④ 比较运算符：“&gt;”，“&lt;”，“&gt;&#x3D;”，“&lt;&#x3D;”，“&#x3D;&#x3D;”， “&#x3D; &#x3D;&#x3D;（全等于）” “&#x3D; &#x3D;”是比较两个数是否相等，“&#x3D;&#x3D;&#x3D;全等于”是加上了类型的比较。 ⑤ 逻辑运算符：“&amp;&amp;”，“||”，“！” ⑥ 三元运算符“ ？：表达式” 二、javascript 中的特殊语法.(了解一下就好，但是要和java规范一样写代码，不要省“；”，也不要省“var”，带var的变量，是局部变量，不带var的变量是全局变量 。) 三、流程控制语句 练习 ：javascript（9x9乘法表） 四、BOM对象： 概念：Browser object Model 浏览器对象模型。将浏览器各个组成部分封装为对象。 BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。① window窗口对象。 window窗口的第一类方法：弹窗有关的方法 window窗口的第二类方法：打开关闭窗口的方法。 window窗口的第三类方法：与定时器有关的方法 Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（.html文件对象）。直接写就可以用 ②、 Location地址栏对象 Location 对象的方法。reload().用来刷新当前页面。 属性：href Location地址栏对象，他的一个属性href。有两个作用，设置当前页面的URL和获取当前页面的完整的URL.（这里面的设置和获取URL都是针对当前页面的。设置的话，就是重新赋值，设置为新的地址，这样当前页面就会跳转到设置的地址页面中去） 倒计时跳转网页案例 ③、 history当前页面历史记录对象。 属性：length：history.length；返回的是。历史记录的个数。 方法：back();加载history列表中的上一个URL。绑定单击事件，就可以做一个后退的按钮。 方法： forword(); 加载history列表中的下一个URL。绑定单击事件，就可以做一个前进的按钮。 方法：go(); 加载history列表中的某一个具体页面。 五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML DOM对象。） ☆ DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。 ☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。 DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析） DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。 ①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element(其他标签对象)对象。或者是创建Element (其他标签对象)对象。 document.write(““) 向页面上写出一条横线（就是往页面写出信息的） 1.1 document对象：获取element对象的方法。 getElementById（） ：根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName （） ：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName （）：根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName（）：根据name属性值获取元素对象们。返回值是一个数组 1.2 document对象：创建其他DOM对象： createElement（“标签名”）：创建元素节点（记住） createAttribute（name）：创建拥有指定名称的属性节点，并返回新的Attr对象。（了解） createComment（）：创建注释节点。（了解） createTextNode（）：创建文本节点。（了解） ②：Element对象（元素标签对象） 1，获取&#x2F;创建：通过document来获取和创建 2.方法： removeAttribute（“”） ：删除属性 setAttribute（“属性名”，“属性值”） ：设置属性值。 补充：input框框，有个value属性，用其节点对象.value可以得到，文本框里面的内容。 ③：Node对象 （是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。 appendchild（节点对象名） ：向节点的子节点列表的结尾添加新的子节点。（增） removechild（节点对象名） ：删除（并返回）当前节点的指定子节点。（删） replacechild（节点对象名） ：用新节点替换一个子节点。（改，不常用）。 属性：父节点&#x3D;当前节点.parentNode; 返回当前节点的父节点。 六、☆javascript 中的几个对象的学习。 1.☆ function函数方法对象、Array数组对象。 function对象，在javascript 中，定义方法，是用function对象，来定义方法的。 语法：function 方法名（参数列表）{方法体} &#x2F;&#x2F; javascript中定义方法，的写法和java类似。 但是是用的function对象定义的方法 &#x2F;&#x2F; js中用function定义的方法，参数列表不用写类型，返回值不用写类型 &#x2F;&#x2F; js中用function定义的方法，如果有多个同名的方法，那么后面的同名方法，会覆盖前面的同名方法， &#x2F;&#x2F; js中用function定义的方法，在调用方法时，只要方法名确定就会调用最后面的同名不同参数的方法。他和参数列表无关。 &#x2F;* js中用function定义的方法，参数列表的括号里面隐藏了一个内置对象，是一个arguments的数组。 所以当参数列表中不写形式参数时，function add(){ 方法体} 括号里面就是一个可变形参 每一个传递过来的实参，都存在arguments[0].arguments[1]……..等数组中。 *&#x2F; 2.☆ Array数组对象 3.☆ Date日期对象 4.☆Math数学对象 5.☆ regExp：正则表达式对象。 先了解什么是正则表达式 正则表达式就是定义字符串的组成规则（通用的规则，在Java中或者其他语言中都可以使用）。在表单的输入框的地方，实现校验输入的字符串是不是符合正则表达式的规则。不符合校验失败，阻止表单的提交。 ☆ Javascript对表单的校验，是依赖于正则表达式的。 正则表达式对象。regExp 6.☆全局对象 在javascript中，有一个全局对象Global，他不用创建对象，直接用其内部的方法，就可以实现对应的功能，一般有字符串的URL编解码方法。 七、 事件绑定的方式 得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。 八、HTML DOM：是关于如何获取、修改、添加或删除HTML元素的标准 ☆①所有的节点对象都有的关键的属性innerHTML innerHTML。是获取节点对象，里面的所有内容。就是获取了，一对“&lt;&gt;标签体&lt;&#x2F;&gt;”中的标签体的内容。标签体可以是一段文字，也可以是其他标签。 通过给innerHTML赋值或者追加值，可以改表标签体的内容。如下图 上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。 ☆②所有的节点对象都有的关键的属性style。 1.给style属性赋值，就可以改变其样式。 注意：两个单词的写法 2. 改变节点对象的class值。用className属性。 3.要想设置和修改，节点的属性值。查Api文档。例如： 标签图片标签，每出现一次，一个 Image 对象就会被创建。找image对象的属性，src设置或返回图像的 URL 九、事件 事件分类 1.点击事件 onclick：单机事件 ondblclick ：双击事件 2.焦点事件 onblur：失去焦点 一般用于表单验证,当光标不在输入框时，就会失去焦点，触发onblur事件发生。 onfocus：元素获得焦点 3.加载事件 onload：一张页面或者一幅图像完成加载 内部加载方式：script标签如果写在head标签里面，在上面的话，要使用窗口的事件机制，加载事件来控制，js 代码，在HTML页面加载完全，才运行。 如下图 4.鼠标事件 onmousedown ：标按钮披按下. 定义方法时,定义一个形参,接受 event 对象. eventi对象的button属性可以获取鼠标按钮键被点击了. onmouseup ：鼠标按键被松开. onmousemove ：鼠标被移动. onmouseover：鼠标移到某元素之上. onmouseout：鼠标从某元素移开. 5.键盘事件 onkeydown： 某个键盘按键被按下. onkeyup ：某个键盘按键被松开. onkeypress： 某个键盘按键被按下并松开. 6.选择和改变事件 onchange：域的内容被改变. ☆ 当在选择的下拉列表上，选择某个选项会触发该事件。 onselect：文本被选中. 7.表单事件: onsubmit：确认按钮被点击. 可以阻止表单的提交 方法返回falsel则表单被阻止提交. 写法： onreset：重置按钮被点击. 练习：动态表格案例 ☆动态表格案例总结：用DOM对象在内存层面你，不管创建了多少子节点或者父节点，这些结构都是在内存层面上的，在浏览器页面上不能够直接显示，要想显示，必须有html的已有标签对象。先获取已有的html标签对象节点，将内存层面上的节点，appendChild为已有节点的子节点。同时，属性的样式会关联到css样式表中，只要和css表中的选择器对应的上，就可以显示样式。 ☆ 技巧：怎样获取当前标签的对象，直接在html标签后面，加上事件属性。绑定事件方式一，事件调用指定方法，括号里面写this。 那么就可以在方法声明的地方，形式参数就是当前对象。如下图： 总结1： 怎么来理解BOM对象和DOM对象以及HTML DOM对象？ 1 . BOM对象，就是将浏览器各个组成部分，封装为对象。有显示器对象、浏览器对象、windows窗口对象、URL地址栏对象、以及历史记录对象，这5个BOM对象。windows窗口对象，是BOM对象中的主要对象，因为其他对象都在一个窗口当中。可以通过windows对象来获取，其他4个BOM对象。 2 .在windows窗口获取的document对象，是DOM对象。 document对象是DOM对象的主要对象。DOM对象也在窗口内，但是只有document对象（.html文件对象）是通过窗口获取，其他DOM对象是通过document对象获取的。 3 .document对象，他是将整个文档封装成一个document对象。对应着HTML里面最外层标签。他可以获取其他节点对象 document.getElementById()；。或者对象们；另外也可以创建其他DOM对象。 4.有了一些基础的DOM对象，也就是有了某个标签的（节点）的对象之后。然后用HTML DOM来、对这个对象进行获取、修改、添加或删除操作。 5.从上往下看，一层一层的，从窗口(window)——&gt;文本对象(document)——&gt;单个文本元素对象(element)——&gt;单个文本元素操作（HTML DOM）这样方便记忆。也便于理解。 节点：在HTML中所有的单个元件，就是单个节点。对应着一对，一对的标签。 子节点：外标签包着内标签，也就是节点包着子节点。例如：文字 超链接。 Node 节点对象：他可以认为是虚有的，它里面的方法用来“CRUDdom树” 其实就是所有的DOM对象，都是一个节点，DOM对象本身，就可以增加节点，删除节点，替换节点，查询节点。 有了DOM这些对象，用他们的功能。就可以用javaScript语言对HTML的标签进行操作。 要记住：虽然能用，JavaScript语言来操作，内存层面的HTML的元素对象代码，使其在浏览器上面显示样式。但是他和HTML里面的标签没有，任何关系。 执行了“JavaScript语言操作的元件对象，比如添加节点，删除节点”不会再HTML文档中自动生成，HTML代码。 理解、标签、标签体、标签属性、控制元素的样式。 1.1标签: 标签就是一对对的&lt;&gt;&lt;&#x2F;&gt;。例如：&lt;img&gt; &lt;/img&gt; 1.2标签体:一对标签里面的内容。例如：&lt;img&gt;这是标签体，可以是子标签也可以是文字 &lt;/img&gt; 1.3 标签属性: 定义在标签&lt;&gt;里面的。例如：&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt; 1.4 标签控制样式: 总结2： 一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求 &lt;script&gt;js代码&lt;/script&gt;，标签一般都写在&lt;body&gt;......&lt;script&gt;&lt;/body&gt;body标签的最下面。 js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://protonlml.github.io/tags/javaScript/"}],"author":"𝚲𝚳𝚲"},{"title":"11.static静态变量","slug":"11.static静态变量","date":"2019-09-24T12:30:00.000Z","updated":"2024-06-16T02:51:10.901Z","comments":true,"path":"2019/09/24/11.static静态变量/","link":"","permalink":"https://protonlml.github.io/2019/09/24/11.static%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/","excerpt":"","text":"static静态变量","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"10.集合","slug":"10.集合","date":"2019-09-24T12:00:00.000Z","updated":"2024-06-16T02:50:59.841Z","comments":true,"path":"2019/09/24/10.集合/","link":"","permalink":"https://protonlml.github.io/2019/09/24/10.%E9%9B%86%E5%90%88/","excerpt":"","text":"集合 一、集合和数组都是存数据的容器 1.集合和数组的区别 数组：长度是固定的，可以存储基本数据类型，也可以存储引用数据类型 集合： 长度是可变的，只能存储引用数据类型。 二、集合的基本操作（增删改查） 对容器类的对象的操作，基本上就是增删改查 1.创建集合对象（&lt;&gt; 中表示泛型） 三、基本数据类型对应的包装类 四、集合综合练习 五、知识点（标号的使用）","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"9.字符串综合练习","slug":"9.字符串综合练习","date":"2019-09-24T11:00:00.000Z","updated":"2024-06-16T02:48:32.190Z","comments":true,"path":"2019/09/24/9.字符串综合练习/","link":"","permalink":"https://protonlml.github.io/2019/09/24/9.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/","excerpt":"","text":"字符串综合练习 一、转换罗马数字 使用到了 string 字符串 转 char[] :方法是toCharArray() 使用到将 char[i] 某个char字符，转为 数字 ：方法使用 Character.getNumericValue(chars[i]); 使用jdk12中 的 switch的写法进行匹配 二、调整字符串 1.","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"8.字符串","slug":"8.字符串","date":"2019-09-23T08:00:00.000Z","updated":"2024-06-16T02:47:50.752Z","comments":true,"path":"2019/09/23/8.字符串/","link":"","permalink":"https://protonlml.github.io/2019/09/23/8.%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串 一、字符串构造方法 二、字符串创建方式 0.直接赋值（最常用），这种赋值后，字符串会放在“字符串常量池”，再次声明这个字符串，可以直接复用，节省内存 1.使用字符数组作为参数，构建String 字符串 2.使用，字节码数组作为构造参数 三、字符串的操作 1.字符串的比较（”&#x3D;&#x3D;” 比较的是地址值，”equals”比较的是内容） 注意点：通过Scanner对象，从键盘录入的字符串是 new出来的，放在堆里 2.字符串，提取指定的字符charAt( )方法 3.字符串的截取 subString() 4.字符串转数字（要注意字符串转为数字后的范围大不大） parseInt() 5.判断字符串是不是空字符串 isEmpty() 6. 字符串的替换 replace() 四、StringBuilder的使用 为什么使用Stringbuilder 只要涉及到字符串的 “拼接”，“替换”，“反转” 就要想到StringBuilder， 而字符串的 “截取subString”，“获取某个字符使用 charAt()”，都是String自身可以做到 五、StringJoiner（拼接字符串使用） 六、总结 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"7.封装","slug":"7.封装","date":"2019-09-23T02:30:00.000Z","updated":"2024-06-16T02:45:38.033Z","comments":true,"path":"2019/09/23/7.封装/","link":"","permalink":"https://protonlml.github.io/2019/09/23/7.%E5%B0%81%E8%A3%85/","excerpt":"","text":"对象的封装 一、对象封装 二、对象中 “成员变量”,”成员方法”. 类中的方法叫做成员方法，类中方法外的变量叫做成员变量。类中方法内的变量，是局部变量。 this 关键字 作用：就是用来区分成员变量，与局部变量重名的。 三、构造方法，构造器 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"6.面向对象","slug":"6.面向对象","date":"2019-09-22T06:00:00.000Z","updated":"2024-06-16T02:44:42.211Z","comments":true,"path":"2019/09/22/6.面向对象/","link":"","permalink":"https://protonlml.github.io/2019/09/22/6.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象 一、 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"经验3","slug":"经验3","date":"2019-09-22T06:00:00.000Z","updated":"2024-06-15T06:14:53.348Z","comments":true,"path":"2019/09/22/经验3/","link":"","permalink":"https://protonlml.github.io/2019/09/22/%E7%BB%8F%E9%AA%8C3/","excerpt":"","text":"模板 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"}],"author":"𝚲𝚳𝚲"},{"title":"4.二维数组","slug":"4.二维数组","date":"2019-09-22T05:00:00.000Z","updated":"2024-06-16T02:56:51.375Z","comments":true,"path":"2019/09/22/4.二维数组/","link":"","permalink":"https://protonlml.github.io/2019/09/22/4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","excerpt":"","text":"二维数组 一、二维数组的静态初始化 二、获取二维数组中的某个值 三、二维数组遍历 四、二维数组动态初始化 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"5.方法与数据类型","slug":"5.方法","date":"2019-09-22T05:00:00.000Z","updated":"2024-06-16T02:44:04.540Z","comments":true,"path":"2019/09/22/5.方法/","link":"","permalink":"https://protonlml.github.io/2019/09/22/5.%E6%96%B9%E6%B3%95/","excerpt":"","text":"方法与数据类型 一、方法 二、数据类型1.基本数据类型（变量中存储的是真实的数据）在栈中 四类八种 整数数据类型 （bat , short , int , long ） 浮点数据类型(float , double) 布尔数据类型（char ） 字符数据类型( boolean) 2.引用数据类型（只要是new出来的都是引用数据类型）在堆中 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"3.数组","slug":"3.数组","date":"2019-09-22T04:00:00.000Z","updated":"2024-06-16T02:40:50.332Z","comments":true,"path":"2019/09/22/3.数组/","link":"","permalink":"https://protonlml.github.io/2019/09/22/3.%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组 一、什么是数组 二、数组的静态初始化 三、数组的动态初始化 数组默认初始化值的规律 整数类型:默认初始化值 0 小数类型:默认初始化值 0.0 字符类型:默认初始化值 ‘\\u0000’ 空格 布尔类型:默认初始化值 false 引用数据类型: 默认初始化值 null (引⽤数据类型包括：类、接⼝类型、数组类型、枚举类型、注解类型，字符串型) 四、数组的静态初始化和动态初始化的区别 五、索引 数组元素访问 数组元素访问的格式为：数组名[ 索引]； 索引：也叫做下标，角标； 索引特点：从0开始，逐个+1增长，连续不间断 （我们可以通过索引把数组中的元素拿出来用，也可以把元素添加到数组当中去） 六、数组角标越界异常 访问了数组不存在索引，就会引发数组角标越界异常 避免：知道索引的范围 七、数组常见操作 1.求最值 2.求和 3.交换数据 4.打乱数据 5.冒泡排序 6.数组拷贝 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"2.判断和循环","slug":"2.判断和循环","date":"2019-09-21T04:00:00.000Z","updated":"2024-06-16T02:37:32.559Z","comments":true,"path":"2019/09/21/2.判断和循环/","link":"","permalink":"https://protonlml.github.io/2019/09/21/2.%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"一、判断if语句 switch语句1234/** * 如果说，要对一个范围进行判断，则需要使用if * 如果对，有限个结果，一一列举出来，任选其一，则需要使用switch */ 注意 1.switch正常执行流程 执行流程 首先还是会拿着小括号中表达式的值跟下面每一个case进行匹配.如果匹配上了,就会执行对应的语句体,如果此时发现了break,那么结束整个switch语句:如果没有发现break,那么程序会继续执行下一个case的语句体,一直遇到break.或者右大括号为止.使用场景:如果多个case的语句体重复了,那么我们考虑利用case穿透去简化代码 2.switch新特性（JDK12） 3.case穿透 就是语句体中没有写break导致的: 应用场景 4. default的位置和省略 位置:default 不一定是写在最下面的 ,我们可以写在任意位置.只不过习惯会写在最下面 省略:default可以省略,语法不会有问题,但是不建议省略. 二、循环 在实际开发中，我们需要重复的执行某段代码，会选择循环来实现 1.for循环 2.while循环 3.for 和while的区别 4.无限循环 循环一直停不下来 注意事项 在无限循环的下面，不能再写其他代码了，因为循环永远停不下来，那么下面的代码永远执行不到 5.跳转控制语句 1.continue:跳过本次循环,继续执行下次循环. 2. break:结束整个循环. © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"1.运算符以及类型转换","slug":"1.运算符以及类型转换","date":"2019-09-21T03:00:00.000Z","updated":"2024-06-16T14:53:26.284Z","comments":true,"path":"2019/09/21/1.运算符以及类型转换/","link":"","permalink":"https://protonlml.github.io/2019/09/21/1.%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"一、算数运算符 二、类型转换1.隐式转换 隐式转换的两种提升规则 取值范围小的,和取值范围大的进行运算,小的会先提升为大的,再进行运算 byte short char三种类型的数据在运算的时候,都会直接先提升为int,然后再进行运算 2.隐式转换小结 取值范围 byte&gt;short&gt;int&gt;long&gt;float&gt;double 什么时候转换 数据类型不一样，不能进行计算，需要转换成一样的才可以计算 转换规则1： 取值范围小的，和取值范围大的进行运算，小的会先提升为大的在进行计算 转换规则2 byte short char 三种类型的数据在运算的时候，都会直接提升为int ，然后再进行运算 三、强制转换 如果把一个取值范围大的数值，赋值给取值范围小的变量。是不允许直接赋值的。如果一定要这么做就需要加入强制转换 格式：目标数据类型 变量名&#x3D;(目标数据类型)被强转的数据 四、+ 加号运算符 “字符+字符”当”+”操作中出现字符串时,这个”+”是字符串连接符,而不是算术运算符了.会将前后的数据进行拼接,并产生一个新的字符串. “字符+数字”时,会把字符通过ASC川码表查询到对应的数字再进行计算. 五、自增自减运算符 六、赋值运算符 七、关系运算符 八、逻辑运算符 九、短路逻辑运算符 十、三元运算符 条件（三元）运算符是 Java 唯一使用三个操作数的运算符：一个条件后跟一个问号（?），如果条件为[真值]，则执行冒号（:）前的表达式；若条件为[假值]，则执行最后的表达式。该运算符经常当作 [if...else]语句的简捷形式来使用。 十一、运算符的优先级 只用记住一点“小括号( )”优先于所有，想要先算谁，就用小括号将其括上 十二、原码，反码，补码 计算机中，最小的存储单元是“一个字节” 它占8个bit位。范围从1000 0000 ~ 0111 1111 （-128~127） &#x3D;&#x3D;计算机中，数字的存储，以及运算都是以补码的形式来操作的。&#x3D;&#x3D; 理解了原码，反码，补码，的基本概念，就可以深入了解以下的内容了。 1.理解同一个数字在不同数据类型下到底有什么区别呢？bit位 &#x3D;&#x3D;就是在前面的位置“补0”&#x3D;&#x3D; 2.理解隐式转换 3.理解强制转换 4.理解数字之间使用“运算符” © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"运算符","slug":"运算符","permalink":"https://protonlml.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客（六）本地hexo博客恢复","slug":"搭建个人博客（六）本地hexo博客恢复","date":"2019-09-19T07:00:00.000Z","updated":"2024-06-16T01:38:22.286Z","comments":true,"path":"2019/09/19/搭建个人博客（六）本地hexo博客恢复/","link":"","permalink":"https://protonlml.github.io/2019/09/19/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%85%AD%EF%BC%89%E6%9C%AC%E5%9C%B0hexo%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/","excerpt":"","text":"搭建个人博客（六）本地hexo博客恢复一、使用SourceTree软件，拉取远程仓库中的博客blog 删除这个文件夹 在本地blog文件夹中,使用Git Bath 运行1234npm install hexonpm installhexo ghexo s 继续编写博客，进行hexo d 上传上传失败执行12npm install hexo-deployer-git --save 之后再上传hexo d 上传 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客(五)：编写博客文章以及上传和备份","slug":"搭建个人博客(五)：编写博客以及上传和备份","date":"2019-09-19T03:00:00.000Z","updated":"2024-06-16T01:41:08.271Z","comments":true,"path":"2019/09/19/搭建个人博客(五)：编写博客以及上传和备份/","link":"","permalink":"https://protonlml.github.io/2019/09/19/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E4%BA%94)%EF%BC%9A%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8A%E4%B8%8A%E4%BC%A0%E5%92%8C%E5%A4%87%E4%BB%BD/","excerpt":"","text":"搭建个人博客(五)：Typora编写博客以及上传和备份一、编写博客 1.在\\blog\\source\\ _posts目录中创建md文件 2.添加博文分类和博文标签的相关配置123456# 通过如下字段,Hexo会自动添加博文分类和博文标签的相关配置---title: title # 添加博文标题categories: categories # 添加博文分类tags: tags # 添加博文标签--- 3.博客标题，以及md文档名要一致 二、本地查看效果123hexo cleanhexo ghexo s 三、上传 按Ctrl+C暂停，随后使用命令 hexo d 推送到远程仓库的 hexo默认分支 上去了。 四、备份 通过Sourcetree备份master分支 这样做的目的是，当我们在本地blog的源文件被误删除了，我们还可以直接拉取仓库中master分支到本地，继续使用。 在Sourcetree上，只用检出master分支就行了 （我们一直都在master分支上操作） 五、每次推送后，都要对Gitee Pages 点击更新 每次推送后，都要对Gitee Pages 点击更新，然后清空浏览器缓存，访问才生效。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床","slug":"Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床","date":"2019-09-18T10:00:00.000Z","updated":"2024-06-16T14:55:42.643Z","comments":true,"path":"2019/09/18/Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床/","link":"","permalink":"https://protonlml.github.io/2019/09/18/Docker-Alist%E5%AE%B9%E5%99%A8+PicGoApp+%E5%A4%B8%E5%85%8B%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床 前言：在搭建自己的博客时，我们会把博文的图片上传到如：七牛云，阿里云oss，腾讯云等。这些第三方云图床上面，优点方便快捷安全。其次是使用“Typora+PicGoApp+gitee”实现远程仓库管理图片。但是作为图片的仓库是公开的，没法实现图片私密。再者就是现在自己搭建图床。 Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床，这里服务端我使用的是自己电脑中的虚拟机，当然自己搭建服务器，或者搭建Nas以及购买第三方服务器都行。 一、准备工作 1.本地安装PicGOApp并且关联了Typora 具体可查看文章搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床 2.PicGo下载alist插件 3.远程服务器上面安装Alist Alist所有操作参照 AList文档 (nn.ci) 这里使用本地虚拟机Docker安装Alist，使用VSCode连接远程服务器，在bash终端使用docker命令下载镜像 1docker run -d --restart=unless-stopped -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=&quot;alist&quot; xhofe/alist:latest Alist容器运行起来，同时也下载了。使用命令查看 1docker ps 生成登陆密码，并且修改登陆密码 1234# 先随机生成一个密码docker exec -it alist ./alist admin random# 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码docker exec -it alist ./alist admin set NEW_PASSWORD 4.浏览器中访问Alist客户端 端口是5244 192.168.56.30:5244 这里我是本地服务器地址 二、挂载网盘 1.登陆Alist添加存储（将夸克网盘挂载到Alist上） 2.添加一个新的驱动，驱动选择“夸克”。挂载路径和序号根据自己需求填写，缓存过期时间填0。Webdav策略选择“本地代理”。 我们需要获取Cookie 打开电脑浏览器（使用Chrome浏览器）并登录夸克网盘账号(用网页版登录)，然后按键盘上的F12，进入开发者模式。点击上方的Network(网络)选项卡，在左侧的Name(名称)中找到“sort?pr&#x3D;u”开头的条目并选中(如果该条目没刷新出来，需要稍等几秒钟)，然后在右侧的Request Headers中，找到Cookie值并复制： 将复制的Cookie值填入alist设置页面，其他选项全部保持默认，然后点击添加即可。 3.Alist两个设置 关闭签名所有 复制令牌 7.夸克网盘挂载成功。 三、PicGo关联alist 设置配置 四、在Typora中复制一张图片测试上传 注意要将 alist设置为 默认图床 参考链接 Typora+PicGo+Alist 私人图床教程_alist 图床-CSDN博客 轻松打造智能家庭数据中心——袋鼠叔叔带你玩转绿联DX4600 (篇3—Docker中搭建Alist本地挂载阿里&#x2F;百度&#x2F;夸克网盘小白保姆教程) (zhihu.com) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"搭建图床","slug":"搭建图床","permalink":"https://protonlml.github.io/categories/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://protonlml.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Picgo","slug":"Picgo","permalink":"https://protonlml.github.io/tags/Picgo/"},{"name":"Alist","slug":"Alist","permalink":"https://protonlml.github.io/tags/Alist/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床","slug":"搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床","date":"2019-09-18T07:00:00.000Z","updated":"2024-06-16T01:40:31.188Z","comments":true,"path":"2019/09/18/搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床/","link":"","permalink":"https://protonlml.github.io/2019/09/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89Typora+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%BA%91%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"搭建个人博客（四）Typora+Picgo+Gitee搭建云图床实现图床的方式有很多种 例如： 使用Typora+PicGo+阿里云 搭建图床 - 知乎 (zhihu.com) 这里提供一种 在编写博文的时候，需要进行插入图片，但是此时的图片是在本地的，我们要使用Typora+Picgo+Gitee实现云图床将图片放在gitee仓库中，在线访问就可以查看到。 一、创建一个仓库 初始化同时创建imgs文件夹 二、生成私人令牌 生成仓库后，点击右上角的头像-&gt;设置-&gt;私人令牌-&gt;生成私人令牌-&gt;复制-&gt;确认，保存好 三、安装PicGo软件1https://picgo.github.io/PicGo-Doc/zh/ 安装PicGo软件后，插件设置中搜索gitee-uploader安装插件 设置PicGo-Server确定一下 设置时间戳重命名，保证文件名中没有中文避免线上不显示 设置图床gitee为默认图床 设置gitee图床连接 至此PicGo设置完毕 四、关联Typora和PicGo软件 打开Typora，偏好设置-图像，关联PicGo 使用Typora编写博客的时候，复制了图片到当前文章当中，直接点击上传 在仓库文件夹中就能看到了 五、说明1.为什么不使用PicGo-Core(command line) gitee上传设置命令的的上传方式，配置了配置文件，有时候也会上传不成功出现错误。如果你已经下载了PicGo-Core(command line)插件，然后又下载了PicGoApp上传，也有可能会出现错误。解决办法：将Typora软件卸载重新安装重新配置。 Typora软件需要激活，这里提供Typora旧版本免激活使用 2.下拉框“复制图片到.&#x2F;${filename}.assests文件夹”选项说明： 复制图片到.&#x2F;${filename}.assests文件夹：以后在C:\\working\\blog\\source\\ _posts 中创建博客文章，先创建md文件，然后写博文在每次往md插入图片时，都会自动在同级目录生成assests文件夹将插入的图片拷贝一份在里面存放，这样以后拷贝文件将assests和md文件一起拷贝，就一直有效了。 上传图片：每次往md插入图片时，都会将图片上传到gitee仓库，图片名自动改为gitee仓库图片地址 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"搭建图床","slug":"搭建图床","permalink":"https://protonlml.github.io/categories/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://protonlml.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Picgo","slug":"Picgo","permalink":"https://protonlml.github.io/tags/Picgo/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客(三)：主题pure使用指南","slug":"搭建个人博客(三)：主题pure使用指南","date":"2019-09-17T05:00:00.000Z","updated":"2024-06-16T14:58:18.471Z","comments":true,"path":"2019/09/17/搭建个人博客(三)：主题pure使用指南/","link":"","permalink":"https://protonlml.github.io/2019/09/17/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E4%B8%89)%EF%BC%9A%E4%B8%BB%E9%A2%98pure%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"搭建个人博客(三)：主题pure使用指南Hexo-theme-pures是一个Hexo的主题框架 一、安装pure主题1. 在hexo根目录中的themes文件夹下克隆pure主题 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 下载完毕，删除文件夹中所有.git相关的文件 2.修改配置文件 在 Hexo 中主要有两份配置文件，其名称都是 _config.yml。 一份位于博客根目录下，主要包含 Hexo 本身的配置；另一份位于主题根目录下，主要用于配置主题相关的选项。 （1.）打开博客根目录配置文件_config.yml，做如下修改: 12language: zh-CN //设置主题为中文版，若使用英文版则不修改theme: pure //修改hexo主题 （2）在博客文件夹下打开git bash命令行窗口依次使用如下指令: 12hexo cleanhexo s 启动服务后：进入本地浏览器输入:http://localhost:4000/，如下图 3.安装pure插件在博客文件夹下打开git bash命令行窗口依次使用如下指令： 123456npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-deployer-git --save 二、配置pure主题1. 复制_source文件夹中的内容将主题目录中 &#x2F;theme&#x2F;_source&#x2F; 下的所有东西复制进博客根目录的source文件夹中 2. pure配置文件的修改： 打开主题根目录下的_config.yml配置文件： （1）配置站点左边的主目录: 1234567891011# menumenu: Home: . Archives: archives # 归档 # categories指代博客根目录的source下的categories文件夹,可进行相关配置,下同 Categories: categories # 分类 Tags: tags # 标签 Repository: repository # github repositories #Books: books # 豆瓣书单 Links: links # 友链 About: about # 关于 单个目录界面的相关配置可在博客根目录的source下的同名文件夹中进行配置 （2）配置站点标题: 1234567891011# Sitesite: logo: enabled: true width: 40 height: 40 url: ../images/logo.png title: 𝚲𝚳𝚲的博客 # 页面title favicon: ../favicon.ico board: &lt;p&gt;欢迎交流与分享经验!&lt;/p&gt; # 站点公告 copyright: true # 底部版权信息 （3）配置主题颜色: 1234567891011# configconfig: skin: theme-black # 主题颜色 theme-black theme-blue theme-green theme-purple layout: main-center # 布局方式 main-left main-center main-right toc: true # 是否开启文章章节目录导航 menu_highlight: false # 是否开启当前菜单高亮显示 thumbnail: false # 缩略图 ，enable posts thumbnail, options: true, false excerpt_link: Read More #New isNewTabLinks: false #是否链接打开新标签页 autoUnfold: true # 默认展开文章目录 （4）配置页码信息: 123456789# Paginationpagination: number: true prev: alwayShow: true next: alwayShow: true midSize: 2 # 当前页码左右到省略号显示的页码数，默认2，表现为 1 ... 4 5 6 7 8 ... 10 showContent: true # 页面文章小于2篇时显示文章内容 （5）配置页面右侧栏目 123456789# Sidebar 页面右侧栏目设置sidebar: rightwidgets: - board - category - tag # - tagcloud #隐藏“标签云” - archive - recent_posts （6）配置打赏信息 1234567891011# Donatedonate: enable: true # 微信打赏 wechatpay: qrcode: images/donate/wechatpayimg.png # 在主题目录的source文件夹中进行图片的设定 title: 微信支付 # 支付宝打赏 alipay: qrcode: images/donate/alipayimg.png # 在主题目录的source文件夹中进行图片的设定 title: 支付宝 （7）配置是否启用分享功能 123456# Share# weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedinshare: enable: false # true是否启用分享 sites: weibo,qq,wechat,facebook,twitter # PC端显示的分享图标 mobile_sites: weibo,qq,qzone # 移动端显示的分享图标 （7）开启搜索功能 1234# Searchsearch: insight: true # 内置搜索功能, baidu: false # 百度搜索功能,不可以同时使用 **（8）配置“项目”导航栏 ** 12345# Repository Info (This will override &#x27;github&#x27; option)# 项目仓库信息（将会覆盖 github 项）repository: platform: gitee # 托管平台（github | gitee） username: lmlpla # 用户名 （9）关闭评论功能 Valine一个无后端的评论框工具，其依赖于 Leancloud 开发，所以使用前需要先注册 Leancloud 账号Valine配置 12345678910111213141516comment: # type: valine # 启用哪种评论系统 valine: # Valine官方地址: https://valine.js.org appid: # 你的 leancloud 应用 appid appkey: # 你的 leancloud 应用 appkey notify: true # 是否开始评论邮件提醒, 教程: https://github.com/xCss/Valine/wiki verify: false # 是否开始验证码功能, 开始邮件提醒会自动开启验证码功能 placeholder: 说点什么... # 输入框默认内容 avatar: mm # 头像展示方式, 具体设置项教程: https://valine.js.org/configuration.html#avatar meta: nick,mail,link # 自定义评论信息 pageSize: 10 # 评论列表分页 lang: zh-cn, # 多语言支持 zh-cn | en visitor: true # 文章阅读量统计: https://valine.js.org/visitor.html highlight: true # 代码高亮 recordIP: true # 记录评论者的IP (10) 开启文章字数统计以及阅读时长预计 12345# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 （11）文章下面的个人信息修改 1234567891011# profileprofile: enabled: true # Whether to show profile bar articleSelfBlock: false # 关闭文章下方的自我介绍 avatar: images/avatar.jpg gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: 𝚲𝚳𝚲 #𝓵𝓶𝓵 author_title: ◙ author_description: 业精于勤，荒于嬉；行成于思，毁于随！ location: Shenzhen, China follow: （12）左下角链接设置 123456789101112# Social Links 左下角链接 social: links: gitee: https://gitee.com/lmlpla #github: https://github.com/cofess #weibo: http://weibo.com/cofess #twitter: https://twitter.com/iwebued # facebook: / # dribbble: / #behance: https://www.behance.net/cofess rss: atom.xml link_tooltip: true # enable the social link tooltip, options: true, false （13）“关于”导航页面的右侧栏目设置 12345678910# My Skills 技能 skills: Git: ★★☆☆☆ Java: ★★★☆☆ Javascript: ★☆☆☆☆ Vue: ★★☆☆☆ #HTML+CSS: ★★★☆☆ #Bootstrap: ★★★☆☆ #ThinkPHP: ★★★☆☆ #平面设计: ★★★☆☆ （14）“关于”导航页面的右侧栏目设置 1234567# My Personal Links 联系我链接 links: Gitee: https://gitee.com/lmlpla Blog: https://lmlpla.gitee.io/blog/ #微博: http://weibo.com/cofess #花瓣: http://huaban.com/cofess #Behance: https://www.behance.net/cofess （15）“关于”导航页面的右侧栏目设置 1234567# My Personal Labels 打标签 labels: - 音乐街舞 - 摄影生活 - - - （16）关闭不需要的设置 123456789# My Personal Works #works: # name: # link: http://www.example.com # date: 2016 # My Personal Projects #projects: # cofess/gulp-startpro: https://github.com/cofess/gulp-startpro #cofess/hexo-theme-pure: https://github.com/cofess/hexo-theme-pure （17）添加背景动画背景动画基于canvas，在themes&#x2F;pure&#x2F;layout&#x2F;layout.ejs的中面添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; （18）修改左下角的站点创建时间（直接用VS Code打开，在主题目录中搜索 publishby） （19）友情链接的配置: 选择博客根目录下 &#x2F;source&#x2F;_data&#x2F; 中的links.yml配置文件，可仿照其中样例进行配置 1234gentryhuang: link: https://gentryhuang.com/ avatar: ../images/gentryhuang-logo.png desc: 脚踏实地,步步为营 (20) 修改关于页面 找到\\blog\\source\\about\\index.md文件，添加样式 1234567891011121314151617181920212223242526272829---title: 关于我description: 集齐龙珠，召唤神兽！layout: aboutcomments: falsesidebar: custom---​```txt/**** * ┏┓ ┏┓ * ┃ ┃ + +* ┃ ━ ┃ ++ + + +* ████━████┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问我的博客* ┃ ┃ + * ┃ ┻ ┃ + + * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽护体，永无bug * ┃ ┃ +* ┃ ┗━━━┓+* ┃ ┣┓ 📬 联系我：lmle_mail@163.com* ┃ ┏┛ + + * ┗┓┓┏━┳┓┏┛ +* ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */​``` 三、更新站点，查看效果 在博客文件夹下打开git bash命令行窗口依次使用如下指令： 123hexo cleanhexo ghexo s 启动服务后：进入本地浏览器输入:http://localhost:4000/ 进行查看 四、效果𝚲𝚳𝚲的博客 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客（二）：Hexo部署到 Gitee","slug":"搭建个人博客（二）：Hexo部署到 Gitee","date":"2019-09-17T04:00:00.000Z","updated":"2024-06-16T01:37:21.407Z","comments":true,"path":"2019/09/17/搭建个人博客（二）：Hexo部署到 Gitee/","link":"","permalink":"https://protonlml.github.io/2019/09/17/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AHexo%E9%83%A8%E7%BD%B2%E5%88%B0%20Gitee/","excerpt":"","text":"搭建个人博客（二）：Hexo部署到 Gitee一、新建 Gitee 仓库 新建的仓库，先不要初始化，同时仓库名要和本地博客所在文件夹名称相同。 没有初始化的仓库有命令提示 二、本地博客文件夹中使用git命令，将本地文件推送到远程仓库 1. 本地文件夹内删除已有的 .gite文件 使用Gitbash窗口 运行 如下命令，将本地文件夹绑定到远程仓库上去 12345git init git add .git commit -m &quot;first commit&quot;git remote add origin https://gitee.com/lmlpla/xxxx.git # xxxx指远程仓库名字git push -u origin &quot;master&quot; 刷新远程仓库，就可以看见本地博客文件被推送到仓库中去了 2.远程仓库创建新的分支hexo 3.设置hexo分支为默认分支 （目的是为了保存hexo博客的源文件，迁移主机，随时拉取就可以使用，再master分支上进行hexo d 命令推送编译后的文件会默认到hexo分支上） 4.使用Sourcetree管理本地博客 三、在 Gitee 中添加 SSH 公钥 使用SSH公钥可以让你在你的电脑和 Gitee 通讯的时候使用安全连接（Git的Remote要使用SSH地址） &#x3D;&#x3D;如果之前gitee上面已经添加过，就跳过第三步&#x3D;&#x3D; 检查本地电脑上是否已有 SSH，在本地打开 git bash 命令行窗口，输入以下命令1cd ~/.ssh 如果没有，显示1bash: cd: /c/Users/Administrator/.ssh: No such file or directory 如果有的话，标识本地已经有创建过的 SSH key 了 1.如果本地没有就创建 SSH key 运行如下命令 最后一个参数替换为自己的 注册Gitee时使用的邮箱，然后直接回车两次1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 2.找到生成的.ssh文件，打开将内部的公钥复制下来 3.测试 SSH 连接 输入命令 1ssh -T git@gitee.com 会得到如下输出，询问是否确认连接，输入yes回车确认 123The authenticity of host &#x27;gitee.com (180.97.125.228)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc.Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 最后连接成功会看到如下输出 12Warning: Permanently added &#x27;gitee.com,180.97.125.228&#x27; (ECDSA) to the list of known hosts.Hi dulily! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access. 在 Gitee 中添加 SSH 公钥 先在 C 盘指定目录中找到 id_rsa_pub 文件，复制内容然后打开 gitee 个人设置里面的 安全设置 - SSH公钥，标题可以随便取，把粘贴的内容复制到公钥里面，点击确定就可以 四、本地修改 _config.yml 修改hexo博客根目录中的配置文件_config.yml 安装 hexo-deployer-git（master分支操作）1npm install hexo-deployer-git --save 推送博客目录到远程 Gitee（master分支操作）12hexo g hexo d 这时候，远程仓库的 blog 目录下的文件(并且在hexo分支上会被更新一遍) 五、开启 Gitee Pages 服务 后期，如果更新了文章，使用 hexo g -d 命令就可以直接推送到远程hexo分支了，然后再更新一下就可以访问到新的博客文章 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客(一)：Hexo本地的使用和配置","slug":"搭建个人博客(一)：Hexo本地的使用和配置","date":"2019-09-17T03:00:00.000Z","updated":"2024-06-15T06:14:53.274Z","comments":true,"path":"2019/09/17/搭建个人博客(一)：Hexo本地的使用和配置/","link":"","permalink":"https://protonlml.github.io/2019/09/17/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E4%B8%80)%EF%BC%9AHexo%E6%9C%AC%E5%9C%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"搭建个人博客(一)：Hexo本地的使用和配置一，准备工作1.了解hexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2. 搭建博客之前,需要安装几个工具 2.1 git版本控制工具 Git是一个免费的、开源的版本控制软件。在Windows上安装git，一般为msysgit，官方下载地址 :http://code.google.com/p/msysgit/downloads/list安装步骤下一步即可…最后在-shell窗口中输入命令 git --version 检查安装是否成功 2.2 Node.js环境 安装nodejs在官网上面，下载绿色的zip包 最好安装node-v18.16.1-win-x64.7z 详情请看本站文章“nodejs安装教程” 𝚲𝚳𝚲的博客 (gitee.io) 3.安装hexo,下载hexo 搭建博客 创建一个 Blog文件夹，在这个文件夹中,使用Git窗口,依次执行下面的命令 12345npm install -g hexo-cli # 安装hexo客户端hexo init #初始化hexonpm i #安装npm工具 hexo g # 生成hexo s # 启动服务 &#x3D;&#x3D;（注意：下载后文件夹中有.git文件夹，给删除掉，后面要上传到自己的远程仓库，进行版本控制。）&#x3D;&#x3D; 二、启动后存在的问题 1.启动hexo 创建成功后 ，浏览器 “localhost 已拒绝连接。” 不是端口问题，4000端口打不开,是因为你是从git窗口里复制的,或者直接点击的。 在url地址栏里面重新敲 localhost:4000 就行了，或者 127.0.0.1:4000 2.启动后能正常访问，访问发现白屏了，什么也没有 主要原因是 nodejs版本不兼容 导致在public文件夹下index.html文件是空白的。 重新安装nodejs 推荐node-v16.19.1-win-x64-&gt;nodejs安装教程：𝚲𝚳𝚲的博客 (gitee.io) 然后在本地启动查看结果。localhost:4000查看能不能访问, Ctrl+C 停止本地服务 重启本地服务,要先 hexo clean 清理缓存 hexo g 生成 hexo s 启动本地服务查看本地,能不能将这个项目跑起来 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"UML类图","slug":"UML类图","date":"2019-09-10T03:00:00.000Z","updated":"2024-06-16T02:17:59.887Z","comments":true,"path":"2019/09/10/UML类图/","link":"","permalink":"https://protonlml.github.io/2019/09/10/UML%E7%B1%BB%E5%9B%BE/","excerpt":"","text":"UML类图用于表示类、接口、实例等之间相互的静态关系。虽然名字叫类图，但类图中并不只有类，还可能包括权限、属性、方法等 2.1 类图关系 设计模式中的对象关系: 依赖关系 虚线箭头，箭头方向指向被依赖的部分 组合关系 实心菱形 聚合关系 空心菱形（想象成盘子，盛东西，盘子的多，另一方少） 关联关系 实线箭头，箭头指向被关联的部分 类与类的连接，（它使一个类知道另一个类的属性和方法，关联关 系一般用成员变量实现） 继承 空心三角形实线 实现 空心三角形虚线 注意： 实现接口有两种方式，一种是棒棒糖的形式，另一种是虚线空心三角形的方式 &#x3D;&#x3D; UML记忆&#x3D;&#x3D; 1. uml箭头：从子类指向父类，只有知道对方信息时才能指向对方方向2. 空心三角箭头：继承或实现，实线-继承：积极的，强关联，关联，通常一个类中有一个类的对象做属性；虚线-实现：消极的，弱关联，依赖3. 空心菱形：聚合，（注：可以看作一个盘子，可以放很多相同的东西（箭头方向所指的类），聚在一起。是has a的关系）弱关联4. 实心菱形：组合，（注：代表器皿里有实体结构存在，组合起来成为一个。是contains-a的关系）强关联 1.uml箭头：从子类指向父类，定义子类时需要通过extends关键字指定父类，只有知道对方信息时才能指向对方方向实线-继承虚线-实现 2.空心菱形-聚合(可以看作一个盘子，可以放很多相同的东西（箭头方向所指的类），聚在一起。是has a的关系）弱关联) 3.实心菱形-组合 4.组合关系中常见的数字表达 ◆常见数字表达及含义，假设有A类和B类，数字标记在A类侧◆0..1：0或1个实例 在系统某一时刻，b的实例可以与0个或1个A实例相关◆0..*：0或多个实例 在系统某一时刻，b的实例可以与0个或多个A实例相关◆1..1：1个实例. b的实例可以和1个A实例相关◆1只能有一个实例. b的实例可以和1个A实例相关◆1..*：至少有一个实例. b实例可以与一个或多个A实例相关 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"UML类图","slug":"UML类图","permalink":"https://protonlml.github.io/tags/UML%E7%B1%BB%E5%9B%BE/"}],"author":"𝚲𝚳𝚲"},{"title":"nodejs安装教程","slug":"nodejs安装教程","date":"2019-09-07T01:00:00.000Z","updated":"2024-06-16T14:59:49.365Z","comments":true,"path":"2019/09/07/nodejs安装教程/","link":"","permalink":"https://protonlml.github.io/2019/09/07/nodejs%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"一、下载nodejs Node.js 中文网 (nodejs.com.cn) 下载zip包，直接解压无须安装，node-v18.16.1-win-x64.7z 解压到C:\\Program Files\\nodejs 目录下 同时创建node_global和node_cach两个文件夹。 二、配置环境变量 1.系统变量下新建NODE_PATH 1C:\\Program Files\\nodejs\\node_global\\node_modules 2.系统变量path中添加如下 123%NODE_PATH%C:\\Program Files\\nodejsC:\\Program Files\\nodejs\\node_global 3.更改用户path变量 这里我们需要将其中默认的C:\\Users\\用户名\\AppData\\Roaming\\npm更改为： 1C:\\Program Files\\nodejs\\node_global 三、修改配置在nodejs文件夹下使用GitBash进行命令配置 1.关闭代理以及配置淘宝镜像123npm config set proxy nullnpm config set https-proxy nullnpm config set registry https://registry.npmmirror.com 查看是否修改成功 1npm config get registry 2.配置默认目录12npm config set prefix &quot;C:\\Program Files\\nodejs\\node_global&quot;npm config set cache &quot;C:\\Program Files\\nodejs\\node_cache&quot; 3.设置权限1npm config set strict-ssl false 4.查看所有设置1npm config ls 四、查看安装版本12node -v npm -v 五、测试是否配置成功 安装vue插件 1npm install -g vue 六、npm install安装失败常见问题的解决办法小结 有时候前端安装npm install 安装包总是安装不上,下面这篇文章主要给大家介绍了关于npm install安装失败常见问题的解决办法,文中通过实例代码介绍的非常详细,需要的朋友可以参考下 显示当前的镜像地址1npm get registry 1. 安装cnpm 1npm install -g cnpm --registry=http://registry.npmmirror.com 安装完之后可以通过cnpm -v 检验是否安装成功。 2.cnpm install安装依赖1cnpm install 在运行cnpm install中,你可以会遇到cnpm:无法加载文件C:Users\\57883 AppData\\Roaming\\npm\\cnpm.ps:因为在此系统上禁止运行脚本的错误.解决方法: 在系统中搜索框输入Windos PowerShell 点击”管理员身份运行” ·输入”set-ExecutionPolicy RemoteSigned’”▣车 ·根据提示,输入A,回车 ·再次回到cnpm-v执行成功. ps:不只是cnpm命令,包括pnpm、yarn等这些命令,如果执行时,报这样的错误,都可以通过此方法解决.前提是,如果是用npm命令来安装这些CLI命令工具,必须安装到全局环境中,才能生效. npm install node-sass 报错如何解决呢? node 与node-sass版本不兼容导致安装依赖失败 解决办法： &#x2F;&#x2F;查看node版本 node-v &#x2F;&#x2F; –save-dev自动将node-sass加入到项目文件夹下的package.json中。 cnpm install –save-dev node-sass 附：npm install命令一直失败的坑执行npm install命令一直失败，报错主要原因如下：reason: getaddrinfo EAI_AGAIN registry.npmjs.org 异常分析 1.解决代理问题123npm config set proxy nullnpm config set https-proxy nullnpm config set registry https://registry.npmmirror.com 2.所以大家可以把上面语句执行一遍试一下，还有要把权限执行下面语句1npm config set strict-ssl false 3.如果还不行，建议大家更换vscode，node版本，我使用的是：12node-v10.12.0-x64VSCodeUserSetup-x64-1.54.3 换网络改为移动网络试试 参考：npm install安装失败常见问题的解决办法小结_node.js_脚本之家 (jb51.net) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://protonlml.github.io/categories/nodejs/"}],"tags":[{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"npm","slug":"npm","permalink":"https://protonlml.github.io/tags/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"https://protonlml.github.io/tags/nodejs/"}],"author":"𝚲𝚳𝚲"}],"categories":[{"name":"新年快乐","slug":"新年快乐","permalink":"https://protonlml.github.io/categories/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"},{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"},{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"},{"name":"maven","slug":"java/maven","permalink":"https://protonlml.github.io/categories/java/maven/"},{"name":"搭建图床","slug":"搭建图床","permalink":"https://protonlml.github.io/categories/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"},{"name":"nodejs","slug":"nodejs","permalink":"https://protonlml.github.io/categories/nodejs/"}],"tags":[{"name":"春节挂件","slug":"春节挂件","permalink":"https://protonlml.github.io/tags/%E6%98%A5%E8%8A%82%E6%8C%82%E4%BB%B6/"},{"name":"技巧优化","slug":"技巧优化","permalink":"https://protonlml.github.io/tags/%E6%8A%80%E5%B7%A7%E4%BC%98%E5%8C%96/"},{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"matery主题","slug":"matery主题","permalink":"https://protonlml.github.io/tags/matery%E4%B8%BB%E9%A2%98/"},{"name":"经验","slug":"经验","permalink":"https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"maven","slug":"maven","permalink":"https://protonlml.github.io/tags/maven/"},{"name":"项目自动化构建工具","slug":"项目自动化构建工具","permalink":"https://protonlml.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"},{"name":"javaScript","slug":"javaScript","permalink":"https://protonlml.github.io/tags/javaScript/"},{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"运算符","slug":"运算符","permalink":"https://protonlml.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"},{"name":"图床","slug":"图床","permalink":"https://protonlml.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Picgo","slug":"Picgo","permalink":"https://protonlml.github.io/tags/Picgo/"},{"name":"Alist","slug":"Alist","permalink":"https://protonlml.github.io/tags/Alist/"},{"name":"UML类图","slug":"UML类图","permalink":"https://protonlml.github.io/tags/UML%E7%B1%BB%E5%9B%BE/"},{"name":"npm","slug":"npm","permalink":"https://protonlml.github.io/tags/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"https://protonlml.github.io/tags/nodejs/"}]}