{"meta":{"title":"Hexo","subtitle":"","description":"","author":"𝚲𝚳𝚲","url":"https://protonlml.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-06-15T06:14:52.776Z","updated":"2024-06-15T06:14:52.776Z","comments":false,"path":"/404.html","permalink":"https://protonlml.github.io/404.html","excerpt":"","text":""},{"title":"关于我","date":"2024-06-15T06:14:53.350Z","updated":"2024-06-15T06:14:53.350Z","comments":false,"path":"about/index.html","permalink":"https://protonlml.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718/** ┏┓ ┏┓ * ┃ ┃ + +* ┃ ━ ┃ ++ + + +* ████━████┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问我的博客* ┃ ┃ + * ┃ ┻ ┃ + + * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽护体，永无bug * ┃ ┃ +* ┃ ┗━━━┓+* ┃ ┣┓ 📬 联系我：lmle_mail@163.com* ┃ ┏┛ + + * ┗┓┓┏━┳┓┏┛ +* ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */"},{"title":"书单","date":"2024-06-15T06:14:53.352Z","updated":"2024-06-15T06:14:53.352Z","comments":false,"path":"books/index.html","permalink":"https://protonlml.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-06-15T06:14:53.353Z","updated":"2024-06-15T06:14:53.353Z","comments":false,"path":"categories/index.html","permalink":"https://protonlml.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-06-15T06:14:53.358Z","updated":"2024-06-15T06:14:53.358Z","comments":true,"path":"links/index.html","permalink":"https://protonlml.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-06-15T06:14:53.360Z","updated":"2024-06-15T06:14:53.360Z","comments":false,"path":"repository/index.html","permalink":"https://protonlml.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-06-15T06:14:53.362Z","updated":"2024-06-15T06:14:53.362Z","comments":false,"path":"tags/index.html","permalink":"https://protonlml.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"悬挂年兽 喜增龙年","slug":"博客搭建/挂年兽","date":"2024-01-01T03:00:00.000Z","updated":"2024-07-23T14:06:32.241Z","comments":true,"path":"2024/01/01/博客搭建/挂年兽/","link":"","permalink":"https://protonlml.github.io/2024/01/01/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%8C%82%E5%B9%B4%E5%85%BD/","excerpt":"","text":"换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码 摘要 这篇文章介绍了一个在博客网站右上角添加悬挂年兽的方法。通过在CSS代码中插入相应的素材链接，可以实现在网站右上角挂上一个龙的效果。对于自定义主题的网站，可以将相关的CSS和HTML代码添加到自定义头部中。对于全屏网站，建议在CSS代码的16行左右插入一行代码以实现相应效果。 一、简介-教程 换新颜新气象，给网站右上角挂一个龙，吸吸龙气 css第6行放入下面素材链接（本站开了防盗所以给你也无用就放下面了） 如果你的主题是自定义，那就是主题设置自定义里面 自定义css 1234567891011121314151617181920212223242526@media screen and (min-width: 850px)&#123; .NewYear &#123; width: 260px; height: 300px; display: inline-block; background: url(https://img.ly522.com/LY/uploads/2023/12/longgyaj.gif) no-repeat 50%/100%; vertical-align: middle; position: fixed; left: 85.8%; top: 55px; z-index: 50; cursor: pointer; animation: new-year 1.2s ease-in-out 0s infinite alternate; margin-left: -1px; transform-origin: 50% 0; pointer-events: none; &#125; &#125; @keyframes new-year&#123; 0% &#123; transform: rotate(10deg); &#125; 100%&#123; transform: rotate(-10deg); &#125; &#125; html放到你的自定义头部html即可！！ 1&lt;div class=&quot;NewYear&quot;&gt;&lt;/div&gt; 注意：如果你的是全屏网站建议在pointer-events: none;下面加一行。即css代码16行左右哪里加 1z-index: 999; 演示图 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！ ​","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"matery主题的使用","slug":"博客搭建/matery主题的使用","date":"2020-03-17T03:00:00.000Z","updated":"2024-06-16T02:11:38.377Z","comments":true,"path":"2020/03/17/博客搭建/matery主题的使用/","link":"","permalink":"https://protonlml.github.io/2020/03/17/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/matery%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"matery主题的使用一、下载matery主题 1.GitHub源项目 GitHub - blinkfox&#x2F;hexo-theme-matery: 一个基于材料设计和响应式设计而成的全面、美观的Hexo主题。 2.在本地clone下来 1git clone https://github.com/blinkfox/hexo-theme-matery.git 二、配置hexo根yml文件 三、自定义主题 1.修改导航名称和路径图标 添加导航二级菜单的写法（如下是“关于”一级菜单修改） 注意：1.菜单导航名称可以是中文也可以是英文(如：Index或主页) ​ 2.图标icon 可以在Font Awesome 中查找 ,线上的 1234567891011About: url: /about # icon: fas fa-user-circle 注释掉原来的，加上下面这一段 icon: fas fa-list children: - name: 爱的颜色 url: /love icon: fas fa-heart - name: 生日快乐 url: /birthday icon: fas fa-cake 2.手机二级菜单配置123navMenu: mleft: true # 二级侧栏子菜单是否对齐左边 bgColor: &quot; &quot; # 二级侧栏子菜单背景颜色,留空即为全局背景色 3.首页中间右侧 banner1234githubLink: enable: true # 是否开启 url: https://github.com/sitoi/sitoi.github.io # GitHub 仓库地址 title: Fork Me # 显示文字 4.首页轮播图相关配置123456cover: showPrevNext: false # 是否显示左右切换按钮 showIndicators: false # 是否显示指示器 autoLoop: false # 是否自动轮播 duration: 120 # 切换延迟时间，默认单位 秒 intervalTime: 5000 # 自动切换下一张的间隔时间 参考： Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐 (blinkfox.github.io) 基于 Hexo GitHub 从零开始搭建个人博客（三）：Matery 主题（DIY 版）详细配置教程，附博客源码 | Sitoi (๑•̀ㅂ•́) ✧被发现了～ (sunhwee.com) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"matery主题","slug":"matery主题","permalink":"https://protonlml.github.io/tags/matery%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"spring","slug":"框架/1.spring","date":"2019-12-31T17:00:00.000Z","updated":"2025-01-17T14:42:05.995Z","comments":true,"path":"2020/01/01/框架/1.spring/","link":"","permalink":"https://protonlml.github.io/2020/01/01/%E6%A1%86%E6%9E%B6/1.spring/","excerpt":"","text":"spring 1、spring理解​ spring是一系列的框架合集，这里的spring指的是狭义上的spring,指的是SpringFramework，他是spring的核心 2 、使用spring框架IOC 容器，控制反转的意思就是，将创建对象new 的动作，交给了spring ，创建了对象，全部都放在IOC容器中 ，是一个map&lt;Clsss,name&gt; 使用spring就是将new 对象这个代码 ，不写死在代码中了， 创建对象，全部都交给spring 来管理 2.1 使用spring框架的步骤1.引入依赖 2.创建配置文件 2.1 使用xml配置文件方式，管理对象 3.、启用Log4j2日志框架为什么要启用log4J2的日志框架？ 因为，spring启动或者运行在控制台显示的日志几乎没有，加入这个框架，在spring启动或者程序运行时，能更好的对spring进行监控，在控制台上面查看spring运行情况！ 3.1 引入log4j2的依赖 1234567891011&lt;!--log4j2的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt; 3.2 、加入日志配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;loggers&gt; &lt;!-- level指定日志级别,从低到高的优先级: TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL trace:追踪,是最低的日志级别,相当于追踪程序的执行 debug:调试,一般在开发中,都将其设置为最低的日志级别 info:信息,输出重要的信息,使用较多 warn:警告,输出警告的信息 error:错误,输出错误信息 fatal:严重错误 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;spring6log&quot;/&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;log&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=&quot;spring6log&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t]%-3level %logger&#123;1024&#125; - %msg%n&quot;/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息,这个log每次运行程序会自动清空,由append属性决定, 适合临时测试用--&gt; &lt;File name=&quot;log&quot; fileName=&quot;d:/spring6_log/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125;%L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的信息, 每次大小超过size, 则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩, 作为存档--&gt; &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;d:/spring6_log/app.log&quot; filePattern=&quot;log/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&#125;%-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;50MB&quot;/&gt; &lt;!-- DefaultRolloverStrategy属性如不设置, 则默认为最多同一文件夹下7个文件,这里设置了20 --&gt; &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt;&lt;/configuration&gt; 3.3正常启动项目，执行程序，在控制台就可以看见spring的日志了 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"框架","slug":"框架","permalink":"https://protonlml.github.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://protonlml.github.io/tags/spring/"}],"author":"𝚲𝚳𝚲"},{"title":"Maven","slug":"java基础/Maven","date":"2019-10-10T03:00:00.000Z","updated":"2024-06-16T02:15:54.402Z","comments":true,"path":"2019/10/10/java基础/Maven/","link":"","permalink":"https://protonlml.github.io/2019/10/10/java%E5%9F%BA%E7%A1%80/Maven/","excerpt":"","text":"Maven 一、Maven的一些理解 1.项目的构建，是指项目的“打包”，“编译”，“部署”，“运行”等一系列操作。 2.用Maven就可以使我们的项目，能够自动化构建。 3.maven是java项目的自动化构建工具。 4.Maven可以，将一个大型的项目的不同功能，拆分成多个模块，分别进行开发管理。 5.Maven可以，通过配置poom文件，来导入某个技术的jar包，同时会自动的导入这个jar包的相关依赖jar包。 二、Maven程序的执行原理 maven核心程序指的是，解压后的maven程序目录。也是maven软件的目录里面的内容。 Maven在自动构建项目的时候，使用插件会在本地仓库中找，使用依赖jar包也在本地仓库中找。本地找不到就到中央仓库中下载。 怎么使用maven？（不用开发工具） 创建一个maven规定的项目目录结构，在有poom.xml文件的目录下面，执行maven命令 当我们执行的Maven命令需要用到某些插件的时候，Maven核心程序会首先到本地仓库中查找 本地仓库的默认位置：[系统当前用户的家目录].m2\\repository(Maven找插件的时候，自动创建) Maven核心程序如果在本地仓库中找不到需要的插件的时候，那么它会自动联网，到中央仓库中下载。 Maven的生命周期就是指的是“项目的构建过程”，项目的构建是有顺序的，执行的任何一个Maven命令都是从生命周期的头开始。 Maven构建项目完成之后，生成的“产品”就放在“项目src所在目录”中的“target”目录中。 Pom 【1】含义：project Object Model 项目对象模型。 pom.xml对于Maven工程师核心配置文件，与构建过程相关的一切设置都在这个文件中进行 Maven坐标类比一下： 数学中可以用（x,yz）三个项量来确定一个空间的点。 Maven的pom文件中，也是使用三个项量，来在仓库中唯一定位一个Maven工程 [1]：groupid：公司或组织域名倒序+项目名 1&lt;groupId&gt;cn.itcast&lt;/groupId&gt; [2]：artifactid：模块名 [3]：version：版本 只要讲“gav”就讲的是Maven的坐标。 [4] :Maven工程的坐标与仓库中的路径对应关系。 在Maven仓库里面。每一个Maven工程，他的坐标一定是不重复的，即标识了这个Maven工程信息，同时也决定了他在仓库中存放的目录是什么。 仓库中保存的内容：宽泛的说就是（Maven工程项目） 主要有3大块： -[1]：Maven核心软件，自身所需要的一些插件 [2]：第三方框架或工具的jar包(其实就是第三方项目，打成了jar包) [3]：我们自己开发的工程。Maven将“插件”、“框架jar包”、“我们自己的项目”都用统一的目录结构，放在了仓库中，这样就方便Maven核心程序的管理和使用。 pom.xml文件解析。 创建的Maven项目中有pom.xml文件，他是Maven项目的核心配置文件。 【1】.除了上面三个坐标用来，定位当前项目用Maven核心程序安装在仓库中的位置。 2】.中间部分是“依赖部分”，就是指当前项目，所使用的到的“其他模块项目和jar包”，在Maven仓库中的坐标。如果仓库中没有指定的依赖jar包，就会自动从私服上面下载，私服上面没有就会到中央仓库中下载。 但是如果当前项目，用到我们自己写的模块，这时候就需要将，要使用的模块项目给“安装”到仓库中，用“ mvn install”命令进行安装。是不可能从网上下载的，因为这是我们自己写的，不是第三方jar包项目。这样我们就可以将一个大的项目，进行拆分成很多小的模块，然后各个模块之间用“依赖坐标”，来互相关联。 【3】最下面是“插件”部分。 依赖 ①Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。 对于我们自己开发的Maven工程，使用mvn install命令安装后就可以进入仓库。 ②依赖的范围 【1】在pom.xml文件中依赖的范围 依赖的范围一般常用的有三个：compile，test、provided三个。 依赖范围：意思就是，当前项目所依赖的这个“依赖”，在编译，测试，打包。过程当中时候有效。 [1]compile范围的“依赖”（编译范围） 对主程序是否有效：有效 对测试程序是否有效：有效 是否参与打包：参与 是否 参与部署：参与 [2]test范围的“依赖”（测试范围） 对主程序是否有效：无效 对测试程序是否有效：有效 是否参与打包：不参与 是否参与部署：不参与 典型例子：“junit依赖”它就是测试依赖，这个jar包，不参与打包，在主程序中没有。 [3]provided范围的“依赖”，通常是为web工程来添加的（不参与部署的范围）。 说明只要加了provided范围的“依赖”，web容器中都有。比如：servlet的这个依赖，部署的时候就不需要，因为Tomcat服务器本身就有servlet的jar包。 对主程序是否有效：有效 对测试程序是否有效：有效 是否参与打包：不参与 是否参与部署：不参与 典型例子：servlet-api.jar maven命令是什么？ maven这个程序，用来构建项目所使用的命令。（这些命令的顺序，就是生命周期的顺序） 比如【1】清理：mvn clean 【2】：编译主程序：mvn compile 【3】：编译测试程序：mvn test-compile 【4】：执行测试：mvn test 【5】：打包：mvn package 【6】：安装：mvn install 【7】：生成站点：mvn site这些命令，构成了Maven构建项目时的，不同生命周期， 12.Maven的生命周期 【1】意思：就是Maven构建项目的的，各个构建环节执行的顺序。：不能打乱顺序，必须按照既定的正确顺序来执行，是生命周期的各个阶段的命令来实现的。 【2】生命周期是在Maven的核心程序中定义了，抽象的生命周期。 生命周期中各个阶段的具体任务是由插件来完成的。 【3】有三套独立的生命周期： ①Clean Lifecycle（清理生命周期）在进行，在真正的构建一个项目之前，必须先进行一些清理工作。 ②Default lifecycle（默认的生命周期）构建的核心部分，编译，测试，打包，安装，部署等等。 ③Site Lifecycle（生成站点生命周期）生成项目报告，站点，发布站点。 【4】每个生命周期的具体实现 比如：只执行“mvn clean 清理命令”就会进行清理生命周期。 执行“mvn install 安装命令”就会进行Maven构建项目的默认生命周期，此时Maven核心程序，会从头开始执行“clean清理”,“compile 编译”，“test-compile 编译测试”，“test 执行测试”，“package 打包”，“install 安装”这一系列的过程。 执行“site 生成站点”，也会从头开始，将所有过程进行一边。这是生成站点生命周期 Maven核心程序为了更好的实现自动化构建，按照这一的特点执行生命周期中的各个阶段：不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行。 【5】生命周期的各个阶段仅仅定义了要执行的任务是什么（命令）完成这个命令，是由特定的Maven插件来完成的。 创建Maven工程之前，需要将IDEA编辑器，和本地下载的Maven程序，进行关联配置。具体操作，见文末。 三、使用IDEA创建普通的javaMaven工程 四、.使用IDEA创建webMaven工程（Maven要聚合模块的做法） 【1】必须先创建一个空的工程。在空的工程中添加模块。（每次添加模块都要使用快捷键“ctrl+alt+shift+s”来调出Project Structure窗口，在这个窗口中添加模块，不能直接在模块上面右键添加模块。（在模块上右键模块会添加到“模块里面”）） 【标准的Maven工程，分模块的大型web项目，目录结构】 说明 我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。 五、依赖 依赖的传递性： 【1】依赖的传递性是指，如果在一个大型的项目当中，各个模块相互依赖，那么在“最下面的模块（依赖关系最下面，这个模块只是被依赖，不去依赖别的模块）”中，pom.xml文件里面，配置的compile”范围的依赖jar包，其他模块的pom.xml文件虽然没有声明一样的compile”范围的依赖jar包，但是也可以使用这个依赖。 【2】前提是“compile”范围的依赖才能传递，“test”“provided”范围的依赖不能传递。所以在各个工程模块中，能够传递的依赖，只在“最下面”模块中声明一次就可以了，不能够传递的“test”“provided”范围的依赖就得各个模块中重复声明依赖。比如：servlet的依赖，他就是“provided范围的模块”，需要在每一个项目模块pom.xml文件中，都要重复声明。 【3】我们在开发项目的时候，会有一个专门的模块来负责维护这些框架jar包的依赖信息的。在这个模块中，全部都写“compile”范围的依赖”，让其他功能模块，来依赖这个“专门模块”，就可以实现“compile”范围的依赖”通用。 【4】子类继承了父类模块，也可以实现依赖传递，默认就是依赖的，不需要再在子类中，重新声明依赖父类，只在子类中声明父类就可以了。 依赖的排除： 依赖的排除，在哪个工程里面排除的，就在哪个工程里面生效。 【1】当我们导入某些依赖jar包的时候，Maven会自动将这个jar的其他依赖jar包也一起导入到工程当中，这个时候，如果不需要这个额外的jar包，就可以用“排除依赖”来进行排除。 【2】找到要排除的依赖的ID（假如spring-jcl依赖要被排除） 3】添加 标签 依赖原则： 解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决） 前提是因为“依赖的传递性”导致的jar包冲突问题。 冲突情景： properties标签配合自定义标签声明数据的配置并。(可以利用这个标签，实现在一个页面上，同种类型的框架jar包，版本号相同，)在父模块中就更简便了 123456789101112131415161718&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;!--不是只能用于声明依赖的版本号。凡是需要统一声明后再引用的场合都可以使用。--&gt;&lt;/properties&gt;&lt;!--spring-core依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring-core依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 六、Mavne继承（pom文件的继承） 存在的问题：我们都知道在一个“模块项目1”中配置了“compile”范围的依赖jar包”，“其他模块项目”来依赖这个“模块项目1”的时候，“其他模块项目”中会自动的存在了“项目模块1的”“compile”范围的依赖jar包”。这是依赖的传递性。只用在“模块项目1”中声明一份就可以了。 但是：如果是““test”“provided”范围的依赖是不能传递的”，需要在每一个模块中都要，重复的手动添加““test”“provided”范围的依赖”，比如“junit依赖”，他就是“test范围的依赖”。（不能够传递的依赖，他就是零散的分散在各个模块当中，就很容易造成各个模块工程之间的版本不一致）。 这就存在一个问题，开发一个大型项目的时候，各个模块是不同开发组来开发的，使用“junit这种依赖”的时候，可能版本号就会不相同，导致各个模块之间不统一。 解决办法：使用Maven的继承，统一成同一个版本。（以junit依赖为例） 【1】专门创建一个模块是所有模块的“父模块”，可以用作““compile”范围的依赖jar包”传递依赖。也可以用作““test”“provided”范围的依赖”的版本管理。 【2】解决思路：将junit依赖统一提取到“父”工程中，在子工程中声明junit依赖时不指定版本，以父工程中统一设定的为准。同时也便于修改。 【3】操作步骤 [1]创建一个Maven工程作为父工程。注意：打包的方式pom 1234&lt;groupId&gt;com.atlml.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; [2]在子工程中声明对父工程的引用（认干爹的一个仪式） 123456789&lt;!--子工程中声明父工程--&gt;&lt;parent&gt; &lt;groupId&gt;com.atlml.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--以当前pom文件为基准的,找父工程pom.xml文件的相对路径--&gt; &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt; [3]在父工程中统一管理junit的依赖 1234567891011121314&lt;!--依赖管理，这里专门用来管理，不能够传递的依赖，进行版本号控制--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- junit是“test”范围的依赖，不能够传递，在这里面统一管理版本号--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; [4]在子工程中删除junit依赖的版本号部分 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--&lt;version&gt;4.11&lt;/version&gt;--&gt; 删除掉 &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; [5]实现效果 [6]：父模块的Pom.xml文件的配置。 七、Maven的聚合： （聚合就是Maven中，各个模块的一键安装。） 注意：配置了继承的模块，在执行安装命令（ install）的时候，要先安装 “父模块”再安装其他模块才能成功。 Maven中的一件安装，就可以自动的按顺序，将每个模块都按依赖顺序进行安装。 实现一件安装步骤： 【1】创建一个“总的聚合工程”，（一般把“父模块”作为“总的聚合工程”，大的情况下也是将，聚合的配置，也配在父模块内） 【2】在一个”总的聚合工程”的pom.xml文件中，配置各个參与聚合的模块 123456&lt;!--配置聚合--&gt;&lt;modules&gt; &lt;!--指定各个子工程的相对路径--&gt; &lt;module&gt;../Hellow&lt;/module&gt; &lt;module&gt;../HellowFriend&lt;/module&gt;&lt;/modules&gt; 八、Maven仓库地址 Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com) 仓库服务 (aliyun.com) 九、IDEA中Maven配置IDEA配置Maven的超详细步骤_java_脚本之家 (jb51.net) IDEA配置Maven（详细版）_idea maven-CSDN博客 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"},{"name":"maven","slug":"java/maven","permalink":"https://protonlml.github.io/categories/java/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://protonlml.github.io/tags/maven/"},{"name":"项目自动化构建工具","slug":"项目自动化构建工具","permalink":"https://protonlml.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}],"author":"𝚲𝚳𝚲"},{"title":"第八章 微头条项目开发","slug":"javaweb/08_第八章 微头条项目开发","date":"2019-10-08T08:00:00.000Z","updated":"2024-12-02T13:17:29.050Z","comments":true,"path":"2019/10/08/javaweb/08_第八章 微头条项目开发/","link":"","permalink":"https://protonlml.github.io/2019/10/08/javaweb/08_%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%BE%AE%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/","excerpt":"","text":"第八章 微头条项目开发一 项目简介1.1 微头条业务简介 微头条新闻发布和浏览平台,主要包含业务如下 用户功能 注册功能 登录功能 头条新闻 新闻的分页浏览 通过标题关键字搜索新闻 查看新闻详情 新闻的修改和删除 权限控制 用户只能修改和自己发布的头条新闻 1.2 技术栈介绍 前端技术栈 ES6作为基础JS语法 nodejs用于运行环境 npm用于项目依赖管理工具 vite用于项目的构建架工具 Vue3用于项目数据的渲染框架 Axios用于前后端数据的交互 Router用于页面的跳转 Pinia用于存储用户的数据 LocalStorage作为用户校验token的存储手段 Element-Plus提供组件 后端技术栈 JAVA作为开发语言,版本为JDK17 Tomcat作为服务容器,版本为10.1.7 Mysql8用于项目存储数据 Servlet用于控制层实现前后端数据交互 JDBC用于实现数据的CURD Druid用于提供数据源的连接池 MD5用于用户密码的加密 Jwt用于token的生成和校验 Jackson用于转换JSON Filter用于用户登录校验和跨域处理 Lombok用于处理实体类 1.3 功能展示 头条首页信息搜索 登录功能 注册功能 权限控制功能 发布头条功能 修改头条功能 删除头条功能 二 前端项目环境搭建 解压前端项目代码并存放到磁盘的合适位置 使用vscode打开工程 进入项目后打开集成终端或者在src上右击选择在集成终端中打开 通过 npm run dev启动前端项目 三 后端项目环境搭建3.1 数据库准备 news_users 用户表 news_type 新闻类型表 news_headline 新闻信息表 数据库创建SQL 导入资料中的top_news.sql文件即可 3.2 MVC项目架构模式 MVC（Model View Controller）是软件工程中的一种**软件架构模式，它把软件系统分为模型、视图和控制器**三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 M：Model 模型层,具体功能如下 存放和数据库对象的实体类以及一些用于存储非数据库表完整相关的VO对象 存放一些对数据进行逻辑运算操作的的一些业务处理代码 V：View 视图层,具体功能如下 存放一些视图文件相关的代码 html css js等 在前后端分离的项目中,后端已经没有视图文件,该层次已经衍化成独立的前端项目 C：Controller 控制层,具体功能如下 1. 接收客户端请求,获得请求数据2. 将准备好的数据响应给客户端 MVC模式下,项目中的常见包 M: 实体类包(pojo &#x2F;entity &#x2F;bean) 专门存放和数据库对应的实体类和一些VO对象 数据库访问包(dao&#x2F;mapper) 专门存放对数据库不同表格CURD方法封装的一些类 服务包(service) 专门存放对数据进行业务逻辑预算的一些类 C: 控制层包(controller) V: web目录下的视图资源 html css js img 等 前端工程化后,在后端项目中已经不存在了 3.3 搭建项目3.3.1 创建WEB项目 3.3.2 导入依赖 3.3.3 准备包结构 controller 控制层代码,主要由Servlet组成 service 服务层代码,主要用于处理业务逻辑 dao 数据访问层,主要用户定义对于各个表格的CURD的方法 pojo 实体类层,主要用于存放和数据库对应的实体类以及一些VO对象 util 工具类包,主要用存放一些工具类 common 公共包,主要用户存放一些其他公共代码 filters 过滤器包,专门用于存放一些过滤器 test 测试代码包,专门用于定义一些测试的功能代码,上线前应该删掉,后期用maven可以自动处理掉 3.5 准备工具类3.5.1 异步响应规范格式类 Result类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.atguigu.headline.common;/** * 全局统一返回结果类 * */public class Result&lt;T&gt; &#123; // 返回码 private Integer code; // 返回消息 private String message; // 返回数据 private T data; public Result()&#123;&#125; // 返回数据 protected static &lt;T&gt; Result&lt;T&gt; build(T data) &#123; Result&lt;T&gt; result = new Result&lt;T&gt;(); if (data != null) result.setData(data); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(T body, Integer code, String message) &#123; Result&lt;T&gt; result = build(body); result.setCode(code); result.setMessage(message); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(T body, ResultCodeEnum resultCodeEnum) &#123; Result&lt;T&gt; result = build(body); result.setCode(resultCodeEnum.getCode()); result.setMessage(resultCodeEnum.getMessage()); return result; &#125; /** * 操作成功 * @param data baseCategory1List * @param &lt;T&gt; * @return */ public static&lt;T&gt; Result&lt;T&gt; ok(T data)&#123; Result&lt;T&gt; result = build(data); return build(data, ResultCodeEnum.SUCCESS); &#125; public Result&lt;T&gt; message(String msg)&#123; this.setMessage(msg); return this; &#125; public Result&lt;T&gt; code(Integer code)&#123; this.setCode(code); return this; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; ResultCodeEnum 枚举类 12345678910111213141516171819202122232425262728package com.atguigu.headline.common;/** * 统一返回结果状态信息类 * */public enum ResultCodeEnum &#123; SUCCESS(200,&quot;success&quot;), USERNAME_ERROR(501,&quot;usernameError&quot;), PASSWORD_ERROR(503,&quot;passwordError&quot;), NOTLOGIN(504,&quot;notLogin&quot;), USERNAME_USED(505,&quot;userNameUsed&quot;) ; private Integer code; private String message; private ResultCodeEnum(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125;&#125; 3.5.2 MD5加密工具类123456789101112131415161718192021222324252627282930package com.atguigu.headline.util;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public final class MD5Util &#123; public static String encrypt(String strSrc) &#123; try &#123; char hexChars[] = &#123; &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; &#125;; byte[] bytes = strSrc.getBytes(); MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); md.update(bytes); bytes = md.digest(); int j = bytes.length; char[] chars = new char[j * 2]; int k = 0; for (int i = 0; i &lt; bytes.length; i++) &#123; byte b = bytes[i]; chars[k++] = hexChars[b &gt;&gt;&gt; 4 &amp; 0xf]; chars[k++] = hexChars[b &amp; 0xf]; &#125; return new String(chars); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;MD5加密出错！！+&quot; + e); &#125; &#125;&#125; 3.5.3 JDBCUtil连接池工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.atguigu.headline.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;public class JDBCUtil &#123; private static ThreadLocal&lt;Connection&gt; threadLocal =new ThreadLocal&lt;&gt;(); private static DataSource dataSource; // 初始化连接池 static&#123; // 可以帮助我们读取.properties配置文件 Properties properties =new Properties(); InputStream resourceAsStream = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); try &#123; properties.load(resourceAsStream); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try &#123; dataSource = DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /*1 向外提供连接池的方法*/ public static DataSource getDataSource()&#123; return dataSource; &#125; /*2 向外提供连接的方法*/ public static Connection getConnection()&#123; Connection connection = threadLocal.get(); if (null == connection) &#123; try &#123; connection = dataSource.getConnection(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; threadLocal.set(connection); &#125; return connection; &#125; /*定义一个归还连接的方法 (解除和ThreadLocal之间的关联关系) */ public static void releaseConnection()&#123; Connection connection = threadLocal.get(); if (null != connection) &#123; threadLocal.remove(); // 把连接设置回自动提交的连接 try &#123; connection.setAutoCommit(true); // 自动归还到连接池 connection.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;&#125; 添加jdbc.properties配置文件 1234567driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/top_newsusername=rootpassword=rootinitialSize=5maxActive=10maxWait=1000 3.5.4 JwtHelper工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu.headline.util;import com.alibaba.druid.util.StringUtils;import io.jsonwebtoken.*;import java.util.Date;public class JwtHelper &#123; private static long tokenExpiration = 24*60*60*1000; private static String tokenSignKey = &quot;123456&quot;; //生成token字符串 public static String createToken(Long userId) &#123; String token = Jwts.builder() .setSubject(&quot;YYGH-USER&quot;) .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration)) .claim(&quot;userId&quot;, userId) .signWith(SignatureAlgorithm.HS512, tokenSignKey) .compressWith(CompressionCodecs.GZIP) .compact(); return token; &#125; //从token字符串获取userid public static Long getUserId(String token) &#123; if(StringUtils.isEmpty(token)) return null; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token); Claims claims = claimsJws.getBody(); Integer userId = (Integer)claims.get(&quot;userId&quot;); return userId.longValue(); &#125; //判断token是否有效 public static boolean isExpiration(String token)&#123; try &#123; boolean isExpire = Jwts.parser() .setSigningKey(tokenSignKey) .parseClaimsJws(token) .getBody() .getExpiration().before(new Date()); //没有过期，有效，返回false return isExpire; &#125;catch(Exception e) &#123; //过期出现异常，返回true return true; &#125; &#125;&#125; 3.5.5 JSON转换的WEBUtil工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.headline.util;import com.atguigu.headline.common.Result;import com.fasterxml.jackson.databind.ObjectMapper;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.text.SimpleDateFormat;public class WebUtil &#123; private static ObjectMapper objectMapper; // 初始化objectMapper static&#123; objectMapper=new ObjectMapper(); // 设置JSON和Object转换时的时间日期格式 objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)); &#125; // 从请求中获取JSON串并转换为Object public static &lt;T&gt; T readJson(HttpServletRequest request,Class&lt;T&gt; clazz)&#123; T t =null; BufferedReader reader = null; try &#123; reader = request.getReader(); StringBuffer buffer =new StringBuffer(); String line =null; while((line = reader.readLine())!= null)&#123; buffer.append(line); &#125; t= objectMapper.readValue(buffer.toString(),clazz); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; return t; &#125; // 将Result对象转换成JSON串并放入响应对象 public static void writeJson(HttpServletResponse response, Result result)&#123; response.setContentType(&quot;application/json;charset=UTF-8&quot;); try &#123; String json = objectMapper.writeValueAsString(result); response.getWriter().write(json); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 3.6 准备各层的接口和实现类3.6.1 准备实体类和VO对象 NewsUser 12345678910111213141516package com.atguigu.headline.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@AllArgsConstructor@NoArgsConstructor@Datapublic class NewsUser implements Serializable &#123; private Integer uid; private String username; private String userPwd; private String nickName;&#125; NewsType 1234567891011121314package com.atguigu.headline.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@AllArgsConstructor@NoArgsConstructor@Datapublic class NewsType implements Serializable &#123; private Integer tid; private String tname;&#125; NewsHeadline 1234567891011121314151617181920212223package com.atguigu.headline.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.Date;@AllArgsConstructor@NoArgsConstructor@Datapublic class NewsHeadline implements Serializable &#123; private Integer hid; private String title; private String article; private Integer type; private Integer publisher; private Integer pageViews; private Date createTime; private Date updateTime; private Integer isDeleted;&#125; HeadlineQueryVo 1234567891011121314151617package com.atguigu.headline.pojo.vo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@AllArgsConstructor@NoArgsConstructor@Datapublic class HeadlineQueryVo implements Serializable &#123; private String keyWords; private Integer type ; private Integer pageNum; private Integer pageSize;&#125; HeadlinePageVo 123456789101112131415161718package com.atguigu.headline.pojo.vo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@AllArgsConstructor@NoArgsConstructor@Datapublic class HeadlinePageVo implements Serializable &#123; private Integer hid; private String title; private Integer type; private Integer pageViews; private Long pastHours; private Integer publisher;&#125; HeadlineDetailVo 1234567891011121314151617181920212223package com.atguigu.headline.pojo.vo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@AllArgsConstructor@NoArgsConstructor@Datapublic class HeadlineDetailVo implements Serializable &#123; private Integer hid; private String title; private String article; private Integer type; private String typeName; private Integer pageViews; private Long pastHours; private Integer publisher; private String author;&#125; 3.6.2 DAO层接口和实现类 BaseDao基础类,封装了公共的查询方法和公共的增删改方法 注意,所有的Dao接口的实现类都要继承BaseDao 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.atguigu.headline.dao;import com.atguigu.headline.util.JDBCUtil;import java.lang.reflect.Field;import java.sql.*;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;public class BaseDao &#123; // 公共的查询方法 返回的是单个对象 public &lt;T&gt; T baseQueryObject(Class&lt;T&gt; clazz, String sql, Object ... args) &#123; T t = null; Connection connection = JDBCUtil.getConnection(); PreparedStatement preparedStatement = null; ResultSet resultSet = null; int rows = 0; try &#123; // 准备语句对象 preparedStatement = connection.prepareStatement(sql); // 设置语句上的参数 for (int i = 0; i &lt; args.length; i++) &#123; preparedStatement.setObject(i + 1, args[i]); &#125; // 执行 查询 resultSet = preparedStatement.executeQuery(); if (resultSet.next()) &#123; t = (T) resultSet.getObject(1); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (null != resultSet) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; if (null != preparedStatement) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; JDBCUtil.releaseConnection(); &#125; return t; &#125; // 公共的查询方法 返回的是对象的集合 public &lt;T&gt; List&lt;T&gt; baseQuery(Class clazz, String sql, Object ... args)&#123; List&lt;T&gt; list =new ArrayList&lt;&gt;(); Connection connection = JDBCUtil.getConnection(); PreparedStatement preparedStatement=null; ResultSet resultSet =null; int rows = 0; try &#123; // 准备语句对象 preparedStatement = connection.prepareStatement(sql); // 设置语句上的参数 for (int i = 0; i &lt; args.length; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; // 执行 查询 resultSet = preparedStatement.executeQuery(); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // 将结果集通过反射封装成实体类对象 while (resultSet.next()) &#123; // 使用反射实例化对象 Object obj =clazz.getDeclaredConstructor().newInstance(); for (int i = 1; i &lt;= columnCount; i++) &#123; String columnName = metaData.getColumnLabel(i); Object value = resultSet.getObject(columnName); // 处理datetime类型字段和java.util.Data转换问题 if(value.getClass().equals(LocalDateTime.class))&#123; value= Timestamp.valueOf((LocalDateTime) value); &#125; Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(obj,value); &#125; list.add((T)obj); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (null !=resultSet) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; if (null != preparedStatement) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; JDBCUtil.releaseConnection(); &#125; return list; &#125; // 通用的增删改方法 public int baseUpdate(String sql,Object ... args) &#123; // 获取连接 Connection connection = JDBCUtil.getConnection(); PreparedStatement preparedStatement=null; int rows = 0; try &#123; // 准备语句对象 preparedStatement = connection.prepareStatement(sql); // 设置语句上的参数 for (int i = 0; i &lt; args.length; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; // 执行 增删改 executeUpdate rows = preparedStatement.executeUpdate(); // 释放资源(可选) &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (null != preparedStatement) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; JDBCUtil.releaseConnection(); &#125; // 返回的是影响数据库记录数 return rows; &#125;&#125; dao层的所有接口 12345678910111213141516package com.atguigu.headline.dao;public interface NewsHeadLineDao &#123; &#125;package com.atguigu.headline.dao;public interface NewsTypeDao &#123; &#125;package com.atguigu.headline.dao;public interface NewsUserDao &#123;&#125; dao层所有实现类 1234567891011121314151617181920package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsHeadLineDao;public class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123; &#125;package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsTypeDao;public class NewsTypeDaoImpl extends BaseDao implements NewsTypeDao&#123; &#125;package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsUserDao;public class NewsUserDaoImpl extends BaseDao implements NewsUserDao&#123; &#125; 3.6.3 Service层接口和实现类 service层所有接口 1234567891011121314package com.atguigu.headline.service;public interface NewsHeadlineService &#123; &#125;package com.atguigu.headline.service;public interface NewsTypeService &#123; List&lt;NewsType&gt; findAll();&#125;package com.atguigu.headline.service;public interface NewsUserService &#123; &#125; service层所有实现类 123456789101112131415161718package com.atguigu.headline.service.impl;import com.atguigu.headline.service.NewsHeadlineService;public class NewsHeadlineServiceImpl implements NewsHeadlineService &#123;&#125;package com.atguigu.headline.service.impl;import com.atguigu.headline.service.NewsTypeService;public class NewsTypeServiceImpl implements NewsTypeService &#123; &#125;package com.atguigu.headline.service.impl;import com.atguigu.headline.service.NewsUserService;public class NewsUserServiceImpl implements NewsUserService &#123; &#125; 3.6.4 Controller层接口和实现类 BaseController 用于将路径关联到处理方法的基础控制器 所有的Controller都要继承该类 12345678910111213141516171819202122232425262728293031323334package com.atguigu.headline.controller;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public class BaseController extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 响应的MIME类型和乱码问题 resp.setContentType(&quot;application/json;charset=UTF-8&quot;); String requestURI = req.getRequestURI(); String[] split = requestURI.split(&quot;/&quot;); String methodName =split[split.length-1]; // 通过反射获取要执行的方法 Class clazz = this.getClass(); try &#123; Method method=clazz.getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class); // 设置方法可以访问 method.setAccessible(true); // 通过反射执行代码 method.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e.getMessage()); &#125; &#125;&#125; 所有的Controller类 12345678910111213141516171819202122232425262728package com.atguigu.headline.controller;import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/headline/*&quot;)public class NewsHeadlineController extends BaseController &#123; &#125;package com.atguigu.headline.controller;import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/type/*&quot;)public class NewsTypeController &#123; &#125;package com.atguigu.headline.controller;import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/user/*&quot;)public class NewsUserController extends BaseController&#123; &#125;package com.atguigu.headline.controller;import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/portal/*&quot;)public class PortalController extends BaseController&#123; &#125; 3.7 开发跨域CORS过滤器3.7.1 什么是跨域 同源策略（Sameoriginpolicy）是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。**同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号** 3.7.2 为什么会产生跨域 前后端分离模式下,客户端请求前端服务器获取视图资源,然后客户端自行向后端服务器获取数据资源,前端服务器的 协议,IP和端口和后端服务器很可能是不一样的,这样就产生了跨域 3.7.3 如何解决跨域 前端项目代理模式处理 后端跨域过滤器方式处理 CrosFilter过滤器 12345678910111213141516171819202122232425package com.atguigu.headline.filters;import jakarta.servlet.*;import jakarta.servlet.annotation.WebFilter;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebFilter(&quot;/*&quot;)public class CrosFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpServletRequest request =(HttpServletRequest) servletRequest; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE, HEAD&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;access-control-allow-origin, authority, content-type, version-info, X-Requested-With&quot;); // 非预检请求,放行即可,预检请求,则到此结束,不需要放行 if(!request.getMethod().equalsIgnoreCase(&quot;OPTIONS&quot;))&#123; filterChain.doFilter(servletRequest, servletResponse); &#125; &#125;&#125; 未来我们使用框架,直接用一个@CrossOrigin 就可以解决跨域问题了 四 PostMan测试工具4.1 什么是PostMan Postman是一个**接口测试工具**,在做接口测试的时候,Postman相当于一个客户端,它可以模拟用户发起的各类HTTP请求,将请求数据发送至服务端,获取对应的响应结果, 从而验证响应中的结果数据是否和预期值相匹配;并确保开发人员能够及时处理接口中的bug,进而保证产品上线之后的稳定性和安全性。 它主要是用来模拟各种HTTP请求的(如:get&#x2F;post&#x2F;delete&#x2F;put..等等),Postman与浏览器的区别在于有的浏览器不能输出Json格式,而Postman更直观接口返回的结果。 4.2 怎么安装PostMan 官网下载地址: https://www.getpostman.com ,或者使用资料中提供的安装包 安装过程简单,一路next即可 第一次启动postman 会要求输入用户名和密码，如果没有的话，关闭，再次启动就可以直接进入了 4.3 怎么使用PostMan 启动PostMan后,创建一个collection,在该collection下专门存放和微头条项目相关的测试 创建完毕后,增加新的接口测试 填写要测试的接口相关的路径,参数,请求体内容等信息 测试完毕后,可以选择将该接口的测试进行保存,方便后续随时再次测试 五 登录注册功能5.1 登录表单提交 需求描述 用户在客户端输入用户名密码并向后端提交,后端根据用户名和密码判断登录是否成功,用户有误或者密码有误响应不同的提示信息 uri: 1user/login 请求方式: 1POST 请求参数 1234&#123; &quot;username&quot;:&quot;zhangsan&quot;, //用户名 &quot;userPwd&quot;:&quot;123456&quot; //明文密码&#125; 响应示例 登录成功 1234567&#123; &quot;code&quot;:&quot;200&quot;, // 成功状态码 &quot;message&quot;:&quot;success&quot; // 成功状态描述 &quot;data&quot;:&#123; &quot;token&quot;:&quot;... ...&quot; // 用户id的token &#125;&#125; 用户名有误 12345&#123; &quot;code&quot;:&quot;501&quot;, &quot;message&quot;:&quot;用户名有误&quot; &quot;data&quot;:&#123;&#125;&#125; 密码有误 12345&#123; &quot;code&quot;:&quot;503&quot;, &quot;message&quot;:&quot;密码有误&quot; &quot;data&quot;:&#123;&#125;&#125; 后端代码 NewsUserController 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.common.ResultCodeEnum;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.NewsUser;import com.atguigu.headline.service.NewsUserService;import com.atguigu.headline.service.impl.NewsUserServiceImpl;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.MD5Util;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;/user/*&quot;)public class NewsUserController extends BaseController&#123; private NewsUserService newsUserService =new NewsUserServiceImpl(); /** * 登录验证 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; NewsUser newsUser = WebUtil.readJson(req, NewsUser.class); Result result =null; NewsUser loginNewsUser =newsUserService.findByUserName(newsUser.getUsername()); // 判断用户名 if (null != loginNewsUser) &#123; // 判断密码 if(loginNewsUser.getUserPwd().equals(MD5Util.encrypt(newsUser.getUserPwd())))&#123; // 密码正确 Map&lt;String,Object&gt; data =new HashMap&lt;&gt;(); // 生成token口令 String token = JwtHelper.createToken(loginNewsUser.getUid().longValue()); // 封装数据map data.put(&quot;token&quot;,token); // 封装结果 result=Result.ok(data); &#125;else&#123; // 封装密码错误结果 result=Result.build(null, ResultCodeEnum.PASSWORD_ERROR); &#125; &#125;else&#123; // 封装用户名错误结果 result=Result.build(null, ResultCodeEnum.USERNAME_ERROR); &#125; // 响应结果 WebUtil.writeJson(resp,result); &#125;&#125; NewsUserService 123456789101112package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsUser;public interface NewsUserService &#123; /** * 根据用户名,获得查询用户的方法 * @param username 要查询的用户名 * @return 如果找到返回NewsUser对象,找不到返回null */ NewsUser findByUserName(String username);&#125; NewsUserServiceImpl 12345678910111213141516package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsUserDao;import com.atguigu.headline.dao.impl.NewsUserDaoImpl;import com.atguigu.headline.pojo.NewsUser;import com.atguigu.headline.service.NewsTypeService;import com.atguigu.headline.service.NewsUserService;import com.atguigu.headline.util.MD5Util;public class NewsUserServiceImpl implements NewsUserService &#123; private NewsUserDao newsUserDao =new NewsUserDaoImpl(); @Override public NewsUser findByUserName(String username) &#123; return newsUserDao.findByUserName(username); &#125;&#125; NewUserDao 1234567891011package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsUser;public interface NewsUserDao &#123; /** * 根据用户名查询用户信息 * @param username 要查询的用户名 * @return 找到返回NewsUser对象,找不到返回null */ NewsUser findByUserName(String username);&#125; NewsUserDaoImpl 12345678910111213141516171819202122package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsUserDao;import com.atguigu.headline.pojo.NewsUser;import java.util.List;public class NewsUserDaoImpl extends BaseDao implements NewsUserDao &#123; @Override public NewsUser findByUserName(String username) &#123; // 准备SQL String sql =&quot;select uid,username,user_pwd userPwd ,nick_name nickName from news_user where username = ?&quot;; // 调用BaseDao公共查询方法 List&lt;NewsUser&gt; newsUserList = baseQuery(NewsUser.class, sql, username); // 如果找到,返回集合中的第一个数据(其实就一个) if (null != newsUserList &amp;&amp; newsUserList.size()&gt;0)&#123; return newsUserList.get(0); &#125; return null; &#125;&#125; 5.2 根据token获取完整用户信息 需求描述 客户端发送请求,提交token请求头,后端根据token请求头获取登录用户的详细信息并响应给客户端进行存储 uri 1user/getUserInfo 请求方式 1GET 请求头 1token: ... ... 响应示例 成功获取 123456789101112&#123; &quot;code&quot;: 200, &quot;message&quot;: &quot;success&quot;, &quot;data&quot;: &#123; &quot;loginUser&quot;: &#123; &quot;uid&quot;: 1, &quot;username&quot;: &quot;zhangsan&quot;, &quot;userPwd&quot;: &quot;&quot;, &quot;nickName&quot;: &quot;张三&quot; &#125; &#125;&#125; 获取失败 12345&#123; &quot;code&quot;: 504, &quot;message&quot;: &quot;notLogin&quot;, &quot;data&quot;: null&#125; 后端代码 NewsUserController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.common.ResultCodeEnum;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.NewsUser;import com.atguigu.headline.service.NewsUserService;import com.atguigu.headline.service.impl.NewsUserServiceImpl;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.MD5Util;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;/user/*&quot;)public class NewsUserController extends BaseController&#123; private NewsUserService newsUserService =new NewsUserServiceImpl(); /** * 接收token,根据token查询完整用户信息 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void getUserInfo(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String token = req.getHeader(&quot;token&quot;); Result result =Result.build(null,ResultCodeEnum.NOTLOGIN); if(null!= token)&#123; if (!JwtHelper.isExpiration(token)) &#123; Integer uid = JwtHelper.getUserId(token).intValue(); NewsUser newsUser =newsUserService.findByUid(uid); newsUser.setUserPwd(&quot;&quot;); Map&lt;String,Object&gt; data =new HashMap&lt;&gt;(); data.put(&quot;loginUser&quot;,newsUser); result=Result.ok(data); &#125; &#125; WebUtil.writeJson(resp,result); &#125;&#125; NewsUserService 123456789101112package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsUser;public interface NewsUserService &#123; /** * 根据用户id查询用户信息 * @param uid 要查询的用户id * @return 找到返回NewsUser对象,找不到返回null */ NewsUser findByUid(Integer uid);&#125; NewsUserServiceImpl 1234567891011121314151617package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsUserDao;import com.atguigu.headline.dao.impl.NewsUserDaoImpl;import com.atguigu.headline.pojo.NewsUser;import com.atguigu.headline.service.NewsTypeService;import com.atguigu.headline.service.NewsUserService;import com.atguigu.headline.util.MD5Util;public class NewsUserServiceImpl implements NewsUserService &#123; private NewsUserDao newsUserDao =new NewsUserDaoImpl(); @Override public NewsUser findByUid(Integer uid) &#123; return newsUserDao.findByUid(uid); &#125;&#125; NewUserDao 12345678910111213package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsUser;public interface NewsUserDao &#123; /** * 根据用户id连接数据库查询用户信息 * @param uid 要查询的用户id * @return 找到返回NewsUser对象,找不到返回null */ NewsUser findByUid(Integer uid);&#125; NewUserDaoImpl 123456789101112131415161718package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsUserDao;import com.atguigu.headline.pojo.NewsUser;import java.util.List;public class NewsUserDaoImpl extends BaseDao implements NewsUserDao &#123; @Override public NewsUser findByUid(Integer uid) &#123; String sql =&quot;select uid,username,user_pwd userPwd ,nick_name nickName from news_user where uid = ?&quot;; List&lt;NewsUser&gt; newsUserList = baseQuery(NewsUser.class, sql, uid); if (null != newsUserList &amp;&amp; newsUserList.size()&gt;0)&#123; return newsUserList.get(0); &#125; return null; &#125;&#125; 5.3 注册时用户名占用校验 需求说明 用户在注册时输入用户名时,立刻将用户名发送给后端,后端根据用户名查询用户名是否可用并做出响应 uri: 1user/checkUserName 请求方式: 1POST 请求参数 1username=zhangsan 响应示例 用户名校验通过 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot; &quot;data&quot;:&#123;&#125;&#125; 用户名占用 12345&#123; &quot;code&quot;:&quot;505&quot;, &quot;message&quot;:&quot;用户名占用&quot; &quot;data&quot;:&#123;&#125;&#125; 后端代码 NewsUserController 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.common.ResultCodeEnum;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.NewsUser;import com.atguigu.headline.service.NewsUserService;import com.atguigu.headline.service.impl.NewsUserServiceImpl;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.MD5Util;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;/user/*&quot;)public class NewsUserController extends BaseController&#123; private NewsUserService newsUserService =new NewsUserServiceImpl(); /** * 注册时校验用户名是否被占用 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void checkUserName(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username = req.getParameter(&quot;username&quot;); NewsUser newsUser = newsUserService.findByUserName(username); Result result=null; if (null == newsUser)&#123; result=Result.ok(null); &#125;else&#123; result=Result.build(null,ResultCodeEnum.USERNAME_USED); &#125; WebUtil.writeJson(resp,result); &#125;&#125; 5.4 注册表单提交 需求说明 客户端将新用户信息发送给服务端,服务端将新用户存入数据库,存入之前做用户名是否被占用校验,校验通过响应成功提示,否则响应失败提示 uri: 1user/regist 请求方式: 1POST 请求参数 12345&#123; &quot;username&quot;:&quot;zhangsan&quot;, &quot;userPwd&quot;:&quot;123456&quot;, &quot;nickName&quot;:&quot;张三&quot;&#125; 响应示例 注册成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot; &quot;data&quot;:&#123;&#125;&#125; 用户名占用 12345&#123; &quot;code&quot;:&quot;505&quot;, &quot;message&quot;:&quot;用户名占用&quot; &quot;data&quot;:&#123;&#125;&#125; 后端代码 NewsUserController 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.common.ResultCodeEnum;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.NewsUser;import com.atguigu.headline.service.NewsUserService;import com.atguigu.headline.service.impl.NewsUserServiceImpl;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.MD5Util;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;/user/*&quot;)public class NewsUserController extends BaseController&#123; private NewsUserService newsUserService =new NewsUserServiceImpl(); /** * 注册功能接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; NewsUser newsUser = WebUtil.readJson(req, NewsUser.class); NewsUser usedUser = newsUserService.findByUserName(newsUser.getUsername()); Result result=null; if (null == usedUser)&#123; newsUserService.registUser(newsUser); result=Result.ok(null); &#125;else&#123; result=Result.build(null,ResultCodeEnum.USERNAME_USED); &#125; WebUtil.writeJson(resp,result); &#125;&#125; NewsUserService 12345678910111213package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsUser;public interface NewsUserService &#123; /** * 注册用户信息,注册成功返回大于0的整数,失败返回0 * @param newsUser * @return */ int registUser(NewsUser newsUser);&#125; NewsUserServiceImpl 123456789101112131415161718package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsUserDao;import com.atguigu.headline.dao.impl.NewsUserDaoImpl;import com.atguigu.headline.pojo.NewsUser;import com.atguigu.headline.service.NewsTypeService;import com.atguigu.headline.service.NewsUserService;import com.atguigu.headline.util.MD5Util;public class NewsUserServiceImpl implements NewsUserService &#123; @Override public int registUser(NewsUser newsUser) &#123; // 密码明文转密文 newsUser.setUserPwd(MD5Util.encrypt(newsUser.getUserPwd())); // 存入数据库 return newsUserDao.insertNewsUser(newsUser); &#125;&#125; NewUserDao 12345678910111213package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsUser;public interface NewsUserDao &#123; /** * 将用户信息存入数据库 * @param newsUser * @return */ int insertNewsUser(NewsUser newsUser);&#125; NewUserDaoImpl 1234567891011121314package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsUserDao;import com.atguigu.headline.pojo.NewsUser;import java.util.List;public class NewsUserDaoImpl extends BaseDao implements NewsUserDao &#123; @Override public int insertNewsUser(NewsUser newsUser) &#123; String sql =&quot;insert into news_user values(DEFAULT,?,?,?)&quot;; return baseUpdate(sql,newsUser.getUsername(),newsUser.getUserPwd(),newsUser.getNickName()); &#125;&#125; 六 头条首页功能6.1 查询所有头条分类 需求说明 进入新闻首页,查询所有分类并动态展示新闻类别栏位 uri: 1portal/findAllTypes 请求方式 1GET 请求参数 1无 响应示例 1234567891011121314151617181920212223242526272829&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;OK&quot; &quot;data&quot;: [ &#123; &quot;tid&quot;:&quot;1&quot;, &quot;tname&quot;:&quot;新闻&quot; &#125;, &#123; &quot;tid&quot;:&quot;2&quot;, &quot;tname&quot;:&quot;体育&quot; &#125;, &#123; &quot;tid&quot;:&quot;3&quot;, &quot;tname&quot;:&quot;娱乐&quot; &#125;, &#123; &quot;tid&quot;:&quot;4&quot;, &quot;tname&quot;:&quot;科技&quot; &#125;, &#123; &quot;tid&quot;:&quot;5&quot;, &quot;tname&quot;:&quot;其他&quot; &#125; ] &#125; 后端代码 PortalController 1234567891011121314151617181920212223242526272829303132333435363738package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.pojo.NewsType;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import com.atguigu.headline.service.NewsHeadlineService;import com.atguigu.headline.service.NewsTypeService;import com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;import com.atguigu.headline.service.impl.NewsTypeServiceImpl;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;@WebServlet(&quot;/portal/*&quot;)public class PortalController extends BaseController&#123; private NewsHeadlineService headlineService=new NewsHeadlineServiceImpl(); private NewsTypeService newsTypeService=new NewsTypeServiceImpl(); /** * 查询所有新闻类型 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void findAllTypes(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; List&lt;NewsType&gt; newsTypeList =newsTypeService.findAll(); WebUtil.writeJson(resp,Result.ok(newsTypeList)); &#125;&#125; NewsTypeService 1234567891011121314package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsType;import java.util.List;public interface NewsTypeService &#123; /** * 查询全部新闻类型 * @return */ List&lt;NewsType&gt; findAll();&#125; NewsTypeServiceImpl 12345678910111213141516package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsTypeDao;import com.atguigu.headline.dao.impl.NewsTypeDaoImpl;import com.atguigu.headline.pojo.NewsType;import com.atguigu.headline.service.NewsTypeService;import java.util.List;public class NewsTypeServiceImpl implements NewsTypeService &#123; private NewsTypeDao newsTypeDao =new NewsTypeDaoImpl(); @Override public List&lt;NewsType&gt; findAll() &#123; return newsTypeDao.findAll(); &#125;&#125; NewUserDao 1234567891011121314package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsType;import java.util.List;public interface NewsTypeDao &#123; /** * 从数据库中查询全部新闻类型 * @return */ List&lt;NewsType&gt; findAll();&#125; NewsTypeDaoImpl 123456789101112131415package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsTypeDao;import com.atguigu.headline.pojo.NewsType;import java.util.List;public class NewsTypeDaoImpl extends BaseDao implements NewsTypeDao &#123; @Override public List&lt;NewsType&gt; findAll() &#123; String sql =&quot;select tid,tname from news_type&quot;; return baseQuery(NewsType.class, sql); &#125;&#125; 6.2 分页带条件查询所有头条 需求说明 客户端向服务端发送查询关键字,新闻类别,页码数,页大小 服务端根据条件搜索分页信息,返回含页码数,页大小,总页数,总记录数,当前页数据等信息,并根据时间降序,浏览量降序排序 uri: 1portal/findNewsPage 请求方式: 1POST 请求参数: 123456&#123; &quot;keyWords&quot;:&quot;马斯克&quot;, // 搜索标题关键字 &quot;type&quot;:0, // 新闻类型 &quot;pageNum&quot;:1, // 页码数 &quot;pageSize&quot;:&quot;10&quot; // 页大小&#125; 响应示例: 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot; &quot;data&quot;:&#123; &quot;pageInfo&quot;:&#123; &quot;pageData&quot;:[ // 本页的数据 &#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 新闻标题 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot; , // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; // 发布用户ID &#125;, &#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 新闻标题 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot;, // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; // 发布用户ID &#125;, &#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 新闻标题 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot;, // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; // 发布用户ID &#125; ], &quot;pageNum&quot;:1, //页码数 &quot;pageSize&quot;:10, // 页大小 &quot;totalPage&quot;:20, // 总页数 &quot;totalSize&quot;:200 // 总记录数 &#125; &#125;&#125; 后端代码 PortalController 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.pojo.NewsType;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import com.atguigu.headline.service.NewsHeadlineService;import com.atguigu.headline.service.NewsTypeService;import com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;import com.atguigu.headline.service.impl.NewsTypeServiceImpl;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;@WebServlet(&quot;/portal/*&quot;)public class PortalController extends BaseController&#123; private NewsHeadlineService headlineService=new NewsHeadlineServiceImpl(); private NewsTypeService newsTypeService=new NewsTypeServiceImpl(); /** * 分页带条件查询新闻 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void findNewsPage(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HeadlineQueryVo headLineQueryVo = WebUtil.readJson(req, HeadlineQueryVo.class); // 查询分页五项数据 Map&lt;String,Object&gt; pageInfo =headlineService.findPage(headLineQueryVo); // 将分页五项数据放入PageInfoMap Map&lt;String,Object&gt; pageInfoMap=new HashMap&lt;&gt;(); pageInfoMap.put(&quot;pageInfo&quot;,pageInfo); // 响应JSON WebUtil.writeJson(resp, Result.ok(pageInfoMap)); &#125;&#125; NewsHeadlineService 1234567891011121314151617package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;import java.util.Map;public interface NewsHeadlineService &#123; /** * 分页查询头条新闻方法 * @param headLineQueryVo * @return */ Map&lt;String, Object&gt; findPage(HeadlineQueryVo headLineQueryVo);&#125; NewsHeadlineServiceImpl 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import com.atguigu.headline.service.NewsHeadlineService;import java.util.HashMap;import java.util.List;import java.util.Map;public class NewsHeadlineServiceImpl implements NewsHeadlineService &#123; private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl(); @Override public Map&lt;String, Object&gt; findPage(HeadlineQueryVo headLineQueryVo) &#123; // 准备一个map,用于装分页的五项数据 Map&lt;String,Object&gt; pageInfo =new HashMap&lt;&gt;(); // 分页查询本页数据 List&lt;HeadlinePageVo&gt; pageData =newsHeadLineDao.findPageList(headLineQueryVo); // 分页查询满足记录的总数据量 int totalSize = newsHeadLineDao.findPageCount(headLineQueryVo); // 页大小 int pageSize =headLineQueryVo.getPageSize(); // 总页码数 int totalPage=totalSize%pageSize == 0 ? totalSize/pageSize : totalSize/pageSize+1; // 当前页码数 int pageNum= headLineQueryVo.getPageNum(); pageInfo.put(&quot;pageData&quot;,pageData); pageInfo.put(&quot;pageNum&quot;,pageNum); pageInfo.put(&quot;pageSize&quot;,pageSize); pageInfo.put(&quot;totalPage&quot;,totalPage); pageInfo.put(&quot;totalSize&quot;,totalSize); return pageInfo; &#125;&#125; NewsHeadLineDao 123456789101112131415161718192021222324package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;public interface NewsHeadLineDao &#123; /** * 根据查询条件,查询满足条件的记录数 * @param headLineQueryVo * @return */ int findPageCount(HeadlineQueryVo headLineQueryVo); /** * 根据查询条件,查询当前页数据 * @param headLineQueryVo * @return */ List&lt;HeadlinePageVo&gt; findPageList(HeadlineQueryVo headLineQueryVo);&#125; NewsHeadlineDaoImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.LinkedList;import java.util.List;public class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123; @Override public int findPageCount(HeadlineQueryVo headLineQueryVo) &#123; // 拼接动态 SQL,拼接参数 List&lt;Object&gt; args =new LinkedList&lt;&gt;(); String sql=&quot;select count(1) from news_headline where is_deleted=0 &quot;; StringBuilder sqlBuffer =new StringBuilder(sql) ; String keyWords = headLineQueryVo.getKeyWords(); //判断并动态拼接条件 if (null != keyWords &amp;&amp; keyWords.length()&gt;0)&#123; sqlBuffer.append(&quot;and title like ? &quot;); args.add(&quot;%&quot;+keyWords+&quot;%&quot;); &#125; // 判断并动态拼接条件 Integer type = headLineQueryVo.getType(); if(null != type &amp;&amp; type != 0)&#123; sqlBuffer.append(&quot;and type = ? &quot;); args.add(type); &#125; // 参数转数组 Object[] argsArr = args.toArray(); System.out.println(sqlBuffer.toString()); Long totalSize = baseQueryObject(Long.class, sqlBuffer.toString(), argsArr); // 返回数据 return totalSize.intValue(); &#125; @Override public List&lt;HeadlinePageVo&gt; findPageList(HeadlineQueryVo headLineQueryVo) &#123; // 拼接动态 SQL,拼接参数 List&lt;Object&gt; args =new LinkedList&lt;&gt;(); String sql=&quot;select hid,title,type,page_views pageViews,TIMESTAMPDIFF(HOUR,create_time,NOW()) pastHours,publisher from news_headline where is_deleted=0 &quot;; StringBuilder sqlBuffer =new StringBuilder(sql) ; String keyWords = headLineQueryVo.getKeyWords(); if (null != keyWords &amp;&amp; keyWords.length()&gt;0)&#123; sqlBuffer.append(&quot;and title like ? &quot;); args.add(&quot;%&quot;+keyWords+&quot;%&quot;); &#125; Integer type = headLineQueryVo.getType(); if(null != type &amp;&amp; type != 0)&#123; sqlBuffer.append(&quot;and type = ? &quot;); args.add(type); &#125; sqlBuffer.append(&quot;order by pastHours , page_views desc &quot;); sqlBuffer.append(&quot;limit ? , ?&quot;); args.add((headLineQueryVo.getPageNum()-1)*headLineQueryVo.getPageSize()); args.add(headLineQueryVo.getPageSize()); // 参数转数组 Object[] argsArr = args.toArray(); System.out.println(sqlBuffer.toString()); List&lt;HeadlinePageVo&gt; pageData = baseQuery(HeadlinePageVo.class, sqlBuffer.toString(), argsArr); return pageData; &#125;&#125; 6.3 查看头条详情 需求说明 用户点击”查看全文”时,向服务端发送新闻id 后端根据新闻id查询完整新闻文章信息并返回 后端要同时让新闻的浏览量+1 uri 1portal/showHeadlineDetail 请求方式 1POST 请求参数 1hid=1 响应示例 1234567891011121314151617&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123; &quot;headline&quot;:&#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;马斯克宣布 ... ...&quot;, // 新闻标题 &quot;article&quot;:&quot;... ...&quot; // 新闻正文 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;typeName&quot;:&quot;科技&quot;, // 新闻所属类别 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot; , // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; , // 发布用户ID &quot;author&quot;:&quot;张三&quot; // 新闻作者 &#125; &#125;&#125; 后端代码 PortalController 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.pojo.NewsType;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import com.atguigu.headline.service.NewsHeadlineService;import com.atguigu.headline.service.NewsTypeService;import com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;import com.atguigu.headline.service.impl.NewsTypeServiceImpl;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;@WebServlet(&quot;/portal/*&quot;)public class PortalController extends BaseController&#123; private NewsHeadlineService headlineService=new NewsHeadlineServiceImpl(); private NewsTypeService newsTypeService=new NewsTypeServiceImpl(); /** * 查询单个新闻详情 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void showHeadlineDetail(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取要查询的详情新闻id Integer hid =Integer.parseInt(req.getParameter(&quot;hid&quot;)); // 查询新闻详情vo HeadlineDetailVo headlineDetailVo =headlineService.findHeadlineDetail(hid); // 封装data内容 Map&lt;String ,Object&gt; data =new HashMap&lt;&gt;(); data.put(&quot;headline&quot;,headlineDetailVo); // 响应JSON WebUtil.writeJson(resp,Result.ok(data)); &#125;&#125; NewsHeadlineService 1234567891011121314151617package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;import java.util.Map;public interface NewsHeadlineService &#123; /** * 根据头条id,显示头条详情 * @param hid * @return */ HeadlineDetailVo findHeadlineDetail(Integer hid);&#125; NewsHeadlineServiceImpl 123456789101112131415161718192021222324package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import com.atguigu.headline.service.NewsHeadlineService;import java.util.HashMap;import java.util.List;import java.util.Map;public class NewsHeadlineServiceImpl implements NewsHeadlineService &#123; private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl(); @Override public HeadlineDetailVo findHeadlineDetail(Integer hid) &#123; // 修改新闻信息浏览量+1 newsHeadLineDao.increasePageViews(hid); // 查询新闻详情 return newsHeadLineDao.findHeadlineDetail(hid); &#125;&#125; NewsHeadLineDao 12345678910111213141516171819package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;public interface NewsHeadLineDao &#123; /** * 多表查询新闻详情 * @param hid * @return */ HeadlineDetailVo findHeadlineDetail(Integer hid); int increasePageViews(Integer hid);&#125; NewsHeadlineDaoImpl 12345678910111213141516171819202122232425262728package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.LinkedList;import java.util.List;public class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123; @Override public HeadlineDetailVo findHeadlineDetail(Integer hid) &#123; String sql =&quot;select hid,title,article,type, tname typeName ,page_views pageViews,TIMESTAMPDIFF(HOUR,create_time,NOW()) pastHours,publisher,nick_name author from news_headline h left join news_type t on h.type = t.tid left join news_user u on h.publisher = u.uid where hid = ?&quot;; List&lt;HeadlineDetailVo&gt; headlineDetailVoList = baseQuery(HeadlineDetailVo.class, sql, hid); if(null != headlineDetailVoList &amp;&amp; headlineDetailVoList.size()&gt;0) return headlineDetailVoList.get(0); return null; &#125; @Override public int increasePageViews(Integer hid) &#123; String sql =&quot;update news_headline set page_views = page_views +1 where hid =?&quot;; return baseUpdate(sql,hid); &#125;&#125; 七 头条发布修改和删除7.1 登录校验 需求说明 客户端在进入发布页前、发布新闻前、进入修改页前、修改前、删除新闻前先向服务端发送请求携带token请求头 后端接收token请求头后,校验用户登录是否过期并做响应 前端根据响应信息提示用户进入登录页还是进入正常业务页面 uri 1user/checkLogin 请求方式 1GET 请求参数 1无 请求头 1token: ... ... 响应示例 登录未过期 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 登录已过期 12345&#123; &quot;code&quot;:&quot;504&quot;, &quot;message&quot;:&quot;loginExpired&quot;, &quot;data&quot;:&#123;&#125;&#125; 后端代码 NewsUserController 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.common.ResultCodeEnum;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.NewsUser;import com.atguigu.headline.service.NewsUserService;import com.atguigu.headline.service.impl.NewsUserServiceImpl;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.MD5Util;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;/user/*&quot;)public class NewsUserController extends BaseController&#123; private NewsUserService newsUserService =new NewsUserServiceImpl(); /** * 通过token检验用户登录是否过期 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void checkLogin(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String token = req.getHeader(&quot;token&quot;); Result result =Result.build(null,ResultCodeEnum.NOTLOGIN); if(null!= token)&#123; if (!JwtHelper.isExpiration(token)) &#123; result=Result.ok(null); &#125; &#125; WebUtil.writeJson(resp,result); &#125;&#125; 登录校验过滤器 1234567891011121314151617181920212223242526272829303132package com.atguigu.headline.filters;import com.atguigu.headline.common.Result;import com.atguigu.headline.common.ResultCodeEnum;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.*;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request =(HttpServletRequest) servletRequest; String token = request.getHeader(&quot;token&quot;); boolean flag =false; // token不为空并且没过期 if (null != token )&#123; boolean expiration = JwtHelper.isExpiration(token); if (!expiration )&#123; flag=true; &#125; &#125; if (flag)&#123; filterChain.doFilter(servletRequest,servletResponse); &#125;else&#123; WebUtil.writeJson((HttpServletResponse) servletResponse, Result.build(null, ResultCodeEnum.NOTLOGIN)); &#125; &#125;&#125; web.xml中配置登录校验过滤器 123456789&lt;!--登录校验过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;loginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.headline.filters.LoginFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;loginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/headline/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 7.2 提交发布头条 需求说明 用户在客户端输入发布的新闻信息完毕后 发布前先请求后端的登录校验接口验证登录 登录通过则提交新闻信息 后端将新闻信息存入数据库 uri 1headline/publish 请求方式 1POST 请求头 1token: ... ... 请求参数 12345&#123; &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 文章标题 &quot;article&quot;:&quot;... ...&quot;, // 文章内容 &quot;type&quot;:&quot;1&quot; // 文章类别&#125; 响应示例 发布成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 失去登录状态发布失败 12345&#123; &quot;code&quot;:&quot;504&quot;, &quot;message&quot;:&quot;loginExpired&quot;, &quot;data&quot;:&#123;&#125;&#125; 后端代码 NewsHeadlineController 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.service.NewsHeadlineService;import com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;/headline/*&quot;)public class NewsHeadlineController extends BaseController &#123; private NewsHeadlineService newsHeadlineService =new NewsHeadlineServiceImpl(); /** * 发布新闻 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void publish(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 读取新闻信息 NewsHeadline newsHeadline = WebUtil.readJson(req, NewsHeadline.class); // 通过token获取发布者ID String token = req.getHeader(&quot;token&quot;); Long userId = JwtHelper.getUserId(token); newsHeadline.setPublisher(userId.intValue()); // 将新闻存入数据库 newsHeadlineService.addNewsHeadline(newsHeadline); WebUtil.writeJson(resp,Result.ok(null)); &#125;&#125; NewsHeadlineService 1234567891011121314151617package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;import java.util.Map;public interface NewsHeadlineService &#123; /** * 新增头条 * @param newsHeadline * @return */ int addNewsHeadline(NewsHeadline newsHeadline);&#125; NewsHeadlineServiceImpl 1234567891011121314151617181920package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import com.atguigu.headline.service.NewsHeadlineService;import java.util.HashMap;import java.util.List;import java.util.Map;public class NewsHeadlineServiceImpl implements NewsHeadlineService &#123; private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl(); public int addNewsHeadline(NewsHeadline newsHeadline) &#123; return newsHeadLineDao.addNewsHeadline(newsHeadline); &#125;&#125; NewsHeadLineDao 1234567891011121314151617package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;public interface NewsHeadLineDao &#123; /** * 头条存入数据库 * @param newsHeadline * @return */ int addNewsHeadline(NewsHeadline newsHeadline);&#125; NewsHeadlineDaoImpl 1234567891011121314151617181920212223242526package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.LinkedList;import java.util.List;public class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123; @Override public int addNewsHeadline(NewsHeadline newsHeadline) &#123; String sql = &quot;insert into news_headline values(DEFAULT,?,?,?,?,0,NOW(),NOW(),0)&quot;; return baseUpdate( sql, newsHeadline.getTitle(), newsHeadline.getArticle(), newsHeadline.getType(), newsHeadline.getPublisher() ); &#125;&#125; 7.3 修改头条回显 需求说明 前端先调用登录校验接口,校验登录是否过期 登录校验通过后 ,则根据新闻id查询新闻的完整信息并响应给前端 uri 1headline/findHeadlineByHid 请求方式 1POST 请求参数 1hid=1 响应示例 查询成功 123456789101112&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123; &quot;headline&quot;:&#123; &quot;hid&quot;:&quot;1&quot;, &quot;title&quot;:&quot;马斯克宣布&quot;, &quot;article&quot;:&quot;... ... &quot;, &quot;type&quot;:&quot;2&quot; &#125; &#125;&#125; 后端代码 NewsHeadlineController 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.service.NewsHeadlineService;import com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;/headline/*&quot;)public class NewsHeadlineController extends BaseController &#123; private NewsHeadlineService newsHeadlineService =new NewsHeadlineServiceImpl(); /** * 修改新闻回显 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void findHeadlineByHid(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Integer hid = Integer.parseInt(req.getParameter(&quot;hid&quot;)); NewsHeadline newsHeadline =newsHeadlineService.findHeadlineByHid(hid); Map&lt;String ,Object&gt; data =new HashMap&lt;&gt;(); data.put(&quot;headline&quot;,newsHeadline); WebUtil.writeJson(resp,Result.ok(data)); &#125;&#125; NewsHeadlineService 1234567891011121314151617package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;import java.util.Map;public interface NewsHeadlineService &#123; /** * 根据新闻id查询单个新闻 * @param hid * @return */ NewsHeadline findHeadlineByHid(Integer hid);&#125; NewsHeadlineServiceImpl 123456789101112131415161718192021package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import com.atguigu.headline.service.NewsHeadlineService;import java.util.HashMap;import java.util.List;import java.util.Map;public class NewsHeadlineServiceImpl implements NewsHeadlineService &#123; private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl(); @Override public NewsHeadline findHeadlineByHid(Integer hid) &#123; return newsHeadLineDao.findHeadlineByHid(hid); &#125;&#125; NewsHeadLineDao 123456789101112package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;public interface NewsHeadLineDao &#123; NewsHeadline findHeadlineByHid(Integer hid);&#125; NewUserDaoImpl 1234567891011121314151617181920212223package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.LinkedList;import java.util.List;public class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123; @Override public NewsHeadline findHeadlineByHid(Integer hid) &#123; String sql =&quot;select hid,title,article,type,publisher,page_views pageViews from news_headline where hid =?&quot;; List&lt;NewsHeadline&gt; newsHeadlineList = baseQuery(NewsHeadline.class, sql, hid); if(null != newsHeadlineList &amp;&amp; newsHeadlineList.size()&gt;0) return newsHeadlineList.get(0); return null; &#125;&#125; 7.4 保存修改 需求描述 客户端将新闻信息修改后,提交前先请求登录校验接口校验登录状态 登录校验通过则提交修改后的新闻信息,后端接收并更新进入数据库 uri 1headline/update 请求方式 1POST 请求参数 123456&#123; &quot;hid&quot;:&quot;1&quot;, &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, &quot;article&quot;:&quot;... ...&quot;, &quot;type&quot;:&quot;2&quot;&#125; 响应示例 修改成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 修改失败 12345&#123; &quot;code&quot;:&quot;504&quot;, &quot;message&quot;:&quot;loginExpired&quot;, &quot;data&quot;:&#123;&#125;&#125; 后端代码 NewsHeadlineController 12345678910111213141516171819202122232425262728293031323334package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.service.NewsHeadlineService;import com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;/headline/*&quot;)public class NewsHeadlineController extends BaseController &#123; private NewsHeadlineService newsHeadlineService =new NewsHeadlineServiceImpl(); /** * 更新新闻信息 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; NewsHeadline newsHeadline = WebUtil.readJson(req, NewsHeadline.class); newsHeadlineService.updateNewsHeadline(newsHeadline); WebUtil.writeJson(resp,Result.ok(null)); &#125;&#125; NewsHeadlineService 123456789101112package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;import java.util.Map;public interface NewsHeadlineService &#123; int updateNewsHeadline(NewsHeadline newsHeadline);&#125; NewsHeadlineServiceImpl 123456789101112131415161718192021package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import com.atguigu.headline.service.NewsHeadlineService;import java.util.HashMap;import java.util.List;import java.util.Map;public class NewsHeadlineServiceImpl implements NewsHeadlineService &#123; private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl(); @Override public int updateNewsHeadline(NewsHeadline newsHeadline) &#123; return newsHeadLineDao.updateNewsHeadline(newsHeadline); &#125;&#125; NewsHeadLineDao 123456789101112package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;public interface NewsHeadLineDao &#123; int updateNewsHeadline(NewsHeadline newsHeadline);&#125; NewUserDaoImpl 12345678910111213141516171819202122232425package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.LinkedList;import java.util.List;public class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123; @Override public int updateNewsHeadline(NewsHeadline newsHeadline) &#123; String sql =&quot;update news_headline set title = ?, article= ? , type =? , update_time = NOW() where hid = ? &quot;; return baseUpdate( sql, newsHeadline.getTitle(), newsHeadline.getArticle(), newsHeadline.getType(), newsHeadline.getHid() ); &#125;&#125; 7.5 删除头条 需求说明 将要删除的新闻id发送给服务端 服务端校验登录是否过期,未过期则直接删除,过期则响应登录过期信息 uri 1headline/removeByHid 请求方式 1POST 请求参数 1hid=1 响应示例 删除成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 删除失败 123456&#123; &quot;code&quot;:&quot;504&quot;, &quot;message&quot;:&quot;loginExpired&quot;, &quot;data&quot;:&#123;&#125; &#125; 后端代码 NewsHeadlineController 12345678910111213141516171819202122232425262728293031323334package com.atguigu.headline.controller;import com.atguigu.headline.common.Result;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.service.NewsHeadlineService;import com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;import com.atguigu.headline.util.JwtHelper;import com.atguigu.headline.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;/headline/*&quot;)public class NewsHeadlineController extends BaseController &#123; private NewsHeadlineService newsHeadlineService =new NewsHeadlineServiceImpl(); /** * 删除新闻 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void removeByHid(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Integer hid = Integer.parseInt(req.getParameter(&quot;hid&quot;)); newsHeadlineService.removeByHid(hid); WebUtil.writeJson(resp,Result.ok(null)); &#125;&#125; NewsHeadlineService 123456789101112package com.atguigu.headline.service;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;import java.util.Map;public interface NewsHeadlineService &#123; int removeByHid(Integer hid);&#125; NewsHeadlineServiceImpl 123456789101112131415161718192021package com.atguigu.headline.service.impl;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import com.atguigu.headline.service.NewsHeadlineService;import java.util.HashMap;import java.util.List;import java.util.Map;public class NewsHeadlineServiceImpl implements NewsHeadlineService &#123; private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl(); @Override public int removeByHid(Integer hid) &#123; return newsHeadLineDao.removeByHid(hid); &#125;&#125; NewsHeadLineDao 123456789101112package com.atguigu.headline.dao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.List;public interface NewsHeadLineDao &#123; int removeByHid(Integer hid);&#125; NewsHeadlineDaoImpl 123456789101112131415161718package com.atguigu.headline.dao.impl;import com.atguigu.headline.dao.BaseDao;import com.atguigu.headline.dao.NewsHeadLineDao;import com.atguigu.headline.pojo.NewsHeadline;import com.atguigu.headline.pojo.vo.HeadlineDetailVo;import com.atguigu.headline.pojo.vo.HeadlinePageVo;import com.atguigu.headline.pojo.vo.HeadlineQueryVo;import java.util.LinkedList;import java.util.List;public class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123; @Override public int removeByHid(Integer hid) &#123; String sql =&quot;update news_headline set is_deleted =1 , update_time =NOW() where hid = ? &quot;; return baseUpdate(sql,hid); &#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/categories/javaweb/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"第七章 前端工程化","slug":"javaweb/07_第七章 前端工程化","date":"2019-10-08T07:00:00.000Z","updated":"2024-12-02T13:17:29.076Z","comments":true,"path":"2019/10/08/javaweb/07_第七章 前端工程化/","link":"","permalink":"https://protonlml.github.io/2019/10/08/javaweb/07_%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/","excerpt":"","text":"第七章 前端工程化一、前端工程化开篇1.1 什么是前端工程化 前端工程化是使用软件工程的方法来单独解决前端的开发流程中模块化、组件化、规范化、自动化的问题,其主要目的为了提高效率和降低成本。 1.2 前端工程化实现技术栈 前端工程化实现的技术栈有很多,我们采用ES6+nodejs+npm+Vite+VUE3+router+pinia+axios+Element-plus组合来实现 ECMAScript6 VUE3中大量使用ES6语法 Nodejs 前端项目运行环境 npm 依赖下载工具 vite 前端项目构建工具 VUE3 优秀的渐进式前端框架 router 通过路由实现页面切换 pinia 通过状态管理实现组件数据传递 axios ajax异步请求封装技术实现前后端数据交互 Element-plus 可以提供丰富的快速构建网页的组件仓库 二、ECMA6Script2.1. es6的介绍 ECMAScript 6，简称ES6，是JavaScript语言的一次重大更新。它于2015年发布，是原来的ECMAScript标准的第六个版本。ES6带来了大量的新特性，包括箭头函数、模板字符串、let和const关键字、解构、默认参数值、模块系统等等，大大提升了JavaScript的开发体验。由于VUE3中大量使用了ES6的语法,所以ES6成为了学习VUE3的门槛之一ES6对JavaScript的改进在以下几个方面： 更加简洁：ES6引入了一些新的语法，如箭头函数、类和模板字符串等，使代码更加简洁易懂。 更强大的功能：ES6引入了一些新的API、解构语法和迭代器等功能，从而使得JavaScript更加强大。 更好的适用性：ES6引入的模块化功能为JavaScript代码的组织和管理提供了更好的方式，不仅提高了程序的可维护性，还让JavaScript更方便地应用于大型的应用程序。 总的来说，ES6在提高JavaScript的核心语言特性和功能方面取得了很大的进展。由于ES6已经成为了JavaScript的标准，它的大多数新特性都已被现在浏览器所支持，因此现在可以放心地使用ES6来开发前端应用程序。 历史版本： 标准版本 发布时间 新特性 ES1 1997年 第一版 ECMAScript ES2 1998年 引入setter和getter函数，增加了try&#x2F;catch，switch语句允许字符串 ES3 1999年 引入了正则表达式和更好的字符串处理 ES4 取消 取消，部分特性被ES3.1和ES5继承 ES5 2009年 Object.defineProperty，JSON，严格模式，数组新增方法等 ES5.1 2011年 对ES5做了一些勘误和例行修订 ES6 2015年 箭头函数、模板字符串、解构、let和const关键字、类、模块系统等 ES2016 2016年 数组.includes，指数操作符（**），Array.prototype.fill等 ES2017 2017年 异步函数async&#x2F;await，Object.values&#x2F;Object.entries，字符串填充 ES2018 2018年 正则表达式命名捕获组，几个有用的对象方法，异步迭代器等 ES2019 2019年 Array.prototype.{flat,flatMap}，Object.fromEntries等 ES2020 2020年 BigInt、动态导入、可选链操作符、空位合并操作符 ES2021 2021年 String.prototype.replaceAll，逻辑赋值运算符，Promise.any等 … … 2.2 es6的变量和模板字符串 ES6 新增了let和const，用来声明变量,使用的细节上也存在诸多差异 let 和var的差别 1、let 不能重复声明 2、let有块级作用域，非函数的花括号遇见let会有块级作用域，也就是只能在花括号里面访问。 3、let不会预解析进行变量提升 4、let 定义的全局变量不会作为window的属性 5、let在es6中推荐优先使用 1234567891011121314151617181920212223242526272829303132&lt;script&gt; //1. let只有在当前代码块有效代码块. 代码块、函数、全局 &#123; let a = 1 var b = 2 &#125; console.log(a); // a is not defined 花括号外面无法访问 console.log(b); // 可以正常输出 //2. 不能重复声明 let name = &#x27;天真&#x27; let name = &#x27;无邪&#x27; //3. 不存在变量提升（先声明，在使用） console.log(test) //可以 但是值为undefined var test = &#x27;test&#x27; console.log(test1) //不可以 let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 let test1 = &#x27;test1&#x27; //4、不会成为window的属性 var a = 100 console.log(window.a) //100 let b = 200 console.log(window.b) //undefined //5. 循环中推荐使用 for (let i = 0; i &lt; 10; i++) &#123; // ... &#125; console.log(i);&lt;/script&gt; const和var的差异 1、新增const和let类似，只是const定义的变量不能修改 2、并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 123456789101112131415161718192021222324&lt;script&gt; //声明场景语法,建议变量名大写区分 const PI = 3.1415926; //1.常量声明必须有初始化值 //const A ; //报错 //2.常量值不可以改动 //const A = &#x27;atguigu&#x27; //A = &#x27;xx&#x27; //不可改动 //3.和let一样，块儿作用域 &#123; const A = &#x27;atguigu&#x27; console.log(A); &#125; //console.log(A); //4.对应数组和对象元素修改，不算常量修改，修改值，不修改地址 const TEAM = [&#x27;刘德华&#x27;,&#x27;张学友&#x27;,&#x27;郭富城&#x27;]; TEAM.push(&#x27;黎明&#x27;); TEAM=[] // 报错 console.log(TEAM)&lt;/script&gt; 模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识 1、字符串中可以出现换行符 2、可以使用 ${xxx} 形式输出变量和拼接变量 12345678910111213141516171819202122232425&lt;script&gt; // 1 多行普通字符串 let ulStr = &#x27;&lt;ul&gt;&#x27;+ &#x27;&lt;li&gt;JAVA&lt;/li&gt;&#x27;+ &#x27;&lt;li&gt;html&lt;/li&gt;&#x27;+ &#x27;&lt;li&gt;VUE&lt;/li&gt;&#x27;+ &#x27;&lt;/ul&gt;&#x27; console.log(ulStr) // 2 多行模板字符串 let ulStr2 = ` &lt;ul&gt; &lt;li&gt;JAVA&lt;/li&gt; &lt;li&gt;html&lt;/li&gt; &lt;li&gt;VUE&lt;/li&gt; &lt;/ul&gt;` console.log(ulStr2) // 3 普通字符串拼接 let name =&#x27;张小明&#x27; let infoStr =name+&#x27;被评为本年级优秀学员&#x27; console.log(infoStr) // 4 模板字符串拼接 let infoStr2 =`$&#123;name&#125;被评为本年级优秀学员` console.log(infoStr2)&lt;/script&gt; 2.3 es6的解构表达式 ES6 的解构赋值是一种方便的语法，可以快速将数组或对象中的值拆分并赋值给变量。解构赋值的语法使用花括号 &#123;&#125; 表示对象，方括号 [] 表示数组。通过解构赋值，函数更方便进行参数接受等！ 数组解构赋值 可以通过数组解构将数组中的值赋值给变量，语法为： 1234let [a, b, c] = [1, 2, 3]; //新增变量名任意合法即可，本质是按照顺序进行初始化变量的值console.log(a); // 1console.log(b); // 2console.log(c); // 3 该语句将数组 [1, 2, 3] 中的第一个值赋值给 a 变量，第二个值赋值给 b 变量，第三个值赋值给 c 变量。 可以使用默认值为变量提供备选值，在数组中缺失对应位置的值时使用该默认值。例如： 12let [a, b, c, d = 4] = [1, 2, 3];console.log(d); // 4 对象解构赋值 可以通过对象解构将对象中的值赋值给变量，语法为： 123456let &#123;a, b&#125; = &#123;a: 1, b: 2&#125;;//新增变量名必须和属性名相同，本质是初始化变量的值为对象中同名属性的值//等价于 let a = 对象.a let b = 对象.b console.log(a); // 1console.log(b); // 2 该语句将对象 {a: 1, b: 2} 中的 a 属性值赋值给 a 变量，b 属性值赋值给 b 变量。 可以为标识符分配不同的变量名称，使用 : 操作符指定新的变量名。例如： 123let &#123;a: x, b: y&#125; = &#123;a: 1, b: 2&#125;;console.log(x); // 1console.log(y); // 2 函数参数解构赋值 解构赋值也可以用于函数参数。例如： 1234function add([x, y]) &#123; return x + y;&#125;add([1, 2]); // 3 该函数接受一个数组作为参数，将其中的第一个值赋给 x，第二个值赋给 y，然后返回它们的和。 ES6 解构赋值让变量的初始化更加简单和便捷。通过解构赋值，我们可以访问到对象中的属性，并将其赋值给对应的变量，从而提高代码的可读性和可维护性。 2.4 es6的箭头函数 ES6 允许使用“箭头” 义函数。语法类似Java中的Lambda表达式 2.4.1 声明和特点123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script&gt; //ES6 允许使用“箭头”（=&gt;）定义函数。 //1. 函数声明 let fn1 = function()&#123;&#125; let fn2 = ()=&gt;&#123;&#125; //箭头函数,此处不需要书写function关键字 let fn3 = x =&gt;&#123;&#125; //单参数可以省略(),多参数无参数不可以! let fn4 = x =&gt; console.log(x) //只有一行方法体可以省略&#123;&#125;; let fun5 = x =&gt; x + 1 //当函数体只有一句返回值时，可以省略花括号和 return 语句 //2. 使用特点 箭头函数this关键字 // 在 JavaScript 中，this 关键字通常用来引用函数所在的对象， // 或者在函数本身作为构造函数时，来引用新对象的实例。 // 但是在箭头函数中，this 的含义与常规函数定义中的含义不同， // 并且是由箭头函数定义时的上下文来决定的，而不是由函数调用时的上下文来决定的。 // 箭头函数没有自己的this，this指向的是外层上下文环境的this let person =&#123; name:&quot;张三&quot;, showName:function ()&#123; console.log(this) // 这里的this是person console.log(this.name) &#125;, viewName: () =&gt;&#123; console.log(this) // 这里的this是window console.log(this.name) &#125; &#125; person.showName() person.viewName() //this应用 function Counter() &#123; this.count = 0; setInterval(() =&gt; &#123; // 这里的 this 是上一层作用域中的 this，即 Counter实例化对象 this.count++; console.log(this.count); &#125;, 1000); &#125; let counter = new Counter();&lt;/script&gt; 2.4.2 实践和应用场景123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #xdd&#123; display: inline-block; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;xdd&quot;&gt;&lt;/div&gt; &lt;script&gt; let xdd = document.getElementById(&quot;xdd&quot;); // 方案1 xdd.onclick = function()&#123; console.log(this) let _this= this; //this 是xdd //开启定时器 setTimeout(function()&#123; console.log(this) //变粉色 _this.style.backgroundColor = &#x27;pink&#x27;; &#125;,2000); &#125; // 方案2 xdd.onclick = function()&#123; console.log(this) //开启定时器 setTimeout(()=&gt;&#123; console.log(this)// 使用setTimeout() 方法所在环境时的this对象 //变粉色 this.style.backgroundColor = &#x27;pink&#x27;; &#125;,2000); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.4.3 rest和spread rest参数,在形参上使用 和JAVA中的可变参数几乎一样 1234567891011121314&lt;script&gt; // 1 参数列表中多个普通参数 普通函数和箭头函数中都支持 let fun1 = function (a,b,c,d=10)&#123;console.log(a,b,c,d)&#125; let fun2 = (a,b,c,d=10) =&gt;&#123;console.log(a,b,c,d)&#125; fun1(1,2,3) fun2(1,2,3,4) // 2 ...作为参数列表,称之为rest参数 普通函数和箭头函数中都支持 ,因为箭头函数中无法使用arguments,rest是一种解决方案 let fun3 = function (...args)&#123;console.log(args)&#125; let fun4 = (...args) =&gt;&#123;console.log(args)&#125; fun3(1,2,3) fun4(1,2,3,4) // rest参数在一个参数列表中的最后一个只,这也就无形之中要求一个参数列表中只能有一个rest参数 //let fun5 = (...args,...args2) =&gt;&#123;&#125; // 这里报错&lt;/script&gt; spread参数,在实参上使用rest 1234567891011121314151617181920&lt;script&gt; let arr =[1,2,3] //let arrSpread = ...arr;// 这样不可以,...arr必须在调用方法时作为实参使用 let fun1 =(a,b,c) =&gt;&#123; console.log(a,b,c) &#125; // 调用方法时,对arr进行转换 转换为1,2,3 fun1(...arr) //应用场景1 合并数组 let arr2=[4,5,6] let arr3=[...arr,...arr2] console.log(arr3) //应用场景2 合并对象属性 let p1=&#123;name:&quot;张三&quot;&#125; let p2=&#123;age:10&#125; let p3=&#123;gender:&quot;boy&quot;&#125; let person =&#123;...p1,...p2,...p3&#125; console.log(person)&lt;/script&gt; 2.5 es6的对象创建和拷贝2.5.1 对象创建的语法糖 ES6中新增了对象创建的语法糖,支持了class extends constructor等关键字,让ES6的语法和面向对象的语法更加接近 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Person&#123; // 属性 #n; age; get name()&#123; return this.n; &#125; set name(n)&#123; this.n =n; &#125; // 实例方法 eat(food)&#123; console.log(this.age+&quot;岁的&quot;+this.n+&quot;用筷子吃&quot;+food) &#125; // 静态方法 static sum(a,b)&#123; return a+b; &#125; // 构造器 constructor(name,age)&#123; this.n=name; this.age = age; &#125; &#125; let person =new Person(&quot;张三&quot;,10); // 访问对象属性 // 调用对象方法 console.log(person.name) console.log(person.n) person.name=&quot;小明&quot; console.log(person.age) person.eat(&quot;火锅&quot;) console.log(Person.sum(1,2)) class Student extends Person&#123; grade ; score ; study()&#123; &#125; constructor(name,age ) &#123; super(name,age); &#125; &#125; let stu =new Student(&quot;学生小李&quot;,18); stu.eat(&quot;面条&quot;) 2.5.2 对象的深拷贝和浅拷贝 对象的拷贝,快速获得一个和已有对象相同的对象的方式 浅拷贝 1234567891011&lt;script&gt; let arr =[&#x27;java&#x27;,&#x27;c&#x27;,&#x27;python&#x27;] let person =&#123; name:&#x27;张三&#x27;, language:arr &#125; // 浅拷贝,person2和person指向相同的内存 let person2 = person; person2.name=&quot;小黑&quot; console.log(person.name)&lt;/script&gt; 深拷贝 123456789101112&lt;script&gt; let arr =[&#x27;java&#x27;,&#x27;c&#x27;,&#x27;python&#x27;] let person =&#123; name:&#x27;张三&#x27;, language:arr &#125; // 深拷贝,通过JSON和字符串的转换形成一个新的对象 let person2 = JSON.parse(JSON.stringify(person)) person2.name=&quot;小黑&quot; console.log(person.name) console.log(person2.name) &lt;/script&gt; 2.6 es6的模块化处理2.6.1模块化介绍 模块化是一种组织和管理前端代码的方式，将代码拆分成小的模块单元，使得代码更易于维护、扩展和复用。它包括了定义、导出、导入以及管理模块的方法和规范。前端模块化的主要优势如下： 提高代码可维护性：通过将代码拆分为小的模块单元，使得代码结构更为清晰，可读性更高，便于开发者阅读和维护。 提高代码可复用性：通过将重复使用的代码变成可复用的模块，减少代码重复率，降低开发成本。 提高代码可扩展性：通过模块化来实现代码的松耦合，便于更改和替换模块，从而方便地扩展功能。 目前，前端模块化有多种规范和实现，包括 CommonJS、AMD 和 ES6 模块化。ES6 模块化是 JavaScript 语言的模块标准，使用 import 和 export 关键字来实现模块的导入和导出。现在，大部分浏览器都已经原生支持 ES6 模块化，因此它成为了最为广泛使用的前端模块化标准. &#96; ES6模块化的几种暴露和导入方式 分别导出 统一导出 默认导出 ES6中无论以何种方式导出,导出的都是一个对象,导出的内容都可以理解为是向这个对象中添加属性或者方法 2.6.2 分别导出 module.js 向外分别暴露成员 123456789101112131415161718//1.分别暴露// 模块想对外导出,添加export关键字即可!// 导出一个变量export const PI = 3.14// 导出一个函数export function sum(a, b) &#123; return a + b;&#125;// 导出一个类export class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayHello() &#123; console.log(`Hello, my name is $&#123;this.name&#125;, I&#x27;m $&#123;this.age&#125; years old.`); &#125;&#125; app.js 导入module.js中的成员 12345678910111213/* *代表module.js中的所有成员 m1代表所有成员所属的对象*/import * as m1 from &#x27;./module.js&#x27;// 使用暴露的属性console.log(m1.PI)// 调用暴露的方法let result =m1.sum(10,20)console.log(result)// 使用暴露的Person类let person =new m1.Person(&#x27;张三&#x27;,10)person.sayHello() index.html作为程序启动的入口 导入 app.js 12&lt;!-- 导入JS文件 添加type=&#x27;module&#x27; 属性,否则不支持ES6的模块化 --&gt;&lt;script src=&quot;./app.js&quot; type=&quot;module&quot; /&gt; 2.6.3 统一导出 module.js向外统一导出成员 123456789101112131415161718192021222324//2.统一暴露// 模块想对外导出,export统一暴露想暴露的内容!// 定义一个常量const PI = 3.14// 定义一个函数function sum(a, b) &#123; return a + b;&#125;// 定义一个类class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayHello() &#123; console.log(`Hello, my name is $&#123;this.name&#125;, I&#x27;m $&#123;this.age&#125; years old.`); &#125;&#125;// 统一对外导出(暴露)export &#123; PI, sum, Person&#125; app.js导入module.js中的成员 123456789101112131415161718192021222324/* &#123;&#125;中导入要使用的来自于module.js中的成员 &#123;&#125;中导入的名称要和module.js中导出的一致,也可以在此处起别名 &#123;&#125;中如果定义了别名,那么在当前模块中就只能使用别名 &#123;&#125;中导入成员的顺序可以不是暴露的顺序 一个模块中可以同时有多个import 多个import可以导入多个不同的模块,也可以是同一个模块*///import &#123;PI ,Person ,sum &#125; from &#x27;./module.js&#x27;//import &#123;PI as pi,Person as People,sum as add&#125; from &#x27;./module.js&#x27;import &#123;PI ,Person ,sum,PI as pi,Person as People,sum as add&#125; from &#x27;./module.js&#x27;// 使用暴露的属性console.log(PI)console.log(pi)// 调用暴露的方法let result1 =sum(10,20)console.log(result1)let result2 =add(10,20)console.log(result2)// 使用暴露的Person类let person1 =new Person(&#x27;张三&#x27;,10)person1.sayHello()let person2 =new People(&#x27;李四&#x27;,11)person2.sayHello() 2.6.4 默认导出 modules混合向外导出 123456789101112131415161718192021222324252627282930// 3默认和混合暴露/* 默认暴露语法 export default sum 默认暴露相当于是在暴露的对象中增加了一个名字为default的属性 三种暴露方式可以在一个module中混合使用*/export const PI = 3.14// 导出一个函数function sum(a, b) &#123; return a + b;&#125;// 导出一个类class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayHello() &#123; console.log(`Hello, my name is $&#123;this.name&#125;, I&#x27;m $&#123;this.age&#125; years old.`); &#125;&#125;// 导出默认export default sum// 统一导出export &#123; Person&#125; app.js 的default和其他导入写法混用 1234567891011121314151617181920212223/* *代表module.js中的所有成员 m1代表所有成员所属的对象*/import * as m1 from &#x27;./module.js&#x27;import &#123;default as add&#125; from &#x27;./module.js&#x27; // 用的少import add2 from &#x27;./module.js&#x27; // 等效于 import &#123;default as add2&#125; from &#x27;./module.js&#x27;// 调用暴露的方法let result =m1.default(10,20)console.log(result)let result2 =add(10,20)console.log(result2)let result3 =add2(10,20)console.log(result3)// 引入其他方式暴露的内容import &#123;PI,Person&#125; from &#x27;./module.js&#x27;// 使用暴露的Person类let person =new Person(&#x27;张三&#x27;,10)person.sayHello()// 使用暴露的属性console.log(PI) 三、前端工程化环境搭建3.1 nodejs的简介和安装3.1.1 什么是Nodejs Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，可以使 JavaScript 运行在服务器端。使用 Node.js，可以方便地开发服务器端应用程序，如 Web 应用、API、后端服务，还可以通过 Node.js 构建命令行工具等。相比于传统的服务器端语言（如 PHP、Java、Python 等），Node.js 具有以下特点： 单线程，但是采用了事件驱动、异步 I&#x2F;O 模型，可以处理高并发请求。 轻量级，使用 C++ 编写的 V8 引擎让 Node.js 的运行速度很快。 模块化，Node.js 内置了大量模块，同时也可以通过第三方模块扩展功能。 跨平台，可以在 Windows、Linux、Mac 等多种平台下运行。 Node.js 的核心是其管理事件和异步 I&#x2F;O 的能力。Node.js 的异步 I&#x2F;O 使其能够处理大量并发请求，并且能够避免在等待 I&#x2F;O 资源时造成的阻塞。此外，Node.js 还拥有高性能网络库和文件系统库，可用于搭建 WebSocket 服务器、上传文件等。在 Node.js 中，我们可以使用 JavaScript 来编写服务器端程序，这也使得前端开发人员可以利用自己已经熟悉的技能来开发服务器端程序，同时也让 JavaScript 成为一种全栈语言。Node.js 受到了广泛的应用，包括了大型企业级应用、云计算、物联网、游戏开发等领域。常用的 Node.js 框架包括 Express、Koa、Egg.js 等，它们能够显著提高开发效率和代码质量。 3.1.2 如何安装nodejs 打开官网https://nodejs.org/en下载对应操作系统的 LTS 版本。 双击安装包进行安装，安装过程中遵循默认选项即可(或者参照https://www.runoob.com/nodejs/nodejs-install-setup.html )。安装完成后，可以在命令行终端输入 node -v 和 npm -v 查看 Node.js 和 npm 的版本号。 定义一个app.js文件,cmd到该文件所在目录,然后在dos上通过node app.js命令即可运行 1234567function sum(a,b)&#123; return a+b;&#125;function main()&#123; console.log(sum(10,20))&#125;main() 3.2 npm 配置和使用3.2.1 npm介绍 NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于后端的Maven 。 3.2.2 npm 安装和配置 1.安装 安装node，自动安装npm包管理工具！ 2.配置依赖下载使用阿里镜像 npm 安装依赖包时默认使用的是官方源，由于国内网络环境的原因，有时会出现下载速度过慢的情况。为了解决这个问题，可以配置使用阿里镜像来加速 npm 的下载速度，具体操作如下： 打开命令行终端，执行以下命令，配置使用阿里镜像： 原来的 registry.npm.taobao.org 已替换为 registry.npmmirror.com 1npm config set registry https://registry.npmmirror.com 确认配置已生效，可以使用以下命令查看当前 registry 的配置：如果输出结果为 https://registry.npmmirror.com，说明配置已成功生效。 1npm config get registry 如果需要恢复默认的官方源，可以执行以下命令： 1npm config set registry https://registry.npmjs.org/ 3.配置全局依赖下载后存储位置 在 Windows 系统上，npm 的全局依赖默认安装在 &lt;用户目录&gt;\\AppData\\Roaming\\npm 目录下。 如果需要修改全局依赖的安装路径，可以按照以下步骤操作： 创建一个新的全局依赖存储目录，例如 D:\\GlobalNodeModules。 打开命令行终端，执行以下命令来配置新的全局依赖存储路径： 1npm config set prefix &quot;D:\\GlobalNodeModules&quot; 确认配置已生效，可以使用以下命令查看当前的全局依赖存储路径： 1npm config get prefix 4.升级npm版本 cmd 输入npm -v 查看版本 如果node中自带的npm版本过低！则需要升级至9.6.6！ 1npm install -g npm@9.6.6 3.2.3 npm 常用命令 1.项目初始化 npm init 进入一个vscode创建好的项目中, 执行 npm init 命令后，npm 会引导您在命令行界面上回答一些问题,例如项目名称、版本号、作者、许可证等信息，并最终生成一个package.json 文件。package.json信息会包含项目基本信息！类似maven的pom.xml npm init -y 执行，-y yes的意思，所有信息使用当前文件夹的默认值！不用挨个填写！ 2.安装依赖 (查看所有依赖地址 https://www.npmjs.com ) npm install 包名 或者 npm install 包名@版本号 安装包或者指定版本的依赖包(安装到当前项目中) npm install -g 包名 安装全局依赖包(安装到d:&#x2F;GlobalNodeModules)则可以在任何项目中使用它，而无需在每个项目中独立安装该包。 npm install 安装package.json中的所有记录的依赖 3.升级依赖 npm update 包名 将依赖升级到最新版本 4.卸载依赖 npm uninstall 包名 5.查看依赖 npm ls 查看项目依赖 npm list -g 查看全局依赖 6.运行命令 npm run 命令是在执行 npm 脚本时使用的命令。npm 脚本是一组在 package.json 文件中定义的可执行命令。npm 脚本可用于启动应用程序，运行测试，生成文档等，还可以自定义命令以及配置需要运行的脚本。 在 package.json 文件中，scripts 字段是一个对象，其中包含一组键值对，键是要运行的脚本的名称，值是要执行的命令。例如，以下是一个简单的 package.json 文件： 1234567891011121314&#123; &quot;name&quot;: &quot;my-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node index.js&quot;, &quot;test&quot;: &quot;jest&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.17.1&quot;, &quot;jest&quot;: &quot;^27.1.0&quot;, &quot;webpack&quot;: &quot;^5.39.0&quot; &#125;&#125; scripts 对象包含 start、test 和 build 三个脚本。当您运行 npm run start 时，将运行 node index.js，并启动应用程序。同样，运行 npm run test 时，将运行 Jest 测试套件，而 npm run build 将运行 webpack 命令以生成最终的构建输出。 总之，npm run 命令为您提供了一种在 package.json 文件中定义和管理一组指令的方法，可以在项目中快速且灵活地运行各种操作。 四、Vue3简介和快速体验4.1 Vue3介绍 Vue (发音为 &#x2F;vjuː&#x2F;，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。官网为:https://cn.vuejs.org/ Vue的两个核心功能： 声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM VUE作者:尤雨溪 尤雨溪（Evan You），毕业于科尔盖特大学，前端框架Vue.js的作者、HTML5版Clear的打造人、独立开源开发者。曾就职于Google Creative Labs和Meteor Development Group。由于工作中大量接触开源的JavaScript项目，最后自己也走上了开源之路，现全职开发和维护Vue.js 尤雨溪毕业于上海复旦附中，在美国完成大学学业，本科毕业于Colgate University，后在Parsons设计学院获得Design &amp; Technology艺术硕士学位，任职于纽约Google Creative Lab。 尤雨溪大学专业并非是计算机专业，在大学期间他学习专业是室内艺术和艺术史，后来读了美术设计和技术的硕士，正是在读硕士期间，他偶然接触到了JavaScript，从此被这门编程语言深深吸引，开启了自己的前端生涯。 4.2 Vue3快速体验(非工程化方式)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里也可以用浏览器打开连接,然后将获得的文本单独保存进入一个vue.js的文件,导入vue.js文件即可 --&gt; &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 给style属性绑定colorStyle数据 --&gt; &lt;!-- &#123;&#123;插值表达式 直接将数据放在该位置&#125;&#125; --&gt; &lt;h1 v-bind:style=&quot;colorStyle&quot;&gt;&#123;&#123;headline&#125;&#125;&lt;/h1&gt; &lt;!-- v-text设置双标签中的文本 --&gt; &lt;p v-text=&quot;article&quot;&gt;&lt;/p&gt; &lt;!-- 给type属性绑定inputType数据 --&gt; &lt;input v-bind:type =&quot;inputType&quot; value=&quot;helloVue3&quot;&gt; &lt;br&gt; &lt;!-- 给按钮单击事件绑定函数 --&gt; &lt;button @click=&quot;sayHello()&quot;&gt;hello&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //组合api const app = Vue.createApp(&#123; // 在setup内部自由声明数据和方法即可!最终返回! setup()&#123; //定义数据 //在VUE中实现DOM的思路是: 通过修改修数据而影响页面元素 // vue3中,数据默认不是响应式的,需要加ref或者reactive处理,后面会详细讲解 let inputType =&#x27;text&#x27; let headline =&#x27;hello vue3&#x27; let article =&#x27;vue is awesome&#x27; let colorStyle =&#123;&#x27;color&#x27;:&#x27;red&#x27;&#125; // 定义函数 let sayHello =()=&gt;&#123; alert(&quot;hello Vue&quot;) &#125; //在setup函数中,return返回的数据和函数可以在html使用 return &#123; inputType, headline, article, colorStyle, sayHello &#125; &#125; &#125;); //挂载到视图 app.mount(&quot;#app&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 五、Vue3通过Vite实现工程化5.1 Vite的介绍 在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。时过境迁，我们见证了诸如 webpack、Rollup 和 Parcel 等工具的变迁，它们极大地改善了前端开发者的开发体验 当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。 包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈：通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。 Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。https://cn.vitejs.dev/guide/why.html前端工程化的作用包括但不限于以下几个方面： 快速创建项目：使用脚手架可以快速搭建项目基本框架，避免从零开始搭建项目的重复劳动和繁琐操作，从而节省时间和精力。 统一的工程化规范：前端脚手架可以预设项目目录结构、代码规范、git提交规范等统一的工程化规范，让不同开发者在同一个项目上编写出风格一致的代码，提高协作效率和质量。 代码模板和组件库：前端脚手架可以包含一些常用的代码模板和组件库，使开发者在实现常见功能时不再重复造轮子，避免因为轮子质量不高带来的麻烦，能够更加专注于项目的业务逻辑。 自动化构建和部署：前端脚手架可以自动进行代码打包、压缩、合并、编译等常见的构建工作，可以通过集成自动化部署脚本，自动将代码部署到测试、生产环境等。 5.2 Vite创建Vue3工程化项目5.2.1 Vite+Vue3项目的创建、启动、停止 1 使用命令行创建工程 在磁盘的合适位置上,创建一个空目录用于存储多个前端项目 用vscode打开该目录 在vocode中打开命令行运行如下命令 1npm create vite@latest 第一次使用vite时会提示下载vite,输入y回车即可,下次使用vite就不会出现了 注意： 选择vue+JavaScript选项即可 2 安装项目所需依赖 cd进入刚刚创建的项目目录 npm install命令安装基础依赖 12cd ./vue3-demo1npm install 3 启动项目 查看项目下的package.json 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;vue3-demo1&quot;, &quot;private&quot;: true, &quot;version&quot;: &quot;0.0.0&quot;, &quot;type&quot;: &quot;module&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build&quot;, &quot;preview&quot;: &quot;vite preview&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;bootstrap&quot;: &quot;^5.2.3&quot;, &quot;sass&quot;: &quot;^1.62.1&quot;, &quot;vue&quot;: &quot;^3.2.47&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vitejs/plugin-vue&quot;: &quot;^4.1.0&quot;, &quot;vite&quot;: &quot;^4.3.2&quot; &#125;&#125; 1npm run dev 5 停止项目 命令行上 ctrl+c 5.2.2 Vite+Vue3项目的目录结构 1.下面是 Vite 项目结构和入口的详细说明： public&#x2F; 目录：用于存放一些公共资源，如 HTML 文件、图像、字体等，这些资源会被直接复制到构建出的目标目录中。 src&#x2F; 目录：存放项目的源代码，包括 JavaScript、CSS、Vue 组件、图像和字体等资源。在开发过程中，这些文件会被 Vite 实时编译和处理，并在浏览器中进行实时预览和调试。以下是src内部划分建议： assets/ 目录：用于存放一些项目中用到的静态资源，如图片、字体、样式文件等。 components/ 目录：用于存放组件相关的文件。组件是代码复用的一种方式，用于抽象出一个可复用的 UI 部件，方便在不同的场景中进行重复使用。 layouts/ 目录：用于存放布局组件的文件。布局组件通常负责整个应用程序的整体布局，如头部、底部、导航菜单等。 pages/ 目录：用于存放页面级别的组件文件，通常是路由对应的组件文件。在这个目录下，可以创建对应的文件夹，用于存储不同的页面组件。 plugins/ 目录：用于存放 Vite 插件相关的文件，可以按需加载不同的插件来实现不同的功能，如自动化测试、代码压缩等。 router/ 目录：用于存放 Vue.js 的路由配置文件，负责管理视图和 URL 之间的映射关系，方便实现页面之间的跳转和数据传递。 store/ 目录：用于存放 Vuex 状态管理相关的文件，负责管理应用程序中的数据和状态，方便统一管理和共享数据，提高开发效率。 utils/ 目录：用于存放一些通用的工具函数，如日期处理函数、字符串操作函数等。 vite.config.js 文件：Vite 的配置文件，可以通过该文件配置项目的参数、插件、打包优化等。该文件可以使用 CommonJS 或 ES6 模块的语法进行配置。 package.json 文件：标准的 Node.js 项目配置文件，包含了项目的基本信息和依赖关系。其中可以通过 scripts 字段定义几个命令，如 dev、build、serve 等，用于启动开发、构建和启动本地服务器等操作。 Vite 项目的入口为 src&#x2F;main.js 文件，这是 Vue.js 应用程序的启动文件，也是整个前端应用程序的入口文件。在该文件中，通常会引入 Vue.js 及其相关插件和组件，同时会创建 Vue 实例，挂载到 HTML 页面上指定的 DOM 元素中。 2.vite的运行界面 在安装了 Vite 的项目中，可以在 npm scripts 中使用 vite 可执行文件，或者直接使用 npx vite 运行它。下面是通过脚手架创建的 Vite 项目中默认的 npm scripts：(package.json) 1234567&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, // 启动开发服务器，别名：`vite dev`，`vite serve` &quot;build&quot;: &quot;vite build&quot;, // 为生产环境构建产物 &quot;preview&quot;: &quot;vite preview&quot; // 本地预览生产构建产物 &#125;&#125; 运行设置端口号：(vite.config.js) 1234567//修改vite项目配置文件 vite.config.jsexport default defineConfig(&#123; plugins: [vue()], server:&#123; port:3000 &#125;&#125;) 5.2.3 Vite+Vue3项目组件(SFC入门) 什么是VUE的组件? 一个页面作为整体,是由多个部分组成的,每个部分在这里就可以理解为一个组件 每个.vue文件就可以理解为一个组件,多个.vue文件可以构成一个整体页面 组件化给我们带来的另一个好处就是组件的复用和维护非常的方便 什么是.vue文件? 传统的页面有.html文件.css文件和.js文件三个文件组成(多文件组件) vue将这文件合并成一个.vue文件(Single-File Component，简称 SFC,单文件组件) .vue文件对js&#x2F;css&#x2F;html统一封装,这是VUE中的概念 该文件由三个部分组成 &lt;script&gt; &lt;template&gt; &lt;style&gt; template标签 代表组件的html部分代码 代替传统的.html文件 script标签 代表组件的js代码 代替传统的.js文件 style标签 代表组件的css样式代码 代替传统的.css文件 工程化vue项目如何组织这些组件? index.html是项目的入口,其中 &lt;div id =&#39;app&#39;&gt;&lt;/div&gt;是用于挂载所有组建的元素 index.html中的script标签引入了一个main.js文件,具体的挂载过程在main.js中执行 main.js是vue工程中非常重要的文件,他决定这项目使用哪些依赖,导入的第一个组件 App.vue是vue中的核心组件,所有的其他组件都要通过该组件进行导入,该组件通过路由可以控制页面的切换 5.2.4 Vite+Vue3响应式入门和setup函数 1 使用vite创建一个 vue+JavaScript项目 123npm create vitenpm install npm run dev App.vue 123456789101112&lt;script&gt; //存储vue页面逻辑js代码&lt;/script&gt;&lt;template&gt; &lt;!-- 页面的样式的是html代码--&gt;&lt;/template&gt;&lt;style scoped&gt; /** 存储的是css代码! &lt;style scoped&gt; 是 Vue.js 单文件组件中用于设置组件样式的一种方式。 它的含义是将样式局限在当前组件中，不对全局样式造成影响。 */&lt;/style&gt; 2 vue3响应式数据入门 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script type=&quot;module&quot;&gt; //存储vue页面逻辑js代码 import &#123;ref&#125; from &#x27;vue&#x27; export default&#123; setup()&#123; //非响应式数据: 修改后VUE不会更新DOM //响应式数据: 修改后VUE会更新DOM //VUE2中数据默认是响应式的 //VUE3中数据要经过ref或者reactive处理后才是响应式的 //ref是VUE3框架提供的一个函数,需要导入 //let counter = 1 //ref处理的响应式数据在js编码修改的时候需要通过.value操作 //ref响应式数据在绑定到html上时不需要.value let counter = ref(1) function increase()&#123; // 通过.value修改响应式数据 counter.value++ &#125; function decrease()&#123; counter.value-- &#125; return &#123; counter, increase, decrease &#125; &#125; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;decrease()&quot;&gt;-&lt;/button&gt; &#123;&#123; counter &#125;&#125; &lt;button @click=&quot;increase()&quot;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;&lt;style scoped&gt; button&#123; border: 1px solid red; &#125;&lt;/style&gt; 3 vue3 setup函数和语法糖 位置：src&#x2F;App.vue 12345678910111213141516171819202122232425262728293031&lt;script type=&quot;module&quot; setup&gt; /* &lt;script type=&quot;module&quot; setup&gt; 通过setup关键字可以省略 export default &#123;setup()&#123; return&#123;&#125;&#125;&#125;这些冗余的语法结构 */ import &#123;ref&#125; from &#x27;vue&#x27; // 定义响应式数据 let counter = ref(1) // 定义函数 function increase()&#123; counter.value++ &#125; function decrease()&#123; counter.value-- &#125; &lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;decrease()&quot;&gt;-&lt;/button&gt; &#123;&#123; counter &#125;&#125; &lt;button @click=&quot;increase()&quot;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;&lt;style scoped&gt; button&#123; border: 1px solid red; &#125;&lt;/style&gt; 5.2.5 Vite+Vue3关于样式的导入方式 全局引入main.js1import &#x27;./style/reset.css&#x27; //书写引入的资源的相对路径即可！ vue文件script代码引入1import &#x27;./style/reset.css&#x27; Vue文件style代码引入1@import &#x27;./style/reset.css&#x27; 5.2.6 关于JS和TS选择的问题 TS是JS的一个超集,使用TS之后,JS的语法更加的像JAVA,实际开发中用的确实更多,那么这里为什么我们没有立即使用TS进行开发,原因如下 1 为了降低难度,提高前端工程化的效率 2 对于学JAVA的我们来说,学习TS非常容易,但是还是需要一些时间 3 TS不是非学不可,不用TS仍然可以正常开发工程化的前端项目 4 尚硅谷已经发布了TS的专项课程,请大家在B站上自行搜索 “尚硅谷 TS” 5 建议大家先学完完整的前端工程化内容,然后再根据需求单独学习TS即可 六、Vue3视图渲染技术6.1 模版语法 Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。 6.1.1 插值表达式和文本渲染 插值表达式:最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 ,即双大括号&#123;&#123;&#125;&#125; 插值表达式是将数据渲染到元素的指定位置的手段之一 插值表达式不绝对依赖标签,其位置相对自由 插值表达式中支持javascript的运算表达式 插值表达式中也支持函数的调用 12345678910111213141516171819202122232425262728293031323334&lt;script setup type=&quot;module&quot;&gt; let msg =&quot;hello vue3&quot; let getMsg= ()=&gt;&#123; return &#x27;hello vue3 message&#x27; &#125; let age = 19 let bee = &#x27;蜜 蜂&#x27; // 购物车 const carts = [&#123;name:&#x27;可乐&#x27;,price:3,number:10&#125;,&#123;name:&#x27;薯片&#x27;,price:6,number:8&#125;]; //计算购物车总金额 function compute()&#123; let count = 0; for(let index in carts)&#123; count += carts[index].price*carts[index].number; &#125; return count; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; msg的值为: &#123;&#123; msg &#125;&#125; &lt;br&gt; getMsg返回的值为:&#123;&#123; getMsg() &#125;&#125; &lt;br&gt; 是否成年: &#123;&#123; age&gt;=18?&#x27;true&#x27;:&#x27;false&#x27; &#125;&#125; &lt;br&gt; 反转: &#123;&#123; bee.split(&#x27; &#x27;).reverse().join(&#x27;-&#x27;) &#125;&#125; &lt;br&gt; 购物车总金额: &#123;&#123; compute() &#125;&#125; &lt;br/&gt; 购物车总金额: &#123;&#123;carts[0].price*carts[0].number + carts[1].price*carts[1].number&#125;&#125; &lt;br&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 为了渲染双标中的文本,我们也可以选择使用v-text和v-html命令 v-*** 这种写法的方式使用的是vue的命令 v-***的命令必须依赖元素,并且要写在元素的开始标签中 v-***指令支持ES6中的字符串模板 插值表达式中支持javascript的运算表达式 插值表达式中也支持函数的调用 v-text可以将数据渲染成双标签中间的文本,但是不识别html元素结构的文本 v-html可以将数据渲染成双标签中间的文本,识别html元素结构的文本 12345678910111213141516171819202122232425262728&lt;script setup type=&quot;module&quot;&gt; let msg =&#x27;hello vue3&#x27; let getMsg= ()=&gt;&#123; return msg &#125; let age = 19 let bee = &#x27;蜜 蜂&#x27; let redMsg =&#x27;&lt;font color=\\&#x27;red\\&#x27;&gt;msg&lt;/font&gt;&#x27; let greenMsg =`&lt;font color=\\&#x27;green\\&#x27;&gt;$&#123;msg&#125;&lt;/font&gt;`&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;span v-text=&#x27;msg&#x27;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-text=&#x27;redMsg&#x27;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-text=&#x27;getMsg()&#x27;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-text=&#x27;age&gt;18?&quot;成年&quot;:&quot;未成年&quot;&#x27;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-text=&#x27;bee.split(&quot; &quot;).reverse().join(&quot;-&quot;)&#x27;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-html=&#x27;msg&#x27;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-html=&#x27;redMsg&#x27;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-html=&#x27;greenMsg&#x27;&gt;&lt;/span&gt; &lt;br&gt; &lt;span v-html=&quot;`&lt;font color=&#x27;green&#x27;&gt;$&#123;msg&#125;&lt;/font&gt;`&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 6.1.2 Attribute属性渲染 想要渲染一个元素的 attribute，应该使用 v-bind指令 由于插值表达式不能直接放在标签的属性中,所有要渲染元素的属性就应该使用v-bind v-bind可以用于渲染任何元素的属性,语法为 v-bind:属性名=&#39;数据名&#39;, 可以简写为 :属性名=&#39;数据名&#39; 12345678910111213141516171819202122232425&lt;script setup type=&quot;module&quot;&gt; const data = &#123; name:&#x27;尚硅谷&#x27;, url:&quot;http://www.atguigu.com&quot;, logo:&quot;http://www.atguigu.com/images/index_new/logo.png&quot; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;a v-bind:href=&#x27;data.url&#x27; target=&quot;_self&quot;&gt; &lt;img :src=&quot;data.logo&quot; :title=&quot;data.name&quot;&gt; &lt;br&gt; &lt;input type=&quot;button&quot; :value=&quot;`点击访问$&#123;data.name&#125;`&quot;&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 6.1.3 事件的绑定 我们可以使用 v-on 来监听 DOM 事件，并在事件触发时执行对应的 Vue的JavaScript代码。 用法：v-on:click=&quot;handler&quot; 或简写为 @click=&quot;handler&quot; vue中的事件名&#x3D;原生事件名去掉on 前缀 如:onClick --&gt; click handler的值可以是方法事件处理器,也可以是内联事件处理器 绑定事件时,可以通过一些绑定的修饰符,常见的事件修饰符如下 .once：只触发一次事件。[重点] .prevent：阻止默认事件。[重点] .stop：阻止事件冒泡。 .capture：使用事件捕获模式而不是冒泡模式。 .self：只在事件发送者自身触发时才触发事件。 12345678910111213141516171819202122232425262728293031323334&lt;script setup type=&quot;module&quot;&gt; import &#123;ref&#125; from &#x27;vue&#x27; // 响应式数据 当发生变化时,会自动更新 dom树 let count=ref(0) let addCount= ()=&gt;&#123; count.value++ &#125; let incrCount= (event)=&gt;&#123; count.value++ // 通过事件对象阻止组件的默认行为 event.preventDefault(); &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;count的值是:&#123;&#123; count &#125;&#125;&lt;/h1&gt; &lt;!-- 方法事件处理器 --&gt; &lt;button v-on:click=&quot;addCount()&quot;&gt;addCount&lt;/button&gt; &lt;br&gt; &lt;!-- 内联事件处理器 --&gt; &lt;button @click=&quot;count++&quot;&gt;incrCount&lt;/button&gt; &lt;br&gt; &lt;!-- 事件修饰符 once 只绑定事件一次 --&gt; &lt;button @click.once=&quot;count++&quot;&gt;addOnce&lt;/button&gt; &lt;br&gt; &lt;!-- 事件修饰符 prevent 阻止组件的默认行为 --&gt; &lt;a href=&quot;http://www.atguigu.com&quot; target=&quot;_blank&quot; @click.prevent=&quot;count++&quot;&gt;prevent&lt;/a&gt; &lt;br&gt; &lt;!-- 原生js方式阻止组件默认行为 (推荐) --&gt; &lt;a href=&quot;http://www.atguigu.com&quot; target=&quot;_blank&quot; @click=&quot;incrCount($event)&quot;&gt;prevent&lt;/a&gt; &lt;br&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 6.2 响应式基础 此处的响应式是指 : 数据模型发生变化时,自动更新DOM树内容,页面上显示的内容会进行同步变化,vue3的数据模型不是自动响应式的,需要我们做一些特殊的处理 6.2.1 响应式需求案例 需求：实现 + - 按钮,实现数字加一减一 12345678910111213141516171819202122&lt;script type=&quot;module&quot; setup&gt; let counter = 0; function show()&#123; alert(counter); &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;counter--&quot;&gt;-&lt;/button&gt; &#123;&#123; counter &#125;&#125; &lt;button @click=&quot;counter++&quot;&gt;+&lt;/button&gt; &lt;hr&gt; &lt;!-- 此案例,我们发现counter值,会改变,但是页面不改变! 默认Vue3的数据是非响应式的!--&gt; &lt;button @click=&quot;show()&quot;&gt;显示counter值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 6.2.2 响应式实现关键字ref ref 可以将一个基本类型的数据（如字符串，数字等）转换为一个响应式对象。 ref 只能包裹单一元素 12345678910111213141516171819202122232425262728293031&lt;script type=&quot;module&quot; setup&gt; /* 从vue中引入ref方法 */ import &#123;ref&#125; from &#x27;vue&#x27; let counter = ref(0); function show()&#123; alert(counter.value); &#125; /* 函数中要操作ref处理过的数据,需要通过.value形式 */ let decr = () =&gt;&#123; counter.value--; &#125; let incr = () =&gt;&#123; counter.value++; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;counter--&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;decr()&quot;&gt;-&lt;/button&gt; &#123;&#123; counter &#125;&#125; &lt;button @click=&quot;counter++&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;incr()&quot;&gt;+&lt;/button&gt; &lt;hr&gt; &lt;button @click=&quot;show()&quot;&gt;显示counter值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 在上面的例子中，我们使用 ref 包裹了一个数字，在代码中给这个数字加 1 后，视图也会跟着动态更新。需要注意的是，由于使用了 ref，因此需要在访问该对象时使用 .value 来获取其实际值。 6.2.3 响应式实现关键字reactive 我们可以使用 reactive() 函数创建一个响应式对象或数组： 123456789101112131415161718192021222324252627282930313233&lt;script type=&quot;module&quot; setup&gt; /* 从vue中引入reactive方法 */ import &#123;ref,reactive&#125; from &#x27;vue&#x27; let data = reactive(&#123; counter:0 &#125;) function show()&#123; alert(data.counter); &#125; /* 函数中要操作reactive处理过的数据,需要通过 对象名.属性名的方式 */ let decr = () =&gt;&#123; data.counter--; &#125; let incr = () =&gt;&#123; data.counter++; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;data.counter--&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;decr()&quot;&gt;-&lt;/button&gt; &#123;&#123; data.counter &#125;&#125; &lt;button @click=&quot;data.counter++&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;incr()&quot;&gt;+&lt;/button&gt; &lt;hr&gt; &lt;button @click=&quot;show()&quot;&gt;显示counter值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 对比ref和reactive: 使用 ref 适用于以下开发场景： 包装基本类型数据：ref 主要用于包装基本类型数据（如字符串、数字等），即只有一个值的数据，如果你想监听这个值的变化，用 ref 最为方便。在组件中使用时也很常见。 访问方式简单：ref 对象在访问时与普通的基本类型值没有太大区别，只需要通过 .value 访问其实际值即可。 使用 reactive 适用于以下开发场景： 包装复杂对象：reactive 可以将一个普通对象转化为响应式对象，这样在数据变化时会自动更新界面，特别适用于处理复杂对象或者数据结构。 需要递归监听的属性：使用 reactive 可以递归追踪所有响应式对象内部的变化，从而保证界面的自动更新。 综上所述，ref 适用与简单情形下的数据双向绑定，对于只有一个字符等基本类型数据或自定义组件等情况，建议可以使用 ref；而对于对象、函数等较为复杂的数据结构，以及需要递归监听的属性变化，建议使用 reactive。当然，在实际项目中根据需求灵活选择也是十分必要的。 6.2.4 扩展响应式关键字toRefs 和 toRef toRef基于reactive响应式对象上的一个属性，创建一个对应的 ref响应式数据。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。toRefs将一个响应式对象多个属性转换为一个多个ref数据，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。 案例：响应显示reactive对象属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script type=&quot;module&quot; setup&gt; /* 从vue中引入reactive方法 */ import &#123;ref,reactive,toRef,toRefs&#125; from &#x27;vue&#x27; let data = reactive(&#123; counter:0, name:&quot;test&quot; &#125;) // 将一个reactive响应式对象中的某个属性转换成一个ref响应式对象 let ct =toRef(data,&#x27;counter&#x27;); // 将一个reactive响应式对象中的多个属性转换成多个ref响应式对象 let &#123;counter,name&#125; = toRefs(data) function show()&#123; alert(data.counter); // 获取ref的响应对象,需要通过.value属性 alert(counter.value); alert(name.value) &#125; /* 函数中要操作ref处理过的数据,需要通过.value形式 */ let decr = () =&gt;&#123; data.counter--; &#125; let incr = () =&gt;&#123; /* ref响应式数据,要通过.value属性访问 */ counter.value++; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;data.counter--&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;decr()&quot;&gt;-&lt;/button&gt; &#123;&#123; data.counter &#125;&#125; &amp;amp; &#123;&#123; ct &#125;&#125; &lt;button @click=&quot;data.counter++&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;incr()&quot;&gt;+&lt;/button&gt; &lt;hr&gt; &lt;button @click=&quot;show()&quot;&gt;显示counter值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 6.3 条件和列表渲染6.3.1 条件渲染 v-if 条件渲染 v-if=&#39;表达式&#39; 只会在指令的表达式返回真值时才被渲染 也可以使用 v-else 为 v-if 添加一个“else 区块”。 一个 v-else 元素必须跟在一个 v-if 元素后面，否则它将不会被识别。 123456789101112131415&lt;script type=&quot;module&quot; setup&gt; import &#123;ref&#125; from &#x27;vue&#x27; let awesome = ref(true)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt; &lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; v-show条件渲染扩展： 另一个可以用来按条件显示一个元素的指令是 v-show。其用法基本一样： 不同之处在于 v-show 会在 DOM 渲染中保留该元素；v-show 仅切换了该元素上名为 display 的 CSS 属性。 v-show 不支持在 &lt;template&gt; 元素上使用，也不能和 v-else 搭配使用。 1234567891011121314151617&lt;script type=&quot;module&quot; setup&gt; import &#123;ref&#125; from &#x27;vue&#x27; let awesome = ref(true)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1 id=&quot;ha&quot; v-show=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;h1 id=&quot;hb&quot; v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;h1 id=&quot;hc&quot; v-else&gt;Oh no 😢&lt;/h1&gt; &lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; v-if vs v-show v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。 v-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。 相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。 总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。 6.3.2 列表渲染 我们可以使用 v-for 指令基于一个数组来渲染一个列表。 v-for 指令的值需要使用 item in items 形式的特殊语法，其中 items 是源数据的数组，而 item 是迭代项的别名： 在 v-for 块中可以完整地访问父作用域内的属性和变量。v-for 也支持使用可选的第二个参数表示当前项的位置索引。 123456789101112131415161718192021222324252627282930313233343536&lt;script type=&quot;module&quot; setup&gt; import &#123;ref,reactive&#125; from &#x27;vue&#x27; let parentMessage= ref(&#x27;产品&#x27;) let items =reactive([ &#123; id:&#x27;item1&#x27;, message:&quot;薯片&quot; &#125;, &#123; id:&#x27;item2&#x27;, message:&quot;可乐&quot; &#125; ])&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;!-- :key不写也可以 --&gt; &lt;li v-for=&#x27;item in items&#x27; :key=&#x27;item.id&#x27;&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;!-- index表示索引,当然不是非得使用index这个单词 --&gt; &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 案例：实现购物车显示和删除购物项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script type=&quot;module&quot; setup&gt; //引入模块 import &#123; reactive&#125; from &#x27;vue&#x27; //准备购物车数据,设置成响应数据 const carts = reactive([&#123;name:&#x27;可乐&#x27;,price:3,number:10&#125;,&#123;name:&#x27;薯片&#x27;,price:6,number:8&#125;]) //计算购物车总金额 function compute()&#123; let count = 0; for(let index in carts)&#123; count += carts[index].price*carts[index].number; &#125; return count; &#125; //删除购物项方法 function removeCart(index)&#123; carts.splice(index,1); &#125; &lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;商品名&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;数量&lt;/th&gt; &lt;th&gt;小计&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody v-if=&quot;carts.length &gt; 0&quot;&gt; &lt;!-- 有数据显示--&gt; &lt;tr v-for=&quot;cart,index in carts&quot; :key=&quot;index&quot;&gt; &lt;th&gt;&#123;&#123; index+1 &#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123; cart.name &#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123; cart.price + &#x27;元&#x27; &#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123; cart.number &#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123; cart.price*cart.number + &#x27;元&#x27;&#125;&#125;&lt;/th&gt; &lt;th&gt; &lt;button @click=&quot;removeCart(index)&quot;&gt;删除&lt;/button&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody v-else&gt; &lt;!-- 没有数据显示--&gt; &lt;tr&gt; &lt;td colspan=&quot;6&quot;&gt;购物车没有数据!&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 购物车总金额: &#123;&#123; compute() &#125;&#125; 元 &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 6.4 双向绑定 单项绑定和双向绑定 单向绑定: 响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变不会同步更新到响应式数据 双向绑定: 响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变会同步更新到响应式数据 用户通过表单标签才能够输入数据,所以双向绑定都是应用到表单标签上的,其他标签不行 v-model专门用于双向绑定表单标签的value属性,语法为 v-model:value=&#39;&#39;,可以简写为 v-model=&#39;&#39; v-model还可以用于各种不同类型的输入，&lt;textarea&gt;、&lt;select&gt; 元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;script type=&quot;module&quot; setup&gt; //引入模块 import &#123; reactive,ref&#125; from &#x27;vue&#x27; let hbs = ref([]); //装爱好的值 let user = reactive(&#123;username:null,password:null,introduce:null,pro:null&#125;) function login()&#123; alert(hbs.value); alert(JSON.stringify(user)); &#125; function clearx()&#123; //user = &#123;&#125;;// 这中写法会将数据变成非响应的,应该是user.username=&quot;&quot; user.username=&#x27;&#x27; user.password=&#x27;&#x27; user.introduce=&#x27;&#x27; user.pro=&#x27;&#x27; hbs.value.splice(0,hbs.value.length);; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; 账号： &lt;input type=&quot;text&quot; placeholder=&quot;请输入账号！&quot; v-model=&quot;user.username&quot;&gt; &lt;br&gt; 密码： &lt;input type=&quot;text&quot; placeholder=&quot;请输入账号！&quot; v-model=&quot;user.password&quot;&gt; &lt;br&gt; 爱好： 吃 &lt;input type=&quot;checkbox&quot; name=&quot;hbs&quot; v-model=&quot;hbs&quot; value=&quot;吃&quot;&gt; 喝 &lt;input type=&quot;checkbox&quot; name=&quot;hbs&quot; v-model=&quot;hbs&quot; value=&quot;喝&quot;&gt; 玩 &lt;input type=&quot;checkbox&quot; name=&quot;hbs&quot; v-model=&quot;hbs&quot; value=&quot;玩&quot;&gt; 乐 &lt;input type=&quot;checkbox&quot; name=&quot;hbs&quot; v-model=&quot;hbs&quot; value=&quot;乐&quot;&gt; &lt;br&gt; 简介:&lt;textarea v-model=&quot;user.introduce&quot;&gt;&lt;/textarea&gt; &lt;br&gt; 籍贯: &lt;select v-model=&quot;user.pro&quot;&gt; &lt;option value=&quot;1&quot;&gt;黑&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;吉&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;辽&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;京&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;津&lt;/option&gt; &lt;option value=&quot;6&quot;&gt;冀&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;button @click=&quot;login()&quot;&gt;登录&lt;/button&gt; &lt;button @click=&quot;clearx()&quot;&gt;重置&lt;/button&gt; &lt;hr&gt; 显示爱好:&#123;&#123; hbs &#125;&#125; &lt;hr&gt; 显示用户信息:&#123;&#123; user &#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 6.5 属性计算 模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象： 1234567891011121314151617181920212223&lt;script type=&quot;module&quot; setup&gt; //引入模块 import &#123; reactive,computed&#125; from &#x27;vue&#x27; const author = reactive(&#123; name: &#x27;John Doe&#x27;, books: [ &#x27;Vue 2 - Advanced Guide&#x27;, &#x27;Vue 3 - Basic Guide&#x27;, &#x27;Vue 4 - The Mystery&#x27; ] &#125;) &lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;author.name&#125;&#125; Has published books?:&lt;/p&gt; &lt;span&gt;&#123;&#123; author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 author.books。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。 因此我们推荐使用计算属性来描述依赖响应式状态的复杂逻辑。这是重构后的示例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script type=&quot;module&quot; setup&gt; //引入模块 import &#123; reactive,computed&#125; from &#x27;vue&#x27; const author = reactive(&#123; name: &#x27;John Doe&#x27;, books: [ &#x27;Vue 2 - Advanced Guide&#x27;, &#x27;Vue 3 - Basic Guide&#x27;, &#x27;Vue 4 - The Mystery&#x27; ] &#125;) // 一个计算属性 ref const publishedBooksMessage = computed(() =&gt; &#123; console.log(&quot;publishedBooksMessage&quot;) return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;) // 一个函数 let hasBooks = ()=&gt;&#123; console.log(&quot;hasBooks&quot;) return author.books.length &gt; 0?&#x27;Yes&#x27;:&#x27;no&#x27; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;author.name&#125;&#125; Has published books?:&lt;/p&gt; &lt;span&gt;&#123;&#123; author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; hasBooks() &#125;&#125;&lt;/span&gt;&lt;!-- 调用方法,每个标签都会调用一次 --&gt; &lt;span&gt;&#123;&#123; hasBooks() &#125;&#125;&lt;/span&gt; &lt;p&gt;&#123;&#123;author.name&#125;&#125; Has published books?:&lt;/p&gt; &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;&lt;!-- 属性计算,属性值不变时,多个个标签只会调用一次 --&gt; &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 我们在这里定义了一个计算属性 publishedBooksMessage。computed() 方法期望接收一个 getter 函数，返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 publishedBooksMessage.value 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。 Vue 的计算属性会自动追踪响应式依赖。它会检测到 publishedBooksMessage 依赖于 author.books，所以当 author.books 改变时，任何依赖于 publishedBooksMessage 的绑定都会同时更新。 计算属性缓存 vs 方法 若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果! 6.6 数据监听器 计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数： watch主要用于以下场景： 当数据发生变化时需要执行相应的操作 监听数据变化，当满足一定条件时触发相应操作 在异步操作前或操作后需要执行相应的操作 监控响应式数据（watch）： 123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=&quot;module&quot; setup&gt; //引入模块 import &#123; ref,reactive,watch&#125; from &#x27;vue&#x27; let firstname=ref(&#x27;&#x27;) let lastname=reactive(&#123;name:&#x27;&#x27;&#125;) let fullname=ref(&#x27;&#x27;) //监听一个ref响应式数据 watch(firstname,(newValue,oldValue)=&gt;&#123; console.log(`$&#123;oldValue&#125;变为$&#123;newValue&#125;`) fullname.value=firstname.value+lastname.name &#125;) //监听reactive响应式数据的指定属性 watch(()=&gt;lastname.name,(newValue,oldValue)=&gt;&#123; console.log(`$&#123;oldValue&#125;变为$&#123;newValue&#125;`) fullname.value=firstname.value+lastname.name &#125;) //监听reactive响应式数据的所有属性(深度监视,一般不推荐) //deep:true 深度监视 //immediate:true 深度监视在进入页面时立即执行一次 watch(()=&gt;lastname,(newValue,oldValue)=&gt;&#123; // 此时的newValue和oldValue一样,都是lastname console.log(newValue) console.log(oldValue) fullname.value=firstname.value+lastname.name &#125;,&#123;deep:true,immediate:false&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; 全名:&#123;&#123;fullname&#125;&#125; &lt;br&gt; 姓氏:&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; &lt;br&gt; 名字:&lt;input type=&quot;text&quot; v-model=&quot;lastname.name&quot; &gt; &lt;br&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 监控响应式数据(watchEffect)： watchEffect默认监听所有的响应式数据 12345678910111213141516171819202122232425262728&lt;script type=&quot;module&quot; setup&gt; //引入模块 import &#123; ref,reactive,watch, watchEffect&#125; from &#x27;vue&#x27; let firstname=ref(&#x27;&#x27;) let lastname=reactive(&#123;name:&#x27;&#x27;&#125;) let fullname=ref(&#x27;&#x27;) //监听所有响应式数据 watchEffect(()=&gt;&#123; //直接在内部使用监听属性即可！不用外部声明 //也不需要，即时回调设置！默认初始化就加载！ console.log(firstname.value) console.log(lastname.name) fullname.value=`$&#123;firstname.value&#125;$&#123;lastname.name&#125;` &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; 全名:&#123;&#123;fullname&#125;&#125; &lt;br&gt; 姓氏:&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; &lt;br&gt; 名字:&lt;input type=&quot;text&quot; v-model=&quot;lastname.name&quot; &gt; &lt;br&gt; &lt;/div&gt;&lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; watch vs. watchEffect watch 和 watchEffect 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式： watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。 watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。 6.7. Vue生命周期6.7.1 生命周期简介 每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码! 周期图解： 常见钩子函数 onMounted() 注册一个回调函数，在组件挂载完成后执行。 onUpdated() 注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。 onUnmounted() 注册一个回调函数，在组件实例被卸载之后调用。 onBeforeMount() 注册一个钩子，在组件被挂载之前被调用。 onBeforeUpdate() 注册一个钩子，在组件即将因为响应式状态变更而更新其 DOM 树之前调用。 onBeforeUnmount() 注册一个钩子，在组件实例被卸载之前调用。 6.7.2 生命周期案例12345678910111213141516171819202122232425262728293031323334353637&lt;script setup&gt; import &#123;ref,onUpdated,onMounted,onBeforeUpdate&#125; from &#x27;vue&#x27; let message =ref(&#x27;hello&#x27;) // 挂载完毕生命周期 onMounted(()=&gt;&#123; console.log(&#x27;-----------onMounted---------&#x27;) let span1 =document.getElementById(&quot;span1&quot;) console.log(span1.innerText) &#125;) // 更新前生命周期 onBeforeUpdate(()=&gt;&#123; console.log(&#x27;-----------onBeforeUpdate---------&#x27;) console.log(message.value) let span1 =document.getElementById(&quot;span1&quot;) console.log(span1.innerText) &#125;) // 更新完成生命周期 onUpdated(()=&gt;&#123; console.log(&#x27;-----------onUpdated---------&#x27;) let span1 =document.getElementById(&quot;span1&quot;) console.log(span1.innerText) &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;span id=&quot;span1&quot; v-text=&quot;message&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;/div&gt; &lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 6.8 Vue组件6.8.1 组件基础 组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。组件就是实现应用中局部功能代码和资源的集合！在实际应用中，组件常常被组织成层层嵌套的树状结构： 这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。 传统方式编写应用： 组件方式编写应用： 组件化：对js&#x2F;css&#x2F;html统一封装,这是VUE中的概念 模块化：对js的统一封装,这是ES6中的概念 组件化中,对js部分代码的处理使用ES6中的模块化 6.8.2 组件化入门案例 案例需求： 创建一个页面，包含头部和菜单以及内容显示区域，每个区域使用独立组建！ 1 准备vue项目 123npm create vitecd vite项目npm install 2 安装相关依赖 12npm install sassnpm install bootstrap 3 创建子组件 在src&#x2F;components文件下 vscode需要安装Vetur插件，这样vue文件有快捷提示 Header.vue 1234567891011&lt;script setup type=&quot;module&quot;&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; 欢迎： xx &lt;a href=&quot;#&quot;&gt;退出登录&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; Navigator.vue 123456789101112131415161718&lt;script setup type=&quot;module&quot;&gt;&lt;/script&gt;&lt;template&gt; &lt;!-- 推荐写一个根标签--&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;学员管理&lt;/li&gt; &lt;li&gt;图书管理&lt;/li&gt; &lt;li&gt;请假管理&lt;/li&gt; &lt;li&gt;考试管理&lt;/li&gt; &lt;li&gt;讲师管理&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; Content.vue 1234567891011&lt;script setup type=&quot;module&quot;&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; 展示的主要内容！ &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; App.vue 入口组件App引入组件 12345678910111213141516171819202122232425262728293031323334353637&lt;script setup&gt; import Header from &#x27;./components/Header.vue&#x27; import Navigator from &#x27;./components/Navigator.vue&#x27; import Content from &#x27;./components/Content.vue&#x27;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;Header class=&quot;header&quot;&gt;&lt;/Header&gt; &lt;Navigator class=&quot;navigator&quot;&gt;&lt;/Navigator&gt; &lt;Content class=&quot;content&quot;&gt;&lt;/Content&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .header&#123; height: 80px; border: 1px solid red; &#125; .navigator&#123; width: 15%; height: 800px; display: inline-block; border: 1px blue solid; float: left; &#125; .content&#123; width: 83%; height: 800px; display: inline-block; border: 1px goldenrod solid; float: right; &#125;&lt;/style&gt; 4 启动测试 1npm run dev 6.8.3 组件之间传递数据6.8.3.1 父传子 Vue3 中父组件向子组件传值可以通过 props 进行，具体操作如下： 首先，在父组件中定义需要传递给子组件的值，接着，在父组件的模板中引入子组件，同时在引入子组件的标签中添加 props 属性并为其设置需要传递的值。 在 Vue3 中，父组件通过 props 传递给子组件的值是响应式的。也就是说，如果在父组件中的传递的值发生了改变，子组件中的值也会相应地更新。 父组件代码：App.vue 123456789101112131415161718192021222324252627&lt;script setup&gt; import Son from &#x27;./components/Son.vue&#x27; import &#123;ref,reactive,toRefs&#125; from &#x27;vue&#x27; let message = ref(&#x27;parent data!&#x27;) let title = ref(42) function changeMessage()&#123; message.value = &#x27;修改数据！&#x27; title.value++ &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt; &lt;hr&gt; &lt;!-- 使用子组件，并且传递数据！ --&gt; &lt;Son :message=&quot;message&quot; :title=&quot;title&quot;&gt;&lt;/Son&gt; &lt;hr&gt; &lt;button @click=&quot;changeMessage&quot;&gt;点击更新&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 子组件代码：Son.vue 123456789101112131415161718&lt;script setup type=&quot;module&quot;&gt; import &#123;ref,isRef,defineProps&#125; from &#x27;vue&#x27; //声明父组件传递属性值 defineProps(&#123; message:String , title:Number &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; 6.8.3.2 子传父 父组件： App.vue 12345678910111213141516171819202122232425262728293031&lt;script setup&gt; import Son from &#x27;./components/Son.vue&#x27; import &#123;ref&#125; from &#x27;vue&#x27; let pdata = ref(&#x27;&#x27;) const padd = (data) =&gt; &#123; console.log(&#x27;2222&#x27;); pdata.value =data; &#125; //自定义接收，子组件传递数据方法！ 参数为数据！ const psub = (data) =&gt; &#123; console.log(&#x27;11111&#x27;); pdata.value = data; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 声明@事件名应该等于子模块对应事件名！调用方法可以是当前自定义！--&gt; &lt;Son @add=&quot;padd&quot; @sub=&quot;psub&quot;&gt;&lt;/Son&gt; &lt;hr&gt; &#123;&#123; pdata &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; 子组件：Son.vue 1234567891011121314151617181920212223242526&lt;script setup&gt; import &#123;ref,defineEmits&#125; from &#x27;vue&#x27; //1.定义要发送给父组件的方法，可以1或者多个 let emites = defineEmits([&#x27;add&#x27;,&#x27;sub&#x27;]); let data = ref(1); function sendMsgToParent()&#123; console.log(&#x27;-------son--------&#x27;); //2.出发父组件对应的方法，调用defineEmites对应的属性 emites(&#x27;add&#x27;,&#x27;add data!&#x27;+data.value) emites(&#x27;sub&#x27;,&#x27;sub data!&#x27;+data.value) data.value ++; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;sendMsgToParent&quot;&gt;发送消息给父组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 6.8.3.3 兄弟传参 Navigator.vue: 发送数据到App.vue 12345678910111213141516171819202122232425&lt;script setup type=&quot;module&quot;&gt; import &#123;defineEmits&#125; from &#x27;vue&#x27; const emits = defineEmits([&#x27;sendMenu&#x27;]); //触发事件，向父容器发送数据 function send(data)&#123; emits(&#x27;sendMenu&#x27;,data); &#125;&lt;/script&gt;&lt;template&gt; &lt;!-- 推荐写一个根标签--&gt; &lt;div&gt; &lt;ul&gt; &lt;li @click=&quot;send(&#x27;学员管理&#x27;)&quot;&gt;学员管理&lt;/li&gt; &lt;li @click=&quot;send(&#x27;图书管理&#x27;)&quot;&gt;图书管理&lt;/li&gt; &lt;li @click=&quot;send(&#x27;请假管理&#x27;)&quot;&gt;请假管理&lt;/li&gt; &lt;li @click=&quot;send(&#x27;考试管理&#x27;)&quot;&gt;考试管理&lt;/li&gt; &lt;li @click=&quot;send(&#x27;讲师管理&#x27;)&quot;&gt;讲师管理&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; App.vue: 发送数据到Content.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script setup&gt; import Header from &#x27;./components/Header.vue&#x27; import Navigator from &#x27;./components/Navigator.vue&#x27; import Content from &#x27;./components/Content.vue&#x27; import &#123;ref&#125; from &quot;vue&quot; //定义接受navigator传递参数 var navigator_menu = ref(&#x27;ceshi&#x27;); const receiver = (data) =&gt;&#123; navigator_menu.value = data; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;hr&gt; &#123;&#123; navigator_menu &#125;&#125; &lt;hr&gt; &lt;Header class=&quot;header&quot;&gt;&lt;/Header&gt; &lt;Navigator @sendMenu=&quot;receiver&quot; class=&quot;navigator&quot;&gt;&lt;/Navigator&gt; &lt;!-- 向子组件传递数据--&gt; &lt;Content class=&quot;content&quot; :message=&quot;navigator_menu&quot;&gt;&lt;/Content&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .header&#123; height: 80px; border: 1px solid red; &#125; .navigator&#123; width: 15%; height: 800px; display: inline-block; border: 1px blue solid; float: left; &#125; .content&#123; width: 83%; height: 800px; display: inline-block; border: 1px goldenrod solid; float: right; &#125;&lt;/style&gt; Content.vue 1234567891011121314151617&lt;script setup type=&quot;module&quot;&gt; defineProps(&#123; message:String &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; 展示的主要内容！ &lt;hr&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; 七、Vue3路由机制router7.1 路由简介 1 什么是路由？ 定义：路由就是根据不同的 URL 地址展示不同的内容或页面。 通俗理解：路由就像是一个地图，我们要去不同的地方，需要通过不同的路线进行导航。 2 路由的作用 单页应用程序（SPA）中，路由可以实现不同视图之间的无刷新切换，提升用户体验； 路由还可以实现页面的认证和权限控制，保护用户的隐私和安全； 路由还可以利用浏览器的前进与后退，帮助用户更好地回到之前访问过的页面。 7.2 路由入门案例 1 案例需求分析 ​ 2 创建项目和导入路由依赖 123npm create vite //创建项目cd 项目文件夹 //进入项目文件夹npm install //安装项目需求依赖npm install vue-router@4 --save //安装全局的vue-router 4版本 3 准备页面和组件 components&#x2F;Home.vue 123456789101112&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;Home页面&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; components&#x2F;List.vue 1234567891011&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;List页面&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; components&#x2F;Add.vue 1234567891011&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;Add页面&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; components&#x2F;Update.vue 1234567891011&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;Update页面&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; App.vue 123456789101112131415161718192021222324252627282930&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;App页面&lt;/h1&gt; &lt;hr/&gt; &lt;!-- 路由的连接 --&gt; &lt;router-link to=&quot;/&quot;&gt;home页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/list&quot;&gt;list页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/add&quot;&gt;add页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/update&quot;&gt;update页&lt;/router-link&gt; &lt;br&gt; &lt;hr/&gt; &lt;!-- 路由连接对应视图的展示位置 --&gt; &lt;hr&gt; 默认展示位置:&lt;router-view&gt;&lt;/router-view&gt; &lt;hr&gt; Home视图展示:&lt;router-view name=&quot;homeView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; List视图展示:&lt;router-view name=&quot;listView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; Add视图展示:&lt;router-view name=&quot;addView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; Update视图展示:&lt;router-view name=&quot;updateView&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 4 准备路由配置 src&#x2F;routers&#x2F;router.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 导入路由创建的相关方法import &#123;createRouter,createWebHashHistory&#125; from &#x27;vue-router&#x27;// 导入vue组件import Home from &#x27;../components/Home.vue&#x27;import List from &#x27;../components/List.vue&#x27;import Add from &#x27;../components/Add.vue&#x27;import Update from &#x27;../components/Update.vue&#x27;// 创建路由对象,声明路由规则const router = createRouter(&#123; //createWebHashHistory() 是 Vue.js 基于 hash 模式创建路由的工厂函数。在使用这种模式下，路由信息保存在 URL 的 hash 中， //使用 createWebHashHistory() 方法，可以创建一个路由历史记录对象，用于管理应用程序的路由。在 Vue.js 应用中， //通常使用该方法来创建路由的历史记录对象。 //就是路由中缓存历史记录的对象，vue-router提供 history: createWebHashHistory(), routes:[ &#123; path:&#x27;/&#x27;, /* component指定组件在默认的路由视图位置展示 components:Home components指定组件在name为某个值的路由视图位置展示 components:&#123; default:Home,// 默认路由视图位置 homeView:Home// name为homeView的路由视图位置 &#125; */ components:&#123; default:Home, homeView:Home &#125; &#125;, &#123; path:&#x27;/list&#x27;, components:&#123; listView : List &#125; &#125;, &#123; path:&#x27;/add&#x27;, components:&#123; addView:Add &#125; &#125;, &#123; path:&#x27;/update&#x27;, components:&#123; updateView:Update &#125; &#125;, ]&#125;)// 对外暴露路由对象export default router; 5 main.js引入router配置 修改文件：main.js (入口文件) 12345678910import &#123; createApp &#125; from &#x27;vue&#x27;import &#x27;./style.css&#x27;import App from &#x27;./App.vue&#x27;//导入router模块import router from &#x27;./routers/router.js&#x27;let app = createApp(App)//绑定路由对象app.use(router)//挂在试图app.mount(&quot;#app&quot;) 6 启动测试 1npm run dev 7.3 路由重定向 重定向的作用：将一个路由重定向到另一个路由上 修改案例：访问&#x2F;list和&#x2F;showAll都定向到List.vue router.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 导入路由创建的相关方法import &#123;createRouter,createWebHashHistory&#125; from &#x27;vue-router&#x27;// 导入vue组件import Home from &#x27;../components/Home.vue&#x27;import List from &#x27;../components/List.vue&#x27;import Add from &#x27;../components/Add.vue&#x27;import Update from &#x27;../components/Update.vue&#x27;// 创建路由对象,声明路由规则const router = createRouter(&#123; history: createWebHashHistory(), routes:[ &#123; path:&#x27;/&#x27;, components:&#123; default:Home, homeView:Home &#125; &#125;, &#123; path:&#x27;/list&#x27;, components:&#123; listView : List &#125; &#125;, &#123; path:&#x27;/showAll&#x27;, // 重定向 redirect :&#x27;/list&#x27; &#125;, &#123; path:&#x27;/add&#x27;, components:&#123; addView:Add &#125; &#125;, &#123; path:&#x27;/update&#x27;, components:&#123; updateView:Update &#125; &#125;, ]&#125;)// 对外暴露路由对象export default router; App.vue 123456789101112131415161718192021222324252627282930&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;App页面&lt;/h1&gt; &lt;hr/&gt; &lt;!-- 路由的连接 --&gt; &lt;router-link to=&quot;/&quot;&gt;home页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/list&quot;&gt;list页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/showAll&quot;&gt;showAll页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/add&quot;&gt;add页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/update&quot;&gt;update页&lt;/router-link&gt; &lt;br&gt; &lt;hr/&gt; &lt;!-- 路由连接对应视图的展示位置 --&gt; &lt;hr&gt; 默认展示位置:&lt;router-view&gt;&lt;/router-view&gt; &lt;hr&gt; Home视图展示:&lt;router-view name=&quot;homeView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; List视图展示:&lt;router-view name=&quot;listView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; Add视图展示:&lt;router-view name=&quot;addView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; Update视图展示:&lt;router-view name=&quot;updateView&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 7.4 编程式路由(useRouter) 普通路由 &lt;router-link to=&quot;/list&quot;&gt;list页&lt;/router-link&gt; 这种路由,to中的内容目前是固定的,点击后只能切换&#x2F;list对象组件(声明式路由) 编程式路由 通过useRouter,动态决定向那个组件切换的路由 在 Vue 3 和 Vue Router 4 中，你可以使用 useRouter 来实现动态路由(编程式路由) 这里的 useRouter 方法返回的是一个 router 对象，你可以用它来做如导航到新页面、返回上一页面等操作。 案例需求: 通过普通按钮配合事件绑定实现路由页面跳转,不直接使用router-link标签 App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script setup type=&quot;module&quot;&gt; import &#123;useRouter&#125; from &#x27;vue-router&#x27; import &#123;ref&#125; from &#x27;vue&#x27; //创建动态路由对象 let router = useRouter() let routePath =ref(&#x27;&#x27;) let showList= ()=&gt;&#123; // 编程式路由 // 直接push一个路径 //router.push(&#x27;/list&#x27;) // push一个带有path属性的对象 router.push(&#123;path:&#x27;/list&#x27;&#125;) &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;App页面&lt;/h1&gt; &lt;hr/&gt; &lt;!-- 路由的连接 --&gt; &lt;router-link to=&quot;/&quot;&gt;home页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/list&quot;&gt;list页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/showAll&quot;&gt;showAll页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/add&quot;&gt;add页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/update&quot;&gt;update页&lt;/router-link&gt; &lt;br&gt; &lt;!-- 动态输入路径,点击按钮,触发单击事件的函数,在函数中通过编程是路由切换页面 --&gt; &lt;button @click=&quot;showList()&quot;&gt;showList&lt;/button&gt; &lt;br&gt; &lt;hr/&gt; &lt;!-- 路由连接对应视图的展示位置 --&gt; &lt;hr&gt; 默认展示位置:&lt;router-view&gt;&lt;/router-view&gt; &lt;hr&gt; Home视图展示:&lt;router-view name=&quot;homeView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; List视图展示:&lt;router-view name=&quot;listView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; Add视图展示:&lt;router-view name=&quot;addView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; Update视图展示:&lt;router-view name=&quot;updateView&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 7.5 路由传参(useRoute) 路径参数 在路径中使用一个动态字段来实现，我们称之为 路径参数 例如： 查看数据详情 /showDetail/1 ,1就是要查看详情的id,可以动态添值！ 键值对参数 类似与get请求通过url传参,数据是键值对形式的 例如: 查看数据详情/showDetail?hid=1,hid=1就是要传递的键值对参数 在 Vue 3 和 Vue Router 4 中，你可以使用 useRoute 这个函数从 Vue 的组合式 API 中获取路由对象。 useRoute 方法返回的是当前的 route 对象，你可以用它来获取关于当前路由的信息，如当前的路径、查询参数等。 案例需求 : 切换到ShowDetail.vue组件时,向该组件通过路由传递参数 修改App.vue文件 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script setup type=&quot;module&quot;&gt; import &#123;useRouter&#125; from &#x27;vue-router&#x27; //创建动态路由对象 let router = useRouter() //动态路由路径传参方法 let showDetail= (id,language)=&gt;&#123; // 尝试使用拼接字符串方式传递路径参数 //router.push(`showDetail/$&#123;id&#125;/$&#123;languange&#125;`) /*路径参数,需要使用params */ router.push(&#123;name:&quot;showDetail&quot;,params:&#123;id:id,language:language&#125;&#125;) &#125; let showDetail2= (id,language)=&gt;&#123; /*uri键值对参数,需要使用query */ router.push(&#123;path:&quot;/showDetail2&quot;,query:&#123;id:id,language:language&#125;&#125;) &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;App页面&lt;/h1&gt; &lt;hr/&gt; &lt;!-- 路径参数 --&gt; &lt;router-link to=&quot;/showDetail/1/JAVA&quot;&gt;showDetail路径传参显示JAVA&lt;/router-link&gt; &lt;button @click=&quot;showDetail(1,&#x27;JAVA&#x27;)&quot;&gt;showDetail动态路由路径传参显示JAVA&lt;/button&gt; &lt;hr/&gt; &lt;!-- 键值对参数 --&gt; &lt;router-link v-bind:to=&quot;&#123;path:&#x27;/showDetail2&#x27;,query:&#123;id:1,language:&#x27;Java&#x27;&#125;&#125;&quot;&gt;showDetail2键值对传参显示JAVA&lt;/router-link&gt; &lt;button @click=&quot;showDetail2(1,&#x27;JAVA&#x27;)&quot;&gt;showDetail2动态路由键值对传参显示JAVA&lt;/button&gt; &lt;hr&gt; showDetail视图展示:&lt;router-view name=&quot;showDetailView&quot;&gt;&lt;/router-view&gt; &lt;hr&gt; showDetail2视图展示:&lt;router-view name=&quot;showDetailView2&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 修改router.js增加路径参数占位符 12345678910111213141516171819202122232425262728293031323334// 导入路由创建的相关方法import &#123;createRouter,createWebHashHistory&#125; from &#x27;vue-router&#x27;// 导入vue组件import ShowDetail from &#x27;../components/ShowDetail.vue&#x27;import ShowDetail2 from &#x27;../components/ShowDetail2.vue&#x27;// 创建路由对象,声明路由规则const router = createRouter(&#123; history: createWebHashHistory(), routes:[ &#123; /* 此处:id :language作为路径的占位符 */ path:&#x27;/showDetail/:id/:language&#x27;, /* 动态路由传参时,根据该名字找到该路由 */ name:&#x27;showDetail&#x27;, components:&#123; showDetailView:ShowDetail &#125; &#125;, &#123; path:&#x27;/showDetail2&#x27;, components:&#123; showDetailView2:ShowDetail2 &#125; &#125;, ]&#125;)// 对外暴露路由对象export default router; ShowDetail.vue 通过useRoute获取路径参数 1234567891011121314151617181920212223242526272829&lt;script setup type=&quot;module&quot;&gt; import&#123;useRoute&#125; from &#x27;vue-router&#x27; import &#123; onUpdated,ref &#125; from &#x27;vue&#x27;; // 获取当前的route对象 let route =useRoute() let languageId = ref(0) let languageName = ref(&#x27;&#x27;) // 借助更新时生命周期,将数据更新进入响应式对象 onUpdated (()=&gt;&#123; // 获取对象中的参数 languageId.value=route.params.id languageName.value=route.params.language console.log(languageId.value) console.log(languageName.value) &#125;) &lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;ShowDetail页面&lt;/h1&gt; &lt;h3&gt;编号&#123;&#123;route.params.id&#125;&#125;:&#123;&#123;route.params.language&#125;&#125;是世界上最好的语言&lt;/h3&gt; &lt;h3&gt;编号&#123;&#123;languageId&#125;&#125;:&#123;&#123;languageName&#125;&#125;是世界上最好的语言&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; ShowDetail2.vue通过useRoute获取键值对参数12345678910111213141516171819202122232425262728293031&lt;script setup type=&quot;module&quot;&gt; import&#123;useRoute&#125; from &#x27;vue-router&#x27; import &#123; onUpdated,ref &#125; from &#x27;vue&#x27;; // 获取当前的route对象 let route =useRoute() let languageId = ref(0) let languageName = ref(&#x27;&#x27;) // 借助更新时生命周期,将数据更新进入响应式对象 onUpdated (()=&gt;&#123; // 获取对象中的参数(通过query获取参数,此时参数是key-value形式的) console.log(route.query) console.log(languageId.value) console.log(languageName.value) languageId.value=route.query.id languageName.value=route.query.language &#125;) &lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;ShowDetail2页面&lt;/h1&gt; &lt;h3&gt;编号&#123;&#123;route.query.id&#125;&#125;:&#123;&#123;route.query.language&#125;&#125;是世界上最好的语言&lt;/h3&gt; &lt;h3&gt;编号&#123;&#123;languageId&#125;&#125;:&#123;&#123;languageName&#125;&#125;是世界上最好的语言&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 7.6 路由守卫 在 Vue 3 中，路由守卫是用于在路由切换期间进行一些特定任务的回调函数。路由守卫可以用于许多任务，例如验证用户是否已登录、在路由切换前提供确认提示、请求数据等。Vue 3 为路由守卫提供了全面的支持，并提供了以下几种类型的路由守卫： 全局前置守卫：在路由切换前被调用，可以用于验证用户是否已登录、中断导航、请求数据等。 全局后置守卫：在路由切换之后被调用，可以用于处理数据、操作 DOM 、记录日志等。 守卫代码的位置: 在router.js中 12345678910111213141516171819202122//全局前置路由守卫router.beforeEach( (to,from,next) =&gt; &#123; //to 是目标地包装对象 .path属性可以获取地址 //from 是来源地包装对象 .path属性可以获取地址 //next是方法，不调用默认拦截！ next() 放行,直接到达目标组件 //next(&#x27;/地址&#x27;)可以转发到其他地址,到达目标组件前会再次经过前置路由守卫 console.log(to.path,from.path,next) //需要判断，注意避免无限重定向 if(to.path == &#x27;/index&#x27;)&#123; next() &#125;else&#123; next(&#x27;/index&#x27;) &#125; &#125; )//全局后置路由守卫router.afterEach((to, from) =&gt; &#123; console.log(`Navigate from $&#123;from.path&#125; to $&#123;to.path&#125;`);&#125;); 登录案例，登录以后才可以进入home,否则必须进入login 定义Login.vue 123456789101112131415161718192021222324252627282930313233&lt;script setup&gt; import &#123;ref&#125; from &#x27;vue&#x27; import &#123;useRouter&#125; from &#x27;vue-router&#x27; let username =ref(&#x27;&#x27;) let password =ref(&#x27;&#x27;) let router = useRouter(); let login = () =&gt;&#123; console.log(username.value,password.value) if(username.value == &#x27;root&#x27; &amp; password.value == &#x27;123456&#x27;)&#123; router.push(&#123;path:&#x27;/home&#x27;,query:&#123;&#x27;username&#x27;:username.value&#125;&#125;) //登录成功利用前端存储机制，存储账号！ localStorage.setItem(&#x27;username&#x27;,username.value) //sessionStorage.setItem(&#x27;username&#x27;,username) &#125;else&#123; alert(&#x27;登录失败，账号或者密码错误！&#x27;); &#125; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; 账号： &lt;input type=&quot;text&quot; v-model=&quot;username&quot; placeholder=&quot;请输入账号！&quot;&gt;&lt;br&gt; 密码： &lt;input type=&quot;password&quot; v-model=&quot;password&quot; placeholder=&quot;请输入密码！&quot;&gt;&lt;br&gt; &lt;button @click=&quot;login()&quot;&gt;登录&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 定义Home.vue 123456789101112131415161718192021222324252627282930313233&lt;script setup&gt; import &#123;ref&#125; from &#x27;vue&#x27; import &#123;useRoute,useRouter&#125; from &#x27;vue-router&#x27; let route =useRoute() let router = useRouter() // 并不是每次进入home页时,都有用户名参数传入 //let username = route.query.username let username =window.localStorage.getItem(&#x27;username&#x27;); let logout= ()=&gt;&#123; // 清除localStorge中的username //window.sessionStorage.removeItem(&#x27;username&#x27;) window.localStorage.removeItem(&#x27;username&#x27;) // 动态路由到登录页 router.push(&quot;/login&quot;) &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;Home页面&lt;/h1&gt; &lt;h3&gt;欢迎&#123;&#123;username&#125;&#125;登录&lt;/h3&gt; &lt;button @click=&quot;logout&quot;&gt;退出登录&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; App.vue 12345678910111213141516&lt;script setup type=&quot;module&quot;&gt; &lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 定义routers.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 导入路由创建的相关方法import &#123;createRouter,createWebHashHistory&#125; from &#x27;vue-router&#x27;// 导入vue组件import Home from &#x27;../components/Home.vue&#x27;import Login from &#x27;../components/login.vue&#x27;// 创建路由对象,声明路由规则const router = createRouter(&#123; history: createWebHashHistory(), routes:[ &#123; path:&#x27;/home&#x27;, component:Home &#125;, &#123; path:&#x27;/&#x27;, redirect:&quot;/home&quot; &#125;, &#123; path:&#x27;/login&#x27;, component:Login &#125;, ]&#125;)// 设置路由的全局前置守卫router.beforeEach((to,from,next)=&gt;&#123; /* to 要去那 from 从哪里来 next 放行路由时需要调用的方法,不调用则不放行 */ console.log(`从哪里来:$&#123;from.path&#125;,到哪里去:$&#123;to.path&#125;`) if(to.path == &#x27;/login&#x27;)&#123; //放行路由 注意放行不要形成循环 next() &#125;else&#123; //let username =window.sessionStorage.getItem(&#x27;username&#x27;); let username =window.localStorage.getItem(&#x27;username&#x27;); if(null != username)&#123; next() &#125;else&#123; next(&#x27;/login&#x27;) &#125; &#125;&#125;)// 设置路由的全局后置守卫router.afterEach((to,from)=&gt;&#123; console.log(`从哪里来:$&#123;from.path&#125;,到哪里去:$&#123;to.path&#125;`)&#125;)// 对外暴露路由对象export default router; 启动测试 1npm run dev 八、 案例开发-日程管理-第五期8.1 重构前端工程 业务目标展示 登录页 注册页 日程管理页 创建项目,安装依赖 1234npm create vitecd 项目目录npm installnpm install vue-router 项目结构如下 开发视图 Header.vue视图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt; &lt;div&gt; &lt;div class=&quot;optionDiv&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt; &lt;button class=&quot;b1s&quot;&gt;登录&lt;/button&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/regist&quot;&gt; &lt;button class=&quot;b1s&quot;&gt;注册&lt;/button&gt; &lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;optionDiv&quot;&gt; 欢迎xxx &lt;button class=&quot;b1b&quot;&gt;退出登录&lt;/button&gt; &lt;router-link to=&quot;/showSchedule&quot;&gt; &lt;button class=&quot;b1b&quot;&gt;查看我的日程&lt;/button&gt; &lt;/router-link&gt; &lt;/div&gt; &lt;br&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .b1s&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; .b1b&#123; border: 2px solid powderblue; border-radius: 4px; width:100px; background-color: antiquewhite; &#125; .optionDiv&#123; width: 300px; float: right; &#125;&lt;/style&gt; Login.vue视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;script setup&gt; import&#123; ref,reactive&#125; from &#x27;vue&#x27; // 响应式数据,保存用户输入的表单信息 let loginUser =reactive(&#123; username:&#x27;&#x27;, userPwd:&#x27;&#x27; &#125;) // 响应式数据,保存校验的提示信息 let usernameMsg =ref(&#x27;&#x27;) let userPwdMsg = ref(&#x27;&#x27;) // 校验用户名的方法 function checkUsername()&#123; // 定义正则 var usernameReg=/^[a-zA-Z0-9]&#123;5,10&#125;$/ // 校验用户名 if(!usernameReg.test(loginUser.username))&#123; // 格式不合法 usernameMsg.value=&quot;格式有误&quot; return false &#125; usernameMsg.value=&quot;ok&quot; return true &#125; // 校验密码的方法 function checkUserPwd()&#123; // 定义正则 var passwordReg=/^[0-9]&#123;6&#125;$/ // 校验密码 if(!passwordReg.test(loginUser.userPwd))&#123; // 格式不合法 userPwdMsg.value=&quot;格式有误&quot; return false &#125; userPwdMsg.value=&quot;ok&quot; return true &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h3 class=&quot;ht&quot;&gt;请登录&lt;/h3&gt; &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入账号&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; type=&quot;text&quot; v-model=&quot;loginUser.username&quot; @blur=&quot;checkUsername()&quot;&gt; &lt;span id=&quot;usernameMsg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; type=&quot;password&quot; v-model=&quot;loginUser.userPwd&quot; @blur=&quot;checkUserPwd()&quot;&gt; &lt;span id=&quot;userPwdMsg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;登录&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;重置&quot;&gt; &lt;router-link to=&quot;/regist&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;去注册&lt;/button&gt; &lt;/router-link&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 500px; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; #usernameMsg , #userPwdMsg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125;&lt;/style&gt; Regist.vue视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;script setup&gt; import&#123; ref,reactive&#125; from &#x27;vue&#x27; // 响应式数据,保存用户输入的表单信息 let registUser =reactive(&#123; username:&#x27;&#x27;, userPwd:&#x27;&#x27; &#125;) // 响应式数据,保存校验的提示信息 let reUserPwd =ref(&#x27;&#x27;) let reUserPwdMsg =ref(&#x27;&#x27;) let usernameMsg =ref(&#x27;&#x27;) let userPwdMsg = ref(&#x27;&#x27;) // 校验用户名的方法 function checkUsername()&#123; // 定义正则 let usernameReg=/^[a-zA-Z0-9]&#123;5,10&#125;$/ // 校验 if(!usernameReg.test(registUser.username))&#123; // 提示 usernameMsg.value = &quot;不合法&quot; return false &#125; // 通过校验 usernameMsg.value=&quot;OK&quot; return true &#125; // 校验密码的方法 function checkUserPwd()&#123; // 定义正则 let passwordReg=/^[0-9]&#123;6&#125;$/ // 校验 if(!passwordReg.test(registUser.userPwd))&#123; // 提示 userPwdMsg.value = &quot;不合法&quot; return false &#125; // 通过校验 userPwdMsg.value=&quot;OK&quot; return true &#125; // 校验密码的方法 function checkReUserPwd()&#123; // 定义正则 let passwordReg=/^[0-9]&#123;6&#125;$/ // 校验 if(!passwordReg.test(reUserPwd.value))&#123; // 提示 reUserPwdMsg.value = &quot;不合法&quot; return false &#125; console.log(registUser.userPwd,reUserPwd.value) // 校验 if(!(registUser.userPwd==reUserPwd.value))&#123; // 提示 reUserPwdMsg.value = &quot;不一致&quot; return false &#125; // 通过校验 reUserPwdMsg.value=&quot;OK&quot; return true &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h3 class=&quot;ht&quot;&gt;请注册&lt;/h3&gt; &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入账号&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;usernameInput&quot; type=&quot;text&quot; name=&quot;username&quot; v-model=&quot;registUser.username&quot; @blur=&quot;checkUsername()&quot;&gt; &lt;span id=&quot;usernameMsg&quot; class=&quot;msg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;userPwdInput&quot; type=&quot;password&quot; name=&quot;userPwd&quot; v-model=&quot;registUser.userPwd&quot; @blur=&quot;checkUserPwd()&quot;&gt; &lt;span id=&quot;userPwdMsg&quot; class=&quot;msg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;确认密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;reUserPwdInput&quot; type=&quot;password&quot; v-model=&quot;reUserPwd&quot; @blur=&quot;checkReUserPwd()&quot;&gt; &lt;span id=&quot;reUserPwdMsg&quot; class=&quot;msg&quot; v-text=&quot;reUserPwdMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;注册&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;重置&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;去登录&lt;/button&gt; &lt;/router-link&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 500px; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; .msg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125;&lt;/style&gt; ShowSchedule.vue视图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h3 class=&quot;ht&quot;&gt;您的日程如下&lt;/h3&gt;&lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;内容&lt;/th&gt; &lt;th&gt;进度&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td class=&quot;buttonContainer&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;btn1&quot;&gt;保存修改&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr buttonContainer&quot; &gt; &lt;td colspan=&quot;4&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;新增日程&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 80%; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:100px; background-color: antiquewhite; &#125; #usernameMsg , #userPwdMsg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125;&lt;/style&gt; App.vue视图 12345678910111213141516171819&lt;script setup&gt;import Header from &#x27;./components/Header.vue&#x27;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;Header&gt;&lt;/Header&gt; &lt;hr&gt; &lt;!-- 用于路由切换视图使用 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 配置路由 1234567891011121314151617181920212223242526272829303132import &#123;createRouter,createWebHashHistory&#125; from &#x27;vue-router&#x27;import Login from &#x27;../components/Login.vue&#x27;import Regist from &#x27;../components/Regist.vue&#x27;import ShowScedule from &#x27;../components/ShowSchedule.vue&#x27;let router = createRouter(&#123; history:createWebHashHistory(), routes:[ &#123; path:&quot;/&quot;, component:Login &#125;, &#123; path:&quot;/login&quot;, component:Login &#125;, &#123; path:&quot;/showSchedule&quot;, component:ShowScedule &#125;, &#123; path:&quot;/regist&quot;, component:Regist &#125; ]&#125;)export default router 配置main.js 1234567891011121314import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// 导入路由import router from &#x27;./router/router.js&#x27;let app =createApp(App)// 全局使用路由app.use(router)app.mount(&#x27;#app&#x27;) 九、Vue3数据交互axios9.0 预讲知识-promise9.0.1 普通函数和回调函数 普通函数: 正常调用的函数,一般函数执行完毕后才会继续执行下一行代码 123456789&lt;script&gt; let fun1 = () =&gt;&#123; console.log(&quot;fun1 invoked&quot;) &#125; // 调用函数 fun1() // 函数执行完毕,继续执行后续代码 console.log(&quot;other code processon&quot;)&lt;/script&gt; 回调函数: 一些特殊的函数,表示未来才会执行的一些功能,后续代码不会等待该函数执行完毕就开始执行了 1234567&lt;script&gt; // 设置一个2000毫秒后会执行一次的定时任务 setTimeout(function ()&#123; console.log(&quot;setTimeout invoked&quot;) &#125;,2000) console.log(&quot;other code processon&quot;)&lt;/script&gt; 9.0.2 Promise 简介 前端中的异步编程技术，类似Java中的多线程+线程结果回调！ Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）Promise对象代表一个异步操作，有三种状态：`Pending`（进行中）、`Resolved`（已完成，又称 Fulfilled）和`Rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从`Pending`变为`Resolved`和从`Pending`变为`Rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。 9.0.3 Promise 基本用法 ES6规定，Promise对象是一个构造函数，用来生成Promise实例。 123456789101112131415161718192021222324252627&lt;script&gt; /* 1.实例化promise对象,并且执行(类似Java创建线程对象,并且start) 参数: resolve,reject随意命名,但是一般这么叫! 参数: resolve,reject分别处理成功和失败的两个函数! 成功resolve(结果) 失败reject(结果) 参数: 在function中调用这里两个方法,那么promise会处于两个不同的状态 状态: promise有三个状态 pending 正在运行 resolved 内部调用了resolve方法 rejected 内部调用了reject方法 参数: 在第二步回调函数中就可以获取对应的结果 */ let promise =new Promise(function(resolve,reject)&#123; console.log(&quot;promise do some code ... ...&quot;) //resolve(&quot;promise success&quot;) reject(&quot;promise fail&quot;) &#125;) console.log(&#x27;other code1111 invoked&#x27;) //2.获取回调函数结果 then在这里会等待promise中的运行结果,但是不会阻塞代码继续运行 promise.then( function(value)&#123;console.log(`promise中执行了resolve:$&#123;value&#125;`)&#125;, function(error)&#123;console.log(`promise中执行了reject:$&#123;error&#125;`)&#125; ) // 3 其他代码执行 console.log(&#x27;other code2222 invoked&#x27;)&lt;/script&gt; 9.0.4 Promise catch() Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456789101112131415161718192021&lt;script&gt; let promise =new Promise(function(resolve,reject)&#123; console.log(&quot;promise do some code ... ...&quot;) // 故意响应一个异常对象 throw new Error(&quot;error message&quot;) &#125;) console.log(&#x27;other code1111 invoked&#x27;) /* then中的reject()的对应方法可以在产生异常时执行,接收到的就是异常中的提示信息 then中可以只留一个resolve()的对应方法,reject()方法可以用后续的catch替换 then中的reject对应的回调函数被后续的catch替换后,catch中接收的数据是一个异常对象 */ promise.then( function(resolveValue)&#123;console.log(`promise中执行了resolve:$&#123;resolveValue&#125;`)&#125; //, //function(rejectValue)&#123;console.log(`promise中执行了reject:$&#123;rejectValue&#125;`)&#125; ).catch( function(error)&#123;console.log(error)&#125; ) console.log(&#x27;other code2222 invoked&#x27;)&lt;/script&gt; 9.0.5 async和await的使用 &#x20;async和await是ES6中用于处理异步操作的新特性。通常，异步操作会涉及到Promise对象，而async&#x2F;await则是在Promise基础上提供了更加直观和易于使用的语法。 async 用于标识函数的 async标识函数后,async函数的返回值会变成一个promise对象 如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态 promise对象 如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定 如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象 1234567891011121314151617181920212223242526272829&lt;script&gt; /* async 用于标识函数的 1. async标识函数后,async函数的返回值会变成一个promise对象 2. 如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态 promise对象 3. 如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定 4. 如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象 */ async function fun1()&#123; //return 10 //throw new Error(&quot;something wrong&quot;) let promise = Promise.reject(&quot;heihei&quot;) return promise &#125; let promise =fun1() promise.then( function(value)&#123; console.log(&quot;success:&quot;+value) &#125; ).catch( function(value)&#123; console.log(&quot;fail:&quot;+value) &#125; )&lt;/script&gt; await await右侧的表达式一般为一个promise对象,但是也可以是一个其他值 如果表达式是promise对象,await返回的是promise成功的值 await会等右边的promise对象执行结束,然后再获取结果,后续代码也会等待await的执行 如果表达式是其他值,则直接返回该值 await必须在async函数中,但是async函数中可以没有await 如果await右边的promise失败了,就会抛出异常,需要通过 try … catch捕获处理 1234567891011121314151617181920212223242526272829&lt;script&gt; /* 1. await右侧的表达式一般为一个promise对象,但是也可以是一个其他值 2. 如果表达式是promise对象,await返回的是promise成功的值 3. await会等右边的promise对象执行结束,然后再获取结果,后续代码也会等待await的执行 4. 如果表达式是其他值,则直接返回该值 5. await必须在async函数中,但是async函数中可以没有await 6. 如果await右边的promise失败了,就会抛出异常,可以通过 try ... catch捕获处理 */ async function fun1()&#123; return 10 &#125; async function fun2()&#123; try&#123; let res = await fun1() //let res = await Promise.reject(&quot;something wrong&quot;) &#125;catch(e)&#123; console.log(&quot;catch got:&quot;+e) &#125; console.log(&quot;await got:&quot;+res) &#125; fun2()&lt;/script&gt; 9.1 Axios介绍 ajax AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。 XMLHttpRequest 只是实现 Ajax 的一种方式。 ajax工作原理： 原生javascript方式进行ajax(了解): 123456789101112131415161718192021222324&lt;script&gt; function loadXMLDoc()&#123; var xmlhttp; if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125; else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; // 设置回调函数处理响应结果 xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125; &#125; // 设置请求方式和请求的资源路径 xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true); // 发送请求 xmlhttp.send(); &#125;&lt;/script&gt; 什么是axios 官网介绍:https://axios-http.com/zh/docs/intro Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。它有如下特性 从浏览器创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF 9.2 Axios 入门案例 1 案例需求:请求后台获取随机土味情话 请求的url 1https://api.uomg.com/api/rand.qinghua?format=json 或者使用 http://forum.atguigu.cn/api/rand.qinghua?format=json 请求的方式 1GET/POST 数据返回的格式 1&#123;&quot;code&quot;:1,&quot;content&quot;:&quot;我努力不是为了你而是因为你。&quot;&#125; 2 准备项目 1234npm create vitenpm install /*npm install vue-router@4 --savenpm install pinia */ 3 安装axios 1npm install axios 4 设计页面（App.Vue） 12345678910111213141516171819202122232425262728293031323334353637&lt;script setup type=&quot;module&quot;&gt; import axios from &#x27;axios&#x27; import &#123; onMounted,reactive &#125; from &#x27;vue&#x27;; let jsonData =reactive(&#123;code:1,content:&#x27;我努力不是为了你而是因为你&#x27;&#125;) let getLoveMessage =()=&gt;&#123; axios(&#123; method:&quot;post&quot;, // 请求方式 url:&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;, // 请求的url data:&#123; // 当请求方式为post时,data下的数据以JSON串放入请求体,否则以key=value形式放url后 username:&quot;123456&quot; &#125; &#125;).then( function (response)&#123;//响应成功时要执行的函数 console.log(response) Object.assign(jsonData,response.data) &#125;).catch(function (error)&#123;// 响应失败时要执行的函数 console.log(error) &#125;) &#125; /* 通过onMounted生命周期,自动加载一次 */ onMounted(()=&gt;&#123; getLoveMessage() &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 5 启动测试 1npm run dev 异步响应的数据结构 响应的数据是经过包装返回的！一个请求的响应包含以下信息。 123456789101112131415161718&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &#x27;OK&#x27;, // `headers` 是服务器响应头 // 所有的 header 名称都是小写，而且可以使用方括号语法访问 // 例如: `response.headers[&#x27;content-type&#x27;]` headers: &#123;&#125;, // `config` 是 `axios` 请求的配置信息 config: &#123;&#125;, // `request` 是生成此响应的请求 // 在node.js中它是最后一个ClientRequest实例 (in redirects)， // 在浏览器中则是 XMLHttpRequest 实例 request: &#123;&#125;&#125; then取值 1234567then(function (response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config);&#125;); 6 通过async和await处理异步请求 12345678910111213141516171819202122232425262728293031323334353637&lt;script setup type=&quot;module&quot;&gt; import axios from &#x27;axios&#x27; import &#123; onMounted,reactive &#125; from &#x27;vue&#x27;; let jsonData =reactive(&#123;code:1,content:&#x27;我努力不是为了你而是因为你&#x27;&#125;) let getLoveWords = async ()=&gt;&#123; return await axios(&#123; method:&quot;post&quot;, url:&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;, data:&#123; username:&quot;123456&quot; &#125; &#125;) &#125; let getLoveMessage =()=&gt;&#123; let &#123;data&#125; = await getLoveWords() Object.assign(message,data) &#125; /* 通过onMounted生命周期,自动加载一次 */ onMounted(()=&gt;&#123; getLoveMessage() &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; axios在发送异步请求时的可选配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&#123; // `url` 是用于请求的服务器 URL url: &#x27;/user&#x27;, // `method` 是创建请求时使用的方法 method: &#x27;get&#x27;, // 默认值 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &#x27;https://some-domain.com/api/&#x27;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法 // 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream // 你可以修改请求头。 transformRequest: [function (data, headers) &#123; // 对发送的 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对接收的 data 进行任意转换处理 return data; &#125;], // 自定义请求头 headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // `params` 是与请求一起发送的 URL 参数 // 必须是一个简单对象或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是可选方法，主要用于序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function (params) &#123; return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;) &#125;, // `data` 是作为请求体被发送的数据 // 仅适用 &#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;DELETE 和 &#x27;PATCH&#x27; 请求方法 // 在没有设置 `transformRequest` 时，则必须是以下类型之一: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属: FormData, File, Blob // - Node 专属: Stream, Buffer data: &#123; firstName: &#x27;Fred&#x27; &#125;, // 发送请求体数据的可选语法 // 请求方式 post // 只有 value 会被发送，key 则不会 data: &#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;, // `timeout` 指定请求超时的毫秒数。 // 如果请求时间超过 `timeout` 的值，则请求会被中断 timeout: 1000, // 默认值是 `0` (永不超时) // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，这使测试更加容易。 // 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。 adapter: function (config) &#123; /* ... */ &#125;, // `auth` HTTP Basic Auth auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // `responseType` 表示浏览器将要响应的数据类型 // 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27; // 浏览器专属：&#x27;blob&#x27; responseType: &#x27;json&#x27;, // 默认值 // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属) // 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求 // Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests responseEncoding: &#x27;utf8&#x27;, // 默认值 // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称 xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // 默认值 // `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称 xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // 默认值 // `onUploadProgress` 允许为上传处理进度事件 // 浏览器专属 onUploadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 // 浏览器专属 onDownloadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数 maxContentLength: 2000, // `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数 maxBodyLength: 2000, // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。 // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)， // 则promise 将会 resolved，否则是 rejected。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认值 &#125;, // `maxRedirects` 定义了在node.js中要遵循的最大重定向数。 // 如果设置为0，则不会进行重定向 maxRedirects: 5, // 默认值 // `socketPath` 定义了在node.js中使用的UNIX套接字。 // e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。 // 只能指定 `socketPath` 或 `proxy` 。 // 若都指定，这使用 `socketPath` 。 socketPath: null, // default // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http // and https requests, respectively, in node.js. This allows options to be added like // `keepAlive` that are not enabled by default. httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // `proxy` 定义了代理服务器的主机名，端口和协议。 // 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。 // 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。 // `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。 // 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。 // 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https` proxy: &#123; protocol: &#x27;https&#x27;, host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;, // see https://axios-http.com/zh/docs/cancellation cancelToken: new CancelToken(function (cancel) &#123; &#125;), // `decompress` indicates whether or not the response body should be decompressed // automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header // from the responses objects of all decompressed responses // - Node only (XHR cannot turn off decompression) decompress: true // 默认值&#125; 9.3 Axios get和post方法 配置添加语法 12345678910111213axios.get(url[, config])axios.get(url,&#123; 上面指定配置key:配置值, 上面指定配置key:配置值&#125;)axios.post(url[, data[, config]])axios.post(url,&#123;key:value //此位置数据，没有空对象即可&#123;&#125;&#125;,&#123; 上面指定配置key:配置值, 上面指定配置key:配置值&#125;) 测试get参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script setup type=&quot;module&quot;&gt; import axios from &#x27;axios&#x27; import &#123; onMounted,ref,reactive,toRaw &#125; from &#x27;vue&#x27;; let jsonData =reactive(&#123;code:1,content:&#x27;我努力不是为了你而是因为你&#x27;&#125;) let getLoveWords= async ()=&gt;&#123; try&#123; return await axios.get( &#x27;https://api.uomg.com/api/rand.qinghua&#x27;, &#123; params:&#123;// 向url后添加的键值对参数 format:&#x27;json&#x27;, username:&#x27;zhangsan&#x27;, password:&#x27;123456&#x27; &#125;, headers:&#123;// 设置请求头 &#x27;Accept&#x27; : &#x27;application/json, text/plain, text/html,*/*&#x27; &#125; &#125; ) &#125;catch (e)&#123; return await e &#125; &#125; let getLoveMessage =()=&gt;&#123; let &#123;data&#125; = await getLoveWords() Object.assign(message,data) &#125; /* 通过onMounted生命周期,自动加载一次 */ onMounted(()=&gt;&#123; getLoveMessage() &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 测试post参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script setup type=&quot;module&quot;&gt; import axios from &#x27;axios&#x27; import &#123; onMounted,ref,reactive,toRaw &#125; from &#x27;vue&#x27;; let jsonData =reactive(&#123;code:1,content:&#x27;我努力不是为了你而是因为你&#x27;&#125;) let getLoveWords= async ()=&gt;&#123; try&#123; return await axios.post( &#x27;https://api.uomg.com/api/rand.qinghua&#x27;, &#123;//请求体中的JSON数据 username:&#x27;zhangsan&#x27;, password:&#x27;123456&#x27; &#125;, &#123;// 其他参数 params:&#123;// url上拼接的键值对参数 format:&#x27;json&#x27;, &#125;, headers:&#123;// 请求头 &#x27;Accept&#x27; : &#x27;application/json, text/plain, text/html,*/*&#x27;, &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27; &#125; &#125; ) &#125;catch (e)&#123; return await e &#125; &#125; let getLoveMessage =()=&gt;&#123; let &#123;data&#125; = await getLoveWords() Object.assign(message,data) &#125; /* 通过onMounted生命周期,自动加载一次 */ onMounted(()=&gt;&#123; getLoveMessage() &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 9.4 Axios 拦截器 如果想在axios发送请求之前,或者是数据响应回来在执行then方法之前做一些额外的工作,可以通过拦截器完成 12345678910111213141516171819202122232425// 添加请求拦截器 请求发送之前axios.interceptors.request.use( function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器 数据响应回来axios.interceptors.response.use( function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); 定义src&#x2F;axios.js提取拦截器和配置语法 1234567891011121314151617181920212223242526272829303132333435363738394041import axios from &#x27;axios&#x27;// 创建instance实例const instance = axios.create(&#123; baseURL:&#x27;https://api.uomg.com&#x27;, timeout:10000&#125;)// 添加请求拦截instance.interceptors.request.use( // 设置请求头配置信息 config=&gt;&#123; //处理指定的请求头 console.log(&quot;before request&quot;) config.headers.Accept = &#x27;application/json, text/plain, text/html,*/*&#x27; return config &#125;, // 设置请求错误处理函数 error=&gt;&#123; console.log(&quot;request error&quot;) return Promise.reject(error) &#125;)// 添加响应拦截器instance.interceptors.response.use( // 设置响应正确时的处理函数 response=&gt;&#123; console.log(&quot;after success response&quot;) console.log(response) return response &#125;, // 设置响应异常时的处理函数 error=&gt;&#123; console.log(&quot;after fail response&quot;) console.log(error) return Promise.reject(error) &#125;)// 默认导出export default instance App.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script setup type=&quot;module&quot;&gt; // 导入我们自己定义的axios.js文件,而不是导入axios依赖 import axios from &#x27;./axios.js&#x27; import &#123; onMounted,ref,reactive,toRaw &#125; from &#x27;vue&#x27;; let jsonData =reactive(&#123;code:1,content:&#x27;我努力不是为了你而是因为你&#x27;&#125;) let getLoveWords= async ()=&gt;&#123; try&#123; return await axios.post( &#x27;api/rand.qinghua&#x27;, &#123; username:&#x27;zhangsan&#x27;, password:&#x27;123456&#x27; &#125;,//请求体中的JSON数据 &#123; params:&#123; format:&#x27;json&#x27;, &#125; &#125;// 其他键值对参数 ) &#125;catch (e)&#123; return await e &#125; &#125; let getLoveMessage =()=&gt;&#123; // 这里返回的是一个fullfilled状态的promise getLoveWords().then( (response) =&gt;&#123; console.log(&quot;after getloveWords&quot;) console.log(response) Object.assign(jsonData,response.data) &#125; ) &#125; /* 通过onMounted生命周期,自动加载一次 */ onMounted(()=&gt;&#123; getLoveMessage() &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 十、案例开发-日程管理-第六期10.1 前端代码处理10.1.1 创建src&#x2F;utils&#x2F;request.js文件123456789101112131415161718192021222324252627282930313233343536import axios from &#x27;axios&#x27;// 创建instance实例const instance = axios.create(&#123; baseURL:&#x27;http://localhost:8080/&#x27; &#125;)// 添加请求拦截instance.interceptors.request.use( // 设置请求头配置信息 config=&gt;&#123; //处理指定的请求头 return config &#125;, // 设置请求错误处理函数 error=&gt;&#123; return Promise.reject(error) &#125;)// 添加响应拦截器instance.interceptors.response.use( // 设置响应正确时的处理函数 response=&gt;&#123; return response &#125;, // 设置响应异常时的处理函数 error=&gt;&#123; return Promise.reject(error) &#125;)// 默认导出export default instance 10.1.2 注册页面完成注册123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&lt;script setup&gt; import &#123;ref,reactive&#125; from &#x27;vue&#x27; /* 导入发送请求的axios对象 */ import request from&#x27;../utils/request&#x27; import &#123;useRouter&#125; from &#x27;vue-router&#x27; const router = useRouter() let registUser = reactive(&#123; username:&quot;&quot;, userPwd:&quot;&quot; &#125;) let usernameMsg=ref(&#x27;&#x27;) let userPwdMsg=ref(&#x27;&#x27;) let reUserPwdMsg=ref(&#x27;&#x27;) let reUserPwd=ref(&#x27;&#x27;) async function checkUsername()&#123; let usernameReg= /^[a-zA-Z0-9]&#123;5,10&#125;$/ if(!usernameReg.test(registUser.username))&#123; usernameMsg.value=&quot;格式有误&quot; return false &#125; // 发送异步请求 继续校验用户名是否被占用 let &#123;data&#125; = await request.post(`user/checkUsernameUsed?username=$&#123;registUser.username&#125;`) if(data.code != 200)&#123; usernameMsg.value=&quot;用户名占用&quot; return false &#125; usernameMsg.value=&quot;可用&quot; return true &#125; function checkUserPwd()&#123; let userPwdReg = /^[0-9]&#123;6&#125;$/ if(!userPwdReg.test(registUser.userPwd))&#123; userPwdMsg.value=&quot;格式有误&quot; return false &#125; userPwdMsg.value=&quot;OK&quot; return true &#125; function checkReUserPwd()&#123; let userPwdReg = /^[0-9]&#123;6&#125;$/ if(!userPwdReg.test(reUserPwd.value))&#123; reUserPwdMsg.value=&quot;格式有误&quot; return false &#125; if(registUser.userPwd != reUserPwd.value)&#123; reUserPwdMsg.value=&quot;两次密码不一致&quot; return false &#125; reUserPwdMsg.value=&quot;OK&quot; return true &#125; // 注册的方法 async function regist()&#123; // 校验所有的输入框是否合法 let flag1 =await checkUsername() let flag2 =await checkUserPwd() let flag3 =await checkReUserPwd() if(flag1 &amp;&amp; flag2 &amp;&amp; flag3)&#123; let &#123;data&#125;= await request.post(&quot;user/regist&quot;,registUser) if(data.code == 200)&#123; // 注册成功跳转 登录页 alert(&quot;注册成功,快去登录吧&quot;) router.push(&quot;/login&quot;) &#125;else&#123; alert(&quot;抱歉,用户名被抢注了&quot;) &#125; &#125;else&#123; alert(&quot;校验不通过,请求再次检查数据&quot;) &#125; &#125; function clearForm()&#123; registUser.username=&quot;&quot; registUser.userPwd=&quot;&quot; usernameMsg.value=&quot;&quot; userPwdMsg.value=&quot;&quot; reUserPwd.value=&quot;&quot; reUserPwdMsg.value=&quot;&quot; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h3 class=&quot;ht&quot;&gt;请注册&lt;/h3&gt; &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入账号&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;usernameInput&quot; type=&quot;text&quot; name=&quot;username&quot; v-model=&quot;registUser.username&quot; @blur=&quot;checkUsername()&quot;&gt; &lt;span id=&quot;usernameMsg&quot; class=&quot;msg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;userPwdInput&quot; type=&quot;password&quot; name=&quot;userPwd&quot; v-model=&quot;registUser.userPwd&quot; @blur=&quot;checkUserPwd()&quot;&gt; &lt;span id=&quot;userPwdMsg&quot; class=&quot;msg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;确认密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;reUserPwdInput&quot; type=&quot;password&quot; v-model=&quot;reUserPwd&quot; @blur=&quot;checkReUserPwd()&quot;&gt; &lt;span id=&quot;reUserPwdMsg&quot; class=&quot;msg&quot; v-text=&quot;reUserPwdMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;regist()&quot; value=&quot;注册&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;clearForm()&quot; value=&quot;重置&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;去登录&lt;/button&gt; &lt;/router-link&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 500px; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; .msg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125;&lt;/style&gt; 10.1.3 登录页面完成登录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;script setup&gt; import &#123;ref,reactive&#125; from &#x27;vue&#x27; import &#123;useRouter&#125; from &#x27;vue-router&#x27; const router = useRouter() import request from &#x27;../utils/request&#x27; let loginUser =reactive(&#123; username:&quot;&quot;, userPwd:&quot;&quot; &#125;) let usernameMsg =ref(&quot;&quot;) let userPwdMsg =ref(&quot;&quot;) function checkUsername()&#123; let usernameReg= /^[a-zA-Z0-9]&#123;5,10&#125;$/ if(!usernameReg.test(loginUser.username))&#123; usernameMsg.value=&quot;格式有误&quot; return false &#125; usernameMsg.value=&quot;OK&quot; return true &#125; function checkUserPwd()&#123; let userPwdReg = /^[0-9]&#123;6&#125;$/ if(!userPwdReg.test(loginUser.userPwd))&#123; userPwdMsg.value=&quot;格式有误&quot; return false &#125; userPwdMsg.value=&quot;OK&quot; return true &#125; async function login()&#123; // 表单数据格式都正确再提交 let flag1 =checkUsername() let flag2 =checkUserPwd() if(!(flag1 &amp;&amp; flag2))&#123; return &#125; let &#123;data&#125; = await request.post(&quot;user/login&quot;,loginUser) if(data.code == 200 )&#123; alert(&quot;登录成功&quot;) // 跳转到showSchedule router.push(&quot;/showSchedule&quot;) &#125; else if( data.code == 503)&#123; alert(&quot;密码有误&quot;) &#125;else if (data.code == 501 )&#123; alert(&quot;用户名有误&quot;) &#125;else &#123; alert(&quot;未知错误&quot;) &#125; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h3 class=&quot;ht&quot;&gt;请登录&lt;/h3&gt; &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入账号&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; type=&quot;text&quot; v-model=&quot;loginUser.username&quot; @blur=&quot;checkUsername()&quot;&gt; &lt;span id=&quot;usernameMsg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; type=&quot;password&quot; v-model=&quot;loginUser.userPwd&quot; @blur=&quot;checkUserPwd()&quot;&gt; &lt;span id=&quot;userPwdMsg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;login()&quot; value=&quot;登录&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;重置&quot;&gt; &lt;router-link to=&quot;/regist&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;去注册&lt;/button&gt; &lt;/router-link&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 500px; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; #usernameMsg , #userPwdMsg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125;&lt;/style&gt; 10.2 后端代码处理10.2.1 添加跨域处理器10.2.1.1 什么是跨域 同源策略（Sameoriginpolicy）是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。**同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号** 10.2.1.2为什么会产生跨域 前后端分离模式下,客户端请求前端服务器获取视图资源,然后客户端自行向后端服务器获取数据资源,前端服务器的 协议,IP和端口和后端服务器很可能是不一样的,这样就产生了跨域 10.2.1.3 如何解决跨域 前端项目代理模式处理 后端跨域过滤器方式处理 CrosFilter过滤器 12345678910111213141516171819202122232425262728293031323334package com.atguigu.schedule.filter;import com.atguigu.schedule.common.Result;import com.atguigu.schedule.util.WebUtil;import jakarta.servlet.*;import jakarta.servlet.annotation.WebFilter;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebFilter(&quot;/*&quot;)public class CrosFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; System.out.println(request.getMethod()); HttpServletResponse response = (HttpServletResponse) servletResponse; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, PUT,OPTIONS, DELETE, HEAD&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;access-control-allow-origin, authority, content-type, version-info, X-Requested-With&quot;); // 如果是跨域预检请求,则直接在此响应200业务码 if(request.getMethod().equalsIgnoreCase(&quot;OPTIONS&quot;))&#123; WebUtil.writeJson(response, Result.ok(null)); &#125;else&#123; // 非预检请求,放行即可 filterChain.doFilter(servletRequest, servletResponse); &#125; &#125;&#125; 未来我们使用框架,直接用一个@CrossOrigin 就可以解决跨域问题了 10.2.2 重构UserController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.atguigu.schedule.controller;import com.atguigu.schedule.common.Result;import com.atguigu.schedule.common.ResultCodeEnum;import com.atguigu.schedule.pojo.SysUser;import com.atguigu.schedule.service.SysUserService;import com.atguigu.schedule.service.impl.SysUserServiceImpl;import com.atguigu.schedule.util.MD5Util;import com.atguigu.schedule.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/user/*&quot;)public class UserController extends BaseController&#123; private SysUserService userService =new SysUserServiceImpl(); /** * 注册时校验用户名是否被占用的业务接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void checkUsernameUsed(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username = req.getParameter(&quot;username&quot;); SysUser registUser = userService.findByUsername(username); //封装结果对象 Result result=null; if(null ==registUser)&#123; // 未占用,创建一个code为200的对象 result= Result.ok(null); &#125;else&#123; // 占用, 创建一个结果为505的对象 result= Result.build(null, ResultCodeEnum.USERNAME_USED); &#125; // 将result对象转换成JSON并响应给客户端 WebUtil.writeJson(resp,result); &#125; /** * 用户注册的业务接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 接收要注册的用户信息 SysUser registUser = WebUtil.readJson(req, SysUser.class); // 调用服务层方法,将用户注册进入数据库 int rows =userService.regist(registUser); Result result =null; if(rows&gt;0)&#123; result=Result.ok(null); &#125;else&#123; result =Result.build(null,ResultCodeEnum.USERNAME_USED); &#125; WebUtil.writeJson(resp,result); &#125; /** * 用户登录的业务接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 接收用户请求参数 // 获取要登录的用户名密码 SysUser inputUser = WebUtil.readJson(req, SysUser.class); // 调用服务层方法,根据用户名查询数据库中是否有一个用户 SysUser loginUser =userService.findByUsername(inputUser.getUsername()); Result result = null; if(null == loginUser)&#123; // 没有根据用户名找到用户,说明用户名有误 result=Result.build(null,ResultCodeEnum.USERNAME_ERROR); &#125;else if(! loginUser.getUserPwd().equals(MD5Util.encrypt(inputUser.getUserPwd())))&#123; // 用户密码有误, result=Result.build(null,ResultCodeEnum.PASSWORD_ERROR); &#125;else&#123; // 登录成功 result=Result.ok(null); &#125; WebUtil.writeJson(resp,result); &#125;&#125; 10.2.3 删除登录校验过滤器 这里不使用cookie和session方式记录用户状态,未来使用token,所以登录过滤器删除即可 十一、Vue3状态管理Pinia11.1 Pinia介绍 如何实现多个组件之间的数据传递? 方式1 组件传参 方式2 路由传参 方式3 通过pinia状态管理定义共享数据 当我们有多个组件共享一个共同的状态(数据源)时，多个视图可能都依赖于同一份状态。来自不同视图的交互也可能需要更改同一份状态。虽然我们的手动状态管理解决方案（props,组件间通信,模块化）在简单的场景中已经足够了，但是在大规模的生产应用中还有很多其他事项需要考虑： 更强的团队协作约定 与 Vue DevTools 集成，包括时间轴、组件内部审查和时间旅行调试 模块热更新 (HMR) 服务端渲染支持 Pinia 就是一个实现了上述需求的状态管理库，由 Vue 核心团队维护，对 Vue 2 和 Vue 3 都可用。https://pinia.vuejs.org/zh/introduction.html 11.2 Pinia基本用法 1 准备vite项目 123npm create vitenpm install npm install vue-router@4 --save 2 安装pinia 1npm install pinia 3 定义pinia store对象 src&#x2F;store&#x2F;store.js [推荐这么命名不是强制] 123456789101112131415161718192021222324252627282930313233import &#123;defineStore &#125; from &#x27;pinia&#x27;//定义数据并且对外暴露// store就是定义共享状态的包装对象// 内部包含四个属性： id 唯一标识 state 完整类型推理，推荐使用箭头函数 存放的数据 getters 类似属性计算，存储放对数据// 操作的方法 actions 存储数据的复杂业务逻辑方法// 理解： store类似Java中的实体类， id就是类名， state 就是装数据值的属性 getters就是get方法，actions就是对数据操作的其他方法export const definedPerson = defineStore( &#123; id: &#x27;personPinia&#x27;, //必须唯一 state:()=&gt;&#123; // state中用于定义数据 return &#123; username:&#x27;张三&#x27;, age:0, hobbies:[&#x27;唱歌&#x27;,&#x27;跳舞&#x27;] &#125; &#125;, getters:&#123;// 用于定义一些通过数据计算而得到结果的一些方法 一般在此处不做对数据的修改操作 // getters中的方法可以当做属性值方式使用 getHobbiesCount()&#123; return this.hobbies.length &#125;, getAge()&#123; return this.age &#125; &#125;, actions:&#123; // 用于定义一些对数据修改的方法 doubleAge()&#123; this.age=this.age*2 &#125; &#125; &#125;) 4 在main.js配置pinia组件到vue中 12345678910111213import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./routers/router.js&#x27;// 导piniaimport &#123; createPinia &#125; from &#x27;pinia&#x27;// 创建pinia对象let pinia= createPinia()let app =createApp(App)app.use(router)// app中使用pinia功能app.use(pinia) app.mount(&#x27;#app&#x27;) 5 Operate.vue 中操作Pinia数据 12345678910111213141516171819202122232425262728293031&lt;script setup type=&quot;module&quot;&gt; import &#123; ref&#125; from &#x27;vue&#x27;; import &#123; definedPerson&#125; from &#x27;../store/store&#x27;; // 读取存储的数据 let person= definedPerson() let hobby = ref(&#x27;&#x27;) &lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;operate视图,用户操作Pinia中的数据&lt;/h1&gt; 请输入姓名:&lt;input type=&quot;text&quot; v-model=&quot;person.username&quot;&gt; &lt;br&gt; 请输入年龄:&lt;input type=&quot;text&quot; v-model=&quot;person.age&quot;&gt; &lt;br&gt; 请增加爱好: &lt;input type=&quot;checkbox&quot; value=&quot;吃饭&quot; v-model=&quot;person.hobbies&quot;&gt; 吃饭 &lt;input type=&quot;checkbox&quot; value=&quot;睡觉&quot; v-model=&quot;person.hobbies&quot;&gt; 睡觉 &lt;input type=&quot;checkbox&quot; value=&quot;打豆豆&quot; v-model=&quot;person.hobbies&quot;&gt; 打豆豆 &lt;br&gt; &lt;!-- 事件中调用person的doubleAge()方法 --&gt; &lt;button @click=&quot;person.doubleAge()&quot;&gt;年龄加倍&lt;/button&gt; &lt;br&gt; &lt;!-- 事件中调用pinia提供的$reset()方法恢复数据的默认值 --&gt; &lt;button @click=&quot;person.$reset()&quot;&gt;恢复默认值&lt;/button&gt; &lt;br&gt; &lt;!-- 事件中调用$patch方法一次性修改多个属性值 --&gt; &lt;button @click=&quot;person.$patch(&#123;username:&#x27;奥特曼&#x27;,age:100,hobbies:[&#x27;晒太阳&#x27;,&#x27;打怪兽&#x27;]&#125;)&quot;&gt;变身奥特曼&lt;/button&gt; &lt;br&gt; 显示pinia中的person数据:&#123;&#123;person&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 6 List.vue中展示Pinia数据 1234567891011121314151617181920212223&lt;script setup type=&quot;module&quot;&gt; import &#123; definedPerson&#125; from &#x27;../store/store&#x27;; // 读取存储的数据 let person= definedPerson()&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;List页面,展示Pinia中的数据&lt;/h1&gt; 读取姓名:&#123;&#123;person.username&#125;&#125; &lt;br&gt; 读取年龄:&#123;&#123;person.age&#125;&#125; &lt;br&gt; 通过get年龄:&#123;&#123;person.getAge&#125;&#125; &lt;br&gt; 爱好数量:&#123;&#123;person.getHobbiesCount&#125;&#125; &lt;br&gt; 所有的爱好: &lt;ul&gt; &lt;li v-for=&#x27;(hobby,index) in person.hobbies&#x27; :key=&quot;index&quot; v-text=&quot;hobby&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 7 定义组件路由router.js 12345678910111213141516171819202122232425// 导入路由创建的相关方法import &#123;createRouter,createWebHashHistory&#125; from &#x27;vue-router&#x27;// 导入vue组件import List from &#x27;../components/List.vue&#x27;import Operate from &#x27;../components/Operate.vue&#x27;// 创建路由对象,声明路由规则const router = createRouter(&#123; history: createWebHashHistory(), routes:[ &#123; path:&#x27;/opearte&#x27;, component:Operate &#125;, &#123; path:&#x27;/list&#x27;, component:List &#125;, ]&#125;)// 对外暴露路由对象export default router; 8 App.vue中通过路由切换组件 1234567891011121314151617&lt;script setup type=&quot;module&quot;&gt; &lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;hr&gt; &lt;router-link to=&quot;/opearte&quot;&gt;显示操作页&lt;/router-link&gt; &lt;br&gt; &lt;router-link to=&quot;/list&quot;&gt;显示展示页&lt;/router-link&gt; &lt;br&gt; &lt;hr&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 9 启动测试 1npm run dev 11.3 Pinia其他细节 State (状态) 在大多数情况下，state 都是你的 store 的核心。人们通常会先定义能代表他们 APP 的 state。在 Pinia 中，state 被定义为一个返回初始状态的函数。 store.js 1234567891011121314151617181920212223242526import &#123;defineStore&#125; from &#x27;pinia&#x27;export const definedPerson = defineStore(&#x27;personPinia&#x27;, &#123; state:()=&gt;&#123; return &#123; username:&#x27;&#x27;, age:0, hobbies:[&#x27;唱歌&#x27;,&#x27;跳舞&#x27;] &#125; &#125;, getters:&#123; getHobbiesCount()&#123; return this.hobbies.length &#125;, getAge()&#123; return this.age &#125; &#125;, actions:&#123; doubleAge()&#123; this.age=this.age*2 &#125; &#125; &#125;) Operate.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script setup type=&quot;module&quot;&gt; import &#123; ref&#125; from &#x27;vue&#x27;; import &#123; definedPerson&#125; from &#x27;../store/store&#x27;; // 读取存储的数据 let person= definedPerson() let hobby = ref(&#x27;&#x27;) let addHobby= ()=&gt; &#123; console.log(hobby.value) person.hobbies.push(hobby.value) &#125; // 监听状态 person.$subscribe((mutation,state)=&gt;&#123; console.log(&#x27;---subscribe---&#x27;) /* mutation.storeId person.$id一样 mutation.payload 传递给 cartStore.$patch() 的补丁对象。 state 数据状态,其实是一个代理 */ console.log(mutation) console.log(mutation.type) console.log(mutation.payload) console.log(mutation.storeId) console.log(person.$id) // 数据 其实是一个代理对象 console.log(state) &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;operate视图,用户操作Pinia中的数据&lt;/h1&gt; 请输入姓名:&lt;input type=&quot;text&quot; v-model=&quot;person.username&quot;&gt; &lt;br&gt; 请输入年龄:&lt;input type=&quot;text&quot; v-model=&quot;person.age&quot;&gt; &lt;br&gt; 请增加爱好: &lt;input type=&quot;checkbox&quot; value=&quot;吃饭&quot; v-model=&quot;person.hobbies&quot;&gt; 吃饭 &lt;input type=&quot;checkbox&quot; value=&quot;睡觉&quot; v-model=&quot;person.hobbies&quot;&gt; 睡觉 &lt;input type=&quot;checkbox&quot; value=&quot;打豆豆&quot; v-model=&quot;person.hobbies&quot;&gt; 打豆豆 &lt;br&gt; &lt;input type=&quot;text&quot; @change=&quot;addHobby&quot; v-model=&quot;hobby&quot;&gt; &lt;br&gt; &lt;!-- 事件中调用person的doubleAge()方法 --&gt; &lt;button @click=&quot;person.doubleAge()&quot;&gt;年龄加倍&lt;/button&gt; &lt;br&gt; &lt;!-- 事件中调用pinia提供的$reset()方法恢复数据的默认值 --&gt; &lt;button @click=&quot;person.$reset()&quot;&gt;恢复默认值&lt;/button&gt; &lt;br&gt; &lt;!-- 事件中调用$patch方法一次性修改多个属性值 --&gt; &lt;button @click=&quot;person.$patch(&#123;username:&#x27;奥特曼&#x27;,age:100,hobbies:[&#x27;晒太阳&#x27;,&#x27;打怪兽&#x27;]&#125;)&quot;&gt;变身奥特曼&lt;/button&gt; &lt;br&gt; person:&#123;&#123;person&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 2 Getter 完全等同于 store 的 state 的计算值。可以通过 defineStore() 中的 getters 属性来定义它们。推荐使用箭头函数，并且它将接收 state 作为第一个参数： 12345678export const useStore = defineStore(&#x27;main&#x27;, &#123; state: () =&gt; (&#123; count: 0, &#125;), getters: &#123; doubleCount: (state) =&gt; state.count * 2, &#125;,&#125;) 3 Action 相当于组件中的 method。它们可以通过 defineStore() 中的 actions 属性来定义，并且它们也是定义业务逻辑的完美选择。类似 getter，action 也可通过 this 访问整个 store 实例，并支持**完整的类型标注(以及自动补全)**。不同的是，action 可以是异步的，你可以在它们里面 await 调用任何 API，以及其他 action！ 12345678910111213export const useCounterStore = defineStore(&#x27;main&#x27;, &#123; state: () =&gt; (&#123; count: 0, &#125;), actions: &#123; increment() &#123; this.count++ &#125;, randomizeCounter() &#123; this.count = Math.round(100 * Math.random()) &#125;, &#125;,&#125;) 十二、案例开发-日程管理-第七期12.1 前端使用pinia存储数据 安装pinia依赖 1npm install pinia src下创建pinia.js文件 123456// 导入pinia组件import &#123;createPinia&#125; from &#x27;pinia&#x27;// 创建pinia对象let pinia = createPinia()// 导出默认的piniaexport default pinia main.js中使用pinia 123456789101112import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// 导入路由import router from &#x27;./router/router.js&#x27;// 导入pinia对象import pinia from &#x27;./pinia.js&#x27;let app =createApp(App)// 全局使用路由app.use(router)// 全局使用piniaapp.use(pinia)app.mount(&#x27;#app&#x27;) src&#x2F;store&#x2F;userStore.js 用于存储用户信息 1234567891011121314import &#123;defineStore&#125; from &#x27;pinia&#x27;export const defineUser = defineStore(&#x27;loginUser&#x27;,&#123; state:()=&gt;&#123; return &#123; uid:0, username:&#x27;&#x27; &#125; &#125;, getters :&#123; &#125;&#125;) src&#x2F;store&#x2F;scheduleStore.js 用于存储用户的日程信息 1234567891011121314151617181920212223242526272829import &#123;defineStore&#125; from &#x27;pinia&#x27;export const defineSchedule = defineStore(&#x27;scheduleList&#x27;,&#123; state:()=&gt;&#123; return &#123; itemList:[ /*&#123; sid:1, uid:1, title:&#x27;学java&#x27;, completed:1 &#125;, &#123; sid:2, uid:1, title:&#x27;学前端&#x27;, completed:0 &#125;*/ ] &#125; &#125;, getters :&#123; &#125;, actions:&#123; &#125;&#125;) Header.vue中,通过pinia的数据来判断展示何种提示 视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;script setup&gt; /* 导入pinia中的user数据 */ import &#123;defineUser&#125; from &#x27;../store/userStore.js&#x27; import &#123;defineSchedule&#125; from &#x27;../store/scheduleStore.js&#x27; let sysUser =defineUser() let schedule = defineSchedule(); /* 导入编程式路由 */ import &#123;useRouter&#125; from &#x27;vue-router&#x27; let router =useRouter() /* 退出登录接口 */ function logout()&#123; // 清除userPina 和schedulepinia sysUser.$reset() schedule.$reset() // 通过路由回到登录页 router.push(&quot;/login&quot;) &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt; &lt;div&gt; &lt;div class=&quot;optionDiv&quot; v-if=&quot;sysUser.username == &#x27;&#x27;&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt; &lt;button class=&quot;b1s&quot;&gt;登录&lt;/button&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/regist&quot;&gt; &lt;button class=&quot;b1s&quot;&gt;注册&lt;/button&gt; &lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;optionDiv&quot; v-else&gt; 欢迎&#123;&#123;sysUser.username&#125;&#125; &lt;button class=&quot;b1b&quot; @click=&quot;logout()&quot;&gt;退出登录&lt;/button&gt; &lt;router-link to=&quot;/showSchedule&quot;&gt; &lt;button class=&quot;b1b&quot;&gt;查看我的日程&lt;/button&gt; &lt;/router-link&gt; &lt;/div&gt; &lt;br&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .b1s&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; .b1b&#123; border: 2px solid powderblue; border-radius: 4px; width:100px; background-color: antiquewhite; &#125; .optionDiv&#123; width: 500px; float: right; &#125;&lt;/style&gt; Login.vue中,登录成功后,接收后端响应回来的用户id和用户名,存储于userStore中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;script setup&gt; /* 导入pinia中的user数据 */ import &#123;defineUser&#125; from &#x27;../store/userStore.js&#x27; let sysUser =defineUser() /* 获取 编程式路由对象 */ import &#123;useRouter&#125; from &#x27;vue-router&#x27; let router =useRouter(); /* 导入axios请求对象 */ import request from &#x27;../utils/request.js&#x27; // 导入ref,reactive处理响应式数据的方法 import&#123; ref,reactive&#125; from &#x27;vue&#x27; // 响应式数据,保存用户输入的表单信息 let loginUser =reactive(&#123; username:&#x27;&#x27;, userPwd:&#x27;&#x27; &#125;) // 响应式数据,保存校验的提示信息 let usernameMsg =ref(&#x27;&#x27;) let userPwdMsg = ref(&#x27;&#x27;) // 校验用户名的方法 function checkUsername()&#123; // 定义正则 var usernameReg=/^[a-zA-Z0-9]&#123;5,10&#125;$/ // 校验用户名 if(!usernameReg.test(loginUser.username))&#123; // 格式不合法 usernameMsg.value=&quot;格式有误&quot; return false &#125; usernameMsg.value=&quot;ok&quot; return true &#125; // 校验密码的方法 function checkUserPwd()&#123; // 定义正则 var passwordReg=/^[0-9]&#123;6&#125;$/ // 校验密码 if(!passwordReg.test(loginUser.userPwd))&#123; // 格式不合法 userPwdMsg.value=&quot;格式有误&quot; return false &#125; userPwdMsg.value=&quot;ok&quot; return true &#125; // 登录的函数 async function login()&#123; console.log(&quot;发送异步请求&quot;) let &#123;data&#125; = await request.post(&quot;/user/login&quot;,loginUser) if(data.code == 200)&#123; alert(&quot;登录成功&quot;) // 更新pinia数据 sysUser.uid =data.data.loginUser.uid sysUser.username =data.data.loginUser.username // 跳转到日程查询页 router.push(&quot;/showSchedule&quot;) &#125;else if(data.code == 501)&#123; alert(&quot;用户名有误,请重新输入&quot;) &#125;else if(data.code == 503)&#123; alert(&quot;密码有误,请重新输入&quot;) &#125;else &#123; alert(&quot;出现未知名错误&quot;) &#125; &#125; // 清除表单信息的方法 function clearForm()&#123; loginUser.username=&#x27;&#x27; loginUser.userPwd=&#x27;&#x27; usernameMsg.value=&#x27;&#x27; userPwdMsg.value=&#x27;&#x27; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h3 class=&quot;ht&quot;&gt;请登录&lt;/h3&gt; &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入账号&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; type=&quot;text&quot; v-model=&quot;loginUser.username&quot; @blur=&quot;checkUsername()&quot;&gt; &lt;span id=&quot;usernameMsg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; type=&quot;password&quot; v-model=&quot;loginUser.userPwd&quot; @blur=&quot;checkUserPwd()&quot;&gt; &lt;span id=&quot;userPwdMsg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;login()&quot; value=&quot;登录&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;clearForm()&quot; value=&quot;重置&quot;&gt; &lt;router-link to=&quot;/regist&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;去注册&lt;/button&gt; &lt;/router-link&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 500px; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; #usernameMsg , #userPwdMsg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125;&lt;/style&gt; 服务端登录处理方法,登录成功,返回登录用户的信息 12345678910111213141516171819202122232425262728293031323334353637/** * 用户登录的业务接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 接收用户请求参数 // 获取要登录的用户名密码 SysUser inputUser = WebUtil.readJson(req, SysUser.class); // 调用服务层方法,根据用户名查询数据库中是否有一个用户 SysUser loginUser =userService.findByUsername(inputUser.getUsername()); Result result = null; if(null == loginUser)&#123; // 没有根据用户名找到用户,说明用户名有误 result=Result.build(null,ResultCodeEnum.USERNAME_ERROR); &#125;else if(! loginUser.getUserPwd().equals(MD5Util.encrypt(inputUser.getUserPwd())))&#123; // 用户密码有误, result=Result.build(null,ResultCodeEnum.PASSWORD_ERROR); &#125;else&#123; // 登录成功,将用户信息存入session req.getSession().setAttribute(&quot;sysUser&quot;,loginUser); // 登录成功 // 将密码请空后,将用户信息响应给客户端 loginUser.setUserPwd(&quot;&quot;); Map&lt;String,Object&gt; data =new HashMap&lt;&gt;(); data.put(&quot;loginUser&quot;,loginUser); result=Result.ok(data); &#125; WebUtil.writeJson(resp,result); &#125; router.js中,通过路由守卫控制只有登录状态下才可以进入showSchedule.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import &#123;createRouter,createWebHashHistory&#125; from &#x27;vue-router&#x27;import pinia from &#x27;../pinia.js&#x27;import &#123;defineUser&#125; from &#x27;../store/userStore.js&#x27;let sysUser = defineUser(pinia)import Login from &#x27;../components/Login.vue&#x27;import Regist from &#x27;../components/Regist.vue&#x27;import ShowScedule from &#x27;../components/ShowSchedule.vue&#x27;let router = createRouter(&#123; history:createWebHashHistory(), routes:[ &#123; path:&quot;/&quot;, component:Login &#125;, &#123; path:&quot;/login&quot;, component:Login &#125;, &#123; path:&quot;/showSchedule&quot;, component:ShowScedule &#125;, &#123; path:&quot;/regist&quot;, component:Regist &#125; ]&#125;)/* 配置路由的前置守卫,在登录状态下才可以范文showSchedule.vue */router.beforeEach( (to,from,next) =&gt;&#123; // 如果是查看日程 if(to.path==&quot;/showSchedule&quot;)&#123; // 如果尚未的登录 if(sysUser.username == &#x27;&#x27;)&#123; alert(&quot;您尚未登录,请登录后再查看日程&quot;) next(&quot;/login&quot;) &#125;else&#123; // 已经登录 放行 next() &#125; // 其他资源 放行 &#125;else&#123; next() &#125;&#125;)export default router 12.2 显示所有日程数据 ShowSchedule.vue中向后端发送异步请求查询数据并展示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;script setup&gt; /* 引入axios */ import request from &#x27;../utils/request.js&#x27; /* 引入pinia数据 */ import &#123;defineSchedule&#125; from &#x27;../store/scheduleStore.js&#x27; import &#123;defineUser&#125; from &#x27;../store/userStore.js&#x27; let schedule = defineSchedule(); let sysUser = defineUser() /* 引入挂载生命周期 */ import &#123; onMounted,onUpdated,ref,reactive &#125; from &#x27;vue&#x27;; // 第一次挂载就立刻向后端发送请求,获取最新数据 onMounted(async function ()&#123; showSchedule() &#125;) async function showSchedule()&#123; let &#123;data&#125; = await request.get(&quot;/schedule/findAllSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;) schedule.itemList =data.data.itemList &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h3 class=&quot;ht&quot;&gt;您的日程如下&lt;/h3&gt;&lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;内容&lt;/th&gt; &lt;th&gt;进度&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot; v-for=&quot;item,index in schedule.itemList&quot; :key=&quot;index&quot;&gt; &lt;td v-text=&quot;index+1&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;input&quot; v-model=&quot;item.title&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; value=&quot;1&quot; v-model=&quot;item.completed&quot;&gt; 已完成 &lt;input type=&quot;radio&quot; value=&quot;0&quot; v-model=&quot;item.completed&quot;&gt; 未完成 &lt;/td&gt; &lt;td class=&quot;buttonContainer&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;btn1&quot;&gt;保存修改&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr buttonContainer&quot; &gt; &lt;td colspan=&quot;4&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;新增日程&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&#123;&#123;schedule&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 80%; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:100px; background-color: antiquewhite; &#125; #usernameMsg , #userPwdMsg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125;&lt;/style&gt; SysScheduleController中查询数据并响应json 1234567891011121314151617181920212223242526272829303132333435363738package com.atguigu.schedule.controller;import com.atguigu.schedule.common.Result;import com.atguigu.schedule.pojo.SysSchedule;import com.atguigu.schedule.service.SysScheduleService;import com.atguigu.schedule.service.impl.SysScheduleServiceImpl;import com.atguigu.schedule.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;@WebServlet(&quot;/schedule/*&quot;)public class SysScheduleController extends BaseController&#123; private SysScheduleService scheduleService =new SysScheduleServiceImpl(); /** * 查询所有日程接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void findAllSchedule(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int uid = Integer.parseInt(req.getParameter(&quot;uid&quot;)); // 调用服务层方法,查询所有日程 List&lt;SysSchedule&gt; itemList = scheduleService.findItemListByUid(uid); // 将日程信息装入result,转换JSON给客户端 Map&lt;String,Object&gt; data =new HashMap&lt;&gt;(); data.put(&quot;itemList&quot;,itemList); WebUtil.writeJson(resp,Result.ok(data)); &#125;&#125; SysScheduleService接口和实现类代码 123456789101112131415161718192021package com.atguigu.schedule.service;import com.atguigu.schedule.pojo.SysSchedule;import java.util.List;public interface SysScheduleService &#123; List&lt;SysSchedule&gt; findItemListByUid(int uid);&#125;// ------------------------------------------------package com.atguigu.schedule.service.impl;import com.atguigu.schedule.dao.SysScheduleDao;import com.atguigu.schedule.dao.impl.SysScheduleDaoImpl;import com.atguigu.schedule.pojo.SysSchedule;import com.atguigu.schedule.service.SysScheduleService;import java.util.List;public class SysScheduleServiceImpl implements SysScheduleService &#123; private SysScheduleDao scheduleDao =new SysScheduleDaoImpl(); @Override public List&lt;SysSchedule&gt; findItemListByUid(int uid) &#123; return scheduleDao.findItemListByUid(uid); &#125;&#125; SysScheduleDao接口和实现类代码 12345678910111213141516171819package com.atguigu.schedule.dao;import com.atguigu.schedule.pojo.SysSchedule;import java.util.List;public interface SysScheduleDao &#123; List&lt;SysSchedule&gt; findItemListByUid(int uid);&#125;//-----------------------------------------------------------package com.atguigu.schedule.dao.impl;import com.atguigu.schedule.dao.BaseDao;import com.atguigu.schedule.dao.SysScheduleDao;import com.atguigu.schedule.pojo.SysSchedule;import java.util.List;public class SysScheduleDaoImpl extends BaseDao implements SysScheduleDao &#123; @Override public List&lt;SysSchedule&gt; findItemListByUid(int uid) &#123; String sql =&quot;select sid,uid,title, completed from sys_schedule where uid = ? &quot;; return baseQuery(SysSchedule.class,sql,uid); &#125;&#125; 12.3 增加和保存日程数据 ShowSchedule.vue下,为增加和修改按钮绑定事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;script setup&gt; /* 引入axios */ import request from &#x27;../utils/request.js&#x27; /* 引入pinia数据 */ import &#123;defineSchedule&#125; from &#x27;../store/scheduleStore.js&#x27; import &#123;defineUser&#125; from &#x27;../store/userStore.js&#x27; let schedule = defineSchedule(); let sysUser = defineUser() /* 引入挂载生命周期 */ import &#123; onMounted,onUpdated,ref,reactive &#125; from &#x27;vue&#x27;; // 第一次挂载就立刻向后端发送请求,获取最新数据 onMounted(async function ()&#123; // 加载完毕后,立刻调用查询数据的方法 showSchedule() &#125;) async function showSchedule()&#123; let &#123;data&#125; = await request.get(&quot;/schedule/findAllSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;) schedule.itemList =data.data.itemList &#125; // 新增日程 async function addItem()&#123; // 立刻向后端发送一个请求,让后端先为当前用户在数据库中增加一个默认格式的空数据 let &#123;data&#125; = await request.get(&quot;/schedule/addDefaultSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;) if(data.code == 200)&#123; // 然后调用刷新页面数据方法,立刻获取最新数据 showSchedule() &#125;else&#123; alert(&quot;添加异常&quot;) &#125; &#125; // 更新日程的方法 async function updateItem(index)&#123; // 根据索引获取元素 // 将元素通过 JSON串的形式 发送给服务端 let &#123;data&#125; =await request.post(&quot;/schedule/updateSchedule&quot;,schedule.itemList[index]) if(data.code == 200)&#123; // 服务端修改完毕后,刷新页面数据 showSchedule() &#125;else&#123; alert(&quot;更新异常&quot;) &#125; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h3 class=&quot;ht&quot;&gt;您的日程如下&lt;/h3&gt;&lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;内容&lt;/th&gt; &lt;th&gt;进度&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot; v-for=&quot;item,index in schedule.itemList&quot; :key=&quot;index&quot;&gt; &lt;td v-text=&quot;index+1&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;input&quot; v-model=&quot;item.title&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; value=&quot;1&quot; v-model=&quot;item.completed&quot;&gt; 已完成 &lt;input type=&quot;radio&quot; value=&quot;0&quot; v-model=&quot;item.completed&quot;&gt; 未完成 &lt;/td&gt; &lt;td class=&quot;buttonContainer&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;btn1&quot; @click=&quot;updateItem(index)&quot;&gt;保存修改&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr buttonContainer&quot; &gt; &lt;td colspan=&quot;4&quot;&gt; &lt;button class=&quot;btn1&quot; @click=&quot;addItem()&quot;&gt;新增日程&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&#123;&#123;schedule&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 80%; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:100px; background-color: antiquewhite; &#125; #usernameMsg , #userPwdMsg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125;&lt;/style&gt; SysScheduleController处理 新增和保存修改业务处理接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.atguigu.schedule.controller;import com.atguigu.schedule.common.Result;import com.atguigu.schedule.pojo.SysSchedule;import com.atguigu.schedule.service.SysScheduleService;import com.atguigu.schedule.service.impl.SysScheduleServiceImpl;import com.atguigu.schedule.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;@WebServlet(&quot;/schedule/*&quot;)public class SysScheduleController extends BaseController&#123; private SysScheduleService scheduleService =new SysScheduleServiceImpl(); /** * 向数据库中增加一个新的默认数据的方法 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void addDefaultSchedule(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int uid = Integer.parseInt(req.getParameter(&quot;uid&quot;)); // 调用服务层方法,为当前用户新增一个默认空数据 scheduleService.addDefault(uid); WebUtil.writeJson(resp,Result.ok(null)); &#125; /** * 更新日程业务接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void updateSchedule(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; SysSchedule sysSchedule = WebUtil.readJson(req, SysSchedule.class); // 调用服务层方法,更新数据 scheduleService.updateSchedule(sysSchedule); // 响应成功 WebUtil.writeJson(resp,Result.ok(null)); &#125;&#125; SysScheduleService接口和实现类处理业务逻辑 1234567891011121314151617181920212223242526272829package com.atguigu.schedule.service;import com.atguigu.schedule.pojo.SysSchedule;import java.util.List;public interface SysScheduleService &#123; Integer addDefault(int uid); Integer updateSchedule(SysSchedule sysSchedule);&#125;// ----------------------------------------------------------package com.atguigu.schedule.service.impl;import com.atguigu.schedule.dao.SysScheduleDao;import com.atguigu.schedule.dao.impl.SysScheduleDaoImpl;import com.atguigu.schedule.pojo.SysSchedule;import com.atguigu.schedule.service.SysScheduleService;import java.util.List;public class SysScheduleServiceImpl implements SysScheduleService &#123; private SysScheduleDao scheduleDao =new SysScheduleDaoImpl(); @Override public Integer addDefault(int uid) &#123; return scheduleDao.addDefault(uid); &#125; @Override public Integer updateSchedule(SysSchedule sysSchedule) &#123; return scheduleDao.updateSchedule(sysSchedule); &#125;&#125; SysScheduleDao接口和实现类操作数据 1234567891011121314151617181920212223242526272829303132package com.atguigu.schedule.dao;import com.atguigu.schedule.pojo.SysSchedule;import java.util.List;public interface SysScheduleDao &#123; Integer addDefault(int uid); Integer updateSchedule(SysSchedule sysSchedule);&#125;//-------------------------------------------------package com.atguigu.schedule.dao.impl;import com.atguigu.schedule.dao.BaseDao;import com.atguigu.schedule.dao.SysScheduleDao;import com.atguigu.schedule.pojo.SysSchedule;import java.util.List;public class SysScheduleDaoImpl extends BaseDao implements SysScheduleDao &#123; @Override public Integer addDefault(int uid) &#123; String sql = &quot;insert into sys_schedule value(default,?,&#x27;请输入日程&#x27;,0)&quot;; return baseUpdate(sql,uid); &#125; @Override public Integer updateSchedule(SysSchedule sysSchedule) &#123; String sql =&quot;update sys_schedule set title = ? ,completed = ? where sid =?&quot;; return baseUpdate(sql,sysSchedule.getTitle(),sysSchedule.getCompleted(),sysSchedule.getSid()); &#125;&#125; 12.5 删除日程数据 ShowSchedule.vue中,为删除按钮增加事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;script setup&gt; /* 引入axios */ import request from &#x27;../utils/request.js&#x27; /* 引入pinia数据 */ import &#123;defineSchedule&#125; from &#x27;../store/scheduleStore.js&#x27; import &#123;defineUser&#125; from &#x27;../store/userStore.js&#x27; let schedule = defineSchedule(); let sysUser = defineUser() /* 引入挂载生命周期 */ import &#123; onMounted,onUpdated,ref,reactive &#125; from &#x27;vue&#x27;; // 第一次挂载就立刻向后端发送请求,获取最新数据 onMounted(async function ()&#123; // 加载完毕后,立刻调用查询数据的方法 showSchedule() &#125;) async function showSchedule()&#123; let &#123;data&#125; = await request.get(&quot;/schedule/findAllSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;) schedule.itemList =data.data.itemList &#125; // 新增日程 async function addItem()&#123; // 立刻向后端发送一个请求,让后端先为当前用户在数据库中增加一个默认格式的空数据 let &#123;data&#125; = await request.get(&quot;/schedule/addDefaultSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;) if(data.code == 200)&#123; // 然后调用刷新页面数据方法,立刻获取最新数据 showSchedule() &#125;else&#123; alert(&quot;添加异常&quot;) &#125; &#125; // 更新日程的方法 async function updateItem(index)&#123; // 根据索引获取元素 // 将元素通过 JSON串的形式 发送给服务端 let &#123;data&#125; =await request.post(&quot;/schedule/updateSchedule&quot;,schedule.itemList[index]) if(data.code = 200)&#123; // 服务端修改完毕后,刷新页面数据 showSchedule() &#125;else&#123; alert(&quot;更新异常&quot;) &#125; &#125; // 删除日程的方法 async function removeItem(index)&#123; // 弹窗提示是否删除 if(confirm(&quot;确定要删除该条数据&quot;))&#123; // 根据索引获取要删除的item的id let sid = schedule.itemList[index].sid // 向服务端发送请求删除元素 let&#123;data&#125; = await request.get(&quot;/schedule/removeSchedule&quot;,&#123;params:&#123;&quot;sid&quot;:sid&#125;&#125;) //根据业务码判断删除是否成功 if(data.code == 200)&#123; // 删除成功,更新数据 showSchedule() &#125;else&#123; // 删除失败,提示失败 alert(&quot;删除失败&quot;) &#125; &#125; &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h3 class=&quot;ht&quot;&gt;您的日程如下&lt;/h3&gt;&lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;内容&lt;/th&gt; &lt;th&gt;进度&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot; v-for=&quot;item,index in schedule.itemList&quot; :key=&quot;index&quot;&gt; &lt;td v-text=&quot;index+1&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;input&quot; v-model=&quot;item.title&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; value=&quot;1&quot; v-model=&quot;item.completed&quot;&gt; 已完成 &lt;input type=&quot;radio&quot; value=&quot;0&quot; v-model=&quot;item.completed&quot;&gt; 未完成 &lt;/td&gt; &lt;td class=&quot;buttonContainer&quot;&gt; &lt;button class=&quot;btn1&quot; @click=&quot;removeItem(index)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;btn1&quot; @click=&quot;updateItem(index)&quot;&gt;保存修改&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr buttonContainer&quot; &gt; &lt;td colspan=&quot;4&quot;&gt; &lt;button class=&quot;btn1&quot; @click=&quot;addItem()&quot;&gt;新增日程&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&#123;&#123;schedule&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 80%; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:100px; background-color: antiquewhite; &#125; #usernameMsg , #userPwdMsg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125;&lt;/style&gt; SysScheduleController中添加删除业务接口 1234567891011121314151617181920212223242526272829303132333435363738package com.atguigu.schedule.controller;import com.atguigu.schedule.common.Result;import com.atguigu.schedule.pojo.SysSchedule;import com.atguigu.schedule.service.SysScheduleService;import com.atguigu.schedule.service.impl.SysScheduleServiceImpl;import com.atguigu.schedule.util.WebUtil;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;@WebServlet(&quot;/schedule/*&quot;)public class SysScheduleController extends BaseController&#123; private SysScheduleService scheduleService =new SysScheduleServiceImpl(); /** * 删除日程业务接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void removeSchedule(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取要删除的日程id int sid = Integer.parseInt(req.getParameter(&quot;sid&quot;)); // 调用服务层方法,删除日程 scheduleService.removeSchedule(sid); // 响应200 WebUtil.writeJson(resp,Result.ok(null)); &#125;&#125; SysScheduleService层处理删除业务的接口和实现类 1234567891011121314151617181920212223242526package com.atguigu.schedule.service;import com.atguigu.schedule.pojo.SysSchedule;import java.util.List;public interface SysScheduleService &#123; Integer removeSchedule(int sid);&#125;//------------------------------------------------------------------package com.atguigu.schedule.service.impl;import com.atguigu.schedule.dao.SysScheduleDao;import com.atguigu.schedule.dao.impl.SysScheduleDaoImpl;import com.atguigu.schedule.pojo.SysSchedule;import com.atguigu.schedule.service.SysScheduleService;import java.util.List;public class SysScheduleServiceImpl implements SysScheduleService &#123; private SysScheduleDao scheduleDao =new SysScheduleDaoImpl(); @Override public Integer removeSchedule(int sid) &#123; return scheduleDao.removeBySid(sid); &#125;&#125; SysScheduleDao操作数据库的接口和实现类 123456789101112131415161718192021222324252627package com.atguigu.schedule.dao;import com.atguigu.schedule.pojo.SysSchedule;import java.util.List;public interface SysScheduleDao &#123; Integer removeBySid(int sid);&#125;//---------------------------------------------------------package com.atguigu.schedule.dao.impl;import com.atguigu.schedule.dao.BaseDao;import com.atguigu.schedule.dao.SysScheduleDao;import com.atguigu.schedule.pojo.SysSchedule;import java.util.List;public class SysScheduleDaoImpl extends BaseDao implements SysScheduleDao &#123; @Override public Integer removeBySid(int sid) &#123; String sql =&quot;delete from sys_schedule where sid = ?&quot;; return baseUpdate(sql,sid); &#125;&#125; 十三、Element-plus组件库13.1 Element-plus介绍 Element Plus 是一套基于 Vue 3 的开源 UI 组件库，是由饿了么前端团队开发的升级版本 Element UI。Element Plus 提供了丰富的 UI 组件、易于使用的 API 接口和灵活的主题定制功能，可以帮助开发者快速构建高质量的 Web 应用程序。 Element Plus 支持按需加载，且不依赖于任何第三方 CSS 库，它可以轻松地集成到任何 Vue.js 项目中。Element Plus 的文档十分清晰，提供了各种组件的使用方法和示例代码，方便开发者快速上手。 Element Plus 目前已经推出了大量的常用 UI 组件，如按钮、表单、表格、对话框、选项卡等，此外还提供了一些高级组件，如日期选择器、时间选择器、级联选择器、滑块、颜色选择器等。这些组件具有一致的设计和可靠的代码质量，可以为开发者提供稳定的使用体验。 与 Element UI 相比，Element Plus 采用了现代化的技术架构和更加先进的设计理念，同时具备更好的性能和更好的兼容性。Element Plus 的更新迭代也更加频繁，可以为开发者提供更好的使用体验和更多的功能特性。 Element Plus 可以在支持 ES2018 和 ResizeObserver 的浏览器上运行。 如果您确实需要支持旧版本的浏览器，请自行添加 Babel 和相应的 Polyfill 官网https://element-plus.gitee.io/zh-CN/ 由于 Vue 3 不再支持 IE11，Element Plus 也不再支持 IE 浏览器。 13.2 Element-plus入门案例 1 准备vite项目 12345npm create vite // 注意选择 vue+typeScriptnpm install npm install vue-router@4 --savenpm install pinianpm install axios 2 安装element-plus 1npm install element-plus 3 完整引入element-plus main.js 1234567891011import &#123; createApp &#125; from &#x27;vue&#x27;//导入element-plus相关内容import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)app.use(ElementPlus)app.mount(&#x27;#app&#x27;) 4 入门案例 App.vue 123456789101112131415161718192021222324252627282930313233&lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const value = ref(true)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 直接使用element-plus组件即可 --&gt; &lt;el-button&gt;按钮&lt;/el-button&gt; &lt;br&gt; &lt;el-switch v-model=&quot;value&quot; size=&quot;large&quot; active-text=&quot;Open&quot; inactive-text=&quot;Close&quot; /&gt; &lt;br /&gt; &lt;el-switch v-model=&quot;value&quot; active-text=&quot;Open&quot; inactive-text=&quot;Close&quot; /&gt; &lt;br /&gt; &lt;el-switch v-model=&quot;value&quot; size=&quot;small&quot; active-text=&quot;Open&quot; inactive-text=&quot;Close&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 5 启动测试 1npm run dev 13.3 Element-plus常用组件https://element-plus.gitee.io/zh-CN/component/button.html © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/categories/javaweb/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"第六章 会话\\_过滤器\\_监听器","slug":"javaweb/06_第六章 会话_过滤器_监听器","date":"2019-10-08T06:00:00.000Z","updated":"2024-12-02T13:17:29.066Z","comments":true,"path":"2019/10/08/javaweb/06_第六章 会话_过滤器_监听器/","link":"","permalink":"https://protonlml.github.io/2019/10/08/javaweb/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E4%BC%9A%E8%AF%9D_%E8%BF%87%E6%BB%A4%E5%99%A8_%E7%9B%91%E5%90%AC%E5%99%A8/","excerpt":"","text":"第六章 会话_过滤器_监听器一 会话1.1 会话管理概述1.1.1 为什么需要会话管理 HTTP是无状态协议 无状态就是不保存状态,即无状态协议(stateless),HTTP协议自身不对请求和响应之间的通信状态进行保存,也就是说,在HTTP协议这个级别,协议对于发送过的请求或者响应都不做持久化处理 简单理解:浏览器发送请求,服务器接收并响应,但是服务器不记录请求是否来自哪个浏览器,服务器没记录浏览器的特征,就是客户端的状态 举例: 张三去一家饭馆点了几道菜,觉得味道不错,第二天又去了,对老板说,还点上次的那几道菜 无状态: 老板没有记录张三是否来过,更没有记录上次他点了那些菜,张三只能重新再点一遍 有状态: 老板把每次来吃饭的用户都做好记录,查阅一下之前的记录,查到了张三之前的菜单,直接下单 1.1.2 会话管理实现的手段 Cookie和Session配合解决 cookie是在客户端保留少量数据的技术,主要通过响应头向客户端响应一些客户端要保留的信息 session是在服务端保留更多数据的技术,主要通过HttpSession对象保存一些和客户端相关的信息 cookie和session配合记录请求状态 举例: 张三去银行办业务 张三第一次去某个银行办业务,银行会为张三开户(Session),并向张三发放一张银行卡(cookie) 张三后面每次去银行,就可以携带之间的银行卡(cookie),银行根据银行卡找到之前张三的账户(session) 1.2 Cookie1.2.1 Cookie概述 cookie是一种客户端会话技术,cookie由服务端产生,它是服务器存放在浏览器的一小份数据,浏览器以后每次访问该服务器的时候都会将这小份数据携带到服务器去。 服务端创建cookie,将cookie放入响应对象中,Tomcat容器将cookie转化为set-cookie响应头,响应给客户端 客户端在收到cookie的响应头时,在下次请求该服务的资源时,会以cookie请求头的形式携带之前收到的Cookie cookie是一种键值对格式的数据,从tomcat8.5开始可以保存中文,但是不推荐 由于cookie是存储于客户端的数据,比较容易暴露,一般不存储一些敏感或者影响安全的数据 原理图 应用场景举例 记录用户名 当我们在用户名的输入框中输入完用户名后,浏览器记录用户名,下一次再访问登录页面时,用户名自动填充到用户名的输入框. 保存电影播放进度 在网页上播放电影的时候,如果中途退出浏览器了,下载再打开浏览器播放同一部电影的时候,会自动跳转到上次退出时候的进度,因为在播放的时候会将播放进度保存到cookie中 1.2.2 Cookie的使用 servletA向响应中增加Cookie 123456789101112@WebServlet(&quot;/servletA&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 创建Cookie Cookie cookie1 =new Cookie(&quot;c1&quot;,&quot;c1_message&quot;); Cookie cookie2 =new Cookie(&quot;c2&quot;,&quot;c2_message&quot;); // 将cookie放入响应对象 resp.addCookie(cookie1); resp.addCookie(cookie2); &#125;&#125; servletB从请求中读取Cookie 1234567891011121314@WebServlet(&quot;/servletB&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求中的cookie Cookie[] cookies = req.getCookies(); //迭代cookies数组 if (null != cookies &amp;&amp; cookies.length!= 0) &#123; for (Cookie cookie : cookies) &#123; System.out.println(cookie.getName()+&quot;:&quot;+cookie.getValue()); &#125; &#125; &#125;&#125; 1.2.2 Cookie的时效性 默认情况下Cookie的有效期是一次会话范围内，我们可以通过cookie的setMaxAge()方法让Cookie持久化保存到浏览器上 会话级Cookie 服务器端并没有明确指定Cookie的存在时间 在浏览器端，Cookie数据存在于内存中 只要浏览器还开着，Cookie数据就一直都在 浏览器关闭，内存中的Cookie数据就会被释放 持久化Cookie 服务器端明确设置了Cookie的存在时间 在浏览器端，Cookie数据会被保存到硬盘上 Cookie在硬盘上存在的时间根据服务器端限定的时间来管控，不受浏览器关闭的影响 持久化Cookie到达了预设的时间会被释放 cookie.setMaxAge(int expiry)参数单位是秒，表示cookie的持久化时间，如果设置参数为0，表示将浏览器中保存的该cookie删除 servletA设置一个Cookie为持久化cookie 12345678910111213@WebServlet(&quot;/servletA&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 创建Cookie Cookie cookie1 =new Cookie(&quot;c1&quot;,&quot;c1_message&quot;); cookie1.setMaxAge(60); Cookie cookie2 =new Cookie(&quot;c2&quot;,&quot;c2_message&quot;); // 将cookie放入响应对象 resp.addCookie(cookie1); resp.addCookie(cookie2); &#125;&#125; servletB接收Cookie,浏览器中间发生一次重启再请求servletB测试 1234567891011121314@WebServlet(&quot;/servletB&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求中的cookie Cookie[] cookies = req.getCookies(); //迭代cookies数组 if (null != cookies &amp;&amp; cookies.length!= 0) &#123; for (Cookie cookie : cookies) &#123; System.out.println(cookie.getName()+&quot;:&quot;+cookie.getValue()); &#125; &#125; &#125;&#125; 1.2.3 Cookie的提交路径 访问互联网资源时不能每次都需要把所有Cookie带上。访问不同的资源时,可以携带不同的cookie,我们可以通过cookie的setPath(String path) 对cookie的路径进行设置 从ServletA中获取cookie 1234567891011121314public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 创建Cookie Cookie cookie1 =new Cookie(&quot;c1&quot;,&quot;c1_message&quot;); // 设置cookie的提交路径 cookie1.setPath(&quot;/web03_war_exploded/servletB&quot;); Cookie cookie2 =new Cookie(&quot;c2&quot;,&quot;c2_message&quot;); // 将cookie放入响应对象 resp.addCookie(cookie1); resp.addCookie(cookie2); &#125;&#125; 向ServletB请求时携带携带了 c1 向其他资源请求时就不携带c1了 1.3 Session1.3.1 HttpSession概述 HttpSession是一种保留更多信息在服务端的一种技术,服务器会为每一个客户端开辟一块内存空间,即session对象. 客户端在发送请求时,都可以使用自己的session. 这样服务端就可以通过session来记录某个客户端的状态了 服务端在为客户端创建session时,会同时将session对象的id,即JSESSIONID以cookie的形式放入响应对象 后端创建完session后,客户端会收到一个特殊的cookie,叫做JSESSIONID 客户端下一次请求时携带JSESSIONID,后端收到后,根据JSESSIONID找到对应的session对象 通过该机制,服务端通过session就可以存储一些专门针对某个客户端的信息了 session也是域对象(后续详细讲解) 原理图如下 应用场景 记录用户的登录状态 用户登录后,将用户的账号等敏感信息存入session 记录用户操作的历史 例如记录用户的访问痕迹,用户的购物车信息等临时性的信息 1.3.2 HttpSession的使用 用户提交form表单到ServletA,携带用户名,ServletA获取session 将用户名存到Session,用户再请求其他任意Servlet,获取之间存储的用户 定义表单页,提交用户名,提交后 12345&lt;form action=&quot;servletA&quot; method=&quot;post&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 定义ServletA,将用户名存入session 12345678910111213141516171819@WebServlet(&quot;/servletA&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求中的参数 String username = req.getParameter(&quot;username&quot;); // 获取session对象 HttpSession session = req.getSession(); // 获取Session的ID String jSessionId = session.getId(); System.out.println(jSessionId); // 判断session是不是新创建的session boolean isNew = session.isNew(); System.out.println(isNew); // 向session对象中存入数据 session.setAttribute(&quot;username&quot;,username); &#125;&#125; 响应中收到了一个JSESSIONID的cookie 定义其他Servlet,从session中读取用户名 1234567891011121314151617@WebServlet(&quot;/servletB&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取session对象 HttpSession session = req.getSession(); // 获取Session的ID String jSessionId = session.getId(); System.out.println(jSessionId); // 判断session是不是新创建的session boolean isNew = session.isNew(); System.out.println(isNew); // 从session中取出数据 String username = (String)session.getAttribute(&quot;username&quot;); System.out.println(username); &#125;&#125; 请求中携带了一个JSESSIONID的cookie getSession方法的处理逻辑 1.3.3 HttpSession时效性 为什么要设置session的时效 用户量很大之后，Session对象相应的也要创建很多。如果一味创建不释放，那么服务器端的内存迟早要被耗尽。 客户端关闭行为无法被服务端直接侦测,或者客户端较长时间不操作也经常出现,类似这些的情况,就需要对session的时限进行设置了 默认的session最大闲置时间(两次使用同一个session中的间隔时间) 在tomcat&#x2F;conf&#x2F;web.xml配置为30分钟 我们可以自己在当前项目的web.xml对最大闲置时间进行重新设定 也可以通过HttpSession的API 对最大闲置时间进行设定 12// 设置最大闲置时间session.setMaxInactiveInterval(60); 也可以直接让session失效 12// 直接让session失效session.invalidate(); 1.4 三大域对象1.4.1 域对象概述 域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同 web项目中,我们一定要熟练使用的域对象分别是 请求域,会话域,应用域 请求域对象是HttpServletRequest ,传递数据的范围是一次请求之内及请求转发 会话域对象是HttpSession,传递数据的范围是一次会话之内,可以跨多个请求 应用域对象是ServletContext,传递数据的范围是本应用之内,可以跨多个会话 生活举例: 热水器摆放位置不同,使用的范围就不同 摆在张三工位下,就只有张三一个人能用 摆在办公室的公共区,办公室内的所有人都可以用 摆在楼层的走廊区,该楼层的所有人都可以用 三大域对象的数据作用范围图解 请求域 会话域 应用域 所有域在一起 1.4.2 域对象的使用 域对象的API API 功能 void setAttribute(String name,String value) 向域对象中添加&#x2F;修改数据 Object getAttribute(String name); 从域对象中获取数据 removeAttribute(String name); 移除域对象中的数据 API测试 ServletA向三大域中放入数据 1234567891011121314151617@WebServlet(&quot;/servletA&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 向请求域中放入数据 req.setAttribute(&quot;request&quot;,&quot;request-message&quot;); //req.getRequestDispatcher(&quot;servletB&quot;).forward(req,resp); // 向会话域中放入数据 HttpSession session = req.getSession(); session.setAttribute(&quot;session&quot;,&quot;session-message&quot;); // 向应用域中放入数据 ServletContext application = getServletContext(); application.setAttribute(&quot;application&quot;,&quot;application-message&quot;); &#125;&#125; ServletB从三大于中取出数据 123456789101112131415161718@WebServlet(&quot;/servletB&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 从请求域中获取数据 String reqMessage =(String)req.getAttribute(&quot;request&quot;); System.out.println(reqMessage); // 从会话域中获取数据 HttpSession session = req.getSession(); String sessionMessage =(String)session.getAttribute(&quot;session&quot;); System.out.println(sessionMessage); // 从应用域中获取数据 ServletContext application = getServletContext(); String applicationMessage =(String)application.getAttribute(&quot;application&quot;); System.out.println(applicationMessage); &#125;&#125; 请求转发时,请求域可以传递数据请求域内一般放本次请求业务有关的数据,如:查询到的所有的部门信息 同一个会话内,不用请求转发,会话域可以传递数据会话域内一般放本次会话的客户端有关的数据,如:当前客户端登录的用户 同一个APP内,不同的客户端,应用域可以传递数据应用域内一般放本程序应用有关的数据 如:Spring框架的IOC容器 二 过滤器2.1 过滤器概述 Filter,即过滤器,是JAVAEE技术规范之一,作用目标资源的请求进行过滤的一套技术规范,是Java Web项目中最为实用的技术之一 Filter接口定义了过滤器的开发规范,所有的过滤器都要实现该接口 Filter的工作位置是项目中所有目标资源之前,容器在创建HttpServletRequest和HttpServletResponse对象后,会先调用Filter的doFilter方法 Filter的doFilter方法可以控制请求是否继续,如果放行,则请求继续,如果拒绝,则请求到此为止,由过滤器本身做出响应 Filter不仅可以对请求做出过滤,也可以在目标资源做出响应前,对响应再次进行处理 Filter是GOF中责任链模式的典型案例 Filter的常用应用包括但不限于: 登录权限检查,解决网站乱码,过滤敏感字符,日志记录,性能分析… … 生活举例: 公司前台,停车场安保,地铁验票闸机 公司前台对来访人员进行审核,如果是游客则拒绝进入公司,如果是客户则放行 . 客户离开时提醒客户不要遗忘物品 停车场保安对来访车辆进行控制,如果没有车位拒绝进入,如果有车位,发放停车卡并放行,车辆离开时收取请车费 地铁验票闸机在人员进入之前检查票,没票拒绝进入,有票验票后放行,人员离开时同样验票 过滤器开发中应用的场景 日志的记录 性能的分析 乱码的处理 事务的控制 登录的控制 跨域的处理 … … 过滤器工作位置图解 Filter接口API 源码 123456789101112package jakarta.servlet;import java.io.IOException;public interface Filter &#123; default public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; default public void destroy() &#123; &#125;&#125; API目标 API 目标 default public void init(FilterConfig filterConfig) 初始化方法,由容器调用并传入初始配置信息filterConfig对象 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 过滤方法,核心方法,过滤请求,决定是否放行,响应之前的其他处理等都在该方法中 default public void destroy() 销毁方法,容器在回收过滤器对象之前调用的方法 2.2 过滤器使用 目标:开发一个日志记录过滤器 用户请求到达目标资源之前,记录用户的请求资源路径 响应之前记录本次请求目标资源运算的耗时 可以选择将日志记录进入文件,为了方便测试,这里将日志直接在控制台打印 定义一个过滤器类,编写功能代码 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.filters;import jakarta.servlet.*;import jakarta.servlet.annotation.WebFilter;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;public class LoggingFilter implements Filter &#123; private SimpleDateFormat dateFormat =new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 参数父转子 HttpServletRequest request =(HttpServletRequest) servletRequest; HttpServletResponse response =(HttpServletResponse) servletResponse; // 拼接日志文本 String requestURI = request.getRequestURI(); String time = dateFormat.format(new Date()); String beforeLogging =requestURI+&quot;在&quot;+time+&quot;被请求了&quot;; // 打印日志 System.out.println(beforeLogging); // 获取系统时间 long t1 = System.currentTimeMillis(); // 放行请求 filterChain.doFilter(request,response); // 获取系统时间 long t2 = System.currentTimeMillis(); // 拼接日志文本 String afterLogging =requestURI+&quot;在&quot;+time+&quot;的请求耗时:&quot;+(t2-t1)+&quot;毫秒&quot;; // 打印日志 System.out.println(afterLogging); &#125;&#125; 说明 doFilter方法中的请求和响应对象是以父接口的形式声明的,实际传入的实参就是HttpServletRequest和HttpServletResponse子接口级别的,可以安全强转 filterChain.doFilter(request,response); 这行代码的功能是放行请求,如果没有这一行代码,则请求到此为止 filterChain.doFilter(request,response);在放行时需要传入request和response,意味着请求和响应对象要继续传递给后续的资源,这里没有产生新的request和response对象 定义两个Servlet作为目标资源 ServletA 123456789101112131415@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 处理器请求 System.out.println(&quot;servletA处理请求的方法,耗时10毫秒&quot;); // 模拟处理请求耗时 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; ServletB 123456789101112131415@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 处理器请求 System.out.println(&quot;servletB处理请求的方法,耗时15毫秒&quot;); // 模拟处理请求耗时 try &#123; Thread.sleep(15); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 配置过滤器以及过滤器的过滤范围 web.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot;&gt; &lt;!--配置filter,并为filter起别名--&gt; &lt;filter&gt; &lt;filter-name&gt;loggingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filters.LoggingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!--为别名对应的filter配置要过滤的目标资源--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;loggingFilter&lt;/filter-name&gt; &lt;!--通过映射路径确定过滤资源--&gt; &lt;url-pattern&gt;/servletA&lt;/url-pattern&gt; &lt;!--通过后缀名确定过滤资源--&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;!--通过servlet别名确定过滤资源--&gt; &lt;servlet-name&gt;servletBName&lt;/servlet-name&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 说明 filter-mapping标签中定义了过滤器对那些资源进行过滤 子标签url-pattern通过映射路径确定过滤范围 &#x2F;servletA 精确匹配,表示对servletA资源的请求进行过滤 *.html 表示对以.action结尾的路径进行过滤 &#x2F;* 表示对所有资源进行过滤 一个filter-mapping下可以配置多个url-pattern 子标签servlet-name通过servlet别名确定对那些servlet进行过滤 使用该标签确定目标资源的前提是servlet已经起了别名 一个filter-mapping下可以定义多个servlet-name 一个filter-mapping下,servlet-name和url-pattern子标签可以同时存在 过滤过程图解 2.3 过滤器生命周期 过滤器作为web项目的组件之一,和Servlet的生命周期类似,略有不同,没有servlet的load-on-startup的配置,默认就是系统启动立刻构造 阶段 对应方法 执行时机 执行次数 创建对象 构造器 web应用启动时 1 初始化方法 void init(FilterConfig filterConfig) 构造完毕 1 过滤请求 void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) 每次请求 多次 销毁 default void destroy() web应用关闭时 1次 测试代码 1234567891011121314151617181920212223242526272829303132package com.atguigu.filters;import jakarta.servlet.*;import jakarta.servlet.annotation.WebServlet;import java.io.IOException;@WebServlet(&quot;/*&quot;)public class LifeCycleFilter implements Filter &#123; public LifeCycleFilter()&#123; System.out.println(&quot;LifeCycleFilter constructor method invoked&quot;); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;LifeCycleFilter init method invoked&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;LifeCycleFilter doFilter method invoked&quot;); filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; System.out.println(&quot;LifeCycleFilter destory method invoked&quot;); &#125;&#125; 2.4 过滤器链的使用 一个web项目中,可以同时定义多个过滤器,多个过滤器对同一个资源进行过滤时,工作位置有先后,整体形成一个工作链,称之为过滤器链 过滤器链中的过滤器的顺序由filter-mapping顺序决定 每个过滤器过滤的范围不同,针对同一个资源来说,过滤器链中的过滤器个数可能是不同的 如果某个Filter是使用ServletName进行匹配规则的配置，那么这个Filter执行的优先级要更低 图解过滤器链 过滤器链功能测试 定义三个过滤器,对目标资源Servlet的请求进行过滤 目标Servlet资源代码 123456789101112131415161718package com.atguigu.servlet;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/servletC&quot;)public class ServletC extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;servletC service method invoked&quot;); &#125;&#125; 三个过滤器代码 12345678910111213141516171819202122232425262728293031323334353637public class Filter1 implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filter1 before chain.doFilter code invoked&quot;); filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;filter1 after chain.doFilter code invoked&quot;); &#125;&#125;public class Filter2 implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filter2 before chain.doFilter code invoked&quot;); filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;filter2 after chain.doFilter code invoked&quot;); &#125;&#125;public class Filter3 implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filter3 before chain.doFilter code invoked&quot;); filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;filter3 after chain.doFilter code invoked&quot;); &#125;&#125; 过滤器配置代码 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot;&gt; &lt;filter&gt; &lt;filter-name&gt;filter1&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filters.Filter1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filters.Filter2&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;filter3&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filters.Filter3&lt;/filter-class&gt; &lt;/filter&gt; &lt;!--filter-mapping的顺序决定了过滤器的工作顺序--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter1&lt;/filter-name&gt; &lt;url-pattern&gt;/servletC&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter2&lt;/filter-name&gt; &lt;url-pattern&gt;/servletC&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filter3&lt;/filter-name&gt; &lt;url-pattern&gt;/servletC&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 工作流程图解 2.5 注解方式配置过滤器 @WebFilter注解的使用 源码 123456789101112131415161718192021222324252627282930313233343536package jakarta.servlet.annotation;import jakarta.servlet.DispatcherType;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebFilter &#123; String description() default &quot;&quot;; String displayName() default &quot;&quot;; WebInitParam[] initParams() default &#123;&#125;; String filterName() default &quot;&quot;; String smallIcon() default &quot;&quot;; String largeIcon() default &quot;&quot;; String[] servletNames() default &#123;&#125;; String[] value() default &#123;&#125;; String[] urlPatterns() default &#123;&#125;; DispatcherType[] dispatcherTypes() default &#123;DispatcherType.REQUEST&#125;; boolean asyncSupported() default false;&#125; 一个比较完整的Filter的XML配置 1234567891011121314151617181920&lt;!--配置filter,并为filter起别名--&gt;&lt;filter&gt; &lt;filter-name&gt;loggingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filters.LoggingFilter&lt;/filter-class&gt; &lt;!--配置filter的初始参数--&gt; &lt;init-param&gt; &lt;param-name&gt;dateTimePattern&lt;/param-name&gt; &lt;param-value&gt;yyyy-MM-dd HH:mm:ss&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!--为别名对应的filter配置要过滤的目标资源--&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;loggingFilter&lt;/filter-name&gt; &lt;!--通过映射路径确定过滤资源--&gt; &lt;url-pattern&gt;/servletA&lt;/url-pattern&gt; &lt;!--通过后缀名确定过滤资源--&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;!--通过servlet别名确定过滤资源--&gt; &lt;servlet-name&gt;servletBName&lt;/servlet-name&gt;&lt;/filter-mapping&gt; 将xml配置转换成注解方式实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.filters;import jakarta.servlet.*;import jakarta.servlet.annotation.WebFilter;import jakarta.servlet.annotation.WebInitParam;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;@WebFilter( filterName = &quot;loggingFilter&quot;, initParams = &#123;@WebInitParam(name=&quot;dateTimePattern&quot;,value=&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;, urlPatterns = &#123;&quot;/servletA&quot;,&quot;*.html&quot;&#125;, servletNames = &#123;&quot;servletBName&quot;&#125;)public class LoggingFilter implements Filter &#123; private SimpleDateFormat dateFormat ; /*init初始化方法,通过filterConfig获取初始化参数 * init方法中,可以用于定义一些其他初始化功能代码 * */ @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // 获取初始参数 String dateTimePattern = filterConfig.getInitParameter(&quot;dateTimePattern&quot;); // 初始化成员变量 dateFormat=new SimpleDateFormat(dateTimePattern); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 参数父转子 HttpServletRequest request =(HttpServletRequest) servletRequest; HttpServletResponse response =(HttpServletResponse) servletResponse; // 拼接日志文本 String requestURI = request.getRequestURI(); String time = dateFormat.format(new Date()); String beforeLogging =requestURI+&quot;在&quot;+time+&quot;被请求了&quot;; // 打印日志 System.out.println(beforeLogging); // 获取系统时间 long t1 = System.currentTimeMillis(); // 放行请求 filterChain.doFilter(request,response); // 获取系统时间 long t2 = System.currentTimeMillis(); String afterLogging =requestURI+&quot;在&quot;+time+&quot;的请求耗时:&quot;+(t2-t1)+&quot;毫秒&quot;; // 打印日志 System.out.println(afterLogging); &#125;&#125; 三 监听器3.1 监听器概述 监听器：专门用于对域对象对象身上发生的事件或状态改变进行监听和相应处理的对象 监听器是GOF设计模式中,观察者模式的典型案例 观察者模式: 当被观察的对象发生某些改变时, 观察者自动采取对应的行动的一种设计模式 监听器使用的感受类似JS中的事件,被观察的对象发生某些情况时,自动触发代码的执行 监听器并不监听web项目中的所有组件,仅仅是对三大域对象做相关的事件监听 监听器的分类 web中定义八个监听器接口作为监听器的规范,这八个接口按照不同的标准可以形成不同的分类 按监听的对象划分 application域监听器 ServletContextListener ServletContextAttributeListener session域监听器 HttpSessionListener HttpSessionAttributeListener HttpSessionBindingListener HttpSessionActivationListener request域监听器 ServletRequestListener ServletRequestAttributeListener 按监听的事件分 域对象的创建和销毁监听器 ServletContextListener HttpSessionListener ServletRequestListener 域对象数据增删改事件监听器 ServletContextAttributeListener HttpSessionAttributeListener ServletRequestAttributeListener 其他监听器 HttpSessionBindingListener HttpSessionActivationListener 3.2 监听器的六个主要接口3.2.1 application域监听器 ServletContextListener 监听ServletContext对象的创建与销毁 方法名 作用 contextInitialized(ServletContextEvent sce) ServletContext创建时调用 contextDestroyed(ServletContextEvent sce) ServletContext销毁时调用 ServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。 ServletContextAttributeListener 监听ServletContext中属性的添加、移除和修改 方法名 作用 attributeAdded(ServletContextAttributeEvent scab) 向ServletContext中添加属性时调用 attributeRemoved(ServletContextAttributeEvent scab) 从ServletContext中移除属性时调用 attributeReplaced(ServletContextAttributeEvent scab) 当ServletContext中的属性被修改时调用 ServletContextAttributeEvent对象代表属性变化事件，它包含的方法如下： 方法名 作用 getName() 获取修改或添加的属性名 getValue() 获取被修改或添加的属性值 getServletContext() 获取ServletContext对象 测试代码 定义监听器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.listeners;import jakarta.servlet.*;import jakarta.servlet.annotation.WebListener;@WebListenerpublic class ApplicationListener implements ServletContextListener , ServletContextAttributeListener &#123; // 监听初始化 @Override public void contextInitialized(ServletContextEvent sce) &#123; ServletContext application = sce.getServletContext(); System.out.println(&quot;application&quot;+application.hashCode()+&quot; initialized&quot;); &#125; // 监听销毁 @Override public void contextDestroyed(ServletContextEvent sce) &#123; ServletContext application = sce.getServletContext(); System.out.println(&quot;application&quot;+application.hashCode()+&quot; destroyed&quot;); &#125; // 监听数据增加 @Override public void attributeAdded(ServletContextAttributeEvent scae) &#123; String name = scae.getName(); Object value = scae.getValue(); ServletContext application = scae.getServletContext(); System.out.println(&quot;application&quot;+application.hashCode()+&quot; add:&quot;+name+&quot;=&quot;+value); &#125; // 监听数据移除 @Override public void attributeRemoved(ServletContextAttributeEvent scae) &#123; String name = scae.getName(); Object value = scae.getValue(); ServletContext application = scae.getServletContext(); System.out.println(&quot;application&quot;+application.hashCode()+&quot; remove:&quot;+name+&quot;=&quot;+value); &#125; // 监听数据修改 @Override public void attributeReplaced(ServletContextAttributeEvent scae) &#123; String name = scae.getName(); Object value = scae.getValue(); ServletContext application = scae.getServletContext(); Object newValue = application.getAttribute(name); System.out.println(&quot;application&quot;+application.hashCode()+&quot; change:&quot;+name+&quot;=&quot;+value+&quot; to &quot;+newValue); &#125;&#125; 定义触发监听器的代码 12345678910111213141516171819202122232425// ServletA用于向application域中放入数据@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 向application域中放入数据 ServletContext application = this.getServletContext(); application.setAttribute(&quot;k1&quot;,&quot;v1&quot;); application.setAttribute(&quot;k2&quot;,&quot;v2&quot;); &#125;&#125;// ServletB用于向application域中修改和移除数据@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext appliation = getServletContext(); // 修改application域中的数据 appliation.setAttribute(&quot;k1&quot;,&quot;value1&quot;); // 删除application域中的数据 appliation.removeAttribute(&quot;k2&quot;); &#125;&#125; 3.2.2 session域监听器 HttpSessionListener 监听HttpSession对象的创建与销毁 方法名 作用 sessionCreated(HttpSessionEvent hse) HttpSession对象创建时调用 sessionDestroyed(HttpSessionEvent hse) HttpSession对象销毁时调用 HttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。 HttpSessionAttributeListener 监听HttpSession中属性的添加、移除和修改 方法名 作用 attributeAdded(HttpSessionBindingEvent se) 向HttpSession中添加属性时调用 attributeRemoved(HttpSessionBindingEvent se) 从HttpSession中移除属性时调用 attributeReplaced(HttpSessionBindingEvent se) 当HttpSession中的属性被修改时调用 HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下： 方法名 作用 getName() 获取修改或添加的属性名 getValue() 获取被修改或添加的属性值 getSession() 获取触发事件的HttpSession对象 测试代码 定义监听器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.listeners;import jakarta.servlet.*;import jakarta.servlet.annotation.WebListener;import jakarta.servlet.http.*;@WebListenerpublic class SessionListener implements HttpSessionListener, HttpSessionAttributeListener &#123; // 监听session创建 @Override public void sessionCreated(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); System.out.println(&quot;session&quot;+session.hashCode()+&quot; created&quot;); &#125; // 监听session销毁 @Override public void sessionDestroyed(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); System.out.println(&quot;session&quot;+session.hashCode()+&quot; destroyed&quot;); &#125; // 监听数据增加 @Override public void attributeAdded(HttpSessionBindingEvent se) &#123; String name = se.getName(); Object value = se.getValue(); HttpSession session = se.getSession(); System.out.println(&quot;session&quot;+session.hashCode()+&quot; add:&quot;+name+&quot;=&quot;+value); &#125; // 监听数据移除 @Override public void attributeRemoved(HttpSessionBindingEvent se) &#123; String name = se.getName(); Object value = se.getValue(); HttpSession session = se.getSession(); System.out.println(&quot;session&quot;+session.hashCode()+&quot; remove:&quot;+name+&quot;=&quot;+value); &#125; // 监听数据修改 @Override public void attributeReplaced(HttpSessionBindingEvent se) &#123; String name = se.getName(); Object value = se.getValue(); HttpSession session = se.getSession(); Object newValue = session.getAttribute(name); System.out.println(&quot;session&quot;+session.hashCode()+&quot; change:&quot;+name+&quot;=&quot;+value+&quot; to &quot;+newValue); &#125;&#125; 定义触发监听器的代码 12345678910111213141516171819202122232425262728// servletA用于创建session并向session中放数据@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 创建session,并向session中放入数据 HttpSession session = req.getSession(); session.setAttribute(&quot;k1&quot;,&quot;v1&quot;); session.setAttribute(&quot;k2&quot;,&quot;v2&quot;); &#125;&#125;// servletB用于修改删除session中的数据并手动让session不可用@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); // 修改session域中的数据 session.setAttribute(&quot;k1&quot;,&quot;value1&quot;); // 删除session域中的数据 session.removeAttribute(&quot;k2&quot;); // 手动让session不可用 session.invalidate(); &#125;&#125; 3.2.3 request域监听器 ServletRequestListener 监听ServletRequest对象的创建与销毁 方法名 作用 requestInitialized(ServletRequestEvent sre) ServletRequest对象创建时调用 requestDestroyed(ServletRequestEvent sre) ServletRequest对象销毁时调用 ServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。 ServletRequestAttributeListener 监听ServletRequest中属性的添加、移除和修改 方法名 作用 attributeAdded(ServletRequestAttributeEvent srae) 向ServletRequest中添加属性时调用 attributeRemoved(ServletRequestAttributeEvent srae) 从ServletRequest中移除属性时调用 attributeReplaced(ServletRequestAttributeEvent srae) 当ServletRequest中的属性被修改时调用 ServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下： 方法名 作用 getName() 获取修改或添加的属性名 getValue() 获取被修改或添加的属性值 getServletRequest () 获取触发事件的ServletRequest对象 定义监听器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.atguigu.listeners;import jakarta.servlet.*;import jakarta.servlet.annotation.WebListener;@WebListenerpublic class RequestListener implements ServletRequestListener , ServletRequestAttributeListener &#123; // 监听初始化 @Override public void requestInitialized(ServletRequestEvent sre) &#123; ServletRequest request = sre.getServletRequest(); System.out.println(&quot;request&quot;+request.hashCode()+&quot; initialized&quot;); &#125; // 监听销毁 @Override public void requestDestroyed(ServletRequestEvent sre) &#123; ServletRequest request = sre.getServletRequest(); System.out.println(&quot;request&quot;+request.hashCode()+&quot; destoryed&quot;); &#125; // 监听数据增加 @Override public void attributeAdded(ServletRequestAttributeEvent srae) &#123; String name = srae.getName(); Object value = srae.getValue(); ServletRequest request = srae.getServletRequest(); System.out.println(&quot;request&quot;+request.hashCode()+&quot; add:&quot;+name+&quot;=&quot;+value); &#125; // 监听数据移除 @Override public void attributeRemoved(ServletRequestAttributeEvent srae) &#123; String name = srae.getName(); Object value = srae.getValue(); ServletRequest request = srae.getServletRequest(); System.out.println(&quot;request&quot;+request.hashCode()+&quot; remove:&quot;+name+&quot;=&quot;+value); &#125; // 监听数据修改 @Override public void attributeReplaced(ServletRequestAttributeEvent srae) &#123; String name = srae.getName(); Object value = srae.getValue(); ServletRequest request = srae.getServletRequest(); Object newValue = request.getAttribute(name); System.out.println(&quot;request&quot;+request.hashCode()+&quot; change:&quot;+name+&quot;=&quot;+value+&quot; to &quot;+newValue); &#125;&#125; 定义触发监听器的代码 12345678910111213141516171819202122232425// servletA向请求域中放数据@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 向request中增加数据 req.setAttribute(&quot;k1&quot;,&quot;v1&quot;); req.setAttribute(&quot;k2&quot;,&quot;v2&quot;); // 请求转发 req.getRequestDispatcher(&quot;servletB&quot;).forward(req,resp); &#125;&#125;// servletB修改删除域中的数据@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 修改request域中的数据 req.setAttribute(&quot;k1&quot;,&quot;value1&quot;); // 删除session域中的数据 req.removeAttribute(&quot;k2&quot;); &#125;&#125; 3.3 session域的两个特殊监听器3.3.3 session绑定监听器 HttpSessionBindingListener 监听当前监听器对象在Session域中的增加与移除 方法名 作用 valueBound(HttpSessionBindingEvent event) 该类的实例被放到Session域中时调用 valueUnbound(HttpSessionBindingEvent event) 该类的实例从Session中移除时调用 HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下： 方法名 作用 getName() 获取当前事件涉及的属性名 getValue() 获取当前事件涉及的属性值 getSession() 获取触发事件的HttpSession对象 测试代码 定义监听器 1234567891011121314151617181920212223package com.atguigu.listeners;import jakarta.servlet.http.HttpSession;import jakarta.servlet.http.HttpSessionBindingEvent;import jakarta.servlet.http.HttpSessionBindingListener;public class MySessionBindingListener implements HttpSessionBindingListener &#123; // 监听绑定 @Override public void valueBound(HttpSessionBindingEvent event) &#123; HttpSession session = event.getSession(); String name = event.getName(); System.out.println(&quot;MySessionBindingListener&quot;+this.hashCode()+&quot; binding into session&quot;+session.hashCode()+&quot; with name &quot;+name); &#125; // 监听解除绑定 @Override public void valueUnbound(HttpSessionBindingEvent event) &#123; HttpSession session = event.getSession(); String name = event.getName(); System.out.println(&quot;MySessionBindingListener&quot;+this.hashCode()+&quot; unbond outof session&quot;+session.hashCode()+&quot; with name &quot;+name); &#125;&#125; 定义触发监听器的代码 123456789101112@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); // 绑定监听器 session.setAttribute(&quot;bindingListener&quot;,new MySessionBindingListener()); // 解除绑定监听器 session.removeAttribute(&quot;bindingListener&quot;); &#125;&#125; 3.3.4 钝化活化监听器 HttpSessionActivationListener 监听某个对象在Session中的序列化与反序列化。 方法名 作用 sessionWillPassivate(HttpSessionEvent se) 该类实例和Session一起钝化到硬盘时调用 sessionDidActivate(HttpSessionEvent se) 该类实例和Session一起活化到内存时调用 HttpSessionEvent对象代表事件对象，通过getSession()方法获取事件涉及的HttpSession对象。 什么是钝化活化 session对象在服务端是以对象的形式存储于内存的,session过多,服务器的内存也是吃不消的 而且一旦服务器发生重启,所有的session对象都将被清除,也就意味着session中存储的不同客户端的登录状态丢失 为了分摊内存 压力并且为了保证session重启不丢失,我们可以设置将session进行钝化处理 在关闭服务器前或者到达了设定时间时,对session进行序列化到磁盘,这种情况叫做session的钝化 在服务器启动后或者再次获取某个session时,将磁盘上的session进行反序列化到内存,这种情况叫做session的活化 如何配置钝化活化 在web目录下,添加 META-INF下创建Context.xml 文件中配置钝化 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context&gt; &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;d:\\mysession&quot;&gt;&lt;/Store&gt; &lt;/Manager&gt;&lt;/Context&gt; 请求servletA,获得session,并存入数据,然后重启服务器 123456789@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); // 添加数据 session.setAttribute(&quot;k1&quot;,&quot;v1&quot;); &#125;&#125; 请求servletB获取session,获取重启前存入的数据 12345678910@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); Object v1 = session.getAttribute(&quot;k1&quot;); System.out.println(v1); &#125;&#125; 如何监听钝化活化 定义监听器 123456789101112131415161718192021222324package com.atguigu.listeners;import jakarta.servlet.http.HttpSession;import jakarta.servlet.http.HttpSessionActivationListener;import jakarta.servlet.http.HttpSessionEvent;import java.io.Serializable;public class ActivationListener implements HttpSessionActivationListener, Serializable &#123; // 监听钝化 @Override public void sessionWillPassivate(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); System.out.println(&quot;session with JSESSIONID &quot;+ session.getId()+&quot; will passivate&quot;); &#125; // 监听活化 @Override public void sessionDidActivate(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); System.out.println(&quot;session with JSESSIONID &quot;+ session.getId()+&quot; did activate&quot;); &#125;&#125; 定义触发监听器的代码 1234567891011@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); // 添加数据 session.setAttribute(&quot;k1&quot;,&quot;v1&quot;); // 添加钝化活化监听器 session.setAttribute(&quot;activationListener&quot;,new ActivationListener()); &#125;&#125; 四 案例开发-日程管理-第三期4.1 过滤器控制登录校验 需求说明:未登录状态下不允许访问showShedule.html和SysScheduleController相关增删改处理,重定向到login.html,登录成功后可以自由访问 开发登录过滤器,对指定资源的请求进行过滤 1234567891011121314151617181920212223242526272829package com.atguigu.schedule.filters;import jakarta.servlet.*;import jakarta.servlet.annotation.WebFilter;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import jakarta.servlet.http.HttpSession;import java.io.IOException;@WebFilter(urlPatterns = &#123;&quot;/showSchedule.html&quot;,&quot;/schedule/*&quot;&#125;)public class LoginFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request =(HttpServletRequest) servletRequest; HttpServletResponse response =(HttpServletResponse) servletResponse; HttpSession session = request.getSession(); Object sysUser = session.getAttribute(&quot;sysUser&quot;); if(null != sysUser)&#123; // session中如果存在登录的用户 代表用户登录过,则放行 filterChain.doFilter(servletRequest,servletResponse); &#125;else&#123; //用户未登录,重定向到登录页 response.sendRedirect(&quot;/login.html&quot;); &#125; &#125;&#125; 修改用户登录请求的login方法,登录成功时,将用户信息存入session 123456789101112131415161718192021222324252627/** * 用户登录的业务接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 接收用户请求参数 // 获取要注册的用户名密码 String username = req.getParameter(&quot;username&quot;); String userPwd = req.getParameter(&quot;userPwd&quot;); // 调用服务层方法,根据用户名查询数据库中是否有一个用户 SysUser loginUser =userService.findByUsername(username); if(null == loginUser)&#123; // 没有根据用户名找到用户,说明用户名有误 resp.sendRedirect(&quot;/loginUsernameError.html&quot;); &#125;else if(! loginUser.getUserPwd().equals(MD5Util.encrypt(userPwd)))&#123; // 用户密码有误, resp.sendRedirect(&quot;/loginUserPwdError.html&quot;); &#125;else&#123; // 登录成功,将用户信息存入session req.getSession().setAttribute(&quot;sysUser&quot;,loginUser); // 登录成功,重定向到日程展示页 resp.sendRedirect(&quot;/showSchedule.html&quot;); &#125; &#125; 五 Ajax4.1 什么是ajax AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。 XMLHttpRequest 只是实现 Ajax 的一种方式。 ajax工作原理： 简单来说,我们之前发的请求通过类似 form表单标签,a标签 这种方式,现在通过 运行js代码动态决定什么时候发送什么样的请求 通过运行JS代码发送的请求浏览器可以不用跳转页面 ,我们可以在JS代码中决定是否要跳转页面 通过运行JS代码发送的请求,接收到返回结果后,我们可以将结果通过dom编程渲染到页面的某些元素上,实现局部更新 4.2 如何实现ajax请求 原生javascript方式进行ajax(了解): 12345678910111213141516&lt;script&gt; function loadXMLDoc()&#123; var xmlhttp=new XMLHttpRequest(); // 设置回调函数处理响应结果 xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125; &#125; // 设置请求方式和请求的资源路径 xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true); // 发送请求 xmlhttp.send(); &#125;&lt;/script&gt; 六 案例开发-日程管理-第四期6.1 注册提交前校验用户名是否占用功能 客户端代码编写处理 regist.html页面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 500px; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; .msg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; // 校验用户名的方法 function checkUsername()&#123; // 定义正则 var usernameReg=/^[a-zA-Z0-9]&#123;5,10&#125;$/ var username =document.getElementById(&quot;usernameInput&quot;).value var usernameMsgSpan =document.getElementById(&quot;usernameMsg&quot;) if(!usernameReg.test(username))&#123; usernameMsgSpan.innerText=&quot;不合法&quot; return false &#125; // 发送ajax请求校验用户名是否被占用 var request; if(window.XMLHttpRequest)&#123; request= new XMLHttpRequest(); &#125;else&#123; request= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; request.onreadystatechange= function ()&#123; // request.readyState == 4 代表请求结束,已经接收到响应结果 // request.status== 200 表示后端响应状态码是200 if(request.readyState == 4 &amp;&amp; request.status== 200)&#123; // 后端的响应的JSON字符串转换为前端的对象 var response =JSON.parse(request.responseText) console.log(response) // 判断业务码是否是200 if (response.code != 200)&#123; usernameMsgSpan.innerText=&quot;已占用&quot; return false &#125; &#125; &#125; // 设置请求方式,请求资源路径,是否为异步请求 request.open(&quot;GET&quot;,&#x27;/user/checkUsernameUsed?username=&#x27;+username,true) // 发送请求 request.send(); // 前面校验都通过 // usernameMsgSpan.innerText=&quot;OK&quot; // return true &#125; // 校验密码的方法 function checkUserPwd()&#123; // 定义正则 var passwordReg=/^[0-9]&#123;6&#125;$/ var userPwd =document.getElementById(&quot;userPwdInput&quot;).value var userPwdMsgSpan =document.getElementById(&quot;userPwdMsg&quot;) if(!passwordReg.test(userPwd))&#123; userPwdMsgSpan.innerText=&quot;不合法&quot; return false &#125; userPwdMsgSpan.innerText=&quot;OK&quot; return true &#125; // 校验密码的方法 function checkReUserPwd()&#123; // 定义正则 var passwordReg=/^[0-9]&#123;6&#125;$/ var userPwd =document.getElementById(&quot;userPwdInput&quot;).value var reUserPwd =document.getElementById(&quot;reUserPwdInput&quot;).value var reUserPwdMsgSpan =document.getElementById(&quot;reUserPwdMsg&quot;) if(!passwordReg.test(userPwd))&#123; reUserPwdMsgSpan.innerText=&quot;不合法&quot; return false &#125; if(userPwd != reUserPwd)&#123; reUserPwdMsgSpan.innerText=&quot;不一致&quot; return false &#125; reUserPwdMsgSpan.innerText=&quot;OK&quot; return true &#125; //表单提交时统一校验 function checkForm()&#123; return checkUsername() &amp;&amp; checkUserPwd() &amp;&amp; checkReUserPwd() &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt;&lt;h3 class=&quot;ht&quot;&gt;请注册&lt;/h3&gt;&lt;form method=&quot;post&quot; action=&quot;/user/regist&quot; onsubmit=&quot;return checkForm()&quot;&gt; &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入账号&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;usernameInput&quot; type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkUsername()&quot;&gt; &lt;span id=&quot;usernameMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;userPwdInput&quot; type=&quot;password&quot; name=&quot;userPwd&quot; onblur=&quot;checkUserPwd()&quot;&gt; &lt;span id=&quot;userPwdMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;确认密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;reUserPwdInput&quot; type=&quot;password&quot; onblur=&quot;checkReUserPwd()&quot;&gt; &lt;span id=&quot;reUserPwdMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;&lt;a href=&quot;/login.html&quot;&gt;去登录&lt;/a&gt;&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 服务端代码处理 添加公共的JSON数据响应格式类 1234567891011121314151617181920212223242526272829package com.atguigu.schedule.common;/** * 业务含义和状态码对应关系的枚举 * */public enum ResultCodeEnum &#123; SUCCESS(200,&quot;success&quot;), USERNAME_ERROR(501,&quot;usernameError&quot;), PASSWORD_ERROR(503,&quot;passwordError&quot;), NOTLOGIN(504,&quot;notLogin&quot;), USERNAME_USED(505,&quot;userNameUsed&quot;) ; private Integer code; private String message; private ResultCodeEnum(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.atguigu.schedule.common;/** * 全局统一响应的JSON格式处理类 * */public class Result&lt;T&gt; &#123; // 返回码 private Integer code; // 返回消息 private String message; // 返回数据 private T data; public Result()&#123;&#125; // 返回数据 protected static &lt;T&gt; Result&lt;T&gt; build(T data) &#123; Result&lt;T&gt; result = new Result&lt;T&gt;(); if (data != null) result.setData(data); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(T body, Integer code, String message) &#123; Result&lt;T&gt; result = build(body); result.setCode(code); result.setMessage(message); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(T body, ResultCodeEnum resultCodeEnum) &#123; Result&lt;T&gt; result = build(body); result.setCode(resultCodeEnum.getCode()); result.setMessage(resultCodeEnum.getMessage()); return result; &#125; /** * 操作成功 * @param data baseCategory1List * @param &lt;T&gt; * @return */ public static&lt;T&gt; Result&lt;T&gt; ok(T data)&#123; Result&lt;T&gt; result = build(data); return build(data, ResultCodeEnum.SUCCESS); &#125; public Result&lt;T&gt; message(String msg)&#123; this.setMessage(msg); return this; &#125; public Result&lt;T&gt; code(Integer code)&#123; this.setCode(code); return this; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 增加Jackson依赖 添加WEBUtil工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.atguigu.schedule.util;import com.atguigu.schedule.common.Result;import com.fasterxml.jackson.databind.ObjectMapper;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.text.SimpleDateFormat;public class WebUtil &#123; private static ObjectMapper objectMapper; // 初始化objectMapper static&#123; objectMapper=new ObjectMapper(); // 设置JSON和Object转换时的时间日期格式 objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)); &#125; // 从请求中获取JSON串并转换为Object public static &lt;T&gt; T readJson(HttpServletRequest request,Class&lt;T&gt; clazz)&#123; T t =null; BufferedReader reader = null; try &#123; reader = request.getReader(); StringBuffer buffer =new StringBuffer(); String line =null; while((line = reader.readLine())!= null)&#123; buffer.append(line); &#125; t= objectMapper.readValue(buffer.toString(),clazz); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; return t; &#125; // 将Result对象转换成JSON串并放入响应对象 public static void writeJson(HttpServletResponse response, Result result)&#123; response.setContentType(&quot;application/json;charset=UTF-8&quot;); try &#123; String json = objectMapper.writeValueAsString(result); response.getWriter().write(json); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 用户名校验业务接口代码 12345678910111213141516171819202122232425/** * SysUserController下,注册时校验用户名是否被占用的业务接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void checkUsernameUsed(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username = req.getParameter(&quot;username&quot;); SysUser registUser = userService.findByUsername(username); //封装结果对象 Result result=null; if(null ==registUser)&#123; // 未占用,创建一个code为200的对象 result= Result.ok(null); &#125;else&#123; // 占用, 创建一个结果为505的对象 result= Result.build(null, ResultCodeEnum.USERNAME_USED); &#125; // 将result对象转换成JSON并响应给客户端 WebUtil.writeJson(resp,result); &#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/categories/javaweb/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"第五章 Servlet","slug":"javaweb/05_第五章 Servlet","date":"2019-10-08T05:00:00.000Z","updated":"2024-12-02T13:17:29.037Z","comments":true,"path":"2019/10/08/javaweb/05_第五章 Servlet/","link":"","permalink":"https://protonlml.github.io/2019/10/08/javaweb/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20Servlet/","excerpt":"","text":"第五章 Servlet一 Servlet简介1.1 动态资源和静态资源 静态资源 无需在程序运行时通过代码运行生成的资源,在程序运行之前就写好的资源. 例如:html css js img ,音频文件和视频文件 动态资源 需要在程序运行时通过代码运行生成的资源,在程序运行之前无法确定的数据,运行时动态生成,例如Servlet,Thymeleaf … … 动态资源指的不是视图上的动画效果或者是简单的人机交互效果 生活举例 去蛋糕店买蛋糕 直接买柜台上已经做好的 : 静态资源 和柜员说要求后现场制作 : 动态资源 1.2 Servlet简介 Servlet (server applet) 是运行在服务端(tomcat)的Java小程序，是sun公司提供一套定义动态资源规范; 从代码层面上来讲Servlet就是一个接口 用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。我们可以把Servlet称为Web应用中的控制器 不是所有的JAVA类都能用于处理客户端请求,能处理客户端请求并做出响应的一套技术标准就是Servlet Servlet是运行在服务端的,所以 Servlet必须在WEB项目中开发且在Tomcat这样的服务容器中运行 请求响应与HttpServletRequest和HttpServletResponse之间的对应关系 二 Servlet开发流程2.1 目标 校验注册时,用户名是否被占用. 通过客户端向一个Servlet发送请求,携带username,如果用户名是’atguigu’,则向客户端响应 NO,如果是其他,响应YES 2.2 开发过程 步骤1 开发一个web类型的module 过程参照之前 步骤2 开发一个UserServlet 1234567891011121314public class UserServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求中的参数 String username = req.getParameter(&quot;username&quot;); if(&quot;atguigu&quot;.equals(username))&#123; //通过响应对象响应信息 resp.getWriter().write(&quot;NO&quot;); &#125;else&#123; resp.getWriter().write(&quot;YES&quot;); &#125; &#125;&#125; 自定义一个类,要继承HttpServlet类 重写service方法,该方法主要就是用于处理用户请求的服务方法 HttpServletRequest 代表请求对象,是有请求报文经过tomcat转换而来的,通过该对象可以获取请求中的信息 HttpServletResponse 代表响应对象,该对象会被tomcat转换为响应的报文,通过该对象可以设置响应中的信息 Servlet对象的生命周期(创建,初始化,处理服务,销毁)是由tomcat管理的,无需我们自己new HttpServletRequest HttpServletResponse 两个对象也是有tomcat负责转换,在调用service方法时传入给我们用的 步骤3 在web.xml为UseServlet配置请求的映射路径 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot;&gt; &lt;servlet&gt; &lt;!--给UserServlet起一个别名--&gt; &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.UserServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!--关联别名和映射路径--&gt; &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt; &lt;!--可以为一个Servlet匹配多个不同的映射路径,但是不同的Servlet不能使用相同的url-pattern--&gt; &lt;url-pattern&gt;/userServlet&lt;/url-pattern&gt; &lt;!-- &lt;url-pattern&gt;/userServlet2&lt;/url-pattern&gt;--&gt; &lt;!-- / 表示通配所有资源,不包括jsp文件 /* 表示通配所有资源,包括jsp文件 /a/* 匹配所有以a前缀的映射路径 *.action 匹配所有以action为后缀的映射路径 --&gt; &lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Servlet并不是文件系统中实际存在的文件或者目录,所以为了能够请求到该资源,我们需要为其配置映射路径 servlet的请求映射路径配置在web.xml中 servlet-name作为servlet的别名,可以自己随意定义,见名知意就好 url-pattern标签用于定义Servlet的请求映射路径 一个servlet可以对应多个不同的url-pattern 多个servlet不能使用相同的url-pattern url-pattern中可以使用一些通配写法 &#x2F; 表示通配所有资源,不包括jsp文件 &#x2F;* 表示通配所有资源,包括jsp文件 &#x2F;a&#x2F;* 匹配所有以a前缀的映射路径 *.action 匹配所有以action为后缀的映射路径 步骤4 开发一个form表单,向servlet发送一个get请求并携带username参数 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;userServlet&quot;&gt; 请输入用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;校验&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 启动项目,访问index.html ,提交表单测试 使用debug模式运行测试 映射关系图 三 Servlet注解方式配置3.1 @WebServlet注解源码 官方JAVAEEAPI文档下载地址 Java EE - Technologies (oracle.com) @WebServlet注解的源码阅读 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package jakarta.servlet.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @since Servlet 3.0 */@Target(&#123; ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet &#123; /** * The name of the servlet * 相当于 servlet-name * @return the name of the servlet */ String name() default &quot;&quot;; /** * The URL patterns of the servlet * 如果只配置一个url-pattern ,则通过该属性即可,和urlPatterns属性互斥 * @return the URL patterns of the servlet */ String[] value() default &#123;&#125;; /** * The URL patterns of the servlet * 如果要配置多个url-pattern ,需要通过该属性,和value属性互斥 * @return the URL patterns of the servlet */ String[] urlPatterns() default &#123;&#125;; /** * The load-on-startup order of the servlet * 配置Servlet是否在项目加载时实例化 * @return the load-on-startup order of the servlet */ int loadOnStartup() default -1; /** * The init parameters of the servlet * 配置初始化参数 * @return the init parameters of the servlet */ WebInitParam[] initParams() default &#123;&#125;; /** * Declares whether the servlet supports asynchronous operation mode. * * @return &#123;@code true&#125; if the servlet supports asynchronous operation mode * @see jakarta.servlet.ServletRequest#startAsync * @see jakarta.servlet.ServletRequest#startAsync( jakarta.servlet.ServletRequest,jakarta.servlet.ServletResponse) */ boolean asyncSupported() default false; /** * The small-icon of the servlet * * @return the small-icon of the servlet */ String smallIcon() default &quot;&quot;; /** * The large-icon of the servlet * * @return the large-icon of the servlet */ String largeIcon() default &quot;&quot;; /** * The description of the servlet * * @return the description of the servlet */ String description() default &quot;&quot;; /** * The display name of the servlet * * @return the display name of the servlet */ String displayName() default &quot;&quot;;&#125; 3.2 @WebServlet注解使用 使用@WebServlet注解替换Servlet配置 12345678910111213141516171819202122@WebServlet( name = &quot;userServlet&quot;, //value = &quot;/user&quot;, urlPatterns = &#123;&quot;/userServlet1&quot;,&quot;/userServlet2&quot;,&quot;/userServlet&quot;&#125;, initParams = &#123;@WebInitParam(name = &quot;encoding&quot;,value = &quot;UTF-8&quot;)&#125;, loadOnStartup = 6)public class UserServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String encoding = getServletConfig().getInitParameter(&quot;encoding&quot;); System.out.println(encoding); // 获取请求中的参数 String username = req.getParameter(&quot;username&quot;); if(&quot;atguigu&quot;.equals(username))&#123; //通过响应对象响应信息 resp.getWriter().write(&quot;NO&quot;); &#125;else&#123; resp.getWriter().write(&quot;YES&quot;); &#125; &#125;&#125; 四 Servlet生命周期4.1 生命周期简介 什么是Servlet的生命周期 应用程序中的对象不仅在空间上有层次结构的关系，在时间上也会因为处于程序运行过程中的不同阶段而表现出不同状态和不同行为——这就是对象的生命周期。 简单的叙述生命周期，就是对象在容器中从开始创建到销毁的过程。 Servlet容器 Servlet对象是Servlet容器创建的，生命周期方法都是由容器(目前我们使用的是Tomcat)调用的。这一点和我们之前所编写的代码有很大不同。在今后的学习中我们会看到，越来越多的对象交给容器或框架来创建，越来越多的方法由容器或框架来调用，开发人员要尽可能多的将精力放在业务逻辑的实现上。 Servlet主要的生命周期执行特点 生命周期 对应方法 执行时机 执行次数 构造对象 构造器 第一次请求或者容器启动 1 初始化 init() 构造完毕后 1 处理服务 service(HttpServletRequest req,HttpServletResponse resp) 每次请求 多次 销毁 destory() 容器关闭 1 4.2 生命周期测试 开发servlet代码 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class ServletLifeCycle extends HttpServlet &#123; public ServletLifeCycle()&#123; System.out.println(&quot;构造器&quot;); &#125; @Override public void init() throws ServletException &#123; System.out.println(&quot;初始化方法&quot;); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;service方法&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;销毁方法&quot;); &#125;&#125; 配置Servlet 1234567891011121314 &lt;servlet&gt; &lt;servlet-name&gt;servletLifeCycle&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.ServletLifeCycle&lt;/servlet-class&gt; &lt;!--load-on-startup 如果配置的是正整数则表示容器在启动时就要实例化Servlet, 数字表示的是实例化的顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;servletLifeCycle&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletLiftCycle&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 请求Servlet测试 略 4.3 生命周期总结 通过生命周期测试我们发现Servlet对象在容器中是单例的 容器是可以处理并发的用户请求的,每个请求在容器中都会开启一个线程 多个线程可能会使用相同的Servlet对象,所以在Servlet中,我们不要轻易定义一些容易经常发生修改的成员变量 load-on-startup中定义的正整数表示实例化顺序,如果数字重复了,容器会自行解决实例化顺序问题,但是应该避免重复 Tomcat容器中,已经定义了一些随系统启动实例化的servlet,我们自定义的servlet的load-on-startup尽量不要占用数字1-5 五 Servlet继承结构5.1 Servlet 接口 源码及功能解释 通过idea查看: 此处略 接口及方法说明 Servlet 规范接口,所有的Servlet必须实现 public void init(ServletConfig config) throws ServletException; 初始化方法,容器在构造servlet对象后,自动调用的方法,容器负责实例化一个ServletConfig对象,并在调用该方法时传入 ServletConfig对象可以为Servlet 提供初始化参数 public ServletConfig getServletConfig(); 获取ServletConfig对象的方法,后续可以通过该对象获取Servlet初始化参数 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; 处理请求并做出响应的服务方法,每次请求产生时由容器调用 容器创建一个ServletRequest对象和ServletResponse对象,容器在调用service方法时,传入这两个对象 public String getServletInfo(); 获取ServletInfo信息的方法 public void destroy(); Servlet实例在销毁之前调用的方法 5.2 GenericServlet 抽象类 源码 通过idea查看: 此处略 源码解释 GenericServlet 抽象类是对Servlet接口一些固定功能的粗糙实现,以及对service方法的再次抽象声明,并定义了一些其他相关功能方法 private transient ServletConfig config; 初始化配置对象作为属性 public GenericServlet() { } 构造器,为了满足继承而准备 public void destroy() { } 销毁方法的平庸实现 public String getInitParameter(String name) 获取初始参数的快捷方法 public Enumeration getInitParameterNames() 返回所有初始化参数名的方法 public ServletConfig getServletConfig() 获取初始Servlet初始配置对象ServletConfig的方法 public ServletContext getServletContext() 获取上下文对象ServletContext的方法 public String getServletInfo() 获取Servlet信息的平庸实现 public void init(ServletConfig config) throws ServletException() 初始化方法的实现,并在此调用了init的重载方法 public void init() throws ServletException 重载init方法,为了让我们自己定义初始化功能的方法 public void log(String msg) public void log(String message, Throwable t) 打印日志的方法及重载 public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; 服务方法再次声明 public String getServletName() 获取ServletName的方法 5.3 HttpServlet 抽象类 源码 通过idea查看: 此处略 解释 abstract class HttpServlet extends GenericServlet HttpServlet抽象类,除了基本的实现以外,增加了更多的基础功能 private static final String METHOD_DELETE &#x3D; “DELETE”; private static final String METHOD_HEAD &#x3D; “HEAD”; private static final String METHOD_GET &#x3D; “GET”; private static final String METHOD_OPTIONS &#x3D; “OPTIONS”; private static final String METHOD_POST &#x3D; “POST”; private static final String METHOD_PUT &#x3D; “PUT”; private static final String METHOD_TRACE &#x3D; “TRACE”; 上述属性用于定义常见请求方式名常量值 public HttpServlet() {} 构造器,用于处理继承 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException 对服务方法的实现 在该方法中,将请求和响应对象转换成对应HTTP协议的HttpServletRequest HttpServletResponse对象 调用重载的service方法 public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException 重载的service方法,被重写的service方法所调用 在该方法中,通过请求方式判断,调用具体的do***方法完成请求的处理 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException 对应不同请求方式的处理方法 除了doOptions和doTrace方法,其他的do*** 方法都在故意响应错误信息 5.4 自定义Servlet 继承关系图解 自定义Servlet中,必须要对处理请求的方法进行重写 要么重写service方法 要么重写doGet&#x2F;doPost方法 六 ServletConfig和ServletContext6.1 ServletConfig的使用 ServletConfig是什么 为Servlet提供初始配置参数的一种对象,每个Servlet都有自己独立唯一的ServletConfig对象 容器会为每个Servlet实例化一个ServletConfig对象,并通过Servlet生命周期的init方法传入给Servlet作为属性 ServletConfig是一个接口,定义了如下API 12345678package jakarta.servlet;import java.util.Enumeration;public interface ServletConfig &#123; String getServletName(); ServletContext getServletContext(); String getInitParameter(String var1); Enumeration&lt;String&gt; getInitParameterNames();&#125; 方法名 作用 getServletName() 获取&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;定义的Servlet名称 getServletContext() 获取ServletContext对象 getInitParameter() 获取配置Servlet时设置的『初始化参数』，根据名字获取值 getInitParameterNames() 获取所有初始化参数名组成的Enumeration对象 ServletConfig怎么用,测试代码如下 定义Servlet 1234567891011121314151617181920212223242526272829303132333435public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletConfig servletConfig = this.getServletConfig(); // 根据参数名获取单个参数 String value = servletConfig.getInitParameter(&quot;param1&quot;); System.out.println(&quot;param1:&quot;+value); // 获取所有参数名 Enumeration&lt;String&gt; parameterNames = servletConfig.getInitParameterNames(); // 迭代并获取参数名 while (parameterNames.hasMoreElements()) &#123; String paramaterName = parameterNames.nextElement(); System.out.println(paramaterName+&quot;:&quot;+servletConfig.getInitParameter(paramaterName)); &#125; &#125;&#125;public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletConfig servletConfig = this.getServletConfig(); // 根据参数名获取单个参数 String value = servletConfig.getInitParameter(&quot;param1&quot;); System.out.println(&quot;param1:&quot;+value); // 获取所有参数名 Enumeration&lt;String&gt; parameterNames = servletConfig.getInitParameterNames(); // 迭代并获取参数名 while (parameterNames.hasMoreElements()) &#123; String paramaterName = parameterNames.nextElement(); System.out.println(paramaterName+&quot;:&quot;+servletConfig.getInitParameter(paramaterName)); &#125; &#125;&#125; 配置Servlet 12345678910111213141516171819202122232425262728293031323334353637&lt;servlet&gt; &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.ServletA&lt;/servlet-class&gt; &lt;!--配置ServletA的初始参数--&gt; &lt;init-param&gt; &lt;param-name&gt;param1&lt;/param-name&gt; &lt;param-value&gt;value1&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;param2&lt;/param-name&gt; &lt;param-value&gt;value2&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServletB&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.ServletB&lt;/servlet-class&gt; &lt;!--配置ServletB的初始参数--&gt; &lt;init-param&gt; &lt;param-name&gt;param3&lt;/param-name&gt; &lt;param-value&gt;value3&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;param4&lt;/param-name&gt; &lt;param-value&gt;value4&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletA&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletB&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletB&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 请求Servlet测试 略 6.2 ServletContext的使用 ServletContext是什么 ServletContext对象有称呼为上下文对象,或者叫应用域对象(后面统一讲解域对象) 容器会为每个app创建一个独立的唯一的ServletContext对象 ServletContext对象为所有的Servlet所共享 ServletContext可以为所有的Servlet提供初始配置参数 ServletContext怎么用 配置ServletContext参数 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;paramA&lt;/param-name&gt; &lt;param-value&gt;valueA&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;paramB&lt;/param-name&gt; &lt;param-value&gt;valueB&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 在Servlet中获取ServletContext并获取参数 1234567891011121314151617181920212223242526272829package com.atguigu.servlet;import jakarta.servlet.ServletConfig;import jakarta.servlet.ServletContext;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 从ServletContext中获取为所有的Servlet准备的参数 ServletContext servletContext = this.getServletContext(); String valueA = servletContext.getInitParameter(&quot;paramA&quot;); System.out.println(&quot;paramA:&quot;+valueA); // 获取所有参数名 Enumeration&lt;String&gt; initParameterNames = servletContext.getInitParameterNames(); // 迭代并获取参数名 while (initParameterNames.hasMoreElements()) &#123; String paramaterName = initParameterNames.nextElement(); System.out.println(paramaterName+&quot;:&quot;+servletContext.getInitParameter(paramaterName)); &#125; &#125;&#125; 6.3 ServletContext其他重要API 获取资源的真实路径 1String realPath = servletContext.getRealPath(&quot;资源在web目录中的路径&quot;); 例如我们的目标是需要获取项目中某个静态资源的路径，不是工程目录中的路径，而是部署目录中的路径；我们如果直接拷贝其在我们电脑中的完整路径的话其实是有问题的，因为如果该项目以后部署到公司服务器上的话，路径肯定是会发生改变的，所以我们需要使用代码动态获取资源的真实路径. 只要使用了servletContext动态获取资源的真实路径，那么无论项目的部署路径发生什么变化，都会动态获取项目运行时候的实际路径，所以就不会发生由于写死真实路径而导致项目部署位置改变引发的路径错误问题 获取项目的上下文路径 1String contextPath = servletContext.getContextPath(); 项目的部署名称,也叫项目的上下文路径,在部署进入tomcat时所使用的路径,该路径是可能发生变化的,通过该API动态获取项目真实的上下文路径,可以帮助我们解决一些后端页面渲染技术或者请求转发和响应重定向中的路径问题 域对象的相关API 域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同 ServletContext代表应用,所以ServletContext域也叫作应用域,是webapp中最大的域,可以在本应用内实现数据的共享和传递 webapp中的三大域对象,分别是应用域,会话域,请求域 后续我们会将三大域对象统一进行讲解和演示,三大域对象都具有的API如下 API 功能解释 void setAttribute(String key,Object value); 向域中存储&#x2F;修改数据 Object getAttribute(String key); 获得域中的数据 void removeAttribute(String key); 移除域中的数据 七 HttpServletRequest7.1 HttpServletRequest简介 HttpServletRequest是什么 HttpServletRequest是一个接口,其父接口是ServletRequest HttpServletRequest是Tomcat将请求报文转换封装而来的对象,在Tomcat调用service方法时传入 HttpServletRequest代表客户端发来的请求,所有请求中的信息都可以通过该对象获得 7.2 HttpServletRequest常见API HttpServletRequest怎么用 获取请求行信息相关(方式,请求的url,协议及版本) API 功能解释 StringBuffer getRequestURL(); 获取客户端请求的url String getRequestURI(); 获取客户端请求项目中的具体资源 int getServerPort(); 获取客户端发送请求时的端口 int getLocalPort(); 获取本应用在所在容器的端口 int getRemotePort(); 获取客户端程序的端口 String getScheme(); 获取请求协议 String getProtocol(); 获取请求协议及版本号 String getMethod(); 获取请求方式 获得请求头信息相关 API 功能解释 String getHeader(String headerName); 根据头名称获取请求头 Enumeration getHeaderNames(); 获取所有的请求头名字 String getContentType(); 获取content-type请求头 获得请求参数相关 API 功能解释 String getParameter(String parameterName); 根据请求参数名获取请求单个参数值 String[] getParameterValues(String parameterName); 根据请求参数名获取请求多个参数值数组 Enumeration getParameterNames(); 获取所有请求参数名 Map&lt;String, String[]&gt; getParameterMap(); 获取所有请求参数的键值对集合 BufferedReader getReader() throws IOException; 获取读取请求体的字符输入流 ServletInputStream getInputStream() throws IOException; 获取读取请求体的字节输入流 int getContentLength(); 获得请求体长度的字节数 其他API API 功能解释 String getServletPath(); 获取请求的Servlet的映射路径 ServletContext getServletContext(); 获取ServletContext对象 Cookie[] getCookies(); 获取请求中的所有cookie HttpSession getSession(); 获取Session对象 void setCharacterEncoding(String encoding) ; 设置请求体字符集 八 HttpServletResponse8.1 HttpServletResponse简介 HttpServletResponse是什么 HttpServletResponse是一个接口,其父接口是ServletResponse HttpServletResponse是Tomcat预先创建的,在Tomcat调用service方法时传入 HttpServletResponse代表对客户端的响应,该对象会被转换成响应的报文发送给客户端,通过该对象我们可以设置响应信息 8.2 HttpServletResponse的常见API HttpServletRequest怎么用 设置响应行相关 API 功能解释 void setStatus(int code); 设置响应状态码 设置响应头相关 API 功能解释 void setHeader(String headerName, String headerValue); 设置&#x2F;修改响应头键值对 void setContentType(String contentType); 设置content-type响应头及响应字符集(设置MIME类型) 设置响应体相关 API 功能解释 PrintWriter getWriter() throws IOException; 获得向响应体放入信息的字符输出流 ServletOutputStream getOutputStream() throws IOException; 获得向响应体放入信息的字节输出流 void setContentLength(int length); 设置响应体的字节长度,其实就是在设置content-length响应头 其他API API 功能解释 void sendError(int code, String message) throws IOException; 向客户端响应错误信息的方法,需要指定响应码和响应信息 void addCookie(Cookie cookie); 向响应体中增加cookie void setCharacterEncoding(String encoding); 设置响应体字符集 MIME类型 MIME类型,可以理解为文档类型,用户表示传递的数据是属于什么类型的文档 浏览器可以根据MIME类型决定该用什么样的方式解析接收到的响应体数据 可以这样理解: 前后端交互数据时,告诉对方发给对方的是 html&#x2F;css&#x2F;js&#x2F;图片&#x2F;声音&#x2F;视频&#x2F;… … tomcat&#x2F;conf&#x2F;web.xml中配置了常见文件的拓展名和MIMIE类型的对应关系 常见的MIME类型举例如下 文件拓展名 MIME类型 .html text&#x2F;html .css text&#x2F;css .js application&#x2F;javascript .png &#x2F;.jpeg&#x2F;.jpg&#x2F;… … image&#x2F;jpeg .mp3&#x2F;.mpe&#x2F;.mpeg&#x2F; … … audio&#x2F;mpeg .mp4 video&#x2F;mp4 .m1v&#x2F;.m1v&#x2F;.m2v&#x2F;.mpe&#x2F;… … video&#x2F;mpeg 九 请求转发和响应重定向9.1 概述 什么是请求转发和响应重定向 请求转发和响应重定向是web应用中间接访问项目资源的两种手段,也是Servlet控制页面跳转的两种手段 请求转发通过HttpServletRequest实现,响应重定向通过HttpServletResponse实现 请求转发生活举例: 张三找李四借钱,李四没有,李四找王五,让王五借给张三 响应重定向生活举例:张三找李四借钱,李四没有,李四让张三去找王五,张三自己再去找王五借钱 9.2 请求转发 请求转发运行逻辑图 请求转发特点(背诵) 请求转发通过HttpServletRequest对象获取请求转发器实现 请求转发是服务器内部的行为,对客户端是屏蔽的 客户端只发送了一次请求,客户端地址栏不变 服务端只产生了一对请求和响应对象,这一对请求和响应对象会继续传递给下一个资源 因为全程只有一个HttpServletRequset对象,所以请求参数可以传递,请求域中的数据也可以传递 请求转发可以转发给其他Servlet动态资源,也可以转发给一些静态资源以实现页面跳转 请求转发可以转发给WEB-INF下受保护的资源 请求转发不能转发到本项目以外的外部资源 请求转发测试代码 ServletA 12345678910111213141516171819202122@WebServlet(&quot;/servletA&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求转发器 // 转发给servlet ok RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;servletB&quot;); // 转发给一个视图资源 ok //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;welcome.html&quot;); // 转发给WEB-INF下的资源 ok //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;); // 转发给外部资源 no //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;http://www.atguigu.com&quot;); // 获取请求参数 String username = req.getParameter(&quot;username&quot;); System.out.println(username); // 向请求域中添加数据 req.setAttribute(&quot;reqKey&quot;,&quot;requestMessage&quot;); // 做出转发动作 requestDispatcher.forward(req,resp); &#125;&#125; ServletB 1234567891011121314@WebServlet(&quot;/servletB&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求参数 String username = req.getParameter(&quot;username&quot;); System.out.println(username); // 获取请求域中的数据 String reqMessage = (String)req.getAttribute(&quot;reqKey&quot;); System.out.println(reqMessage); // 做出响应 resp.getWriter().write(&quot;servletB response&quot;); &#125;&#125; 打开浏览器,输入以下url测试 1http://localhost:8080/web03_war_exploded/servletA?username=atguigu 9.3 响应重定向 响应重定向运行逻辑图 响应重定向特点(背诵) 响应重定向通过HttpServletResponse对象的sendRedirect方法实现 响应重定向是服务端通过302响应码和路径,告诉客户端自己去找其他资源,是在服务端提示下的,客户端的行为 客户端至少发送了两次请求,客户端地址栏是要变化的 服务端产生了多对请求和响应对象,且请求和响应对象不会传递给下一个资源 因为全程产生了多个HttpServletRequset对象,所以请求参数不可以传递,请求域中的数据也不可以传递 重定向可以是其他Servlet动态资源,也可以是一些静态资源以实现页面跳转 重定向不可以到给WEB-INF下受保护的资源 重定向可以到本项目以外的外部资源 响应重定向测试代码 ServletA 123456789101112131415161718192021@WebServlet(&quot;/servletA&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求参数 String username = req.getParameter(&quot;username&quot;); System.out.println(username); // 向请求域中添加数据 req.setAttribute(&quot;reqKey&quot;,&quot;requestMessage&quot;); // 响应重定向 // 重定向到servlet动态资源 OK resp.sendRedirect(&quot;servletB&quot;); // 重定向到视图静态资源 OK //resp.sendRedirect(&quot;welcome.html&quot;); // 重定向到WEB-INF下的资源 NO //resp.sendRedirect(&quot;WEB-INF/views/view1&quot;); // 重定向到外部资源 //resp.sendRedirect(&quot;http://www.atguigu.com&quot;); &#125;&#125; ServletB 123456789101112131415@WebServlet(&quot;/servletB&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求参数 String username = req.getParameter(&quot;username&quot;); System.out.println(username); // 获取请求域中的数据 String reqMessage = (String)req.getAttribute(&quot;reqKey&quot;); System.out.println(reqMessage); // 做出响应 resp.getWriter().write(&quot;servletB response&quot;); &#125;&#125; 打开浏览器,输入以下url测试 1http://localhost:8080/web03_war_exploded/servletA?username=atguigu 十 web乱码和路径问题总结10.1 乱码问题 乱码问题产生的根本原因是什么 数据的编码和解码使用的不是同一个字符集 使用了不支持某个语言文字的字符集 各个字符集的兼容性 由上图得知,上述字符集都兼容了ASCII ASCII中有什么? 英文字母和一些通常使用的符号,所以这些东西无论使用什么字符集都不会乱码 10.1.1 HTML乱码问题 设置项目文件的字符集要使用一个支持中文的字符集 查看当前文件的字符集 查看项目字符集 配置,将Global Encoding 全局字符集,Project Encoding 项目字符集, Properties Files 属性配置文件字符集设置为UTF-8 当前视图文件的字符集通过 来告知浏览器通过什么字符集来解析当前文件 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 中文&lt;/body&gt;&lt;/html&gt; 10.1.2 Tomcat控制台乱码 在tomcat10.1.7这个版本中,修改 tomcat&#x2F;conf&#x2F;logging.properties中,所有的UTF-8为GBK即可 修改前 修改后 重启测试 sout乱码问题,设置JVM加载.class文件时使用UTF-8字符集 设置虚拟机加载.class文件的字符集和编译时使用的字符集一致 10.1.3 请求乱码问题10.1.3.1 GET请求乱码 GET请求方式乱码分析 GET方式提交参数的方式是将参数放到URL后面,如果使用的不是UTF-8,那么会对参数进行URL编码处理 HTML中的 影响了GET方式提交参数的URL编码 tomcat10.1.7的URI编码默认为 UTF-8 当GET方式提交的参数URL编码和tomcat10.1.7默认的URI编码不一致时,就会出现乱码 GET请求方式乱码演示 浏览器解析的文档的 GET方式提交时,会对数据进行URL编码处理 ,是将GBK 转码为 “百分号码” tomcat10.1.7 默认使用UTF-8对URI进行解析,造成前后端使用的字符集不一致,出现乱码 GET请求方式乱码解决 方式1 :设置GET方式提交的编码和Tomcat10.1.7的URI默认解析编码一致即可 (推荐) 方式2 : 设置Tomcat10.1.7的URI解析字符集和GET请求发送时所使用URL转码时的字符集一致即可,修改conf&#x2F;server.xml中 Connecter 添加 URIEncoding&#x3D;”GBK” (不推荐) 10.1.3.2 POST方式请求乱码 POST请求方式乱码分析 POST请求将参数放在请求体中进行发送 请求体使用的字符集受到了 的影响 Tomcat10.1.7 默认使用UTF-8字符集对请求体进行解析 如果请求体的URL转码和Tomcat的请求体解析编码不一致,就容易出现乱码 POST方式乱码演示 POST请求请求体受到了 的影响 请求体中,将GBK数据进行 URL编码 后端默认使用UTF-8解析请求体,出现字符集不一致,导致乱码 POST请求方式乱码解决 方式1 : 请求时,使用UTF-8字符集提交请求体 (推荐) 方式2 : 后端在获取参数前,设置解析请求体使用的字符集和请求发送时使用的字符集一致 (不推荐) 10.1.3 响应乱码问题 响应乱码分析 在Tomcat10.1.7中,向响应体中放入的数据默认使用了工程编码 UTF-8 浏览器在接收响应信息时,使用了不同的字符集或者是不支持中文的字符集就会出现乱码 响应乱码演示 服务端通过response对象向响应体添加数据 浏览器接收数据解析乱码 响应乱码解决 方式1 : 手动设定浏览器对本次响应体解析时使用的字符集(不推荐) edge和 chrome浏览器没有提供直接的比较方便的入口,不方便 方式2: 后端通过设置响应体的字符集和浏览器解析响应体的默认字符集一致(不推荐) 方式3: 通过设置content-type响应头,告诉浏览器以指定的字符集解析响应体(推荐) 10.2 路径问题 相对路径和绝对路径 相对路径 相对路径的规则是: 以当前资源所在的路径为出发点去寻找目标资源 相对路径不以 &#x2F; 开头 在file协议下,使用的是磁盘路径 在http协议下,使用的是url路径 相对路径中可以使用 .&#x2F;表示当前资源所在路径,可以省略不写 相对路径中可以使用..&#x2F;表示当前资源所在路径的上一层路径,需要时要手动添加 绝对路径 绝对路径的规则是: 使用以一个固定的路径做出出发点去寻找目标资源,和当前资源所在的路径没有关系 绝对路径要以&#x2F; 开头 绝对路径的写法中,不以当前资源的所在路径为出发点,所以不会出现 .&#x2F; 和..&#x2F; 不同的项目和不同的协议下,绝对路径的基础位置可能不同,要通过测试确定 绝对路径的好处就是:无论当前资源位置在哪,寻找目标资源路径的写法都一致 应用场景 前端代码中,href src action 等属性 请求转发和重定向中的路径 10.2.1 前端路径问题 前端项目结构 10.2.1.1 相对路径情况分析 相对路径情况1:web&#x2F;index.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png 访问index.html的url为 : http://localhost:8080/web03_war_exploded/index.html 当前资源为 : index.html 当前资源的所在路径为 : http://localhost:8080/web03_war_exploded/ 要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/static/img/logo.png index.html中定义的了 : &lt;img src=&quot;static/img/logo.png&quot;/&gt; 寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/)后拼接src属性值(static/img/logo.png),正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/static/img/logo.png) 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;static/img/logo.png&quot;&gt;&lt;/body&gt;&lt;/html&gt; 相对路径情况2:web&#x2F;a&#x2F;b&#x2F;c&#x2F;test.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png 访问test.html的url为 : http://localhost:8080/web03_war_exploded/a/b/c/test.html 当前资源为 : test.html 当前资源的所在路径为 : http://localhost:8080/web03_war_exploded/a/b/c/ 要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/static/img/logo.png test.html中定义的了 : &lt;img src=&quot;../../../static/img/logo.png&quot;/&gt; 寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/a/b/c/)后拼接src属性值(../../../static/img/logo.png),其中 ..&#x2F;可以抵消一层路径,正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/static/img/logo.png) 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ../代表上一层路径 --&gt; &lt;img src=&quot;../../../static/img/logo.png&quot;&gt;&lt;/body&gt;&lt;/html&gt; 相对路径情况3:web&#x2F;WEB-INF&#x2F;views&#x2F;view1.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png view1.html在WEB-INF下,需要通过Servlet请求转发获得 12345678@WebServlet(&quot;/view1Servlet&quot;)public class View1Servlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;); requestDispatcher.forward(req,resp); &#125;&#125; 访问view1.html的url为 : http://localhost:8080/web03_war_exploded/view1Servlet 当前资源为 : view1Servlet 当前资源的所在路径为 : http://localhost:8080/web03_war_exploded/ 要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/static/img/logo.png view1.html中定义的了 : &lt;img src=&quot;static/img/logo.png&quot;/&gt; 寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/)后拼接src属性值(static/img/logo.png),正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/static/img/logo.png) 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;static/img/logo.png&quot;&gt;&lt;/body&gt;&lt;/html&gt; 10.2.1.2 绝对路径情况分析 绝对路径情况1:web&#x2F;index.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png 访问index.html的url为 : http://localhost:8080/web03_war_exploded/index.html 绝对路径的基准路径为 : http://localhost:8080 要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/static/img/logo.png index.html中定义的了 : &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;/&gt; 寻找方式就是在基准路径(http://localhost:8080)后面拼接src属性值(/web03_war_exploded/static/img/logo.png),得到的正是目标资源访问的正确路径 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 绝对路径写法 --&gt; &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;&gt;&lt;/body&gt;&lt;/html&gt; 绝对路径情况2:web&#x2F;a&#x2F;b&#x2F;c&#x2F;test.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png 访问test.html的url为 : http://localhost:8080/web03_war_exploded/a/b/c/test.html 绝对路径的基准路径为 : http://localhost:8080 要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/static/img/logo.png test.html中定义的了 : &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;/&gt; 寻找方式就是在基准路径(http://localhost:8080)后面拼接src属性值(/web03_war_exploded/static/img/logo.png),得到的正是目标资源访问的正确路径 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 绝对路径写法 --&gt; &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;&gt;&lt;/body&gt;&lt;/html&gt; 绝对路径情况3:web&#x2F;WEB-INF&#x2F;views&#x2F;view1.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png view1.html在WEB-INF下,需要通过Servlet请求转发获得 12345678@WebServlet(&quot;/view1Servlet&quot;)public class View1Servlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;); requestDispatcher.forward(req,resp); &#125;&#125; 访问view1.html的url为 : http://localhost:8080/web03_war_exploded/view1Servlet 绝对路径的基准路径为 : http://localhost:8080 要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/static/img/logo.png view1.html中定义的了 : &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;/&gt; 寻找方式就是在基准路径(http://localhost:8080)后面拼接src属性值(/static/img/logo.png),得到的正是目标资源访问的正确路径 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;&gt;&lt;/body&gt;&lt;/html&gt; 10.2.1.3 base标签的使用 base标签定义页面相对路径公共前缀 base 标签定义在head标签中,用于定义相对路径的公共前缀 base 标签定义的公共前缀只在相对路径上有效,绝对路径中无效 如果相对路径开头有 .&#x2F; 或者..&#x2F;修饰,则base标签对该路径同样无效 index.html 和a&#x2F;b&#x2F;c&#x2F;test.html 以及view1Servlet 中的路径处理 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--定义相对路径的公共前缀,将相对路径转化成了绝对路径--&gt; &lt;base href=&quot;/web03_war_exploded/&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;static/img/logo.png&quot;&gt;&lt;/body&gt;&lt;/html&gt; 10.2.1.4 缺省项目上下文路径 项目上下文路径变化问题 通过 base标签虽然解决了相对路径转绝对路径问题,但是base中定义的是项目的上下文路径 项目的上下文路径是可以随意变化的 一旦项目的上下文路径发生变化,所有base标签中的路径都需要改 解决方案 将项目的上下文路径进行缺省设置,设置为 &#x2F;,所有的绝对路径中就不必填写项目的上下文了,直接就是&#x2F;开头即可 10.2.2 重定向中的路径问题 目标 :由&#x2F;x&#x2F;y&#x2F;z&#x2F;servletA重定向到a&#x2F;b&#x2F;c&#x2F;test.html 12345678@WebServlet(&quot;/x/y/z/servletA&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; 10.2.2.1相对路径写法 访问ServletA的url为 : http://localhost:8080/web03_war_exploded/x/y/z/servletA 当前资源为 : servletA 当前资源的所在路径为 : http://localhost:8080/web03_war_exploded/x/x/z/ 要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/a/b/c/test.html ServletA重定向的路径 : ..&#x2F;..&#x2F;..&#x2F;a&#x2F;b&#x2F;c&#x2F;test&#x2F;html 寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/x/y/z/)后拼接(../../../a/b/c/test/html),形成(http://localhost:8080/web03_war_exploded/x/y/z/../../../a/b/c/test/html)每个../抵消一层目录,正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/a/b/c/test/html) 12345678@WebServlet(&quot;/x/y/z/servletA&quot;)public class ServletA extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 相对路径重定向到test.html resp.sendRedirect(&quot;../../../a/b/c/test.html&quot;); &#125;&#125; 10.2.2.2绝对路径写法 访问ServletA的url为 : http://localhost:8080/web03_war_exploded/x/y/z/servletA 绝对路径的基准路径为 : http://localhost:8080 要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/a/b/c/test.html ServletA重定向的路径 : &#x2F;web03_war_exploded&#x2F;a&#x2F;b&#x2F;c&#x2F;test.html 寻找方式就是在基准路径(http://localhost:8080)后面拼接(/web03_war_exploded/a/b/c/test.html),得到( http://localhost:8080/web03_war_exploded/a/b/c/test.html)正是目标资源访问的正确路径 绝对路径中需要填写项目上下文路径,但是上下文路径是变换的 可以通过 ServletContext的getContextPath()获取上下文路径 可以将项目上下文路径定义为 &#x2F; 缺省路径,那么路径中直接以&#x2F;开头即可 123456//绝对路径中,要写项目上下文路径//resp.sendRedirect(&quot;/web03_war_exploded/a/b/c/test.html&quot;);// 通过ServletContext对象动态获取项目上下文路径//resp.sendRedirect(getServletContext().getContextPath()+&quot;/a/b/c/test.html&quot;);// 缺省项目上下文路径时,直接以/开头即可resp.sendRedirect(&quot;/a/b/c/test.html&quot;); 10.2.3 请求转发中的路径问题 目标 :由x&#x2F;y&#x2F;servletB请求转发到a&#x2F;b&#x2F;c&#x2F;test.html 1234567@WebServlet(&quot;/x/y/servletB&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#125;&#125; 10.2.3.1 相对路径写法 访问ServletB的url为 : http://localhost:8080/web03_war_exploded/x/y/servletB 当前资源为 : servletB 当前资源的所在路径为 : http://localhost:8080/web03_war_exploded/x/x/ 要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/a/b/c/test.html ServletA请求转发路径 : ..&#x2F;..&#x2F;a&#x2F;b&#x2F;c&#x2F;test&#x2F;html 寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/x/y/)后拼接(../../a/b/c/test/html),形成(http://localhost:8080/web03_war_exploded/x/y/../../a/b/c/test/html)每个../抵消一层目录,正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/a/b/c/test/html) 12345678910@WebServlet(&quot;/x/y/servletB&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;../../a/b/c/test.html&quot;); requestDispatcher.forward(req,resp); &#125;&#125; 10.2.3.2绝对路径写法 请求转发只能转发到项目内部的资源,其绝对路径无需添加项目上下文路径 请求转发绝对路径的基准路径相当于http://localhost:8080/web03_war_exploded 在项目上下文路径为缺省值时,也无需改变,直接以&#x2F;开头即可 12345678@WebServlet(&quot;/x/y/servletB&quot;)public class ServletB extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/a/b/c/test.html&quot;); requestDispatcher.forward(req,resp); &#125;&#125; 10.2.3.3目标资源内相对路径处理 此时需要注意,请求转发是服务器行为,浏览器不知道,地址栏不变化,相当于我们访问test.html的路径为http://localhost:8080/web03_war_exploded/x/y/servletB 那么此时 test.html资源的所在路径就是http://localhost:8080/web03_war_exploded/x/y/所以test.html中相对路径要基于该路径编写,如果使用绝对路径则不用考虑 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 当前资源路径是 http://localhost:8080/web03_war_exploded/x/y/servletB 当前资源所在路径是 http://localhost:8080/web03_war_exploded/x/y/ 目标资源路径=所在资源路径+src属性值 http://localhost:8080/web03_war_exploded/x/y/../../static/img/logo.png http://localhost:8080/web03_war_exploded/static/img/logo.png 得到目标路径正是目标资源的访问路径 --&gt;&lt;img src=&quot;../../static/img/logo.png&quot;&gt;&lt;/body&gt;&lt;/html&gt; 十一 MVC架构模式 MVC（Model View Controller）是软件工程中的一种**软件架构模式，它把软件系统分为模型、视图和控制器**三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 M：Model 模型层,具体功能如下 存放和数据库对象的实体类以及一些用于存储非数据库表完整相关的VO对象 存放一些对数据进行逻辑运算操作的的一些业务处理代码 V：View 视图层,具体功能如下 存放一些视图文件相关的代码 html css js等 在前后端分离的项目中,后端已经没有视图文件,该层次已经衍化成独立的前端项目 C：Controller 控制层,具体功能如下 接收客户端请求,获得请求数据 将准备好的数据响应给客户端 MVC模式下,项目中的常见包 M: 实体类包(pojo &#x2F;entity &#x2F;bean) 专门存放和数据库对应的实体类和一些VO对象 数据库访问包(dao&#x2F;mapper) 专门存放对数据库不同表格CURD方法封装的一些类 服务包(service) 专门存放对数据进行业务逻辑运算的一些类 C: 控制层包(controller) V: web目录下的视图资源 html css js img 等 前端工程化后,在后端项目中已经不存在了 非前后端分离的MVC 前后端分离的MVC 十二 案例开发-日程管理-第二期12.1 项目搭建12.1.1 数据库准备 创建schedule_system数据库并执行如下语句 12345678910111213141516171819202122232425262728293031323334353637383940SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ 创建日程表-- ----------------------------DROP TABLE IF EXISTS `sys_schedule`;CREATE TABLE `sys_schedule` ( `sid` int NOT NULL AUTO_INCREMENT, `uid` int NULL DEFAULT NULL, `title` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `completed` int(1) NULL DEFAULT NULL, PRIMARY KEY (`sid`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ 插入日程数据-- ------------------------------ ------------------------------ 创建用户表-- ----------------------------DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `uid` int NOT NULL AUTO_INCREMENT, `username` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `user_pwd` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, PRIMARY KEY (`uid`) USING BTREE, UNIQUE INDEX `username`(`username`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ 插入用户数据-- ----------------------------INSERT INTO `sys_user` VALUES (1, &#x27;zhangsan&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;);INSERT INTO `sys_user` VALUES (2, &#x27;lisi&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;);SET FOREIGN_KEY_CHECKS = 1; 获得如下表格 12.1.2 项目结构 12.1.3 导入依赖 12.1.4 pojo包处理 使用lombok处理getter setter equals hashcode 构造器 123456789101112131415161718192021222324252627282930313233//-----------------------------------------------------package com.atguigu.schedule.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@AllArgsConstructor@NoArgsConstructor@Datapublic class SysUser implements Serializable &#123; private Integer uid; private String username; private String userPwd;&#125;//------------------------------------------------------package com.atguigu.schedule.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@AllArgsConstructor@NoArgsConstructor@Datapublic class SysSchedule implements Serializable &#123; private Integer sid; private Integer uid; private String title; private Integer completed;&#125;//------------------------------------------------------ 12.1.5 dao包处理导入JDBCUtil连接池工具类并准备jdbc.properties配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.atguigu.schedule.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;public class JDBCUtil &#123; private static ThreadLocal&lt;Connection&gt; threadLocal =new ThreadLocal&lt;&gt;(); private static DataSource dataSource; // 初始化连接池 static&#123; // 可以帮助我们读取.properties配置文件 Properties properties =new Properties(); InputStream resourceAsStream = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); try &#123; properties.load(resourceAsStream); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try &#123; dataSource = DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /*1 向外提供连接池的方法*/ public static DataSource getDataSource()&#123; return dataSource; &#125; /*2 向外提供连接的方法*/ public static Connection getConnection()&#123; Connection connection = threadLocal.get(); if (null == connection) &#123; try &#123; connection = dataSource.getConnection(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; threadLocal.set(connection); &#125; return connection; &#125; /*定义一个归还连接的方法 (解除和ThreadLocal之间的关联关系) */ public static void releaseConnection()&#123; Connection connection = threadLocal.get(); if (null != connection) &#123; threadLocal.remove(); // 把连接设置回自动提交的连接 try &#123; connection.setAutoCommit(true); // 自动归还到连接池 connection.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;&#125; 1234567driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/schedule_systemusername=rootpassword=rootinitialSize=5maxActive=10maxWait=1000 创建BaseDao对象并复制如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.atguigu.schedule.dao;import com.atguigu.schedule.util.JDBCUtil;import java.lang.reflect.Field;import java.sql.*;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;public class BaseDao &#123; // 公共的查询方法 返回的是单个对象 public &lt;T&gt; T baseQueryObject(Class&lt;T&gt; clazz, String sql, Object ... args) &#123; T t = null; Connection connection = JDBCUtil.getConnection(); PreparedStatement preparedStatement = null; ResultSet resultSet = null; int rows = 0; try &#123; // 准备语句对象 preparedStatement = connection.prepareStatement(sql); // 设置语句上的参数 for (int i = 0; i &lt; args.length; i++) &#123; preparedStatement.setObject(i + 1, args[i]); &#125; // 执行 查询 resultSet = preparedStatement.executeQuery(); if (resultSet.next()) &#123; t = (T) resultSet.getObject(1); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != resultSet) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (null != preparedStatement) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; JDBCUtil.releaseConnection(); &#125; return t; &#125; // 公共的查询方法 返回的是对象的集合 public &lt;T&gt; List&lt;T&gt; baseQuery(Class clazz, String sql, Object ... args)&#123; List&lt;T&gt; list =new ArrayList&lt;&gt;(); Connection connection = JDBCUtil.getConnection(); PreparedStatement preparedStatement=null; ResultSet resultSet =null; int rows = 0; try &#123; // 准备语句对象 preparedStatement = connection.prepareStatement(sql); // 设置语句上的参数 for (int i = 0; i &lt; args.length; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; // 执行 查询 resultSet = preparedStatement.executeQuery(); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // 将结果集通过反射封装成实体类对象 while (resultSet.next()) &#123; // 使用反射实例化对象 Object obj =clazz.getDeclaredConstructor().newInstance(); for (int i = 1; i &lt;= columnCount; i++) &#123; String columnName = metaData.getColumnLabel(i); Object value = resultSet.getObject(columnName); // 处理datetime类型字段和java.util.Data转换问题 if(value.getClass().equals(LocalDateTime.class))&#123; value= Timestamp.valueOf((LocalDateTime) value); &#125; Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(obj,value); &#125; list.add((T)obj); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null !=resultSet) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; if (null != preparedStatement) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; JDBCUtil.releaseConnection(); &#125; return list; &#125; // 通用的增删改方法 public int baseUpdate(String sql,Object ... args) &#123; // 获取连接 Connection connection = JDBCUtil.getConnection(); PreparedStatement preparedStatement=null; int rows = 0; try &#123; // 准备语句对象 preparedStatement = connection.prepareStatement(sql); // 设置语句上的参数 for (int i = 0; i &lt; args.length; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; // 执行 增删改 executeUpdate rows = preparedStatement.executeUpdate(); // 释放资源(可选) &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != preparedStatement) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; JDBCUtil.releaseConnection(); &#125; // 返回的是影响数据库记录数 return rows; &#125;&#125; dao层所有接口 123456789//---------------------------------------------------package com.atguigu.schedule.dao;public interface SysUserDao &#123;&#125;//---------------------------------------------------package com.atguigu.schedule.dao;public interface SysScheduleDao &#123;&#125;//--------------------------------------------------- dao层所有实现类 1234567891011121314//------------------------------------------------------------------------------package com.atguigu.schedule.dao.impl;import com.atguigu.schedule.dao.BaseDao;import com.atguigu.schedule.dao.SysUserDao;public class SysUserDaoImpl extends BaseDao implements SysUserDao &#123;&#125;//------------------------------------------------------------------------------package com.atguigu.schedule.dao.impl;import com.atguigu.schedule.dao.BaseDao;import com.atguigu.schedule.dao.SysScheduleDao;public class SysScheduleDaoImpl extends BaseDao implements SysScheduleDao &#123;&#125;//------------------------------------------------------------------------------ 12.1.6 service包处理 接口 123456789//------------------------------------------------------------------------------package com.atguigu.schedule.service;public interface SysUserService &#123;&#125;//------------------------------------------------------------------------------package com.atguigu.schedule.service;public interface SysScheduleService &#123;&#125;//------------------------------------------------------------------------------ 实现类 1234567891011//------------------------------------------------------------------------------package com.atguigu.schedule.service.impl;import com.atguigu.schedule.service.SysUserService;public class SysUserServiceImpl implements SysUserService &#123;&#125;//------------------------------------------------------------------------------package com.atguigu.schedule.service.impl;import com.atguigu.schedule.service.SysScheduleService;public class SysScheduleServiceImpl implements SysScheduleService &#123;&#125;//------------------------------------------------------------------------------ 12.1.7 controller包处理 BaseController处理请求路径问题 1234567891011121314151617181920212223242526272829303132package com.atguigu.schedule.controller;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Method;public class BaseController extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String requestURI = req.getRequestURI(); String[] split = requestURI.split(&quot;/&quot;); String methodName =split[split.length-1]; // 通过反射获取要执行的方法 Class clazz = this.getClass(); try &#123; Method method=clazz.getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class); // 设置方法可以访问 method.setAccessible(true); // 通过反射执行代码 method.invoke(this,req,resp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 多个处理器继承BaseController 1234567891011121314151617//----------------------------------------------------------------------------package com.atguigu.schedule.controller;import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/user/*&quot;)public class UserController extends BaseController&#123;&#125;//----------------------------------------------------------------------------package com.atguigu.schedule.controller;import jakarta.servlet.annotation.WebServlet;@WebServlet(&quot;/schedule/*&quot;)public class SysScheduleController extends BaseController&#123;&#125;//---------------------------------------------------------------------------- 12.1.8 加密工具类的使用 导入MD5Util工具类 123456789101112131415161718192021222324252627package com.atguigu.schedule.util;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public final class MD5Util &#123; public static String encrypt(String strSrc) &#123; try &#123; char hexChars[] = &#123; &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; &#125;; byte[] bytes = strSrc.getBytes(); MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); md.update(bytes); bytes = md.digest(); int j = bytes.length; char[] chars = new char[j * 2]; int k = 0; for (int i = 0; i &lt; bytes.length; i++) &#123; byte b = bytes[i]; chars[k++] = hexChars[b &gt;&gt;&gt; 4 &amp; 0xf]; chars[k++] = hexChars[b &amp; 0xf]; &#125; return new String(chars); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;MD5加密出错!!!&quot;) &#125; &#125;&#125; 12.1.9 页面文件的导入 复制资源下的日程管理中的HTML到项目的web目录下即可 12.3 业务代码12.3.1 注册业务处理 controller 123456789101112131415161718192021222324252627282930313233343536373839404142package com.atguigu.schedule.controller;import com.atguigu.schedule.pojo.SysUser;import com.atguigu.schedule.service.SysUserService;import com.atguigu.schedule.service.impl.SysUserServiceImpl;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/user/*&quot;)public class SysUserController extends BaseContoller &#123; private SysUserService userService =new SysUserServiceImpl(); /** * 接收用户注册请求的业务处理方法( 业务接口 不是java中的interface ) * @param req * @param resp * @throws ServletException * @throws IOException */ protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1 接收客户端提交的参数 String username = req.getParameter(&quot;username&quot;); String userPwd = req.getParameter(&quot;userPwd&quot;); // 2 调用服务层方法,完成注册功能 //将参数放入一个SysUser对象中,在调用regist方法时传入 SysUser sysUser =new SysUser(null,username,userPwd); int rows =userService.regist(sysUser); // 3 根据注册结果(成功 失败) 做页面跳转 if(rows&gt;0)&#123; resp.sendRedirect(&quot;/registSuccess.html&quot;); &#125;else&#123; resp.sendRedirect(&quot;/registFail.html&quot;); &#125; &#125;&#125; service 123456789101112package com.atguigu.schedule.service;import com.atguigu.schedule.pojo.SysUser;public interface SysUserService &#123; /** * 用户完成注册的业务方法 * @param registUser 用于保存注册用户名和密码的对象 * @return 注册成功返回&gt;0的整数,否则返回0 */ int regist(SysUser registUser);&#125; 12345678910111213141516171819package com.atguigu.schedule.service.impl;import com.atguigu.schedule.dao.SysUserDao;import com.atguigu.schedule.dao.impl.SysUserDaoImpl;import com.atguigu.schedule.pojo.SysUser;import com.atguigu.schedule.service.SysUserService;import com.atguigu.schedule.util.MD5Util;public class SysUserServiceImpl implements SysUserService &#123; private SysUserDao userDao =new SysUserDaoImpl(); @Override public int regist(SysUser sysUser) &#123; // 将用户的明文密码转换为密文密码 sysUser.setUserPwd(MD5Util.encrypt(sysUser.getUserPwd())); // 调用DAO 层的方法 将sysUser信息存入数据库 return userDao.addSysUser(sysUser); &#125;&#125; dao 1234567891011121314package com.atguigu.schedule.dao;import com.atguigu.schedule.pojo.SysUser;public interface SysUserDao &#123; /** * 向数据库中增加一条用户记录的方法 * @param sysUser 要增加的记录的username和user_pwd字段以SysUser实体类对象的形式接收 * @return 增加成功返回1 增加失败返回0 */ int addSysUser(SysUser sysUser);&#125; 123456789101112package com.atguigu.schedule.dao.impl;import com.atguigu.schedule.dao.BaseDao;import com.atguigu.schedule.dao.SysUserDao;import com.atguigu.schedule.pojo.SysUser;public class SysUserDaoImpl extends BaseDao implements SysUserDao &#123; @Override public int addSysUser(SysUser sysUser) &#123; String sql =&quot;insert into sys_user values(DEFAULT,?,?)&quot;; return baseUpdate(sql,sysUser.getUsername(),sysUser.getUserPwd()); &#125;&#125; 12.3.2 登录业务处理 controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.schedule.controller;import com.atguigu.schedule.pojo.SysUser;import com.atguigu.schedule.service.SysUserService;import com.atguigu.schedule.service.impl.SysUserServiceImpl;import com.atguigu.schedule.util.MD5Util;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/user/*&quot;)public class SysUserController extends BaseContoller &#123; private SysUserService userService =new SysUserServiceImpl(); /** * 接收用登录请求,完成的登录业务接口 * @param req * @param resp * @throws ServletException * @throws IOException */ protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1 接收用户名和密码 String username = req.getParameter(&quot;username&quot;); String userPwd = req.getParameter(&quot;userPwd&quot;); //2 调用服务层方法,根据用户名查询用户信息 SysUser loginUser =userService.findByUsername(username); if(null == loginUser)&#123; // 跳转到用户名有误提示页 resp.sendRedirect(&quot;/loginUsernameError.html&quot;); &#125;else if(! MD5Util.encrypt(userPwd).equals(loginUser.getUserPwd()))&#123; //3 判断密码是否匹配 // 跳转到密码有误提示页 resp.sendRedirect(&quot;/loginUserPwdError.html&quot;); &#125;else&#123; //4 跳转到首页 resp.sendRedirect(&quot;/showSchedule.html&quot;); &#125; &#125;&#125; service 123456789101112package com.atguigu.schedule.service;import com.atguigu.schedule.pojo.SysUser;public interface SysUserService &#123; /** * 根据用户名获得完整用户信息的方法 * @param username 要查询的用户名 * @return 如果找到了返回SysUser对象,找不到返回null */ SysUser findByUsername(String username);&#125; 1234567891011121314151617181920package com.atguigu.schedule.service.impl;import com.atguigu.schedule.dao.SysUserDao;import com.atguigu.schedule.dao.impl.SysUserDaoImpl;import com.atguigu.schedule.pojo.SysUser;import com.atguigu.schedule.service.SysUserService;import com.atguigu.schedule.util.MD5Util;public class SysUserServiceImpl implements SysUserService &#123; private SysUserDao userDao =new SysUserDaoImpl(); @Override public SysUser findByUsername(String username) &#123; // 调用服务层方法,继续查询 return userDao.findByUsername(username); &#125;&#125; dao 123456789101112package com.atguigu.schedule.dao;import com.atguigu.schedule.pojo.SysUser;public interface SysUserDao &#123; /** * 根据用户名获得完整用户信息的方法 * @param username 要查询的用户名 * @return 如果找到了返回SysUser对象,找不到返回null */ SysUser findByUsername(String username);&#125; 123456789101112131415import com.atguigu.schedule.dao.BaseDao;import com.atguigu.schedule.dao.SysUserDao;import com.atguigu.schedule.pojo.SysUser;import java.util.List;public class SysUserDaoImpl extends BaseDao implements SysUserDao &#123; @Override public SysUser findByUsername(String username) &#123; String sql =&quot;select uid,username, user_pwd userPwd from sys_user where username = ?&quot;; List&lt;SysUser&gt; userList = baseQuery(SysUser.class, sql, username); return null != userList&amp;&amp; userList.size()&gt;0? userList.get(0):null; &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/categories/javaweb/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"第四章 XML_Tomcat10_HTTP","slug":"javaweb/04_第四章 XML_Tomcat_HTTP","date":"2019-10-08T04:00:00.000Z","updated":"2024-12-02T13:17:29.026Z","comments":true,"path":"2019/10/08/javaweb/04_第四章 XML_Tomcat_HTTP/","link":"","permalink":"https://protonlml.github.io/2019/10/08/javaweb/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20XML_Tomcat_HTTP/","excerpt":"","text":"第四章 XML_Tomcat10_HTTP一 XML XML是EXtensible Markup Language的缩写，翻译过来就是可扩展标记语言。所以很明显，XML和HTML一样都是标记语言，也就是说它们的基本语法都是标签。 可扩展 三个字表面上的意思是XML允许自定义格式。但这不代表你可以随便写。 在XML基本语法规范的基础上，你使用的那些第三方应用程序、框架会通过XML约束的方式强制规定配置文件中可以写什么和怎么写 XML基本语法这个知识点的定位是：我们不需要从零开始，从头到尾的一行一行编写XML文档，而是在第三方应用程序、框架已提供的配置文件的基础上修改。要改成什么样取决于你的需求，而怎么改取决XML基本语法和具体的XML约束。 1.1 常见配置文件类型 properties文件,例如druid连接池就是使用properties文件作为配置文件 XML文件,例如Tomcat就是使用XML文件作为配置文件 YAML文件,例如SpringBoot就是使用YAML作为配置文件 json文件,通常用来做文件传输，也可以用来做前端或者移动端的配置文件 等等… 1.1.1 properties配置文件 示例 1234atguigu.jdbc.url=jdbc:mysql://localhost:3306/atguiguatguigu.jdbc.driver=com.mysql.cj.jdbc.Driveratguigu.jdbc.username=rootatguigu.jdbc.password=root 语法规范 由键值对组成 键和值之间的符号是等号 每一行都必须顶格写，前面不能有空格之类的其他符号 1.1.2 xml配置文件 示例 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;students&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;/student&gt;&lt;/students&gt; XML的基本语法 XML的基本语法和HTML的基本语法简直如出一辙。其实这不是偶然的，XML基本语法+HTML约束&#x3D;HTML语法。在逻辑上HTML确实是XML的子集。 XML文档声明 这部分基本上就是固定格式，要注意的是文档声明一定要从第一行第一列开始写 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 根标签 &#x20;根标签有且只能有一个。 标签关闭 双标签：开始标签和结束标签必须成对出现。 单标签：单标签在标签内关闭。 标签嵌套 可以嵌套，但是不能交叉嵌套。 注释不能嵌套 标签名、属性名建议使用小写字母 属性 属性必须有值 属性值必须加引号，单双都行 XML的约束(稍微了解) 将来我们主要就是根据XML约束中的规定来编写XML配置文件，而且会在我们编写XML的时候根据约束来提示我们编写, 而XML约束主要包括DTD和Schema两种。 DTD Schema Schema约束要求我们一个XML文档中，所有标签，所有属性都必须在约束中有明确的定义。 下面我们以web.xml的约束声明为例来做个说明： 1234&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; 1.2 DOM4J进行XML解析1.2.1 DOM4J的使用步骤 导入jar包 dom4j.jar 创建解析器对象(SAXReader) 解析xml 获得Document对象 获取根节点RootElement 获取根节点下的子节点 1.2.2 DOM4J的API介绍1.创建SAXReader对象 1SAXReader saxReader = new SAXReader(); &#x20;2. 解析XML获取Document对象: 需要传入要解析的XML文件的字节输入流 1Document document = reader.read(inputStream); &#x20;3. 获取文档的根标签 1Element rootElement = documen.getRootElement() &#x20;4. 获取标签的子标签 1234//获取所有子标签List&lt;Element&gt; sonElementList = rootElement.elements();//获取指定标签名的子标签List&lt;Element&gt; sonElementList = rootElement.elements(&quot;标签名&quot;); &#x20;5. 获取标签体内的文本 1String text = element.getText(); &#x20;6. 获取标签的某个属性的值 1String value = element.attributeValue(&quot;属性名&quot;); 二 Tomcat102.1 WEB服务器 Web服务器通常由硬件和软件共同构成。 硬件：电脑，提供服务供其它客户电脑访问 软件：电脑上安装的服务器软件，安装后能提供服务给网络中的其他计算机，将本地文件映射成一个虚拟的url地址供网络中的其他人访问。 常见的JavaWeb服务器： Tomcat（Apache）：当前应用最广的JavaWeb服务器 Jetty:更轻量级、更灵活的servlet容器 JBoss（Redhat红帽）：支持JavaEE，应用比较广EJB容器 –&gt; SSH轻量级的框架代替 GlassFish（Orcale）：Oracle开发JavaWeb服务器，应用不是很广 Resin（Caucho）：支持JavaEE，应用越来越广 Weblogic（Orcale）：要钱的！支持JavaEE，适合大型项目 Websphere（IBM）：要钱的！支持JavaEE，适合大型项目 2.2 Tomcat服务器2.2.1 简介 Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。 2.2.2 安装 版本 版本：企业用的比较广泛的是8.0和9.0,目前比较新正式发布版本是Tomcat10.0, Tomcat11仍然处于测试阶段。 JAVAEE 版本和Servlet版本号对应关系 Jakarta EE Releases Servlet Version EE Version 6.1 Jakarta EE ? 6.0 Jakarta EE 10 5.0 Jakarta EE 9&#x2F;9.1 4.0 JAVA EE 8 3.1 JAVA EE 7 3.1 JAVA EE 7 3.0 JAVAEE 6 Tomcat 版本和Servlet版本之间的对应关系 Servlet Version **Tomcat ** Version JDK Version 6.1 11.0.x 17 and later 6.0 10.1.x 11 and later 5.0 10.0.x (superseded) 8 and later 4.0 9.0.x 8 and later 3.1 8.5.x 7 and later 3.1 8.0.x (superseded) 7 and later 3.0 7.0.x (archived) 6 and later (7 and later for WebSocket) 下载 Tomcat官方网站：http://tomcat.apache.org/ 安装版：需要安装，一般不考虑使用。 解压版: 直接解压缩使用，我们使用的版本。 安装 正确安装JDK并配置JAVA_HOME(以JDK17为例 https://injdk.cn中可以下载各种版本的JDK) 解压tomcat到非中文无空格目录 点击bin&#x2F;startup.bat启动 打开浏览器输入 http://localhost:8080访问测试 直接关闭窗口或者运行 bin&#x2F;shutdown.bat关闭tomcat 处理dos窗口日志中文乱码问题: 修改conf&#x2F;logging.properties,将所有的UTF-8修改为GBK 修改前 修改后 重启测试 2.3 Tomcat目录及测试 C:\\Program4java\\apache-tomcat-10.1.7 这个目录下直接包含Tomcat的bin目录，conf目录等，我们称之为Tomcat的安装目录或根目录。 bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat10.exe、tomcat10w.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA_HOME环境变量才能启动，shutdawn.bat用来停止Tomcat； conf：这是一个非常非常重要的目录，这个目录下有四个最为重要的文件： server.xml：配置整个服务器信息。例如修改端口号。默认HTTP请求的端口号是：8080 tomcat-users.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了； 123456789101112131415&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot; version=&quot;1.0&quot;&gt; &lt;role rolename=&quot;admin-gui&quot;/&gt; &lt;role rolename=&quot;admin-script&quot;/&gt; &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;role rolename=&quot;manager-script&quot;/&gt; &lt;role rolename=&quot;manager-jmx&quot;/&gt; &lt;role rolename=&quot;manager-status&quot;/&gt; &lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin-gui,admin-script,manager-gui,manager-script,manager-jmx,manager-status&quot; /&gt;&lt;/tomcat-users&gt; web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text&#x2F;html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME就是用来说明文档的内容是什么类型的！ context.xml：对所有应用的统一配置，通常我们不会去配置它。 lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的jar包了，所以建议只把Tomcat需要的jar包放到这个目录下； logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。 temp：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！ webapps：存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中访问：","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/categories/javaweb/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"第三章 JavaScript","slug":"javaweb/03_第三章 JavaScript","date":"2019-10-08T03:00:00.000Z","updated":"2024-12-02T13:17:29.018Z","comments":true,"path":"2019/10/08/javaweb/03_第三章 JavaScript/","link":"","permalink":"https://protonlml.github.io/2019/10/08/javaweb/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20JavaScript/","excerpt":"","text":"第三章 JavaScript一 JS简介1.1 JS起源 Javascript是一种由Netscape(网景)的LiveScript发展而来的原型化继承的面向对象的动态类型的区分大小写的客户端脚本语言，主要目的是为了解决服务器端语言，遗留的速度问题，为客户提供更流畅的浏览效果。当时服务端需要对数据进行验证，由于网络速度相当缓慢,只有28.8kbps，验证步骤浪费的时间太多。于是Netscape的浏览器Navigator加入了Javascript，提供了数据验证的基本功能。ECMA-262 是正式的 JavaScript 标准。这个标准基于 JavaScript (Netscape) 和 JScript (Microsoft)。ECMA-262 的开发始于 1996 年，在 1997 年 7 月，ECMA 会员大会采纳了它的首个版本。这个标准由 ECMA 组织发展和维护。JavaScript 的正式名称是 “ECMAScript”。JavaScript的组成包含ECMAScript、DOM、BOM。JS是一种运行于浏览器端上的小脚本语句,可以实现网页如文本内容动,数据动态变化和动画特效等,JS有 如下特点 脚本语言 JavaScript是一种解释型的脚本语言。不同于C、C++、Java等语言先编译后执行, JavaScript不会产生编译出来的字节码文件，而是在程序的运行过程中对源文件逐行进行解释。 基于对象 JavaScript是一种基于对象的脚本语言，它不仅可以创建对象，也能使用现有的对象。但是面向对象的三大特性：『封装』、『继承』、『多态』中，JavaScript能够实现封装，可以模拟继承，不支持多态，所以它不是一门面向对象的编程语言。 弱类型 JavaScript中也有明确的数据类型，但是声明一个变量后它可以接收任何类型的数据，并且会在程序执行过程中根据上下文自动转换类型。 事件驱动 JavaScript是一种采用事件驱动的脚本语言，它不需要经过Web服务器就可以对用户的输入做出响应。 跨平台性 JavaScript脚本语言不依赖于操作系统，仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用，前提是机器上的浏览器支持JavaScript脚本语言。目前JavaScript已被大多数的浏览器所支持。 1.2 JS 组成部分 ECMA 及版本变化 是一种由欧洲计算机制造商协会（ECMA）通过ECMA-262标准化的脚本程序语言,ECMAScript描述了语法、类型、语句、关键字、保留字、运算符和对象。它就是定义了脚本语言的所有属性、方法和对象。 ECMA-262第1版本质上跟网景的JavaScript 1.1相同，删除了浏览器特定代码和少量细微的修改.ECMA-262要求支持Unicode标准（以支持多语言）且对象要与平台无关 ECMA-262第2版只是做了一些编校工作，主要是为了严格符合ISO&#x2F;IEC-16262的要求，并没有增减或改变任何特性。 ECMA-262第3版第一次真正对ECMAScript进行更新，更新了字符串处理、错误定义和数值输出，增加了对正则表达式、新的控制语句、try&#x2F;catch异常处理的支持。 ECMA-262第4版是对这门语言的一次彻底修订。开发者开始修订ECMAScript以满足全球Web开发日益增长的需求。 第4版包括强类型变量、新语句和数据结构、真正的类和经典的继承，以及操作数据的新手段。 ECMA-262第5版是ECMA-262第3版的小幅改进，于2009年12月3日正式发布。第5版致力于厘清第3版存在的歧义，也增加了新功能。新功能包括原生的解析和序列化JSON数据的JSON对象、方便继承和高级属性定义的方法、新的增强ECMAScript引擎解释和执行代码能力的严格模式。 ECMA-262第6版俗称ES6、ES2015或ES Harmony（和谐版），于2015年6月发布。**这一版包含了大概这个规范有史以来最重要的一批增强特性。**ES6正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型。但是并不是所有的浏览器都全面支持了ES6,很多情况下我们需要将ES6的语法通过工具转换成5以后运行 ECMA-262第7版也称为ES7或ES2016，于2016年6月发布。这次修订只包含少量语法层面的增强，如Array.prototype.includes和指数操作符。 ECMA-262第8版也称为ES8、ES2017，完成于2017年6月。这一版主要增加了异步函数（async&#x2F;await）、SharedArrayBuffer及Atomics API、Object.values()&#x2F;Object.entries()&#x2F;Object.getOwnProperty- Descriptors()和字符串填充方法，另外明确支持对象字面量最后的逗号。 ECMA-262第9版也称为ES9、ES2018，发布于2018年6月。这次修订包括异步迭代、剩余和扩展属性、一组新的正则表达式特性、Promise finally()以及模板字面量修订。 ECMA-262第10版也称为ES10、ES2019，发布于2019年6月。这次修订增加了Array.prototype.flat()&#x2F;flatMap()、String.prototype.trimStart()&#x2F;trimEnd()、Object.fromEntries()方法以及Symbol.prototype.description属性，明确定义了Function.prototype.toString()的返回值并固定了Array.prototype.sort()的顺序。另外，这次修订解决了与JSON字符串兼容的问题，并定义了catch子句的可选绑定。 ECMA-262第11版，也成为ES11、ES2020，发布于2020年6月。这次修订增加了String 的 matchAll 方法、动态导入语句 import()、import.meta、export * as ns from ‘module’、Promise.allSettled、GlobalThis、Nullish coalescing Operator、Optional Chaining以及一种新的数据类型BigInt，在此之后JavaScript正式迎来第8位数据类型。 BOM编程 BOM是Browser Object Model的简写，即浏览器对象模型。 BOM有一系列对象组成，是访问、控制、修改浏览器的属性和方法 BOM没有统一的标准(每种客户端都可以自定标准)。 BOM编程是将浏览器窗口的各个组成部分抽象成各个对象,通过各个对象的API操作组件行为的一种编程 BOM编程的对象结构如下 window 顶级对象,代表整个浏览器窗口 location对象 window对象的属性之一,代表浏览器的地址栏 history对象 window对象的属性之一,代表浏览器的访问历史 screen对象 window对象的属性之一,代表屏幕 navigator对象 window对象的属性之一,代表浏览器软件本身 document对象 window对象的属性之一,代表浏览器窗口目前解析的html文档 DOM编程 简单来说:DOM编程就是使用document对象的API完成对网页HTML文档进行动态修改,以实现网页数据和样式动态变化效果的编程. document对象代表整个html文档，可用来访问页面中的所有元素，是最复杂的一个dom对象，可以说是学习好dom编程的关键所在。 根据HTML代码结构特点,document对象本身是一种树形结构的文档对象。 上面的代码生成的树如下 DOM编程其实就是用window对象的document属性的相关API完成对页面元素的控制的编程 1.3 JS的引入方式 内部脚本方式引入 说明 在页面中,通过一对script标签引入JS代码 script代码放置位置具备一定的随意性,一般放在head标签中居多 代码 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小标题&lt;/title&gt; &lt;style&gt; /* 通过选择器确定样式的作用范围 */ .btn1 &#123; display: block; width: 150px; height: 40px; background-color: rgb(245, 241, 129); color: rgb(238, 31, 31); border: 3px solid rgb(238, 23, 66); font-size: 22px; font-family: &#x27;隶书&#x27;; line-height: 30px; border-radius: 5px; &#125; &lt;/style&gt; &lt;script&gt; function suprise()&#123; alert(&quot;Hello,我是惊喜&quot;) &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button class=&quot;btn1&quot; onclick=&quot;suprise()&quot;&gt;点我有惊喜&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 效果 外部脚本方式引入 说明 内部脚本仅能在当前页面上使用,代码复用度不高 可以将脚本放在独立的js文件中,通过script标签引入外部脚本文件 一对script标签要么用于定义内部脚本,要么用于引入外部js文件,不能混用 一个html文档中,可以有多个script标签 抽取脚本代码到独立的js文件中 在html文件中,通过script标签引入外部脚本文件 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小标题&lt;/title&gt; &lt;style&gt; /* 通过选择器确定样式的作用范围 */ .btn1 &#123; display: block; width: 150px; height: 40px; background-color: rgb(245, 241, 129); color: rgb(238, 31, 31); border: 3px solid rgb(238, 23, 66); font-size: 22px; font-family: &#x27;隶书&#x27;; line-height: 30px; border-radius: 5px; &#125; &lt;/style&gt; &lt;script src=&quot;js/button.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button class=&quot;btn1&quot; onclick=&quot;suprise()&quot;&gt;点我有惊喜&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 二 JS的数据类型和运算符2.1 JS的数据类型 数值类型 数值类型统一为 number,不区分整数和浮点数 字符串类型 字符串类型为 string 和JAVA中的String相似,JS中不严格区分单双引号,都可以用于表示字符串 布尔类型 布尔类型为boolean 和Java中的boolean相似,但是在JS的if语句中,非空字符串会被转换为’真’,非零数字也会被认为是’真’ 引用数据类型 引用数据类型对象是Object类型, 各种对象和数组在JS中都是Object类型 function类型 JS中的各种函数属于function数据类型 命名未赋值 js为弱类型语言,统一使用 var 声明对象和变量,在赋值时才确定真正的数据类型,变量如果只声明没有赋值的话,数据类型为undefined 赋予NULL值 在JS中,如果给一个变量赋值为null,其数据类型是Object, 可以通过typeof关键字判断数据类型 2.2 JS的变量 JS中的变量具有如下特征 1 弱类型变量,可以统一声明成var 2 var声明的变量可以再次声明 3 变量可以使用不同的数据类型多次赋值 4 JS的语句可以以; 结尾,也可以不用;结尾 5 变量标识符严格区分大小写 6 标识符的命名规则参照JAVA 7 如果使用了 一个没有声明的变量,那么运行时会报uncaught ReferenceError: *** is not defined at index.html:行号:列号 8 如果一个变量只声明,没赋值,那么值是undefined 2.3 JS的运算符 算数运算符 + - * &#x2F; % 其中需要注意的是 &#x2F; 和 % &#x2F; 在除0时,结果是Infinity ,而不是报错 %在模0时,结果是NaN,意思为 not a number ,而不是报错 复合算数运算符 ++ – +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; 符合算数运算符基本和JAVA一致,同样需要注意 &#x2F;&#x3D;和%&#x3D; 在&#x2F;&#x3D;0时,结果是Infinity ,而不是报错 在%&#x3D;0时,结果是NaN,意思为 not a number ,而不是报错 关系运算符 &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D; 需要注意的是 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 差别 &#x3D;&#x3D; 符号,如果两端的数据类型不一致,会尝试将两端的数据转换成number,再对比number大小 ‘123’ 这种字符串可以转换成数字 true会被转换成1 false会被转换成0 &#x3D;&#x3D;&#x3D; 符号,如果两端数据类型不一致,直接返回false,数据类型一致在比较是否相同 逻辑运算符 || &amp;&amp; 几乎和JAVA中的一样,需要注意的是,这里直接就是短路的逻辑运算符,单个的 | 和 &amp; 以及 ^ 是位运算符 条件运算符 条件? 值1 : 值2 几乎和JAVA中的一样 位运算符 | &amp; ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt; 和 java中的类似(了解) 三 JS的流程控制和函数3.1 JS分支结构 if结构 这里的if结构几乎和JAVA中的一样,需要注意的是 if()中的非空字符串会被认为是true if()中的非零数字会被认为是true 代码 1234567891011121314151617181920if(&#x27;false&#x27;)&#123;// 非空字符串 if判断为true console.log(true)&#125;else&#123; console.log(false)&#125;if(&#x27;&#x27;)&#123;// 长度为0字符串 if判断为false console.log(true)&#125;else&#123; console.log(false)&#125;if(1)&#123;// 非零数字 if判断为true console.log(true)&#125;else&#123; console.log(false)&#125;if(0)&#123; console.log(true)&#125;else&#123; console.log(false)&#125; 结果 switch结构 几乎和JAVA的语法一致 代码 1234567891011121314151617181920212223242526var monthStr=prompt(&quot;请输入月份&quot;,&quot;例如:10 &quot;);var month= Number.parseInt(monthStr)switch(month)&#123; case 3: case 4: case 5: console.log(&quot;春季&quot;); break; case 6: case 7: case 8: console.log(&quot;夏季&quot;); break; case 9: case 10: case 11: console.log(&quot;秋季&quot;); break; case 1: case 2: case 12: console.log(&quot;冬季&quot;); break; default : console.log(&quot;月份有误&quot;)&#125; 效果 3.2 JS循环结构 while结构 几乎和JAVA一致 代码 1234567891011/* 打印99 乘法表 */var i = 1;while(i &lt;= 9)&#123; var j = 1; while(j &lt;= i)&#123; document.write(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;); j++; &#125; document.write(&quot;&lt;hr/&gt;&quot;); i++;&#125; 效果 for循环 几乎和JAVA一致 代码 1234567/* 打印99 乘法表 */for( var i = 1;i &lt;= 9; i++)&#123; for(var j = 1;j &lt;= i;j++)&#123; document.write(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;); &#125; document.write(&quot;&lt;hr/&gt;&quot;);&#125; 效果 foreach循环 迭代数组时,和java不一样 括号中的临时变量表示的是元素的索引,不是元素的值, ()中也不在使用: 分隔,而是使用 in 关键字 代码 123456var cities =[&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;,&quot;武汉&quot;,&quot;西安&quot;,&quot;成都&quot;]document.write(&quot;&lt;ul&gt;&quot;)for(var index in cities)&#123; document.write(&quot;&lt;li&gt;&quot;+cities[index]+&quot;&lt;/li&gt;&quot;)&#125;document.write(&quot;&lt;/ul&gt;&quot;) 效果 3.3 JS函数声明 JS中的方法,多称为函数,函数的声明语法和JAVA中有较大区别 函数说明 函数没有权限控制符 不用声明函数的返回值类型,需要返回在函数体中直接return即可,也无需void关键字 参数列表中,无需数据类型 调用函数时,实参和形参的个数可以不一致 声明函数时需要用function关键字 J函数没有异常列表 代码 12345678910111213141516171819/* 语法1 function 函数名 (参数列表)&#123;函数体&#125; */function sum(a, b)&#123; return a+b;&#125;var result =sum(10,20);console.log(result)/* 语法2 var 函数名 = function (参数列表)&#123;函数体&#125; */var add = function(a, b)&#123; return a+b;&#125;var result = add(1,2);console.log(result); 调用测试 四 JS的对象和JSON4.1 JS声明对象的语法 语法1 通过new Object()直接创建对象 代码 1234567891011121314151617var person =new Object();// 给对象添加属性并赋值person.name=&quot;张小明&quot;;person.age=10;person.foods=[&quot;苹果&quot;,&quot;橘子&quot;,&quot;香蕉&quot;,&quot;葡萄&quot;];// 给对象添加功能函数person.eat= function ()&#123; console.log(this.age+&quot;岁的&quot;+this.name+&quot;喜欢吃:&quot;) for(var i = 0;i&lt;this.foods.length;i++)&#123; console.log(this.foods[i]) &#125; &#125;//获得对象属性值console.log(person.name)console.log(person.age)//调用对象方法person.eat(); 效果 语法2 通过 {}形式创建对象 语法为 var person &#x3D;{“属性名”:”属性值”,”属性名”,”属性值”,”函数名”:函数} 代码 12345678910111213141516var person =&#123; &quot;name&quot;:&quot;张小明&quot;, &quot;age&quot;:10, &quot;foods&quot;:[&quot;苹果&quot;,&quot;香蕉&quot;,&quot;橘子&quot;,&quot;葡萄&quot;], &quot;eat&quot;:function ()&#123; console.log(this.age+&quot;岁的&quot;+this.name+&quot;喜欢吃:&quot;) for(var i = 0;i&lt;this.foods.length;i++)&#123; console.log(this.foods[i]) &#125; &#125;&#125;//获得对象属性值console.log(person.name)console.log(person.age)//调用对象方法person.eat(); 效果 4.2 JSON格式 JSON（JavaScript Object Notation, JS对象简谱）是一种轻量级的数据交换格式。它基于ECMAScript（European Computer Manufacturers Association, 欧洲计算机协会的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 简单来说,JSON 就是一种字符串格式,这种格式无论是在前端还是在后端,都可以很容易的转换成对象,所以常用于前后端数据传递 说明 JSON的语法 ​ var obj&#x3D;”{‘属性名’:’属性值’,’属性名’:{‘属性名’:’属性值’},’属性名’:[‘值1’,’值1’,’值3’]}” JSON字符串一般用于传递数据,所以字符串中的函数就显得没有意义,在此不做研究 通过JSON.parse()方法可以将一个JSON串转换成对象 通过JSON.stringify()方法可以将一个对象转换成一个JSON格式的字符串 代码 123456789101112131415/* 定义一个JSON串 */var personStr =&#x27;&#123;&quot;name&quot;:&quot;张小明&quot;,&quot;age&quot;:20,&quot;girlFriend&quot;:&#123;&quot;name&quot;:&quot;铁铃&quot;,&quot;age&quot;:23&#125;,&quot;foods&quot;:[&quot;苹果&quot;,&quot;香蕉&quot;,&quot;橘子&quot;,&quot;葡萄&quot;],&quot;pets&quot;:[&#123;&quot;petName&quot;:&quot;大黄&quot;,&quot;petType&quot;:&quot;dog&quot;&#125;,&#123;&quot;petName&quot;:&quot;小花&quot;,&quot;petType&quot;:&quot;cat&quot;&#125;]&#125;&#x27;console.log(personStr)console.log(typeof personStr)/* 将一个JSON串转换为对象 */var person =JSON.parse(personStr);console.log(person)console.log(typeof person)/* 获取对象属性值 */console.log(person.name)console.log(person.age)console.log(person.girlFriend.name)console.log(person.foods[1])console.log(person.pets[1].petName)console.log(person.pets[1].petType) 1234567891011121314151617181920212223242526272829303132/* 定义一个对象 */var person=&#123; &#x27;name&#x27;:&#x27;张小明&#x27;, &#x27;age&#x27;:20, &#x27;girlFriend&#x27;:&#123; &#x27;name&#x27;:&#x27;铁铃&#x27;, &#x27;age&#x27;:23 &#125;, &#x27;foods&#x27;:[&#x27;苹果&#x27;,&#x27;香蕉&#x27;,&#x27;橘子&#x27;,&#x27;葡萄&#x27;], &#x27;pets&#x27;:[ &#123; &#x27;petName&#x27;:&#x27;大黄&#x27;, &#x27;petType&#x27;:&#x27;dog&#x27; &#125;, &#123; &#x27;petName&#x27;:&#x27;小花&#x27;, &#x27;petType&#x27;:&#x27;cat&#x27; &#125; ]&#125;/* 获取对象属性值 */console.log(person.name)console.log(person.age)console.log(person.girlFriend.name)console.log(person.foods[1])console.log(person.pets[1].petName)console.log(person.pets[1].petType)/* 将对象转换成JSON字符串 */var personStr =JSON.stringify(person)console.log(personStr)console.log(typeof personStr) 前后端传递数据 4.3 JS常见对象4.3.1 数组 创建数组的四种方式 new Array() 创建空数组 new Array(5) 创建数组时给定长度 new Array(ele1,ele2,ele3,… … ,elen); 创建数组时指定元素值 [ele1,ele2,ele3,… … ,elen]; 相当于第三种语法的简写 数组的常见API 在JS中,数组属于Object类型,其长度是可以变化的,更像JAVA中的集合 方法 描述 concat() 连接两个或更多的数组，并返回结果。 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中。 entries() 返回数组的可迭代对象。 every() 检测数值元素的每个元素是否都符合条件。 fill() 使用一个固定值来填充数组。 filter() 检测数值元素，并返回符合条件所有元素的数组。 find() 返回符合传入测试（函数）条件的数组元素。 findIndex() 返回符合传入测试（函数）条件的数组元素索引。 forEach() 数组每个元素都执行一次回调函数。 from() 通过给定的对象中创建一个数组。 includes() 判断一个数组是否包含一个指定的值。 indexOf() 搜索数组中的元素，并返回它所在的位置。 isArray() 判断对象是否为数组。 join() 把数组的所有元素放入一个字符串。 keys() 返回数组的可迭代对象，包含原始数组的键(key)。 lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 Array.of() 将一组值转换为数组。 Array.at() 用于接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。 Array.flat() 创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 Array.flatMap() 使用映射函数映射每个元素，然后将结果压缩成一个新数组。 4.3.2 Boolean对象 boolean对象的方法比较简单 方法 描述 toString() 把布尔值转换为字符串，并返回结果。 valueOf() 返回 Boolean 对象的原始值。 4.3.3 Date对象 和JAVA中的Date类比较类似 方法 描述 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getYear() 已废弃。 请使用 getFullYear() 方法代替。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setTime() setTime() 方法以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCSeconds() setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。 setYear() 已废弃。请使用 setFullYear() 方法代替。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 已废弃。请使用 toUTCString() 方法代替。 toISOString() 使用 ISO 标准返回字符串的日期格式。 toJSON() 以 JSON 数据格式返回日期字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toUTCString() 根据世界时，把 Date 对象转换为字符串。实例：var today = new Date(); var UTCstring = today.toUTCString(); UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 4.3.4 Math 和JAVA中的Math类比较类似 方法 描述 abs(x) 返回 x 的绝对值。 acos(x) 返回 x 的反余弦值。 asin(x) 返回 x 的反正弦值。 atan(x) 以介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 Ex 的指数。 floor(x) 对 x 进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y,z,…,n) 返回 x,y,z,…,n 中的最高值。 min(x,y,z,…,n) 返回 x,y,z,…,n中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 四舍五入。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 tanh(x) 返回一个数的双曲正切函数值。 trunc(x) 将数字的小数部分去掉，只保留整数部分。 4.3.5 Number Number中准备了一些基础的数据处理函数 方法 描述 isFinite 检测指定参数是否为无穷大。 isInteger 检测指定参数是否为整数。 isNaN 检测指定参数是否为 NaN。 isSafeInteger 检测指定参数是否为安全整数。 toExponential(x) 把对象的值转换为指数计数法。 toFixed(x) 把数字转换为字符串，结果的小数点后有指定位数的数字。 toLocaleString(locales, options) 返回数字在特定语言环境下的表示字符串。 toPrecision(x) 把数字格式化为指定的长度。 toString() 把数字转换为字符串，使用指定的基数。 valueOf() 返回一个 Number 对象的基本数字值。 4.3.6 String 和JAVA中的String类似 方法 描述 charAt() 返回在指定位置的字符。 charCodeAt() 返回在指定的位置的字符的 Unicode 编码。 concat() 连接两个或更多字符串，并返回新的字符串。 endsWith() 判断当前字符串是否是以指定的子字符串结尾的（区分大小写）。 fromCharCode() 将 Unicode 编码转为字符。 indexOf() 返回某个指定的字符串值在字符串中首次出现的位置。 includes() 查找字符串中是否包含指定的子字符串。 lastIndexOf() 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 match() 查找找到一个或多个正则表达式的匹配。 repeat() 复制字符串指定次数，并将它们连接在一起返回。 replace() 在字符串中查找匹配的子串，并替换与正则表达式匹配的子串。 replaceAll() 在字符串中查找匹配的子串，并替换与正则表达式匹配的所有子串。 search() 查找与正则表达式相匹配的值。 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。 split() 把字符串分割为字符串数组。 startsWith() 查看字符串是否以指定的子字符串开头。 substr() 从起始索引号提取字符串中指定数目的字符。 substring() 提取字符串中两个指定的索引号之间的字符。 toLowerCase() 把字符串转换为小写。 toUpperCase() 把字符串转换为大写。 trim() 去除字符串两边的空白。 toLocaleLowerCase() 根据本地主机的语言环境把字符串转换为小写。 toLocaleUpperCase() 根据本地主机的语言环境把字符串转换为大写。 valueOf() 返回某个字符串对象的原始值。 toString() 返回一个字符串。 五 事件的绑定5.1 什么是事件 HTML 事件可以是浏览器行为，也可以是用户行为。 当这些一些行为发生时,可以自动触发对应的JS函数的运行,我们称之为事件发生.JS的事件驱动指的就是行为触发代码运行的这种特点 5.2 常见事件 鼠标事件 属性 描述 onclick 当用户点击某个对象时调用的事件句柄。 oncontextmenu 在用户点击鼠标右键打开上下文菜单时触发 ondblclick 当用户双击某个对象时调用的事件句柄。 onmousedown 鼠标按钮被按下。 onmouseenter 当鼠标指针移动到元素上时触发。 onmouseleave 当鼠标指针移出元素时触发 onmousemove 鼠标被移动。 onmouseover 鼠标移到某元素之上。 onmouseout 鼠标从某元素移开。 onmouseup 鼠标按键被松开。 键盘事件 属性 描述 onkeydown 某个键盘按键被按下。 onkeypress 某个键盘按键被按下并松开。 onkeyup 某个键盘按键被松开。 表单事件 属性 描述 onblur 元素失去焦点时触发 onchange 该事件在表单元素的内容改变时触发( , , , 和 ) onfocus 元素获取焦点时触发 onfocusin 元素即将获取焦点时触发 onfocusout 元素即将失去焦点时触发 oninput 元素获取用户输入时触发 onreset 表单重置时触发 onsearch 用户向搜索域输入文本时触发 ( &lt;input&#x3D;”search”&gt;) onselect 用户选取文本时触发 ( 和 ) onsubmit 表单提交时触发 5.3 事件的绑定 通过属性绑定 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小标题&lt;/title&gt; &lt;script&gt; function testDown1()&#123; console.log(&quot;down1&quot;) &#125; function testDown2()&#123; console.log(&quot;down2&quot;) &#125; function testFocus()&#123; console.log(&quot;获得焦点&quot;) &#125; function testBlur()&#123; console.log(&quot;失去焦点&quot;) &#125; function testChange(input)&#123; console.log(&quot;内容改变&quot;) console.log(input.value); &#125; function testMouseOver()&#123; console.log(&quot;鼠标悬停&quot;) &#125; function testMouseLeave()&#123; console.log(&quot;鼠标离开&quot;) &#125; function testMouseMove()&#123; console.log(&quot;鼠标移动&quot;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; onkeydown=&quot;testDown1(),testDown2()&quot; onfocus=&quot;testFocus()&quot; onblur=&quot;testBlur()&quot; onchange=&quot;testChange(this)&quot; onmouseover=&quot;testMouseOver()&quot; onmouseleave=&quot;testMouseLeave()&quot; onmousemove=&quot;testMouseMove()&quot; /&gt;&lt;/body&gt; 说明 通过事件属性绑定函数,在行为发生时会自动执行函数 一个事件可以同时绑定多个函数 一个元素可以同时绑定多个事件 方法中可以传入 this对象,代表当前元素 通过DOM编程绑定 123456789101112131415161718192021&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小标题&lt;/title&gt; &lt;script&gt; // 页面加载完毕事件,浏览器加载完整个文档行为 window.onload=function()&#123; var in1 =document.getElementById(&quot;in1&quot;); // 通过DOM编程绑定事件 in1.onchange=testChange &#125; function testChange()&#123; console.log(&quot;内容改变&quot;) console.log(event.target.value); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;in1&quot; type=&quot;text&quot; /&gt;&lt;/body&gt; 5.4 事件的触发 行为触发 发生行为时触发,演示:略 DOM编程触发 通过DOM编程,用代码触发,执行某些代码相当于发生了某些行为 代码 123456789101112131415161718192021222324252627282930&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小标题&lt;/title&gt; &lt;script&gt; // 页面加载完毕事件,浏览器加载完整个文档行为 window.onload=function()&#123; var in1 =document.getElementById(&quot;in1&quot;); // 通过DOM编程绑定事件 in1.onchange=testChange var btn1 =document.getElementById(&quot;btn1&quot;); btn1.onclick=function ()&#123; console.log(&quot;按钮点击了&quot;) // 调用事件方法触发事件 in1.onchange() &#125; &#125; function testChange()&#123; console.log(&quot;内容改变&quot;) console.log(event.target.value); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;in1&quot; type=&quot;text&quot; /&gt; &lt;br&gt; &lt;button id=&quot;btn1&quot;&gt;按钮&lt;/button&gt;&lt;/body&gt; 六 BOM编程6.1 什么是BOM BOM是Browser Object Model的简写，即浏览器对象模型。 BOM由一系列对象组成，是访问、控制、修改浏览器的属性和方法(通过window对象及属性的一系列方法 控制浏览器行为的一种编程) BOM没有统一的标准(每种客户端都可以自定标准)。 BOM编程是将浏览器窗口的各个组成部分抽象成各个对象,通过各个对象的API操作组件行为的一种编程 BOM编程的对象结构如下 window 顶级对象,代表整个浏览器窗口 location对象 window对象的属性之一,代表浏览器的地址栏 history对象 window对象的属性之一,代表浏览器的访问历史 screen对象 window对象的属性之一,代表屏幕 navigator对象 window对象的属性之一,代表浏览器软件本身 document对象 window对象的属性之一,代表浏览器窗口目前解析的html文档 console对象 window对象的属性之一,代表浏览器开发者工具的控制台 localStorage对象 window对象的属性之一,代表浏览器的本地数据持久化存储 sessionStorage对象 window对象的属性之一,代表浏览器的本地数据会话级存储 6.2 window对象的常见属性(了解) 属性 描述 closed 返回窗口是否已被关闭。 defaultStatus 设置或返回窗口状态栏中的默认文本。 document 对 Document 对象的只读引用。(请参阅对象) frames 返回窗口中所有命名的框架。该集合是 Window 对象的数组，每个 Window 对象在窗口中含有一个框架。 history 对 History 对象的只读引用。请参数 History 对象。 innerHeight 返回窗口的文档显示区的高度。 innerWidth 返回窗口的文档显示区的宽度。 localStorage 在浏览器中存储 key&#x2F;value 对。没有过期时间。 length 设置或返回窗口中的框架数量。 location 用于窗口或框架的 Location 对象。请参阅 Location 对象。 name 设置或返回窗口的名称。 navigator 对 Navigator 对象的只读引用。请参数 Navigator 对象。 opener 返回对创建此窗口的窗口的引用。 outerHeight 返回窗口的外部高度，包含工具条与滚动条。 outerWidth 返回窗口的外部宽度，包含工具条与滚动条。 pageXOffset 设置或返回当前页面相对于窗口显示区左上角的 X 位置。 pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。 parent 返回父窗口。 screen 对 Screen 对象的只读引用。请参数 Screen 对象。 screenLeft 返回相对于屏幕窗口的x坐标 screenTop 返回相对于屏幕窗口的y坐标 screenX 返回相对于屏幕窗口的x坐标 sessionStorage 在浏览器中存储 key&#x2F;value 对。 在关闭窗口或标签页之后将会删除这些数据。 screenY 返回相对于屏幕窗口的y坐标 self 返回对当前窗口的引用。等价于 Window 属性。 status 设置窗口状态栏的文本。 top 返回最顶层的父窗口。 6.3 window对象的常见方法(了解) 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框。 atob() 解码一个 base-64 编码的字符串。 btoa() 创建一个 base-64 编码的字符串。 blur() 把键盘焦点从顶层窗口移开。 clearInterval() 取消由 setInterval() 设置的 timeout。 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 close() 关闭浏览器窗口。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 createPopup() 创建一个 pop-up 窗口。 focus() 把键盘焦点给予一个窗口。 getSelection() 返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置。 getComputedStyle() 获取指定元素的 CSS 样式。 matchMedia() 该方法用来检查 media query 语句，它返回一个 MediaQueryList对象。 moveBy() 可相对窗口的当前坐标把它移动指定的像素。 moveTo() 把窗口的左上角移动到一个指定的坐标。 open() 打开一个新的浏览器窗口或查找一个已命名的窗口。 print() 打印当前窗口的内容。 prompt() 显示可提示用户输入的对话框。 resizeBy() 按照指定的像素调整窗口的大小。 resizeTo() 把窗口的大小调整到指定的宽度和高度。 scroll() 已废弃。 该方法已经使用了 scrollTo() 方法来替代。 scrollBy() 按照指定的像素值来滚动内容。 scrollTo() 把内容滚动到指定的坐标。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 stop() 停止页面载入。 postMessage() 安全地实现跨源通信。 6.4 通过BOM编程控制浏览器行为演示 三种弹窗方式 12345678910111213141516171819202122232425262728293031&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小标题&lt;/title&gt; &lt;script&gt; function testAlert()&#123; //普通信息提示框 window.alert(&quot;提示信息&quot;); &#125; function testConfirm()&#123; //确认框 var con =confirm(&quot;确定要删除吗?&quot;); if(con)&#123; alert(&quot;点击了确定&quot;) &#125;else&#123; alert(&quot;点击了取消&quot;) &#125; &#125; function testPrompt()&#123; //信息输入对话框 var res =prompt(&quot;请输入昵称&quot;,&quot;例如:张三&quot;); alert(&quot;您输入的是:&quot;+res) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;提示框&quot; onclick=&quot;testAlert()&quot;/&gt; &lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;确认框&quot; onclick=&quot;testConfirm()&quot;/&gt; &lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;对话框&quot; onclick=&quot;testPrompt()&quot;/&gt; &lt;br&gt;&lt;/body&gt; 页面跳转 12345678910111213141516171819&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小标题&lt;/title&gt; &lt;script&gt; function goAtguigu()&#123; var flag =confirm(&quot;即将跳转到尚硅谷官网,本页信息即将丢失,确定吗?&quot;) if(flag)&#123; // 通过BOM编程地址栏url切换 window.location.href=&quot;http://www.atguigu.com&quot; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;跳转到尚硅谷&quot; onclick=&quot;goAtguigu()&quot;/&gt; &lt;br&gt;&lt;/body&gt; 6.5 通过BOM编程实现会话级和持久级数据存储 会话级数据 : 内存型数据,是浏览器在内存上临时存储的数据,浏览器关闭后,数据失去,通过window的sessionStorge属性实现 持久级数据 : 磁盘型数据,是浏览器在磁盘上持久存储的数据,浏览器关闭后,数据仍在,通过window的localStorge实现 可以用于将来存储一些服务端响应回来的数据,比如:token令牌,或者一些其他功能数据,根据数据的业务范围我们可以选择数据存储的会话&#x2F;持久 级别 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function saveItem()&#123; // 让浏览器存储一些会话级数据 window.sessionStorage.setItem(&quot;sessionMsg&quot;,&quot;sessionValue&quot;) // 让浏览器存储一些持久级数据 window.localStorage.setItem(&quot;localMsg&quot;,&quot;localValue&quot;) console.log(&quot;haha&quot;) &#125; function removeItem()&#123; // 删除数据 sessionStorage.removeItem(&quot;sessionMsg&quot;) localStorage.removeItem(&quot;localMsg&quot;) &#125; function readItem()&#123; console.log(&quot;read&quot;) // 读取数据 console.log(&quot;session:&quot;+sessionStorage.getItem(&quot;sessionMsg&quot;)) console.log(&quot;local:&quot;+localStorage.getItem(&quot;localMsg&quot;)) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;saveItem()&quot;&gt;存储数据&lt;/button&gt; &lt;button onclick=&quot;removeItem()&quot;&gt;删除数据&lt;/button&gt; &lt;button onclick=&quot;readItem()&quot;&gt;读取数据&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 测试,存储数据后,再读取数据,然后关闭浏览器,获取数据,发现sessionStorge的数据没有了,localStorge的数据还在 通过removeItem可以将这些数据直接删除 在F12开发者工具的应用程序栏,可以查看数据的状态 七 DOM编程7.1 什么是DOM编程 简单来说:DOM(Document Object Model)编程就是使用document对象的API完成对网页HTML文档进行动态修改,以实现网页数据和样式动态变化效果的编程. document对象代表整个html文档，可用来访问页面中的所有元素，是最复杂的一个dom对象，可以说是学习好dom编程的关键所在。 根据HTML代码结构特点,document对象本身是一种树形结构的文档对象。 上面的代码生成的树如下 DOM编程其实就是用window对象的document属性的相关API完成对页面元素的控制的编程 dom树中节点的类型 node 节点,所有结点的父类型 element 元素节点,node的子类型之一,代表一个完整标签 attribute 属性节点,node的子类型之一,代表元素的属性 text 文本节点,node的子类型之一,代表双标签中间的文本 7.2 获取页面元素的几种方式7.2.1 在整个文档范围内查找元素结点 功能 API 返回值 根据id值查询 document.getElementById(“id值”) 一个具体的元素节 根据标签名查询 document.getElementsByTagName(“标签名”) 元素节点数组 根据name属性值查询 document.getElementsByName(“name值”) 元素节点数组 根据类名查询 document.getElementsByClassName(“类名”) 元素节点数组 7.2.2 在具体元素节点范围内查找子节点 功能 API 返回值 查找子标签 element.children 返回子标签数组 查找第一个子标签 element.firstElementChild 标签对象 查找最后一个子标签 element.lastElementChild 节点对象 7.2.3 查找指定子元素节点的父节点 功能 API 返回值 查找指定元素节点的父标签 element.parentElement 标签对象 7.2.4 查找指定元素节点的兄弟节点 功能 API 返回值 查找前一个兄弟标签 node.previousElementSibling 标签对象 查找后一个兄弟标签 node.nextElementSibling 标签对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 1 获得document dom树 window.document 2 从document中获取要操作的元素 1. 直接获取 var el1 =document.getElementById(&quot;username&quot;) // 根据元素的id值获取页面上唯一的一个元素 var els =document.getElementsByTagName(&quot;input&quot;) // 根据元素的标签名获取多个同名元素 var els =document.getElementsByName(&quot;aaa&quot;) // 根据元素的name属性值获得多个元素 var els =document.getElementsByClassName(&quot;a&quot;) // 根据元素的class属性值获得多个元素 2. 间接获取 var cs=div01.children // 通过父元素获取全部的子元素 var firstChild =div01.firstElementChild // 通过父元素获取第一个子元素 var lastChild = div01.lastElementChild // 通过父元素获取最后一个子元素 var parent = pinput.parentElement // 通过子元素获取父元素 var pElement = pinput.previousElementSibling // 获取前面的第一个元素 var nElement = pinput.nextElementSibling // 获取后面的第一个元素 3 对元素进行操作 1. 操作元素的属性 2. 操作元素的样式 3. 操作元素的文本 4. 增删元素 */ function fun1()&#123; //1 获得document //2 通过document获得元素 var el1 =document.getElementById(&quot;username&quot;) // 根据元素的id值获取页面上唯一的一个元素 console.log(el1) &#125; function fun2()&#123; var els =document.getElementsByTagName(&quot;input&quot;) // 根据元素的标签名获取多个同名元素 for(var i = 0 ;i&lt;els.length;i++)&#123; console.log(els[i]) &#125; &#125; function fun3()&#123; var els =document.getElementsByName(&quot;aaa&quot;) // 根据元素的name属性值获得多个元素 console.log(els) for(var i =0;i&lt; els.length;i++)&#123; console.log(els[i]) &#125; &#125; function fun4()&#123; var els =document.getElementsByClassName(&quot;a&quot;) // 根据元素的class属性值获得多个元素 for(var i =0;i&lt; els.length;i++)&#123; console.log(els[i]) &#125; &#125; function fun5()&#123; // 先获取父元素 var div01 = document.getElementById(&quot;div01&quot;) // 获取所有子元素 var cs=div01.children // 通过父元素获取全部的子元素 for(var i =0;i&lt; cs.length;i++)&#123; console.log(cs[i]) &#125; console.log(div01.firstElementChild) // 通过父元素获取第一个子元素 console.log(div01.lastElementChild) // 通过父元素获取最后一个子元素 &#125; function fun6()&#123; // 获取子元素 var pinput =document.getElementById(&quot;password&quot;) console.log(pinput.parentElement) // 通过子元素获取父元素 &#125; function fun7()&#123; // 获取子元素 var pinput =document.getElementById(&quot;password&quot;) console.log(pinput.previousElementSibling) // 获取前面的第一个元素 console.log(pinput.nextElementSibling) // 获取后面的第一个元素 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div01&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;a&quot; id=&quot;username&quot; name=&quot;aaa&quot;/&gt; &lt;input type=&quot;text&quot; class=&quot;b&quot; id=&quot;password&quot; name=&quot;aaa&quot;/&gt; &lt;input type=&quot;text&quot; class=&quot;a&quot; id=&quot;email&quot;/&gt; &lt;input type=&quot;text&quot; class=&quot;b&quot; id=&quot;address&quot;/&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;a&quot;/&gt;&lt;br&gt; &lt;hr&gt; &lt;input type=&quot;button&quot; value=&quot;通过父元素获取子元素&quot; onclick=&quot;fun5()&quot; id=&quot;btn05&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;通过子元素获取父元素&quot; onclick=&quot;fun6()&quot; id=&quot;btn06&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;通过当前元素获取兄弟元素&quot; onclick=&quot;fun7()&quot; id=&quot;btn07&quot;/&gt; &lt;hr&gt; &lt;input type=&quot;button&quot; value=&quot;根据id获取指定元素&quot; onclick=&quot;fun1()&quot; id=&quot;btn01&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;根据标签名获取多个元素&quot; onclick=&quot;fun2()&quot; id=&quot;btn02&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;根据name属性值获取多个元素&quot; onclick=&quot;fun3()&quot; id=&quot;btn03&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;根据class属性值获得多个元素&quot; onclick=&quot;fun4()&quot; id=&quot;btn04&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 7.3 操作元素属性值7.3.1 属性操作 需求 操作方式 读取属性值 元素对象.属性名 修改属性值 元素对象.属性名&#x3D;新的属性值 7.3.2 内部文本操作 需求 操作方式 获取或者设置标签体的文本内容 element.innerText 获取或者设置标签体的内容 element.innerHTML 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 1 获得document dom树 window.document 2 从document中获取要操作的元素 1. 直接获取 var el1 =document.getElementById(&quot;username&quot;) // 根据元素的id值获取页面上唯一的一个元素 var els =document.getElementsByTagName(&quot;input&quot;) // 根据元素的标签名获取多个同名元素 var els =document.getElementsByName(&quot;aaa&quot;) // 根据元素的name属性值获得多个元素 var els =document.getElementsByClassName(&quot;a&quot;) // 根据元素的class属性值获得多个元素 2. 间接获取 var cs=div01.children // 通过父元素获取全部的子元素 var firstChild =div01.firstElementChild // 通过父元素获取第一个子元素 var lastChild = div01.lastElementChild // 通过父元素获取最后一个子元素 var parent = pinput.parentElement // 通过子元素获取父元素 var pElement = pinput.previousElementSibling // 获取前面的第一个元素 var nElement = pinput.nextElementSibling // 获取后面的第一个元素 3 对元素进行操作 1. 操作元素的属性 元素名.属性名=&quot;&quot; 2. 操作元素的样式 元素名.style.样式名=&quot;&quot; 样式名&quot;-&quot; 要进行驼峰转换 3. 操作元素的文本 元素名.innerText 只识别文本 元素名.innerHTML 同时可以识别html代码 4. 增删元素 */ function changeAttribute()&#123; var in1 =document.getElementById(&quot;in1&quot;) // 语法 元素.属性名=&quot;&quot; // 获得属性值 console.log(in1.type) console.log(in1.value) // 修改属性值 in1.type=&quot;button&quot; in1.value=&quot;嗨&quot; &#125; function changeStyle()&#123; var in1 =document.getElementById(&quot;in1&quot;) // 语法 元素.style.样式名=&quot;&quot; 原始样式名中的&quot;-&quot;符号 要转换驼峰式 background-color &gt; backgroundColor in1.style.color=&quot;green&quot; in1.style.borderRadius=&quot;5px&quot; &#125; function changeText()&#123; var div01 =document.getElementById(&quot;div01&quot;) /* 语法 元素名.innerText 只识别文本 元素名.innerHTML 同时可以识别html代码 */ console.log(div01.innerText) div01.innerHTML=&quot;&lt;h1&gt;嗨&lt;/h1&gt;&quot; &#125; &lt;/script&gt; &lt;style&gt; #in1&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;in1&quot; type=&quot;text&quot; value=&quot;hello&quot;&gt; &lt;div id=&quot;div01&quot;&gt; hello &lt;/div&gt; &lt;hr&gt; &lt;button onclick=&quot;changeAttribute()&quot;&gt;操作属性&lt;/button&gt; &lt;button onclick=&quot;changeStyle()&quot;&gt;操作样式&lt;/button&gt; &lt;button onclick=&quot;changeText()&quot;&gt;操作文本&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 7.4 增删元素7.4.1 对页面的元素进行增删操作 API 功能 document.createElement(“标签名”) 创建元素节点并返回，但不会自动添加到文档中 document.createTextNode(“文本值”) 创建文本节点并返回，但不会自动添加到文档中 element.appendChild(ele) 将ele添加到element所有子节点后面 parentEle.insertBefore(newEle,targetEle) 将newEle插入到targetEle前面 parentEle.replaceChild(newEle, oldEle) 用新节点替换原有的旧子节点 element.remove() 删除某个标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; /* 1 获得document dom树 window.document 2 从document中获取要操作的元素 1. 直接获取 var el1 =document.getElementById(&quot;username&quot;) // 根据元素的id值获取页面上唯一的一个元素 var els =document.getElementsByTagName(&quot;input&quot;) // 根据元素的标签名获取多个同名元素 var els =document.getElementsByName(&quot;aaa&quot;) // 根据元素的name属性值获得多个元素 var els =document.getElementsByClassName(&quot;a&quot;) // 根据元素的class属性值获得多个元素 2. 间接获取 var cs=div01.children // 通过父元素获取全部的子元素 var firstChild =div01.firstElementChild // 通过父元素获取第一个子元素 var lastChild = div01.lastElementChild // 通过父元素获取最后一个子元素 var parent = pinput.parentElement // 通过子元素获取父元素 var pElement = pinput.previousElementSibling // 获取前面的第一个元素 var nElement = pinput.nextElementSibling // 获取后面的第一个元素 3 对元素进行操作 1. 操作元素的属性 元素名.属性名=&quot;&quot; 2. 操作元素的样式 元素名.style.样式名=&quot;&quot; 样式名&quot;-&quot; 要进行驼峰转换 3. 操作元素的文本 元素名.innerText 只识别文本 元素名.innerHTML 同时可以识别html代码 4. 增删元素 var element =document.createElement(&quot;元素名&quot;) // 创建元素 父元素.appendChild(子元素) // 在父元素中追加子元素 父元素.insertBefore(新元素,参照元素) // 在某个元素前增加元素 父元素.replaceChild(新元素,被替换的元素) // 用新的元素替换某个子子元素 元素.remove() // 删除当前元素 */ function addCs()&#123; // 创建一个新的元素 // 创建元素 var csli =document.createElement(&quot;li&quot;) // &lt;li&gt;&lt;/li&gt; // 设置子元素的属性和文本 &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt; csli.id=&quot;cs&quot; csli.innerText=&quot;长沙&quot; // 将子元素放入父元素中 var cityul =document.getElementById(&quot;city&quot;) // 在父元素中追加子元素 cityul.appendChild(csli) &#125; function addCsBeforeSz()&#123; // 创建一个新的元素 // 创建元素 var csli =document.createElement(&quot;li&quot;) // &lt;li&gt;&lt;/li&gt; // 设置子元素的属性和文本 &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt; csli.id=&quot;cs&quot; csli.innerText=&quot;长沙&quot; // 将子元素放入父元素中 var cityul =document.getElementById(&quot;city&quot;) // 在父元素中追加子元素 //cityul.insertBefore(新元素,参照元素) var szli =document.getElementById(&quot;sz&quot;) cityul.insertBefore(csli,szli) &#125; function replaceSz()&#123; // 创建一个新的元素 // 创建元素 var csli =document.createElement(&quot;li&quot;) // &lt;li&gt;&lt;/li&gt; // 设置子元素的属性和文本 &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt; csli.id=&quot;cs&quot; csli.innerText=&quot;长沙&quot; // 将子元素放入父元素中 var cityul =document.getElementById(&quot;city&quot;) // 在父元素中追加子元素 //cityul.replaceChild(新元素,被替换的元素) var szli =document.getElementById(&quot;sz&quot;) cityul.replaceChild(csli,szli) &#125; function removeSz()&#123; var szli =document.getElementById(&quot;sz&quot;) // 哪个元素调用了remove该元素就会从dom树中移除 szli.remove() &#125; function clearCity()&#123; var cityul =document.getElementById(&quot;city&quot;) /* var fc =cityul.firstChild while(fc != null )&#123; fc.remove() fc =cityul.firstChild &#125; */ cityul.innerHTML=&quot;&quot; //cityul.remove() &#125; &lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;city&quot;&gt; &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt; &lt;li id=&quot;sh&quot;&gt;上海&lt;/li&gt; &lt;li id=&quot;sz&quot;&gt;深圳&lt;/li&gt; &lt;li id=&quot;gz&quot;&gt;广州&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;!-- 目标1 在城市列表的最后添加一个子标签 &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt; --&gt; &lt;button onclick=&quot;addCs()&quot;&gt;增加长沙&lt;/button&gt; &lt;!-- 目标2 在城市列表的深圳前添加一个子标签 &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt; --&gt; &lt;button onclick=&quot;addCsBeforeSz()&quot;&gt;在深圳前插入长沙&lt;/button&gt; &lt;!-- 目标3 将城市列表的深圳替换为 &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt; --&gt; &lt;button onclick=&quot;replaceSz()&quot;&gt;替换深圳&lt;/button&gt; &lt;!-- 目标4 将城市列表删除深圳 --&gt; &lt;button onclick=&quot;removeSz()&quot;&gt;删除深圳&lt;/button&gt; &lt;!-- 目标5 清空城市列表 --&gt; &lt;button onclick=&quot;clearCity()&quot;&gt;清空&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 八 正则表达式8.1 正则表达式简介 正则表达式是描述字符模式的对象。正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。 语法 123var patt=new RegExp(pattern,modifiers);或者更简单的方式:var patt=/pattern/modifiers; 修饰符 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 方括号 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 (red|blue|green) 查找任何指定的选项。 元字符 元字符 描述 . 查找单个字符，除了换行和行结束符。 \\w 查找数字、字母及下划线。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NULL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。例如，&#x2F;a+&#x2F; 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。 n* 匹配任何包含零个或多个 n 的字符串。例如，&#x2F;bo*&#x2F; 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。 n? 匹配任何包含零个或一个 n 的字符串。例如，&#x2F;e?le?&#x2F; 匹配 “angel” 中的 “el”，”angle” 中的 “le”。 n{X} 匹配包含 X 个 n 的序列的字符串。例如，&#x2F;a{2}&#x2F; 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。 n{X,} X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，&#x2F;a{2,}&#x2F; 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。 n{X,Y} X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，&#x2F;a{1,3}&#x2F; 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?&#x3D;n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 RegExp对象方法 方法 描述 compile 在 1.5 版本中已废弃。 编译正则表达式。 exec 检索字符串中指定的值。返回找到的值，并确定其位置。 test 检索字符串中指定的值。返回 true 或 false。 toString 返回正则表达式的字符串。 支持正则的String的方法 方法 描述 search 检索与正则表达式相匹配的值。 match 找到一个或多个正则表达式的匹配。 replace 替换与正则表达式匹配的子串。 split 把字符串分割为字符串数组。 8.2 正则表达式体验8.2.1 验证注意：这里是使用正则表达式对象来调用方法。 123456// 创建一个最简单的正则表达式对象var reg = /o/;// 创建一个字符串对象作为目标字符串var str = &#x27;Hello World!&#x27;;// 调用正则表达式对象的test()方法验证目标字符串是否满足我们指定的这个模式，返回结果trueconsole.log(&quot;/o/.test(&#x27;Hello World!&#x27;)=&quot;+reg.test(str)); 8.2.2 匹配1234567891011// 创建一个最简单的正则表达式对象var reg = /o/;// 创建一个字符串对象作为目标字符串var str = &#x27;Hello World!&#x27;;// 在目标字符串中查找匹配的字符，返回匹配结果组成的数组var resultArr = str.match(reg);// 数组长度为1console.log(&quot;resultArr.length=&quot;+resultArr.length);// 数组内容是oconsole.log(&quot;resultArr[0]=&quot;+resultArr[0]); 8.2.3 替换注意：这里是使用字符串对象来调用方法。 12345678910// 创建一个最简单的正则表达式对象var reg = /o/;// 创建一个字符串对象作为目标字符串var str = &#x27;Hello World!&#x27;;var newStr = str.replace(reg,&#x27;@&#x27;);// 只有第一个o被替换了，说明我们这个正则表达式只能匹配第一个满足的字符串console.log(&quot;str.replace(reg)=&quot;+newStr);//Hell@ World!// 原字符串并没有变化，只是返回了一个新字符串console.log(&quot;str=&quot;+str);//str=Hello World! 8.2.4 全文查找如果不使用g对正则表达式对象进行修饰，则使用正则表达式进行查找时，仅返回第一个匹配；使用g后，返回所有匹配。 12345678910111213// 目标字符串var targetStr = &#x27;Hello World!&#x27;;// 没有使用全局匹配的正则表达式var reg = /[A-Z]/;// 获取全部匹配var resultArr = targetStr.match(reg);// 数组长度为1console.log(&quot;resultArr.length=&quot;+resultArr.length);// 遍历数组，发现只能得到&#x27;H&#x27;for(var i = 0; i &lt; resultArr.length; i++)&#123; console.log(&quot;resultArr[&quot;+i+&quot;]=&quot;+resultArr[i]);&#125; 对比 123456789101112// 目标字符串var targetStr = &#x27;Hello World!&#x27;;// 使用了全局匹配的正则表达式var reg = /[A-Z]/g;// 获取全部匹配var resultArr = targetStr.match(reg);// 数组长度为2console.log(&quot;resultArr.length=&quot;+resultArr.length);// 遍历数组，发现可以获取到“H”和“W”for(var i = 0; i &lt; resultArr.length; i++)&#123; console.log(&quot;resultArr[&quot;+i+&quot;]=&quot;+resultArr[i]);&#125; 8.2.5 忽略大小写12345678910111213//目标字符串var targetStr = &#x27;Hello WORLD!&#x27;;//没有使用忽略大小写的正则表达式var reg = /o/g;//获取全部匹配var resultArr = targetStr.match(reg);//数组长度为1console.log(&quot;resultArr.length=&quot;+resultArr.length);//遍历数组，仅得到&#x27;o&#x27;for(var i = 0; i &lt; resultArr.length; i++)&#123; console.log(&quot;resultArr[&quot;+i+&quot;]=&quot;+resultArr[i]);&#125; 对比 123456789101112//目标字符串var targetStr = &#x27;Hello WORLD!&#x27;;//使用了忽略大小写的正则表达式var reg = /o/gi;//获取全部匹配var resultArr = targetStr.match(reg);//数组长度为2console.log(&quot;resultArr.length=&quot;+resultArr.length);//遍历数组，得到&#x27;o&#x27;和&#x27;O&#x27;for(var i = 0; i &lt; resultArr.length; i++)&#123; console.log(&quot;resultArr[&quot;+i+&quot;]=&quot;+resultArr[i]);&#125; 8.2.6 元字符使用1234567var str01 = &#x27;I love Java&#x27;;var str02 = &#x27;Java love me&#x27;;// 匹配以Java开头var reg = /^Java/g;console.log(&#x27;reg.test(str01)=&#x27;+reg.test(str01)); // falseconsole.log(&quot;&lt;br /&gt;&quot;);console.log(&#x27;reg.test(str02)=&#x27;+reg.test(str02)); // true 1234567var str01 = &#x27;I love Java&#x27;;var str02 = &#x27;Java love me&#x27;;// 匹配以Java结尾var reg = /Java$/g;console.log(&#x27;reg.test(str01)=&#x27;+reg.test(str01)); // trueconsole.log(&quot;&lt;br /&gt;&quot;);console.log(&#x27;reg.test(str02)=&#x27;+reg.test(str02)); // false 8.2.7 字符集合的使用12345//n位数字的正则var targetStr=&quot;123456789&quot;;var reg=/^[0-9]&#123;0,&#125;$/;//或者 ： var reg=/^\\d*$/;var b = reg.test(targetStr);//true 1234//数字+字母+下划线，6-16位var targetStr=&quot;HelloWorld&quot;;var reg=/^[a-z0-9A-Z_]&#123;6,16&#125;$/;var b = reg.test(targetStr);//true 8.2.8 常用正则表达式 需求 正则表达式 用户名 &#x2F;^[a-zA-Z ][a-zA-Z-0-9]{5,9}$&#x2F; 密码 &#x2F;^[a-zA-Z0-9 _-@#&amp; *]{6,12}$&#x2F; 前后空格 &#x2F;^\\s+|\\s+$&#x2F;g 电子邮箱 &#x2F;^[a-zA-Z0-9 _.-]+@([a-zA-Z0-9-]+[.]{1})+[a-zA-Z]+$&#x2F; 九 案例开发-日程管理-第一期9.1 登录页及校验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 500px; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; #usernameMsg , #userPwdMsg &#123; color: rgb(230, 87, 51); &#125; .buttonContainer&#123; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; // 检验用户名格式是否合法的函数 function checkUsername()&#123; // 定义正则表示字符串的规则 var usernameReg= /^[a-zA-Z0-9]&#123;5,10&#125;$/ // 获得用户在页面上输入的信息 var usernameInput =document.getElementById(&quot;usernameInput&quot;) var username = usernameInput.value // 获得格式提示的框 var usernameMsg =document.getElementById(&quot;usernameMsg&quot;) // 格式有误时,返回false,在页面上提示 if(!usernameReg.test(username))&#123; usernameMsg.innerText=&quot;用户名格式有误&quot; return false &#125; // 格式OK,返回true 在页面上提示OK usernameMsg.innerText=&quot;OK&quot; return true &#125; // 检验密码格式是否合法的函数 function checkUserPwd()&#123; // 定义正则表示字符串的规则 var userPwdReg= /^[0-9]&#123;6&#125;$/ // 获得用户在页面上输入的信息 var userPwdInput =document.getElementById(&quot;userPwdInput&quot;) var userPwd = userPwdInput.value // 获得格式提示的框 var userPwdMsg =document.getElementById(&quot;userPwdMsg&quot;) // 格式有误时,返回false,在页面上提示 if(!userPwdReg.test(userPwd))&#123; userPwdMsg.innerText=&quot;密码必须是6位数字&quot; return false &#125; // 格式OK,返回true 在页面上提示OK userPwdMsg.innerText=&quot;OK&quot; return true &#125; // 表单在提交时,校验用户名和密码格式,格式OK才会提交 function checkForm()&#123; var flag1 =checkUsername() var flag2 =checkUserPwd() return flag1&amp;&amp;flag2 &#125; &lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt; &lt;h3 class=&quot;ht&quot;&gt;请登录&lt;/h3&gt; &lt;form method=&quot;post&quot; action=&quot;/user/login&quot; onsubmit=&quot;return checkForm()&quot;&gt; &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入账号&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; type=&quot;text&quot; id=&quot;usernameInput&quot; name=&quot;username&quot; onblur=&quot;checkUsername()&quot;&gt; &lt;span id=&quot;usernameMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; type=&quot;password&quot; id=&quot;userPwdInput&quot; name=&quot;userPwd&quot; onblur=&quot;checkUserPwd()&quot;&gt; &lt;span id=&quot;userPwdMsg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;&lt;a href=&quot;regist.html&quot;&gt;去注册&lt;/a&gt;&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 9.2 注册页及校验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .ht&#123; text-align: center; color: cadetblue; font-family: 幼圆; &#125; .tab&#123; width: 500px; border: 5px solid cadetblue; margin: 0px auto; border-radius: 5px; font-family: 幼圆; &#125; .ltr td&#123; border: 1px solid powderblue; &#125; .ipt&#123; border: 0px; width: 50%; &#125; .btn1&#123; border: 2px solid powderblue; border-radius: 4px; width:60px; background-color: antiquewhite; &#125; .msg &#123; color: gold; &#125; .buttonContainer&#123; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; function checkUsername()&#123; var usernameReg = /^[a-zA-Z0-9]&#123;5,10&#125;$/ var usernameInput = document.getElementById(&quot;usernameInput&quot;) var username = usernameInput.value var usernameMsg = document.getElementById(&quot;usernameMsg&quot;) if(!usernameReg.test(username))&#123; usernameMsg.innerText=&quot;格式有误&quot; return false &#125; usernameMsg.innerText=&quot;OK&quot; return true &#125; function checkUserPwd()&#123; var userPwdReg = /^\\d&#123;6&#125;$/ var userPwdInput = document.getElementById(&quot;userPwdInput&quot;) var userPwd = userPwdInput.value var userPwdMsg = document.getElementById(&quot;userPwdMsg&quot;) if(!userPwdReg.test(userPwd))&#123; userPwdMsg.innerText=&quot;格式有误&quot; return false &#125; userPwdMsg.innerText=&quot;OK&quot; return true &#125; function checkReUserPwd()&#123; var userPwdReg = /^\\d&#123;6&#125;$/ // 再次输入的密码的格式 var reUserPwdInput = document.getElementById(&quot;reUserPwdInput&quot;) var reUserPwd = reUserPwdInput.value var reUserPwdMsg = document.getElementById(&quot;reUserPwdMsg&quot;) if(!userPwdReg.test(reUserPwd))&#123; reUserPwdMsg.innerText=&quot;格式有误&quot; return false &#125; // 获得上次密码,对比两次密码是否一致 var userPwdInput = document.getElementById(&quot;userPwdInput&quot;) var userPwd = userPwdInput.value if(reUserPwd != userPwd)&#123; reUserPwdMsg.innerText=&quot;两次密码不一致&quot; return false &#125; reUserPwdMsg.innerText=&quot;OK&quot; return true &#125; function checkForm()&#123; var flag1 = checkUsername() var flag2 = checkUserPwd() var flag3 = checkReUserPwd() return flag1 &amp;&amp; flag2 &amp;&amp; flag3 &#125; &lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt;&lt;h3 class=&quot;ht&quot;&gt;请注册&lt;/h3&gt;&lt;form method=&quot;post&quot; action=&quot;/user/regist&quot; onsubmit=&quot;return checkForm()&quot;&gt; &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入账号&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;usernameInput&quot; type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkUsername()&quot;&gt; &lt;span id=&quot;usernameMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;请输入密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;userPwdInput&quot; type=&quot;password&quot; name=&quot;userPwd&quot; onblur=&quot;checkUserPwd()&quot;&gt; &lt;span id=&quot;userPwdMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td&gt;确认密码&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;ipt&quot; id=&quot;reUserPwdInput&quot; type=&quot;password&quot; onblur=&quot;checkReUserPwd()&quot;&gt; &lt;span id=&quot;reUserPwdMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;ltr&quot;&gt; &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;input class=&quot;btn1&quot; type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;button class=&quot;btn1&quot;&gt;&lt;a href=&quot;login.html&quot;&gt;去登录&lt;/a&gt;&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/categories/javaweb/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"第二章 HTML&CSS","slug":"javaweb/02_第二章 HTML&CSS","date":"2019-10-08T02:00:00.000Z","updated":"2024-12-02T13:24:00.624Z","comments":true,"path":"2019/10/08/javaweb/02_第二章 HTML&CSS/","link":"","permalink":"https://protonlml.github.io/2019/10/08/javaweb/02_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20HTML&CSS/","excerpt":"","text":"第二章 HTML&amp;CSS一 HTML入门1.1 HTML&amp;CSS&amp;JavaScript的作用 HTML 主要用于网页主体结构的搭建 CSS 主要用于页面元素美化 JavaScript 主要用于页面元素的动态处理 1.2 什么是HTML HTML是Hyper Text Markup Language的缩写。意思是超文本标记语言。它的作用是搭建网页结构，在网页上展示内容 HTML5 是 HyperText Markup Language 5 的缩写，HTML5 技术结合了 HTML4.01 的相关标准并革新，符合现代网络发展要求，在 2008 年正式发布。HTML5 由不同的技术构成，其在互联网中得到了非常广泛的应用，提供更多增强网络应用的标准机。与传统的技术相比，HTML5 的语法特征更加明显，并且结合了 SVG 的内容。这些内容在网页中使用可以更加便捷地处理多媒体内容，而且 HTML5中还结合了其他元素，对原有的功能进行调整和修改，进行标准化工作。HTML5 在 2012 年已形成了稳定的版本。2014年10月28日，W3C发布了HTML5的最终版。 1.3 什么是超文本 HTML文件本质上是文本文件，而普通的文本文件只能显示字符。但是HTML技术则通过HTML标签把其他网页、图片、音频、视频等各种多媒体资源引入到当前网页中，让网页有了非常丰富的呈现方式，这就是超文本的含义——本身是文本，但是呈现出来的最终效果超越了文本。 1.4 什么是标记语言 说HTML是一种『标记语言』是因为它不是像Java这样的『编程语言』，因为它是由一系列『标签』组成的，没有常量、变量、流程控制、异常处理、IO等等这些功能。HTML很简单，每个标签都有它固定的含义和确定的页面显示效果。 双标签:标签是通过一组尖括号+标签名的方式来定义的： 1&lt;p&gt;HTML is a very popular fore-end technology.&lt;/p&gt; 这个例子中使用了一个p标签来定义一个段落，&lt;p&gt;叫开始标签，&lt;&#x2F;p&gt;叫结束标签。开始标签和结束标签一起构成了一个完整的标签。开始标签和结束标签之间的部分叫文本标签体，也简称：标签体。 单标签 1&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; 属性 1&lt;a href=&quot;http://www.xxx.com&quot;&gt;show detail&lt;/a&gt; href&#x3D;”网址” 就是属性，href是属性名，”网址”是属性值 1.5 HTML基础结构 1 文档声明 HTML文件中第一行的内容，用来告诉浏览器当前HTML文档的基本信息，其中最重要的就是当前HTML文档遵循的语法标准。这里我们只需要知道HTML有4和5这两个大的版本 HTML4版本的文档类型声明是： 12&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML5版本的文档类型声明是： 1&lt;!DOCTYPE html&gt; 现在主流的技术选型都是使用HTML5，之前的版本基本不用了。 2根标签 html标签是整个文档的根标签，所有其他标签都必须放在html标签里面。 3头部元素 head标签用于定义文档的头部，其他头部元素都放在head标签里。头部元素包括title标签、script标签、style标签、link标签、meta标签等等。 4主体元素 body标签定义网页的主体内容，在浏览器窗口内显示的内容都定义到body标签内。 5注释 HTML注释的写法是 1&lt;!-- 注释内容 --&gt; 1.6 HTML的入门程序 第一步 准备一个纯文本文件,拓展名为html 第二步 使用记事本打开网页,在网页内开发代码 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;我的第一个网页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello html!!! &lt;/body&gt;&lt;/html&gt; 第三步 使用浏览器打开文件,查看显示的内容 1.7 HTML概念词汇解释 标签 代码中的一个 &lt;&gt; 叫做一个标签,有些标签成对出现,称之为双标签,有些标签单独出现,称之为单标签 属性 一般在开始标签中,用于定义标签的一些特征 文本 双标签中间的文字,包含空格换行等结构 元素 经过浏览器解析后,每一个完整的标签(标签+属性+文本)可以称之为一个元素 1.8 HTML的语法规则 1 根标签有且只能有一个 2 无论是双标签还是单标签都需要正确关闭 3 标签可以嵌套但不能交叉嵌套 4 注释语法为 ,注意不能嵌套 5 属性必须有值，值必须加引号,H5中属性名和值相同时可以省略属性值 6 HTML中不严格区分字符串使用单双引号 7 HTML标签不严格区分大小写,但是不能大小写混用 8 HTML中不允许自定义标签名,强行自定义则无效 1.9 开发工具VsCode的安装和使用 前端工程师“Front-End-Developer”源自于美国。大约从2005年开始正式的前端工程师角色被行业所认可，到了2010年，互联网开始全面进入移动时代，前端开发的工作越来越重要。 最初所有的开发工作都是由后端工程师完成的，随着业务越来越繁杂，工作量变大，于是我们将项目中的可视化部分和一部分交互功能的开发工作剥离出来，形成了前端开发。由于互联网行业的急速发展，导致了在不同的国家，有着截然不同的分工体制。 在日本和一些人口比较稀疏的国家，例如加拿大、澳大利亚等，流行“Full-Stack Engineer”，也就是我们通常所说的全栈工程师。通俗点说就是一个人除了完成前端开发和后端开发工作以外，有的公司从产品设计到项目开发再到后期运维可能都是同一个人，甚至可能还要负责UI、配动画，也可以是扫地、擦窗、写文档、维修桌椅等等。 而在美国等互联网环境比较发达的国家项目开发的分工协作更为明确，整个项目开发分为前端、中间层和后端三个开发阶段，这三个阶段分别由三个或者更多的人来协同完成。国内的大部分互联网公司只有前端工程师和后端工程师，中间层的工作有的由前端来完成，有的由后端来完成。 PRD（产品原型-产品经理） - PSD（视觉设计-UI工程师） - HTML&#x2F;CSS&#x2F;JavaScript（PC&#x2F;移动端网页，实现网页端的视觉展示和交互-前端工程师） 前端工程师比较推崇的一款开发工具就是visual studio code,下载地址为:https://code.visualstudio.com/ 1 安装过程 安装过程比较简单,一路next,注意安装路径不要有中文,空格和特殊符号即可 2 安装插件 Auto Rename Tag 自动修改标签对插件 Chinese Language Pack 汉化包 HTML CSS Support HTML CSS 支持 Intellij IDEA Keybindings IDEA快捷键支持 Live Server 实时加载功能的小型服务器 open in browser 通过浏览器打开当前文件的插件 Prettier-Code formatter 代码美化格式化插件 Vetur VScode中的Vue工具插件 vscode-icons 文件显示图标插件 Vue 3 snipptes 生成VUE模板插件 Vue language Features Vue3语言特征插件 3 准备工作空间 直接用vscode打开某个目录即可直接将某个目录作为项目代码存放的根目录 4 在工作空间下创建目录和文件 点击带有”+”号的按钮即可创建文件或者目录 在html中,输入” ! “ 并回车即可快速出现html的基本结构 5 通过live Server 小型服务器运行项目 点击右下角Go Live , 或者在html编辑视图上右击 open with live Server ,会自动启动小型服务器,并自动打开浏览器访问当前资源 Live Server 实时加载功能 Live Server使用完毕后,要记得关闭 6 其他常见设置 设置字体: 齿轮&gt;search&gt;搜索 “字体大小” 设置字体大小可以用滚轮控制: 齿轮&gt;设置&gt;搜索 “Mouse Wheel Zoom” 设置左侧树缩进: 齿轮&gt;设置&gt;搜索 “树缩进” 设置文件夹折叠: 齿轮&gt;设置&gt;搜索 “compact” 取消第一个勾选 设置编码自动保存: 齿轮&gt; 设置&gt; 搜索 “Auto Save” ,选择为”afterDelay” 1.10 在线帮助文档http://www.w3school.com.cn 二 HTML常见标签2.1 标题标签 标题标签一般用于在页面上定义一些标题性的内容,如新闻标题,文章标题等,有h1到h6六级标题 代码 12345678&lt;body&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;h3&gt;三级标题&lt;/h3&gt; &lt;h4&gt;四级标题&lt;/h4&gt; &lt;h5&gt;五级标题&lt;/h5&gt; &lt;h6&gt;六级标题&lt;/h6&gt;&lt;/body&gt; 效果 2.2 段落标签 段落标签一般用于定义一些在页面上要显示的大段文字,多个段落标签之间实现自动分段的效果 代码 1234567891011121314&lt;body&gt; &lt;p&gt; 记者从工信部了解到，近年来我国算力产业规模快速增长，年增长率近30%，算力规模排名全球第二。 &lt;/p&gt; &lt;p&gt; 工信部统计显示，截至去年底，我国算力总规模达到180百亿亿次浮点运算/秒，存力总规模超过1000EB（1万亿GB）。 国家枢纽节点间的网络单向时延降低到20毫秒以内，算力核心产业规模达到1.8万亿元。中国信息通信研究院测算， 算力每投入1元，将带动3至4元的GDP经济增长。 &lt;/p&gt; &lt;p&gt; 近年来，我国算力基础设施发展成效显著，梯次优化的算力供给体系初步构建，算力基础设施的综合能力显著提升。 当前，算力正朝智能敏捷、绿色低碳、安全可靠方向发展。 &lt;/p&gt;&lt;/body&gt; 效果 2.3 换行标签 单纯实现换行的标签是br,如果想添加分隔线,可以使用hr标签 代码 1234567&lt;body&gt; 工信部统计显示，截至去年底，我国算力总规模达到180百亿亿次浮点运算/秒，存力总规模超过1000EB（1万亿GB）。 &lt;br&gt; 国家枢纽节点间的网络单向时延降低到20毫秒以内，算力核心产业规模达到1.8万亿元。 &lt;hr&gt; 中国信息通信研究院测算，算力每投入1元，将带动3至4元的GDP经济增长。&lt;/body&gt; 效果 2.4 列表标签 有序列表 分条列项展示数据的标签, 其每一项前面的符号带有顺序特征 列表标签 ol 列表项标签 li 代码 12345&lt;ol&gt; &lt;li&gt;JAVA&lt;/li&gt; &lt;li&gt;前端&lt;/li&gt; &lt;li&gt;大数据&lt;/li&gt;&lt;/ol&gt; 效果 无序列表 分条列项展示数据的标签, 其每一项前面的符号不带有顺序特征 列表标签 ul 列表项标签 li 代码 12345&lt;ul&gt; &lt;li&gt;JAVASE&lt;/li&gt; &lt;li&gt;JAVAEE&lt;/li&gt; &lt;li&gt;数据库&lt;/li&gt;&lt;/ul&gt; 效果 嵌套列表 列表和列表之前可以签到,实现某一项内容详细展示 代码 123456789101112&lt;ol&gt; &lt;li&gt; JAVA &lt;ul&gt; &lt;li&gt;JAVASE&lt;/li&gt; &lt;li&gt;JAVAEE&lt;/li&gt; &lt;li&gt;数据库&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;前端&lt;/li&gt; &lt;li&gt;大数据&lt;/li&gt;&lt;/ol&gt; 效果 2.5 超链接标签 点击后带有链接跳转的标签 ,也叫作a标签 href属性用于定义连接 href中可以使用绝对路径,以&#x2F;开头,始终以一个固定路径作为基准路径作为出发点 href中也可以使用相对路径,不以&#x2F;开头,以当前文件所在路径为出发点 href中也可以定义完整的URL target用于定义打开的方式 _blank 在新窗口中打开目标资源 _self 在当前窗口中打开目标资源 代码 123456789101112131415&lt;body&gt; &lt;!-- href属性用于定义连接 href中可以使用绝对路径,以/开头,始终以一个路径作为基准路径作为出发点 href中也可以使用相对路径,不以/开头,以当前文件所在路径为出发点 href中也可以定义完整的URL target用于定义打开的方式 _blank 在新窗口中打开目标资源 _self 在当前窗口中打开目标资源 --&gt; &lt;a href=&quot;01html的基本结构.html&quot; target=&quot;_blank&quot;&gt;相对路径本地资源连接&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;/day01-html/01html的基本结构.html&quot; target=&quot;_self&quot;&gt;绝对路径本地资源连接&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.atguigu.com&quot; target=&quot;_blank&quot;&gt;外部资源链接&lt;/a&gt; &lt;br&gt; &lt;/body&gt; 效果 2.6 多媒体标签 img(重点) 图片标签,用于在页面上引入图片 代码 123456789&lt;!-- src 用于定义图片的连接title 用于定义鼠标悬停时显示的文字alt 用于定义图片加载失败时显示的提示文字--&gt;&lt;img src=&quot;img/logo.png&quot; title=&quot;尚硅谷&quot; alt=&quot;尚硅谷logo&quot; /&gt; 效果 audio 用于在页面上引入一段声音 代码 1234567891011&lt;!-- src 用于定义目标声音资源 autoplay 用于控制打开页面时是否自动播放 controls 用于控制是否展示控制面板 loop 用于控制是否进行循环播放 --&gt; &lt;audio src=&quot;img/music.mp3&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; /&gt; 效果 video 用于在页面上引入一段视频 代码 12345678910111213&lt;body&gt; &lt;!-- src 用于定义目标视频资源 autoplay 用于控制打开页面时是否自动播放 controls 用于控制是否展示控制面板 loop 用于控制是否进行循环播放 --&gt; &lt;video src=&quot;img/movie.mp4&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; width=&quot;400px&quot; /&gt;&lt;/body&gt; 效果 2.7 表格标签(重点) 常规表格 table标签 代表表格 thead标签 代表表头 可以省略不写 tbody标签 代表表体 可以省略不写 tfoot标签 代表表尾 可以省略不写 tr标签 代表一行 td标签 代表行内的一格 th标签 自带加粗和居中效果的td 代码 1234567891011121314151617181920212223&lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt;&lt;table border=&quot;1px&quot; style=&quot;width: 400px; margin: 0px auto;&quot;&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;分数&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;张小明&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;李小东&lt;/td&gt;&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;王小虎&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 展示效果 单元格跨行 通过td的rowspan属性实现上下跨行 代码 123456789101112131415161718192021222324252627&lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt;&lt;table border=&quot;1px&quot; style=&quot;width: 400px; margin: 0px auto;&quot;&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;分数&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;张小明&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td rowspan=&quot;3&quot;&gt; 前三名升职加薪 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;李小东&lt;/td&gt;&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;王小虎&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果 单元格跨行 通过td的colspan属性实现左右的跨列 代码 123456789101112131415161718192021222324252627282930313233343536373839&lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt;&lt;table border=&quot;1px&quot; style=&quot;width: 400px; margin: 0px auto;&quot;&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;分数&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;张小明&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td rowspan=&quot;6&quot;&gt; 前三名升职加薪 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;李小东&lt;/td&gt;&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;王小虎&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;总人数&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;2000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;平均分&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;90&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;及格率&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;80%&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果 2.8 表单标签(重点) 表单标签,可以实现让用户在界面上输入各种信息并提交的一种标签. 是向服务端发送数据主要的方式之一 form标签,表单标签,其内部用于定义可以让用户输入信息的表单项标签 action, form标签的属性之一,用于定义信息提交的服务器的地址 method, form标签的属性之一,用于定义信息的提交方式 get get方式, 数据会缀到url后,以?作为参数开始的标识,多个参数用&amp;隔开 post post方式,数据会通过请求体发送,不会在缀到url后 input标签,主要的表单项标签,可以用于定义表单项 name, input标签的属性之一,用于定义提交的参数名 type, input标签的属性之一,用于定义表单项类型 text 文本框 password 密码框 submit 提交按钮 reset 重置按钮 代码 123456&lt;form action=&quot;http://www.atguigu.com&quot; method=&quot;get&quot;&gt; 用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码 &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;&lt;/form&gt; 效果 2.9 常见表单项标签(重点) 单行文本框 代码 1个性签名：&lt;input type=&quot;text&quot; name=&quot;signal&quot;/&gt;&lt;br/&gt; 效果 密码框 代码 1密码：&lt;input type=&quot;password&quot; name=&quot;secret&quot;/&gt;&lt;br/&gt; 效果 单选框 代码 123你的性别是：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;spring&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;summer&quot; checked=&quot;checked&quot; /&gt;女 效果 说明 name属性相同的radio为一组，组内互斥 当用户选择了一个radio并提交表单，这个radio的name属性和value属性组成一个键值对发送给服务器 设置checked&#x3D;”checked”属性设置默认被选中的radio 如果属性名和属性值一样的话，可以省略属性值，只写checked即可 复选框 代码 123456你喜欢的球队是：&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;Brazil&quot;/&gt;巴西&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;German&quot; checked/&gt;德国&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;France&quot;/&gt;法国&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;China&quot; checked=&quot;checked&quot;/&gt;中国&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;Italian&quot;/&gt;意大利 效果 说明 设置checked&#x3D;”checked”属性设置默认被选中的checkbox 下拉框 代码 1234567你喜欢的运动是：&lt;select name=&quot;interesting&quot;&gt; &lt;option value=&quot;swimming&quot;&gt;游泳&lt;/option&gt; &lt;option value=&quot;running&quot;&gt;跑步&lt;/option&gt; &lt;option value=&quot;shooting&quot; selected=&quot;selected&quot;&gt;射击&lt;/option&gt; &lt;option value=&quot;skating&quot;&gt;溜冰&lt;/option&gt;&lt;/select&gt; 效果 说明 下拉列表用到了两种标签，其中select标签用来定义下拉列表，而option标签设置列表项。 name属性在select标签中设置,value属性在option标签中设置。 option标签的标签体是显示出来给用户看的，提交到服务器的是value属性的值。 通过在option标签中设置selected&#x3D;”selected”属性实现默认选中的效果。 按钮 代码 123&lt;button type=&quot;button&quot;&gt;普通按钮&lt;/button&gt;或&lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;/&gt;&lt;button type=&quot;reset&quot;&gt;重置按钮&lt;/button&gt;或&lt;input type=&quot;reset&quot; value=&quot;重置按钮&quot;/&gt;&lt;button type=&quot;submit&quot;&gt;提交按钮&lt;/button&gt;或&lt;input type=&quot;submit&quot; value=&quot;提交按钮&quot;/&gt; 效果 说明 普通按钮: 点击后无效果，需要通过JavaScript绑定单击响应函数 重置按钮: 点击后将表单内的所有表单项都恢复为默认值 提交按钮: 点击后提交表单 隐藏域 代码 1&lt;input type=&quot;hidden&quot; name=&quot;userId&quot; value=&quot;2233&quot;/&gt; 说明 通过表单隐藏域设置的表单项不会显示到页面上，用户看不到。但是提交表单时会一起被提交。用来设置一些需要和表单一起提交但是不希望用户看到的数据，例如：用户id等等。 多行文本框 代码 1自我介绍：&lt;textarea name=&quot;desc&quot;&gt;&lt;/textarea&gt; 效果 说明 textarea没有value属性，如果要设置默认值需要写在开始和结束标签之间。 文件标签 代码 1头像:&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; 效果 说明 不同浏览器显示的样式有微小差异 2.10 布局相关标签 div标签 俗称”块”,主要用于划分页面结构,做页面布局 span标签 俗称”层”,主要用于划分元素范围,配合CSS做页面元素样式的修饰 代码 1234567891011&lt;div style=&quot;width: 500px; height: 400px;background-color: cadetblue;&quot;&gt; &lt;div style=&quot;width: 400px; height: 100px;background-color: beige;margin: 10px auto;&quot;&gt; &lt;span style=&quot;color: blueviolet;&quot;&gt;页面开头部分&lt;/span&gt; &lt;/div&gt; &lt;div style=&quot;width: 400px; height: 100px;background-color: blanchedalmond;margin: 10px auto;&quot;&gt; &lt;span style=&quot;color: blueviolet;&quot;&gt;页面中间部分&lt;/span&gt; &lt;/div&gt; &lt;div style=&quot;width: 400px; height: 100px;background-color: burlywood;margin: 10px auto;&quot;&gt; &lt;span style=&quot;color: blueviolet;&quot;&gt;页面结尾部分&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; 展示效果 2.11 特殊字符 对于有特殊含义的字符,需要通过转移字符来表示 代码 123&amp;lt;span&amp;gt; &lt;br&gt;&amp;lt;a href=&quot;http://www.atguigu.com&quot;&amp;gt;尚&amp;nbsp;硅&amp;nbsp;谷&amp;lt;/a&amp;gt; &lt;br&gt;&amp;amp;amp; 效果 三 CSS的使用 CSS 层叠样式表(英文全称：(Cascading Style Sheets) 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力 ,简单来说,美化页面 3.1 CSS引入方式 行内式,通过元素开始标签的style属性引入, 样式语法为 样式名:样式值; 样式名:样式值; 代码 123456789101112131415&lt;input type=&quot;button&quot; value=&quot;按钮&quot; style=&quot; display: block; width: 60px; height: 40px; background-color: rgb(140, 235, 100); color: white; border: 3px solid green; font-size: 22px; font-family: &#x27;隶书&#x27;; line-height: 30px; border-radius: 5px;&quot;/&gt; 效果 缺点 html代码和css样式代码交织在一起,增加阅读难度和维护成本 css样式代码仅对当前元素有效,代码重复量高,复用度低 内嵌式 代码 123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; /* 通过选择器确定样式的作用范围 */ input &#123; display: block; width: 80px; height: 40px; background-color: rgb(140, 235, 100); color: white; border: 3px solid green; font-size: 22px; font-family: &#x27;隶书&#x27;; line-height: 30px; border-radius: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; &lt;/body&gt; 效果 说明 内嵌式样式需要在head标签中,通过一对style标签定义CSS样式 CSS样式的作用范围控制要依赖选择器 CSS的样式代码中注释的方式为 &#x2F;* *&#x2F; 内嵌式虽然对样式代码做了抽取,但是CSS代码仍然在html文件中 内嵌样式仅仅能作用于当前文件,代码复用度还是不够,不利于网站风格统一 连接式&#x2F;外部样式表 可以在项目单独创建css样式文件,专门用于存放CSS样式代码 在head标签中,通过link标签引入外部CSS样式即可 12345678910&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;link href=&quot;css/buttons.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; &lt;/body&gt; 说明 CSS样式代码从html文件中剥离,利于代码的维护 CSS样式文件可以被多个不同的html引入,利于网站风格统一 3.2 CSS选择器 元素选择器 代码 123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; input &#123; display: block; width: 80px; height: 40px; background-color: rgb(140, 235, 100); color: white; border: 3px solid green; font-size: 22px; font-family: &#x27;隶书&#x27;; line-height: 30px; border-radius: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; &lt;button&gt;按钮5&lt;/button&gt;&lt;/body&gt; 效果 说明 根据标签名确定样式的作用范围 语法为 元素名 {} 样式只能作用到同名标签上,其他标签不可用 相同的标签未必需要相同的样式,会造成样式的作用范围太大 id选择器 代码 123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; #btn1 &#123; display: block; width: 80px; height: 40px; background-color: rgb(140, 235, 100); color: white; border: 3px solid green; font-size: 22px; font-family: &#x27;隶书&#x27;; line-height: 30px; border-radius: 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; &lt;input id=&quot;btn2&quot; type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; &lt;input id=&quot;btn3&quot; type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; &lt;input id=&quot;btn4&quot; type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; &lt;button id=&quot;btn5&quot;&gt;按钮5&lt;/button&gt;&lt;/body&gt; 效果 说明 根据元素id属性的值确定样式的作用范围 语法为 #id值 {} id属性的值在页面上具有唯一性,所有id选择器也只能影响一个元素的样式 因为id属性值不够灵活,所以使用该选择器的情况较少 class选择器 代码 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .shapeClass &#123; display: block; width: 80px; height: 40px; border-radius: 5px; &#125; .colorClass&#123; background-color: rgb(140, 235, 100); color: white; border: 3px solid green; &#125; .fontClass &#123; font-size: 22px; font-family: &#x27;隶书&#x27;; line-height: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input class =&quot;shapeClass colorClass fontClass&quot;type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; &lt;input class =&quot;shapeClass colorClass&quot; type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; &lt;input class =&quot;colorClass fontClass&quot; type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; &lt;input class =&quot;fontClass&quot; type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; &lt;button class=&quot;shapeClass colorClass fontClass&quot; &gt;按钮5&lt;/button&gt;&lt;/body&gt; 效果 说明 根据元素class属性的值确定样式的作用范围 语法为 .class值 {} class属性值可以有一个,也可以有多个,多个不同的标签也可以是使用相同的class值 多个选择器的样式可以在同一个元素上进行叠加 因为class选择器非常灵活,所以在CSS中,使用该选择器的情况较多 3.4 CSS浮动 CSS 的 Float（浮动）使元素脱离文档流，按照指定的方向（左或右发生移动），直到它的外边缘碰到包含框或另一个浮动框的边框为止。 浮动设计的初衷为了解决文字环绕图片问题，浮动后一定不会将文字挡住，这是设计初衷。 文档流是是文档中可显示对象在排列时所占用的位置&#x2F;空间，而脱离文档流就是在页面中不占位置了。 浮动原理 当把框 1 向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘 当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。如果把所有三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。 如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住” 浮动的样式名:float 通过代码感受浮动的效果 代码 12345678910111213141516171819202122232425262728293031323334&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .outerDiv &#123; width: 500px; height: 300px; border: 1px solid green; background-color: rgb(230, 224, 224); &#125; .innerDiv&#123; width: 100px; height: 100px; border: 1px solid blue; float: left; &#125; .d1&#123; background-color: greenyellow; /* float: right; */ &#125; .d2&#123; background-color: rgb(79, 230, 124); &#125; .d3&#123; background-color: rgb(26, 165, 208); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outerDiv&quot;&gt; &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt; &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt; &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 效果 3.5 CSS定位 position 属性指定了元素的定位类型。 这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。 元素可以使用的顶部，底部，左侧和右侧属性定位。然而，这些属性无法工作，除非是先设定position属性。他们也有不同的工作方式，这取决于定位方法。 静态定位 说明 不设置的时候的默认值就是static，静态定位，没有定位，元素出现在该出现的位置，块级元素垂直排列，行内元素水平排列 代码 123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .innerDiv&#123; width: 100px; height: 100px; &#125; .d1&#123; background-color: rgb(166, 247, 46); position: static; &#125; .d2&#123; background-color: rgb(79, 230, 124); &#125; .d3&#123; background-color: rgb(26, 165, 208); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt; &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt; &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;&lt;/body&gt; 效果 绝对定位 说明 absolute ,通过 top left right bottom 指定元素在页面上的固定位置 定位后元素会让出原来位置,其他元素可以占用 代码 1234567891011121314151617181920212223242526&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .innerDiv&#123; width: 100px; height: 100px; &#125; .d1&#123; background-color: rgb(166, 247, 46); position: absolute; left: 300px; top: 100px; &#125; .d2&#123; background-color: rgb(79, 230, 124); &#125; .d3&#123; background-color: rgb(26, 165, 208); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt; &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt; &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;&lt;/body&gt; 效果 相对定位 说明 relative 相对于自己原来的位置进行地位 定位后保留原来的站位,其他元素不会移动到该位置 代码 1234567891011121314151617181920212223242526&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .innerDiv&#123; width: 100px; height: 100px; &#125; .d1&#123; background-color: rgb(166, 247, 46); position: relative; left: 30px; top: 30px; &#125; .d2&#123; background-color: rgb(79, 230, 124); &#125; .d3&#123; background-color: rgb(26, 165, 208); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt; &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt; &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;&lt;/body&gt; 效果 固定定位 说明 fixed 失踪在浏览器窗口固定位置,不会随着页面的上下移动而移动 元素定位后会让出原来的位置,其他元素可以占用 代码 123456789101112131415161718192021222324252627&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .innerDiv&#123; width: 100px; height: 100px; &#125; .d1&#123; background-color: rgb(166, 247, 46); position: fixed; right: 30px; top: 30px; &#125; .d2&#123; background-color: rgb(79, 230, 124); &#125; .d3&#123; background-color: rgb(26, 165, 208); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt; &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt; &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt; br*100+tab&lt;/body&gt; 效果 3.6 CSS盒子模型 所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin），边框（border），填充（padding），和实际内容（content） 说明： Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .outerDiv &#123; width: 800px; height: 300px; border: 1px solid green; background-color: rgb(230, 224, 224); margin: 0px auto; &#125; .innerDiv&#123; width: 100px; height: 100px; border: 1px solid blue; float: left; /* margin-top: 10px; margin-right: 20px; margin-bottom: 30px; margin-left: 40px; */ margin: 10px 20px 30px 40px; &#125; .d1&#123; background-color: greenyellow; /* padding-top: 10px; padding-right: 20px; padding-bottom: 30px; padding-left: 40px; */ padding: 10px 20px 30px 40px; &#125; .d2&#123; background-color: rgb(79, 230, 124); &#125; .d3&#123; background-color: rgb(26, 165, 208); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outerDiv&quot;&gt; &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt; &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt; &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 效果 在浏览器上,通过F12工具查看盒子模型状态 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/categories/javaweb/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"第一章 WEB概述","slug":"javaweb/01_第一章 概述","date":"2019-10-08T01:00:00.000Z","updated":"2024-12-02T13:21:18.452Z","comments":true,"path":"2019/10/08/javaweb/01_第一章 概述/","link":"","permalink":"https://protonlml.github.io/2019/10/08/javaweb/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%BF%B0/","excerpt":"","text":"第一章 WEB概述1.1 JAVAWEB简介 用Java技术来解决相关web互联网领域的技术栈.使用JAVAEE技术体系开发企业级互联网项目. 项目规模和架构模式与JAVASE阶段有着很大的差别. 在互联网项目下,首先需要明白客户端和服务器的概念 客户端 :与用户进行交互，用于接收用户的输入(操作)、展示服务器端的数据以及向服务器传递数据 手机APP 微信小程序 PC端程序 PC浏览器 其他设备 服务端:与客户端进行交互，接收客户端的数据、处理具体的业务逻辑、传递给客户端其需要的数据 “服务器”是一个非常宽泛的概念，从硬件而言: 服务器是计算机的一种，它比普通计算机运行更快、负载更高、价格更贵。服务器在网络中为其它客户机（如PC机、智能手机、ATM等终端甚至是火车系统等大型设备）提供计算或者应用服务。从软件而言: 服务器其实就是安装在计算机上的一个软件，根据其作用的不同又可以分为各种不同的服务器，例如应用服务器、数据库服务器、Redis服务器、DNS服务器、ftp服务器等等 综上所述: 用我们自己的话来总结的话，服务器其实就是一台(或者一个集群)安装了服务器软件的高性能计算机 1.2 JAVAWEB技术栈 前端部分 HTML CSS JavaScript ES6 Nodejs npm vite vue3 router pinia axios element-plus … 后端部分 HTTP xml Tomcat Servlet Request Response Cookie Sesssion Filter Listener MySQL JDBC Druid Jackson lombok jwt … 图解 1.3 JAVAWEB交互模式 请求 客户端向服务端传递数据的主要方式之一,客户端主动向服务端发送请求,可以携带数据,交给服务端处理. 请求只能是客户端向服务端 响应 服务端向客户端传递数据的主要方式之一,在接收请求后开始对数据进行处理,将结果反馈给客户端使用.响应只能是服务端向客户端 1.4 JAVAWEB的CS和BS模式根据客户端的不同,我们可以将JAVA的互联网项目运行模式分为CS模式和BS模式 CS模式 Client-Server模式 客户端-服务端模式, 该模式特点如下 1 程序分两部分,一部分是客户端需要安装的程序,一部分是要部署在服务器上的程序 2 用户需要在硬件设备或者操作系统中,下载安装特定的客户端程序才可以使用 3 程序运行的压力由客户端和服务端共同承担 4 可以借助客户端运算资源,对数据继续处理,一般可以有较好的画质和展现效果 5 程序更新时,往往需要同时更新客户端和服务端两部分 6 跨平台性能一般,不同的平台未必都有对应的客户端程序 7 开发成本较高,要为不同的客户端开发不同客户端程序 BS模式 Browser-Server模式 1 程序就一部分,只要部署在服务器上即可 2 无论用户使用什么设备和操作系统,只要有一个安装任意一款浏览器即可 3 程序运行的压力主要由服务端承担 4 客户端承担的计算压力小,可以对数据进行简单的继续处理,但是不像CS模式那些可以获得较好的画质和展现效果 5 程序更新时,只需要同时服务端部分 6 跨平台性能优秀,只要有一个浏览器,到处都可以使用 7 开发成本略低,不必为不同的客户端开发不同客户端程序 模式选择 对于我们JAVA程序员来说,我们开发的是服务端代码,所有无论前端是何种类型的服务端,我们只要按照接口文档要求开发后端功能即可,尤其是在当前前后端分离模式开发为主的时代背景下,我们可以在几乎不接触前端的状态下完成开发 1.5 JAVAWEB实现前后端分离 非前后端分离 1 开发不分离: 程序员既要编写后端代码,又要去修改甚至编写前端代码,程序员的工作压力较大 2 部署不分离: 使用了后端动态页面技术(JSP,Thymeleaf等),前端代码不能脱离后端服务器环境,必须部署在一起 前后端分离 1 开发分离:后端程序员只要按照接口文档去编写后端代码,无需编写或者关系前端代码,前后端程序员压力都降低 2 部署分离:前端使用前端的页面动态技术,通过VUE等框架,工程化项目,前端项目可以部署到独立的服务器上 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/categories/javaweb/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"2.Servlet","slug":"javaweb/2.Servlet","date":"2019-10-07T01:00:00.000Z","updated":"2024-12-02T12:57:53.906Z","comments":true,"path":"2019/10/07/javaweb/2.Servlet/","link":"","permalink":"https://protonlml.github.io/2019/10/07/javaweb/2.Servlet/","excerpt":"","text":"Servlet 1.什么是Servlet &#x3D;&#x3D;Servlet 是运行在服务端（tomcat）的 java 小程序&#x3D;&#x3D;，是sun公司提供的一套定义动态资源规范；从代码层面上来讲Servlet就是一个接口 用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。我们可以把Servlet称为Web应用中的&#x3D;&#x3D;控制器&#x3D;&#x3D; 不是所有的JAVA类都能用于处理客户端请求，能处理客户端请求并做出响应的一套技术标准就是Servlet Servlet是运行在服务端的，所以Servlet &#x3D;&#x3D;必须在WEB项目中&#x3D;&#x3D;开发且在Tomcat 这样的服务容器中运行 2.浏览器请求-服务器响应的过程​ 2.1 首先要知道，在Tomcat(web项目运行容器)中，lib目录下就有Servlet.jar api ，这个是tomcat自带的，我们在web项目中，不需要重复导入这个jar包。但是项目在Modules设置中要加入tomcat依赖才能生效。 2.2我们要自定义Servlet类，来继承HttpServlet 这个抽象类，（它是Servlet.jar包中的） ​ 重写 service方法（HttpServlet中的service方法，是用来判断请求是哪种类型的请求，如果是get就跳转到doGet 方法执行，如果是post 方式请求则跳转doPost 方法执行）或者直接重写 doGet 或者 doPost方法 ​ 2.3 在web.xml文件中，配置servlet路径映射。注意标签不要写颠倒了. 3.Concent_typeConcent_type 应答类型 浏览器 上传文件时，在请求头中，有一行是Concent_type:text 这种，告诉服务器tomcat上传的数据是什么类型的。 在响应头中也有Concent_type 一行的值。 告诉浏览器，响应的是什么类型的资源。浏览器好作出响应的解析 这种映射关系，是tomcat中的web.xml文件中的映射，tomcat提前已经写好了 4.请求路径，怎么找到servlet资源的. 5.Servlet的注解方式配置直接在Servlet类上面，使用@WebServlet注解来映射地址，这样就不用在web.xml配置文件中书写一大堆servl映射了。 6.Servlet生命周期应用程序中的对象不仅在空间上有层次结构的关系，在时间上也会因为处于程序运行过程中的不同阶段而表现出不同状态和不同行为，这就是对象的生命周期。 简单的叙述生命周期，就是对象在容器中从开始创建到销毁的过程。 Servlet对象是Servlet容器创建的，生命周期方法都是由容器（目前我们使用的是Tomcat）调用的。这一点和我们之前所编写的代码有很大不同。在今后的学习中我们会看到，越来越多的对象交给容器或框架来创建，越来越多的方法由容器或框架来调用，开发人员要尽可能多的将精力放在业务逻辑的实现上。 servlet对象一般是在第一次请求时，才进行创建,而且时单例的（请求时稍慢） 如果配置了loadOnStartup 配置的是正数，那么就会在tomcat启动时就创建servlet(请求时就快了) 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;servletLifeCycle&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.ServletLifeCycle&lt;/servlet-class&gt; &lt;!--load-on-startup 如果配置的是正整数 则表示容器在启动时就要实例化Servlet, 数字表示的是实例化的顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;servletLifeCycle&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletLiftCycle&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注解方式：&#x3D;&#x3D;@WebServlet(value&#x3D;”&#x2F;s1”,loadOnStartup &#x3D; 6)&#x3D;&#x3D; 6.1生命周期总结1.通过生命周期测试发现Servlet&gt;对象在容器中是单例的； 2.容器是可以处理并发的用户请求的，每个请求在容器中都会开启一个线程； 3.多个线程可能会使用相同的Servlet对象，所以在Servlet中，&#x3D;&#x3D;我们不要轻易定义一些需要经常修改的成员变量；&#x3D;&#x3D; 4.load-on-startupl中定义的正整数表示实例化顺序，如果数字重复了，容器会自行解决实例化顺序问题，但是应该避免重复： 5.Tomcat容器中，已经定义了一些随系统启动实例化的Servlet，自定义的Servlet的load-on-startup尽量不要占用数字1-5； 7.defaultServletdefaultServlet是tomcat中自带的在tomcat的web.xml文件中设置了1 它是在启动tomcat的时候，就创建了。 作用是：请求所有的静态资源都会走这个defaultServlet 根据请求的资源路径以及名称去找对应的资源，然后将IO流的方式写入到response对象中，返回给前端。 springMVC中也有一个servlet，如果项目不是前后端分离，单体ssm项目，那这个springmvc会导致这个tomcat中默认的defaultServlet失效，导致访问不到静态资源，需要配置才能恢复访问。 8.servlet的继承结构 在HttpServlet中的service方法，是用来判断请求是哪种类型的请求，如果是get就跳转到doGet 方法执行，如果是post 方式请求则跳转doPost 方法执行 继承HttpServlet后，要么重写service 要么重写 doGet&#x2F;doPost 如果两个都重写了，则service优先 9.ServletConfig（了解） ServletConfig是什么？1.为Servlet提供初始配置参数的一种对象，每个Servlet都有自己独立唯一的ServletConfig 2.对象容器会为每个Servlet实例化一个ServletConfig对象，并通过Servlet生命周期的init方法传入给Servlet作为属性 一个servlet对应一个ServletConfig 为其提供服务，在其内部配置参数。 Servlet是单例多线程的，（多个客户端请对一个servlet进行请求）当tomcat启动时，或者第一次请求servlet时，servlet会被创建。 （当然在web.xml中同一个servlet被声明多次，也会出现多个实例对象） 一个servlet对应一个ServletConfig 在service中ServletConfig 来获取 当前Servlet的init配置参数 10.ServletContextServletContext &#x3D;&gt; Servlet上下文对象 ServletContext 是什么？ ServletContext 对象 有称呼为上下文对象，或者叫应用域对象（后面统一讲解域对象） 容器会为每个app项目创建一个独立的唯一的 ServletContext对象 ServletContext对象为所有的 Servlet所共享、 ServletContext可以为所有的Servlet提供初始配置参数 一个项目，就只有一个ServletContext 对象 ServletContext 对象是单例的，不管你用什么方式获取 getServletContext 都是同一个 作用1.为所有servlet提供初始配置 12345678910111213141516171819202122232425/** * servletConfig 对象的使用 * 一个servlet对应一个ServletConfig对象为其服务 * */@WebServlet(value = &quot;/s1&quot;, loadOnStartup = 6, initParams = &#123;@WebInitParam(name = &quot;a&quot;, value = &quot;2222&quot;)&#125;)public class Servlet1 extends HttpServlet &#123; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; ServletConfig servletConfig = getServletConfig();// 获取到迭代器对象 Enumeration&lt;String&gt; initParameterNames = servletConfig.getInitParameterNames(); while (initParameterNames.hasMoreElements()) &#123; //判断有没有下一个参数，有返回true 无返回false// 取出下一个元素 String s = initParameterNames.nextElement();// 取出配置的值 String value = getInitParameter(s); System.out.println(value); &#125; System.out.println(&quot;servlet1执行了&quot;); &#125;&#125; 2. 获取资源的磁盘路径 涉及到文件上传，并将文件存到当前项目中 肯定会用到 getRealPath 1String realPath = servletContext.getRealPath(&quot;资源在web目录中的路径&quot;); 例如我们的目标是需要获取项目中某个静态资源的路径，不是工程目录中的路径，而是部署目录中的路径；我们如果直接拷贝其在我们电脑中的完整路径的话其实是有问题的，因为如果该项目以后部署到公司服务器上的话，路径肯定是会发生改变的，所以我们需要使用代码动态获取资源的真实路径。 只要使用了servletContexti动态获取资源的真实路径，那么无论项目的部署路径发生什么变化，都会动态获取项目运行时候的实际磁盘路径，所以就不会发生由于写死真实路径而导致项目部署位置改变引发的路径错误问题。 3.动态获取项目的上下文路径(项目的访问路径)1servletContext.getContextPath(); // 获取的是项目的访问路径 项目的部署名称，也叫项目的上下文路径，在部署进入tomcat时所使用的路径，该路径是可能发生变化的，通过该P动态获取项目真实的上下文路径，可以帮助我们解决一些后端页面渲染技术或者请求转发和响应重定向中的路径问题。 11.域对象的理解 域对象有： 应用域对象是ServletContext，传递数据的范围是本应用之内（当前项目中），可以跨多个会话， 会话域对象是HttpSession，传递数据的范围是一次会话之内，可以跨多个请求； 请求域对象是HttpServletRequest，传递数据的范围是一次请求之内及请求转发； 域对象：一些用于在一些特定的范围内存储数据和传递数据的对象，不同的范围称为不同的“域”不同的域对象代表不同的域，共享数据的范围也不同； ServletContext代表应用，所以ServletContexti域也叫作应用域，是webapp中最大的域，可以在本应用内实现数据的共享和传递； webapp 中的三大域对象，分别是应用域，会话域，请求域。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * servletConText 对象作为域对象的使用 * servletContext.setAttribute(key,value); * servletContext.getAttribute(key); * // 移除域中指定的值 * servletContext.removeAttribute(&quot;key1&quot;); * * */@WebServlet(&quot;/servlet3&quot;)public class Servlet3 extends HttpServlet &#123; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; ServletContext application = getServletContext();// 在 servletContext 作用域中，设置一个值 application.setAttribute(&quot;key1&quot;,&quot;value1&quot;); &#125;&#125;/** * servletContext的使用 * ServletConText 对象 一个app项目中只有一个 * 4. 作为全局域对象 * ServletContext 对象，又叫作 应用域对象 * 在里面存储一值，整个app项目都能拿到 * * */@WebServlet(&quot;/servlet2&quot;)public class Servlet2 extends HttpServlet &#123; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; ServletContext servletContext = servletConfig.getServletContext(); // 获取servletContext作用域中，存储的值 String key1 = (String) servletContext.getAttribute(&quot;key1&quot;); System.out.println(key1);// 移除域中指定的值 servletContext.removeAttribute(&quot;key1&quot;);// 获取作用域中的所有key以及value Enumeration&lt;String&gt; attributeNames = servletContext.getAttributeNames(); while (attributeNames.hasMoreElements())&#123; String key = attributeNames.nextElement(); System.out.println(key); String value = (String) servletContext.getAttribute(key); System.out.println(key+&quot;====================&quot;+value); &#125; &#125;&#125; 12.HttpServletRequest(请求对象) HttpServletRequest是什么？HttpServletRequest是一个接口，其父接口是 ServletRequest；HttpServletRequest是Tomcat将请求报文转换封装而来的对象，在Tomcati调用service方法时传入；HttpServletRequest代表客户端发来的请求，请求中的所有信息都可以通过该对象获得； 12.1 HttpServletRequest怎么用？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * HttpRequest 请求对象的使用 */@WebServlet(&quot;/servlet4&quot;)public class Servlet4 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 获取请求行，信息相关（方式，请求的URL，协议及版本） */ //1.获取客户端请求的URL StringBuffer requestURL = request.getRequestURL(); System.out.println(requestURL); //http://localhost:8080/d02/servlet4 //2.获取客户端请求的URI String requestURI = request.getRequestURI(); System.out.println(requestURI);///d02/servlet4 //3.获取客户端发送请求时的端口。（可以是代理端口） int serverPort = request.getServerPort(); System.out.println(serverPort);//8080 //4.获取本应用在所在容器的端口。（tomcat端口） int localPort = request.getLocalPort(); System.out.println(localPort);//8080 //5.获取客户端程序的端口。 int remotePort = request.getRemotePort(); System.out.println(remotePort);//8546 //6.获取请求协议。 String scheme = request.getScheme(); System.out.println(scheme);//http //7.获取请求协议及版本号。 String protocol = request.getProtocol(); System.out.println(protocol);//HTTP/1.1 //8.获取请求方式。 String method = request.getMethod(); System.out.println(method);//GET System.out.println(&quot;*************获取请求参数相关**************************&quot;); //1.根据请求参数名获取请求单个参数值。 String username = request.getParameter(&quot;username&quot;); System.out.println(username); System.out.println(&quot;***************************************&quot;); //2.根据请求参数名获取请求多个参数值数组。 String[] habbies = request.getParameterValues(&quot;habby&quot;); for (String habby : habbies) &#123; System.out.println(habby); &#125; System.out.println(&quot;***************************************&quot;); //3.获取所有请求参数名。 Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); while (parameterNames.hasMoreElements()) &#123; String parameterName = parameterNames.nextElement(); System.out.println(parameterName); &#125; System.out.println(&quot;***************************************&quot;); /** * 获取请求参数相关 * * 我们获取参数，有时候参数名是一个，但是参数值有多个 * 比如：爱好 habby * 基于这种情况，我们就使用Map来获取请求参数 * 将所有请求参数的值都看作多个来获取 * */ //4.获取所有请求参数的键值对集合。 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); Set&lt;String&gt; strings = parameterMap.keySet(); for (String parameterName : strings) &#123; String[] value = parameterMap.get(parameterName); if(value.length&gt;1)&#123; //请求参数有多个 System.out.println(parameterName + &quot;========&quot; + Arrays.toString(value)); &#125; else &#123; //请求参数有一个 System.out.println(parameterName + &quot;========&quot; + value[0]); &#125; &#125; System.out.println(&quot;***************************************&quot;); /** * 获取请求体中，非键值对数据 * * //5.获取读取请求体的字符输入流。 JSON字符串 * BufferedReader reader = request.getReader(); * System.out.println(&quot;***************************************&quot;); * * //6.获取读取请求体的字节输入流。 文件 文件上传 * ServletInputStream inputStream = request.getInputStream(); * System.out.println(&quot;***************************************&quot;); * */ //7.获得请求体长度的字节数。 int contentLength = request.getContentLength(); System.out.println(contentLength); System.out.println(&quot;*****************其他API **********************&quot;); /** * 其他API */ //1.获取请求的Servlet的映射路径。 String servletPath = request.getServletPath(); System.out.println(servletPath);// /servlet4 //2.获取ServletContext 对象。 ServletContext servletContext = request.getServletContext(); //3.获取请求中的所有cookie。 Cookie[] cookies = request.getCookies(); //4.获取Session对象。 HttpSession session = request.getSession(); session.setAttribute(&quot;sessionKey&quot;,&quot;sessionValue&quot;); String sessionKey = (String) session.getAttribute(&quot;sessionKey&quot;); System.out.println(sessionKey); //sessionValue //5.设置请求体字符集。 String characterEncoding = request.getCharacterEncoding(); System.out.println(characterEncoding);//UTF-8 &#125;&#125; 13.HttpResponse(响应对象) HttpServletResponse是什么？HttpServletResponse是一个接口，其父接口是ServletResponse；HttpServletResponse，是Tomcat 预先创建的，在Tomcat 调用service方法时传入；HttpServletResponse代表对客户端的响应，该对象会被转换成响应的报文发送给客户端，通过该对象我们可以设置响应信息； 13.1HttpResponse怎么用？12345678910111213141516171819202122232425262728293031323334353637383940414243/** * HTppServletResponse * * 响应对象的使用 * */@WebServlet(&quot;/servlet5&quot;)public class Servlet5 extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置响应状态码 response.setStatus(200); //2.设置/修改 响应头键值对 response.setHeader(&quot;key1&quot;,&quot;value1&quot;); //3.设置content-type响应头 及响应字符集（设置MIME类型） response.setContentType(&quot;text/html&quot;); //4.获得向响应体放入信息的字符输出流 PrintWriter writer = response.getWriter(); writer.print(&quot;aaa&quot;); //5.获得向响应体放入信息的字节输出流 ServletOutputStream outputStream = response.getOutputStream(); //6.设置响应体的字节长度，其实就是在设置content--length响应头 response.setContentLength(2); //7.向客户端响应错误信息的方法，需要指定响应码和响应信息 response.sendError(1); //8.向响应体中增加cookie response.addCookie(new Cookie(&quot;JSESSIONID&quot;,&quot;484512424&quot;)); //9.设置响应体字符集 response.setCharacterEncoding(&quot;UTF-8&quot;); &#125;&#125; 14.MIME类型通常在响应设置 httpServletResponse.SetContextType(“MIME类型”) MME类型，可以理解为文档类型，用户表示传递的数据是属于什么类型的文档； 浏览器可以根据MME类型决定该用什么样的方式解析接收到的响应体数据； 可以这样理解：前后端交互数据时，告诉对方发给对方的是html&#x2F;css&#x2F;js&#x2F;图片&#x2F;声音&#x2F;视频&#x2F;。…； tomcat&#x2F;conf&#x2F;web.xml中配置了常见文件的拓展名和MIMIE类型的对应关系； 常见的MIME类型举例如下： 文件拓展名 MIME类型 .html text&#x2F;html .css text&#x2F;css .js application&#x2F;javascript .json application&#x2F;json .png&#x2F;.jpeg&#x2F;.jpg&#x2F;… … image&#x2F;jpeg .mp3&#x2F;.mpe&#x2F;.mpeg&#x2F;… … audio&#x2F;mpeg .mp4 video&#x2F;mp4 .m1v&#x2F;.m2v&#x2F;.mpe&#x2F;… … video&#x2F;mpeg © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://protonlml.github.io/categories/Servlet/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"1.vue","slug":"javaweb/1.vue(编程不良人)","date":"2019-10-06T03:00:00.000Z","updated":"2024-11-30T12:59:50.460Z","comments":true,"path":"2019/10/06/javaweb/1.vue(编程不良人)/","link":"","permalink":"https://protonlml.github.io/2019/10/06/javaweb/1.vue(%E7%BC%96%E7%A8%8B%E4%B8%8D%E8%89%AF%E4%BA%BA)/","excerpt":"","text":"vue ## 1.vue简介 官方定义：渐进式javascript框架==>简化页面中js操作 通俗定义：js框架 用来简化页面dom操作，通过使用vue实现页面中复杂功能从而不需要频繁操作dom甚至不需要操作任何dom vue框架 前后端分离 基础 特性：MVVM双向绑定机制 Model 数据变化-----视图View ## 2.Vue入门案例 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;备忘录小案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 这个Vue对象 V 必须大写！！！！ new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello Vue&quot; &#125;, methods: &#123;&#125; &#125;)&lt;/script&gt; ## 总结 >1.一个页面中只能存在一个vue实例 >2.el代表vue实例作用范围日后只有在作用范围内才能使用vue相关语法 >3.data代表vue实例中一系列数据日后只能在vue作用范围内进行数据获取获取数据方式{{属性名}} >4.在使用{{属性名}}获取数据时获取数据可以进行算数逻辑 调用相关类型相关方法 >5.e1代表vue实例作用范围，el值可以是任何css选择器但是推荐使用id选择器 ## 3.Vue指令的一些总结 首先要明确，所有的Vue指令都是写在html的标签内部的，后跟 \"=\"，==v-on=\" \"== ​ 例如：```div块元素``` ### 3.1 vue指令 ① v-text ,v-html ​ 作用：都是用来获取vue实例中data中声明的属性值，渲染在页面上 ​ 语法: ​ 例如：`````` ​ ``` ``` v-text、{{}}区别：1.v-text取值覆盖标签原始内容 而 {{}}直接将值插入到指定位置：插值表达式 2.v-text在网络条件比较差情况下避免插值闪烁 v-text、v-html 1.v-text直接将获取的数据以文本方式渲染到页面中 相当于 innerText 2.v-html获取的数据先进行html标签解析解析之后在渲染 innerHTML 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;!-- v-text 和 v-html 的使用 v-text 相当于 innerText 获取或者插入 父标签 的 子标签插入 text文本 v-html 相当于 innerHtml 获取或者设置 父标签的 子标签 为 新标签 --&gt; &lt;p v-text=&quot;users[1].age&quot;&gt;&lt;/p&gt; &lt;!-- v-text 原样显示 tag内容--&gt; &lt;p v-text=&quot;tag&quot;&gt;&lt;/p&gt; &lt;!-- v-html 解析tag中的内容，有html标签会解析--&gt; &lt;p v-html=&quot;tag&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;这是msg&quot;, users: [ &#123;id: 1, name: &quot;黄智贤&quot;, age: 23, studentID: 20240901&#125;, &#123;id: 2, name: &quot;蔡徐坤&quot;, age: 11, studentID: 20240902&#125;, &#123;id: 3, name: &quot;黄晓明&quot;, age: 28, studentID: 20240903&#125;, &#123;id: 4, name: &quot;成龙&quot;, age: 53, studentID: 20240904&#125;, ], product: &#123;id: 1, name: &quot;手机&quot;, price: 100&#125;, tag: &quot;&lt;a href=&#x27;www.baidu.com&#x27;&gt;百度一下&lt;/a&gt;&quot; &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; ----- ②.v-on事件绑定 事件三要素：1.事件源 2.事件 3.监听器 作用：用来给html标签绑定指定事件 简化写法：@ ​ 例如：button标签绑定 单击事件 ​ `````` 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 1.v-on 绑定点击事件 v-on 可简写为 @ --&gt; &lt;!-- 点击事件 @click=&quot;&quot; --&gt; &lt;span v-on:click=&quot;fun1($event)&quot;&gt;测试@click&lt;/span&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;!-- 2. @mouseover 鼠标移动到上面 事件 --&gt; &lt;span @mouseover=&quot;fun2()&quot;&gt;测试mouseover&lt;/span&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;!-- 3. @mouseout鼠标移除事件 --&gt; &lt;span @mouseout=&quot;fun3()&quot;&gt;测试mouseout&lt;/span&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;!-- 4. @keydown 键盘按下事件 ，并同时获取keyCod --&gt; &lt;!-- 取event对象 一定使用 $ 来取 --&gt; &lt;span @keydown=&quot;fun4($event)&quot;&gt;&lt;input type=&quot;text&quot;&gt;&lt;/span&gt;&lt;br&gt; &lt;span&gt;按下的键盘按键的 key_Code是&#123;&#123; key_code &#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;!-- 按键修饰符，和键盘事件连用 --&gt; &lt;span @keydown.enter=&quot;fun7&quot;&gt;&lt;input type=&quot;text&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;span @keydown.ctrl=&quot;fun8&quot;&gt;&lt;input type=&quot;text&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;!-- 5. --&gt; &lt;hr&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;!--事件传递 子事件，会传递到父标签上 --&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div3&quot; style=&quot;border: 1px solid rebeccapurple&quot; @mouseover=&quot;fun5()&quot;&gt; &lt;hr&gt; &lt;!-- 属性值，不能使用 &#123;&#123;&#125;&#125; 插值表达式来设置值 src=&quot;&#123;&#123;img&#125;&#125;&quot; 这样写可以显示但是会报错 应该使用v-bind:src 来绑定属性值 --&gt; &lt;img v-bind:src=&quot;img&quot; alt=&quot;切水果&quot; @mouseover=&quot;fun2()&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello Vue&quot;, img: &quot;./2312.jpg&quot;, users: [ &#123;id: 1, name: &quot;黄智贤&quot;, age: 23, studentID: 20240901&#125;, &#123;id: 2, name: &quot;蔡徐坤&quot;, age: 11, studentID: 20240902&#125;, &#123;id: 3, name: &quot;黄晓明&quot;, age: 28, studentID: 20240903&#125;, &#123;id: 4, name: &quot;成龙&quot;, age: 53, studentID: 20240904&#125;, ], product: &#123;id: 1, name: &quot;手机&quot;, price: 100&#125;, tag: &quot;&lt;a href=&#x27;www.baidu.com&#x27;&gt;百度一下&lt;/a&gt;&quot;, // 一定要给一个默认值 key_code: &quot;1&quot; &#125;, methods: &#123; fun1(event) &#123; // 这里书写点击后的逻辑 alert(&quot;点击了测试@click&quot;); &#125;, fun2() &#123; console.log(&quot;fun2测试 鼠标移上去了mouseover&quot;); &#125;, fun3() &#123; console.log(&quot;fun3测试鼠标移走了 mouseout&quot;); &#125;, fun4(event) &#123; let key_code = event.keyCode; this.key_code = key_code; &#125;, fun5(event) &#123; console.log(&quot;div3上面的mouseover鼠标移入事件&quot;); &#125;, fun6() &#123; alert(&quot;图片被点击了&quot;); &#125;, fun7() &#123; alert(&quot;回车键被按下了&quot;); &#125;, fun8() &#123; console.log(&quot;ctrl被按下了&quot;) &#125; &#125; &#125;);&lt;/script&gt; ----- ③. v-show ; v-if指令 ​ 作用：都是用来控制html标签 哪些显示 哪些不显示 ​ 语法：直接在对应标签加入v-show=\"true\" v-if=\"false\" ​ 例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .img_sg &#123; whith: 100px; height: 100px &#125; .img_dj &#123; width: 100px; height: 120px &#125; .dashed_div &#123; width: 200px; height: 200px; border: 10px dashed green; &#125; .solid_div &#123; width: 200px; height: 200px; border: 10px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;!-- v-if 指令 和 v-show指令的使用 这两个指令都是对页面元素的隐藏与显示 需求：不同人看到的页面不一样，比如管理员能看到所有页面元素，访客可能就看不到有一些元素 v-if=&quot;true&quot; 显示 v-show=&quot;true&quot; 显示 区别： v-if 作用于标签上值为false时，会删除dom树上的这个节点（页面开销） v-show 只是控制当前标签的css样式。其dom树还在。 F12查看 --&gt; &lt;div v-if=&quot;true&quot;&gt;hellow1&lt;/div&gt; &lt;!-- 使用vue来控制--&gt; &lt;div v-if=&quot;isShow&quot;&gt;hellow2&lt;/div&gt; &lt;!-- v-show也可以控制页面元素是否显示 --&gt; &lt;div v-show=&quot;true&quot;&gt;hellow3&lt;/div&gt; &lt;!-- 使用vue对象中的data属性--&gt; &lt;div v-show=&quot;isShow&quot;&gt;hellow4&lt;/div&gt; &lt;br&gt; &lt;button @click=&quot;fun2&quot;&gt;点我hellow2和hellow4显示或者隐藏&lt;/button&gt; &lt;hr&gt; &lt;hr&gt; &lt;hr&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, //作用范围 data: &#123; msg: &quot;hello vue&quot;, isShow: &quot;true&quot;, img_src: &quot;./img/2312.jpg&quot;, img_style: &quot;img_sg&quot;, div_css: &quot;dashed_div&quot; &#125;, methods: &#123; fun1() &#123; 0 console.log(&quot;fun1&quot;) this.isShow = false; &#125;, fun2() &#123; console.log(&quot;fun2执行le&quot;); this.isShow = !this.isShow; &#125;, fun3() &#123; console.log(&quot;fun3执行了&quot;); this.img_src = &quot;./img/2312.jpg&quot;; this.img_style = &quot;img_sg&quot; &#125;, fun4() &#123; console.log(&quot;fun4执行了&quot;); this.img_src = &quot;./img/dijia.jpeg&quot;; this.img_style = &quot;img_dj&quot; &#125;, dashedLine() &#123; this.div_css = &quot;dashed_div&quot; &#125;, solidLine() &#123; this.div_css = &quot;solid_div&quot; &#125; &#125; &#125;);&lt;/script&gt; ​ 区别：v-if操作dom v-show 操作css ​ 总结：页面元素频繁的显示隐藏 变化快 v-show 页面元素变化慢v-if ----- ④. v-bind 指令 ​ 作用：用来将html标签属性 绑定vue实例进行管理 ​ 语法：绑定哪个数据直接在属性前加入 v-bind:属性名=\"vue管理属性值\" ​ 简化写法：v-bind： ​ 简化之后直接一个冒号 ： ​ 例如：`````` 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .img_sg &#123; whith: 100px; height: 100px &#125; .img_dj &#123; width: 100px; height: 120px &#125; .dashed_div &#123; width: 200px; height: 200px; border: 10px dashed green; &#125; .solid_div &#123; width: 200px; height: 200px; border: 10px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;!-- v-bind 指令的使用 v-bind指令是用来，绑定 标签上的属性的， 将标签属性的值，交给vue实例来管理 --&gt; &lt;!-- 使用场景：鼠标移入照片上，切换照片，移除照片切换照片--&gt; &lt;!--思路：切换img的src 让其动态的指定不同照片的路径，使用v-bind来绑定属性 鼠标移动到img图片上，和从img图片上移除，都绑定事件。来切换src照片地址 --&gt; &lt;!-- &lt;img src=&quot;./img/2312.jpg&quot; alt=&quot;切水果&quot;&gt;--&gt; &lt;!-- 这里，img图片源的 src 通过v-bind：进行绑定了。 img 图片的 class 样式 也进行了绑定， 达到一定条件，样式就改变了。 使用了， v-bind： 的简化写法 ： 直接一个冒号就可以了 --&gt; &lt;img :class=&quot;img_style&quot; v-bind:src=&quot;img_src&quot; alt=&quot;照片&quot; @mouseover=&quot;fun3&quot; @mouseout=&quot;fun4&quot;&gt; &lt;hr&gt; &lt;hr&gt; &lt;hr&gt; &lt;!-- 只要是html标签所具有的属性，其都可以进行绑定， 除了form 表单中 input框框中的value值，只能用 v-mode 来绑定 --&gt; &lt;!--这里是div的样式为动态的--&gt; &lt;div :class=&quot;div_css&quot;&gt;&lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;button @click=&quot;dashedLine&quot;&gt;切换为虚线&lt;/button&gt; &lt;button @click=&quot;solidLine&quot;&gt;切换为实线&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, //作用范围 data: &#123; msg: &quot;hello vue&quot;, isShow: &quot;true&quot;, img_src: &quot;./img/2312.jpg&quot;, img_style: &quot;img_sg&quot;, div_css: &quot;dashed_div&quot; &#125;, methods: &#123; fun3() &#123; console.log(&quot;fun3执行了&quot;); this.img_src = &quot;./img/2312.jpg&quot;; this.img_style = &quot;img_sg&quot; &#125;, fun4() &#123; console.log(&quot;fun4执行了&quot;); this.img_src = &quot;./img/dijia.jpeg&quot;; this.img_style = &quot;img_dj&quot; &#125;, dashedLine() &#123; this.div_css = &quot;dashed_div&quot; &#125;, solidLine() &#123; this.div_css = &quot;solid_div&quot; &#125; &#125; &#125;);&lt;/script&gt; ⑤. v-for指令 作用：用来对vue实例中数据进行循环遍历 到指定html标签中 语法：直接在对应标签上使用对象数组数组对象v-for=\"（index,value,key）（index,item）（index,item）in vue实例遍历数据\" ​ 注意：建议后面跟着 :key=\"唯一标识\" 这是为了使vue更好的确定唯一值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #table, #table tr, #table tr td, #table tr th &#123; border: 1px solid red; border-collapse: collapse; text-align: center; &#125; #table tr, #table tr td, #table tr th &#123; width: 80px; height: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;br&gt; &lt;!-- v-for的使用 v-for 可以用来，遍历对象 要想将哪个标签循环显示，就直接在这个标签上面使用 v-for &lt;td v-for=&quot;&quot; :key=&quot;&quot;&gt;&lt;/td&gt; 遍历对象固定写法：v-for=&quot; 单个值 角标 in vue实例中的属性 &quot; :key=&quot;单个值.id&quot; 例如：v-for=&quot;(index,value,key) in user&quot; :key=&quot;value.id&quot; 固定写法： 遍历数组 如： v-for=&quot;index,user in users&quot; :key=&quot;user.id&quot; 注意：这里面的index是当前循环的角标 0开始，而且要写在第一个位置 --&gt; &lt;span&gt;做一个表格&lt;/span&gt; &lt;table id=&quot;table&quot;&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;(index,user) in users &quot; :key=&quot;user.id&quot;&gt; &lt;td&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/td&gt; &lt;td v-text=&quot;user.name&quot;&gt;&lt;/td&gt; &lt;td v-html=&quot;user.age&quot;&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123; user.studentID &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; user.fraction &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;ul&gt; &lt;li v-for=&quot;(index ,user) in users&quot; :key=&quot;user.id&quot;&gt;&#123;&#123; user.name &#125;&#125;_------&#123;&#123; index &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;hr&gt; &lt;hr&gt; &lt;hr&gt; &lt;hr&gt; &lt;!-- v-mode的使用 是用来绑定 form表单中的value的属性 v-mode 是最能直接体现 VMMV 的 双向绑定特性 如下： --&gt; &lt;form&gt; 用户名：&lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt; &lt;br&gt; 密码：&lt;input type=&quot;text&quot; v-model=&quot;user.password&quot;&gt;&lt;br&gt; email: &lt;input type=&quot;text&quot; v-model=&quot;user.email&quot;&gt;&lt;br&gt; qq: &lt;input type=&quot;text&quot; v-model=&quot;user.qq&quot;&gt;&lt;br&gt; &lt;!-- 注册按钮，是用来 发送 ajax请求的 获取form表单中所有的值--&gt; &lt;input type=&quot;button&quot; value=&quot;注册&quot; @click=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello Vue&quot;, users: [ &#123;name: &quot;张三&quot;, age: 23, studentID: 20240901, fraction: 180&#125;, &#123;name: &quot;李四&quot;, age: 24, studentID: 20240902, fraction: 100&#125;, &#123;name: &quot;万物&quot;, age: 25, studentID: 20240903, fraction: &quot;4411&quot;&#125;, ], user: &#123;&#125; &#125;, methods: &#123; submit() &#123; console.log(this.user); &#125; &#125; &#125;)&lt;/script&gt; ⑥. v-model指令 作用：用来将form表单中 绑定value 的值 value属性绑定给vue实例进行管理 注意：最能直观体现双向绑定原理的指令 语法：直接在对应form表单标签中加入`````` 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #table, #table tr, #table tr td, #table tr th &#123; border: 1px solid red; border-collapse: collapse; text-align: center; &#125; #table tr, #table tr td, #table tr th &#123; width: 80px; height: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;br&gt; &lt;!-- v-mode的使用 是用来绑定 form表单中的value的属性 v-mode 是最能直接体现 VMMV 的 双向绑定特性 如下： --&gt; &lt;form&gt; 用户名：&lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt; &lt;br&gt; 密码：&lt;input type=&quot;text&quot; v-model=&quot;user.password&quot;&gt;&lt;br&gt; email: &lt;input type=&quot;text&quot; v-model=&quot;user.email&quot;&gt;&lt;br&gt; qq: &lt;input type=&quot;text&quot; v-model=&quot;user.qq&quot;&gt;&lt;br&gt; &lt;!-- 注册按钮，是用来 发送 ajax请求的 获取form表单中所有的值--&gt; &lt;input type=&quot;button&quot; value=&quot;注册&quot; @click=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello Vue&quot;, users: [ &#123;name: &quot;张三&quot;, age: 23, studentID: 20240901, fraction: 180&#125;, &#123;name: &quot;李四&quot;, age: 24, studentID: 20240902, fraction: 100&#125;, &#123;name: &quot;万物&quot;, age: 25, studentID: 20240903, fraction: &quot;4411&quot;&#125;, ], user: &#123;&#125; &#125;, methods: &#123; submit() &#123; console.log(this.user); &#125; &#125; &#125;)&lt;/script&gt; ## 4.小案例： ### 4.1备忘录小案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;备忘录小案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;!-- &lt;a href=&quot;javascript:&quot; @click=&quot;deleteByIndex(index)&quot;&gt;删除&lt;/a&gt; a标签中的 href=&quot;javascript:&quot; 阻止了a标签的默认行为，就是加上这句话后，点击a标签，不会跳转刷新页面--&gt; &lt;!-- &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;--&gt; 请输入内容：&lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加到备忘录&quot; @click=&quot;addMemo&quot;&gt;&lt;br&gt; &lt;ul&gt; &lt;!-- &lt;li&gt;1.今天晚上吃点好吃的&lt;/li&gt;--&gt; &lt;!-- &lt;li&gt;2.今天晚上一起打游戏&lt;/li&gt;--&gt; &lt;!-- &lt;li&gt;3.今天晚上一起学习&lt;/li&gt;--&gt; &lt;li v-for=&quot; (index ,record) in lis&quot; :key=&quot;record.id&quot; track-by=&quot;$index&quot;&gt;&#123;&#123; index + 1 &#125;&#125;.&#123;&#123; record &#125;&#125; &lt;a href=&quot;javascript:&quot; @click=&quot;deleteByIndex(index)&quot;&gt;删除&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;a href=&quot;javascript:&quot; @click=&quot;clearMemo&quot;&gt;清空备忘录&lt;/a&gt; &lt;br&gt; &lt;h3&gt;当前备忘录共：&#123;&#123; lis.length &#125;&#125;条&lt;/h3&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;&quot;, lis: [&quot;今天晚上吃点好吃的&quot;, &quot;今天晚上一起打游戏&quot;, &quot;今天晚上一起学习&quot;] &#125;, methods: &#123; addMemo() &#123; // 将input框框中的值添加到 li列表中 if (!this.msg) &#123; alert(&quot;请输入内容！&quot;); return false; &#125; this.lis.push(this.msg); this.msg = &quot;&quot;; &#125;, deleteByIndex(index)&#123; this.lis.splice(index, 1); &#125;, clearMemo() &#123; // 清空备忘录 this.lis.deleteData(); &#125; &#125; &#125;)&lt;/script&gt; ## 5.练习 ### 1.购物车案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;购物车案例&lt;/title&gt; &lt;style&gt; #table &#123; margin: 0 auto; &#125; #table, #table tr, #table th, #table td &#123; width: 500px; border: 1px solid black; text-align: center; border-collapse: collapse; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;购物车案例&lt;/h1&gt; 编号：&lt;input type=&quot;text&quot;&gt; 名称：&lt;input type=&quot;text&quot;&gt; 价格：&lt;input type=&quot;text&quot;&gt; 数量：&lt;input type=&quot;text&quot;&gt; &lt;button&gt;添加到购物车&lt;/button&gt; &lt;br&gt; &lt;br&gt; &lt;table id=&quot;table&quot;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;购买数量&lt;/th&gt; &lt;th&gt;小计&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;(index,product) in products&quot; :key=&quot;product.id&quot;&gt; &lt;td&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; product.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; product.price &#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;+&quot; @click=&quot;quantityIn(index)&quot;&gt;&amp;nbsp&#123;&#123; product.number &#125;&#125;&amp;nbsp&lt;input type=&quot;button&quot; value=&quot;-&quot; @click=&quot;quantityRt(index)&quot;&gt;&lt;/td&gt; &lt;!-- 这种计算的列，直接写计算表达式 --&gt; &lt;td&gt;&#123;&#123; (product.number * product.price).toFixed(2) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&#123;&#123; products.length + 1 &#125;&#125;&lt;/td&gt; &lt;td&gt;总价格&lt;/td&gt; &lt;td colspan=&quot;3&quot;&gt;&#123;&#123; totalPrice &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; stock: 10, //库存数 products: [ &#123;name: &quot;iphone8&quot;, price: 19.95, number: 1&#125;, &#123;name: &quot;meta40 pro&quot;, price: 25.22, number: 1&#125;], total: 0 &#125;, methods: &#123; // 数量增加 quantityIn(index) &#123; if (this.products[index].number &lt; this.stock) &#123; this.products[index].number++; // 总价格变化 this.totalPrice; &#125; else &#123; alert(&quot;最多只能买10件&quot;) &#125; &#125;, // 数量减少 quantityRt(index) &#123; if (this.products[index].number &gt; 1) &#123; this.products[index].number--; // 总价格变化 this.totalPrice; &#125; else &#123; alert(&quot;数量错误&quot;); &#125; &#125;, &#125;, //做计算用的属性 /* * 作用： 用来在vue实例中完成相关业务计算工作 日后在将某个数据渲染页面时 （如果该数据不是直出）需要经过业务处理之后(计算逻辑)再渲染就可以使用 computed 好处： 提升vue运行性能主要使用computed进行计算相关处理会将第一次计算结果进行缓存， * 便于日后页面多次使用&#123;&#123;&#125;&#125;页面中多次使用插值表达式来取这个值 * 使用的时候，直接写属性名totalPrice，不要写totalPrice() * */ computed: &#123; //计算总价格 // 在计算值的时候，从data中取值，一定要注意 取的是字符串，一定要转为int 或者 float totalPrice() &#123; console.log(&quot;===============methods=============&quot;); var totalPrice = 0; for (let i = 0; i &lt; this.products.length; i++) &#123; totalPrice += this.products[i].number * this.products[i].price; &#125; return totalPrice.toFixed(2); &#125; &#125;, created() &#123; this.totalPrice; &#125; &#125;);&lt;/script&gt; ## 6.computed 属性的使用 12345* 作用： 用来在vue实例中完成相关业务计算工作 日后在将某个数据渲染页面时 （如果该数据不是直出）需要经过业务处理之后(计算逻辑)再渲染就可以使用 computed 好处： 提升vue运行性能主要使用computed进行计算相关处理会将第一次计算结果进行缓存， * 便于日后页面多次使用&#123;&#123;&#125;&#125;页面中多次使用插值表达式来取这个值 1234567891011121314151617181920212223242526272829303132333435363738-------------------------------------------------------&lt;td&gt;总价格&lt;/td&gt; &lt;td colspan=&quot;3&quot;&gt;&#123;&#123; totalPrice &#125;&#125;&lt;/td&gt; &lt;td colspan=&quot;3&quot;&gt;&#123;&#123; totalPrice &#125;&#125;&lt;/td&gt; &lt;td colspan=&quot;3&quot;&gt;&#123;&#123; totalPrice &#125;&#125;&lt;/td&gt;这里面页面使用了三次&#123;&#123; totalPrice &#125;&#125; 实际只计算1次，因为 totalPrice 的计算，放在了computed: &#123;&#125; 里面实际上，只要不是直出数据渲染到页面上，就可以将计算，放在computed: &#123;&#125; 中。来提高运行速度-----------------------------------------------------//做计算用的属性 /* * 作用： 用来在vue实例中完成相关业务计算工作 日后在将某个数据渲染页面时 （如果该数据不是直出）需要经过业务处理之后(计算逻辑)再渲染就可以使用 computed 好处： 提升vue运行性能主要使用computed进行计算相关处理会将第一次计算结果进行缓存， * 便于日后页面多次使用&#123;&#123;&#125;&#125;页面中多次使用插值表达式来取这个值 * */ new Vue(&#123; el: &quot;#app&quot;, data: &#123; &#125;, methods:&#123; &#125;, computed: &#123; //计算总价格 // 在计算值的时候，从data中取值，一定要注意 取的是字符串，一定要转为int 或者 float totalPrice() &#123; console.log(&quot;===============methods=============&quot;); var totalPrice = 0; for (let i = 0; i &lt; this.products.length; i++) &#123; totalPrice += this.products[i].number * this.products[i].price; &#125; return totalPrice.toFixed(2); &#125; &#125; &#125;); ## 7.事件修饰符 >7.1 .stop > 作用：用来阻止事件冒泡 用来阻止事件继续问外层传递（前提是内外层的事件，是同种类型的事件） >7.2 .prevent > 作用：用来阻止标签的默认行为 >7.3 .self > 作用：只监所自身标签触发的事件，一般用在父级元素上面，只关注父元素本身事件，子元素就算触发了它的事件，父元素也会忽略 >7.4 .once > 作用：该事件只触发一次 ### 7.1 阻止标签的默认行为发生 12345678910&lt;!-- 阻止 标签的默认行行为 方法1： 在事件上使用prevent修饰符来，去除a标签的默认行为 方法2：在href上面写 &lt;a href=&quot;javaScript:&quot; @click=&quot;a&quot;&gt;a标签&lt;/a&gt; --&gt; &lt;br&gt; &lt;hr&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;a&quot;&gt;a标签&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;javaScript:&quot; @click=&quot;a&quot;&gt;a标签&lt;/a&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #div1 &#123; //border: 3px solid red; background: red; width: 500px; height: 500px; &#125; #div2 &#123; //border: 3px solid orchid; background: yellow; width: 300px; height: 300px; margin-left: 100px; float: left; margin-top: 100px; &#125; #div3 &#123; //border: 3px solid green; background: blue; width: 100px; height: 100px; margin-left: 100px; float: left; margin-top: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- .stop 作用：用来阻止事件冒泡 用来阻止事件继续问外层传递（前提是内外层的事件，是同种类型的事件） .prevent 作用：用来阻止标签的默认行为 .self 作用：只监所自身标签触发的事件，一般用在父级元素上面，只关注父元素本身的事件，子元素就算触发了它的事件，父元素也会忽略 .once 作用：该事件只触发一次--&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; msg1 &#125;&#125;&lt;/h1&gt; &lt;!-- 事件冒泡： 前提是，外层元素标签绑定的事件，和内层标签绑定的是同一种事件， 当内层子标签，触发了它上面的事件， 其外层父标签也会自动除法事件。 这就是事件冒泡 解决办法： 不想让事件往外层冒泡，可以直接在内层标签元素的事件上面，加上事件修饰符.stop 就是 用来阻止其事件往外层传递 --&gt; &lt;div id=&quot;div1&quot; @click=&quot;div1click&quot;&gt; &lt;div id=&quot;div2&quot; @click.stop=&quot;div2click&quot;&gt; &lt;div id=&quot;div3&quot; @click.stop=&quot;div3click&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 阻止 标签的默认行行为 方法1： 在事件上使用prevent修饰符来，去除a标签的默认行为 方法2：在href上面写 &lt;a href=&quot;javaScript:&quot; @click=&quot;a&quot;&gt;a标签&lt;/a&gt; --&gt; &lt;br&gt; &lt;hr&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;a&quot;&gt;a标签&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;javaScript:&quot; @click=&quot;a&quot;&gt;a标签&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg1: &quot;事件冒泡&quot; &#125;, methods: &#123; div1click() &#123; console.log(&quot;div1被点击了&quot;); &#125;, div2click() &#123; console.log(&quot;div2被点击了&quot;); &#125;, div3click() &#123; console.log(&quot;div3被点击了&quot;); &#125;, a() &#123; console.log(&quot;a标签被点击了，执行了该方法，默认的行为href跳转失效了&quot;); &#125; &#125;, computed: &#123;&#125; &#125;)&lt;/script&gt; ## 8.按键修饰符（和键盘事件连用“keydown”“keyup”\"keypress\"\"） **Vue** **允许为** **v-on** **在监听键盘事件时添加按键修饰符 ** **就是把我们常用的键盘按键，给做成了属性，我们在使用“keydown”“keyup”\"keypress\"\"事件的时候，可以直接在：“事件后面.属性”** > > >.enter > >.tab > >.delete (捕获\"删除\"和 \"退格\"键) > >.esc > >.space > >.up > >.down > >.left > >.right > >.ctrl > >.alt > >.shift > >.meta 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;v-on 按钮修饰符&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; @keydown.enter=&quot;fun1&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, //表示当前vue对象接管了 div 区域 methods: &#123; fun1: function () &#123; alert(&quot;你按了回车&quot;); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 子组件事件传递， 子组件，调用父组件中的，函数。 可以传一个参数。 反过来看，就明白了？变相子组件，传数据给父组件 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"vue","slug":"vue","permalink":"https://protonlml.github.io/categories/vue/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"}],"author":"𝚲𝚳𝚲"},{"title":"10.mysql第13章约束","slug":"mysql/10.mysql第13章约束","date":"2019-10-03T10:00:00.000Z","updated":"2024-11-02T16:16:04.352Z","comments":true,"path":"2019/10/03/mysql/10.mysql第13章约束/","link":"","permalink":"https://protonlml.github.io/2019/10/03/mysql/10.mysql%E7%AC%AC13%E7%AB%A0%E7%BA%A6%E6%9D%9F/","excerpt":"","text":"约束 1. 约束(constraint)概述1. 1 为什么需要约束数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。为了保证数据的完整性，SQL规范以约束的方式对 表数据进行额外的条件限制 。从以下四个方面考虑：实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男&#x2F;女”引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的 5 倍。1. 2 什么是约束约束是表级的强制规定。可以在 创建表时规定约束（通过 CREATE TABLE 语句） ，或者在 表创建之后通过 ALTER TABLE 语句规定约束 。1. 3 约束的分类根据约束数据列的限制， 约束可分为：单列约束 ：每个约束只约束一列多列约束 ：每个约束可约束多列数据根据约束的作用范围 ，约束可分为：列级约束 ：只能作用在一个列上，跟在列的定义后面表级约束 ：可以作用在多个列上，不与列一起，而是单独定义根据约束起的作用 ，约束可分为：NOT NULL 非空约束，规定某个字段不能为空UNIQUE 唯一约束 ， 规定某个字段在整个表中是唯一的PRIMARY KEY 主键(非空且唯一)约束FOREIGN KEY 外键约束CHECK 检查约束DEFAULT 默认值约束位置 支持的约束类型 是否可以起约束名列级约束： 列的后面 语法都支持，但外键没有效果 不可以表级约束： 所有列的下面 默认和非空不支持，其他支持 可以（主键没有效果）注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果查看某个表已有的约束2. 非空约束2. 1 作用限定某个字段&#x2F;某列的值不允许为空2. 2 关键字NOT NULL2. 3 特点默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空一个表可以有很多列都分别限定了非空空字符串’’不等于NULL， 0 也不等于NULL2. 4 添加非空约束（ 1 ）建表时举例：1234#information_schema数据库名（系统库）#table_constraints表名称（专门存储各个表的约束）SELECT * FROM information_schema.table_constraintsWHERE table_name = &#x27;表名称&#x27;; CREATE TABLE 表名称(字段名 数据类型,字段名 数据类型 NOT NULL,字段名 数据类型 NOT NULL);（ 2 ）建表后举例：2. 5 删除非空约束举例：3. 唯一性约束12345CREATE TABLE emp(id INT( 10 ) NOT NULL,NAME VARCHAR( 20 ) NOT NULL,sex CHAR NULL); 123456CREATE TABLE student(sid int,sname varchar( 20 ) not null,tel char( 11 ) ,cardid char( 18 ) not null); 1insert into student values( 1 ,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;110222198912032545&#x27;); #成功 12insert into student values( 2 ,&#x27;李四&#x27;,&#x27;13710011002&#x27;,null);#身份证号为空ERROR 1048 ( 23000 ): Column &#x27;cardid&#x27; cannot be null 1insert into student values( 2 ,&#x27;李四&#x27;,null,&#x27;110222198912032546&#x27;);#成功，tel允许为空 12insert into student values( 3 ,null,null,&#x27;110222198912032547&#x27;);#失败ERROR 1048 ( 23000 ): Column &#x27;sname&#x27; cannot be null 1alter table 表名称 modify 字段名 数据类型 not null; 12ALTER TABLE empMODIFY sex VARCHAR( 30 ) NOT NULL; 1alter table student modify sname varchar( 20 ) not null; 12alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空 或1alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空 12ALTER TABLE empMODIFY sex VARCHAR( 30 ) NULL; 12ALTER TABLE empMODIFY NAME VARCHAR( 15 ) DEFAULT &#x27;abc&#x27; NULL; 3. 1 作用用来限制某个字段&#x2F;某列的值不能重复。3. 2 关键字UNIQUE3. 3 特点同一个表可以有多个唯一约束。唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。唯一性约束允许列值为空。在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。MySQL会给唯一约束的列上默认创建一个唯一索引。3. 4 添加唯一约束（ 1 ）建表时举例：123456789101112create table 表名称(字段名 数据类型,字段名 数据类型 unique,字段名 数据类型 unique key,字段名 数据类型);create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,[constraint 约束名] unique key(字段名)); 表示用户名和密码组合不能重复（ 2 ）建表后指定唯一键约束举例：123456create table student(sid int,sname varchar( 20 ),tel char( 11 ) unique,cardid char( 18 ) unique key); 12345CREATE TABLE t_course(cid INT UNIQUE,cname VARCHAR( 100 ) UNIQUE,description VARCHAR( 200 )); CREATE TABLE USER(123456id INT NOT NULL,NAME VARCHAR( 25 ),PASSWORD VARCHAR( 16 ),-- 使用表级约束语法CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD)); 12insert into student values( 1 ,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);insert into student values( 2 ,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;); 12345678mysql&gt; select * from student;+-----+-------+-------------+--------------------+| sid | sname | tel | cardid |+-----+-------+-------------+--------------------+| 1 | 张三 | 13710011002 | 101223199012015623 || 2 | 李四 | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec) 12insert into student values( 3 ,&#x27;王五&#x27;,&#x27;13710011004&#x27;,&#x27;101223199012015624&#x27;); #身份证号重复ERROR 1062 ( 23000 ): Duplicate entry &#x27;101223199012015624&#x27; for key &#x27;cardid&#x27; 12insert into student values( 3 ,&#x27;王五&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015625&#x27;);ERROR 1062 ( 23000 ): Duplicate entry &#x27;13710011003&#x27; for key &#x27;tel&#x27; #字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的#方式 1 ：1alter table 表名称 add unique key(字段列表); #方式 2 ：1alter table 表名称 modify 字段名 字段类型 unique; ALTER TABLE USERADD UNIQUE(NAME,PASSWORD);举例：3. 5 关于复合唯一约束ALTER TABLE USER1ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD); ALTER TABLE USERMODIFY NAME VARCHAR( 20 ) UNIQUE;123456create table student(sid int primary key,sname varchar( 20 ),tel char( 11 ) ,cardid char( 18 )); 12alter table student add unique key(tel);alter table student add unique key(cardid); 1234567create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的); #学生表123456create table student(sid int, #学号sname varchar( 20 ), #姓名tel char( 11 ) unique key, #电话cardid char( 18 ) unique key #身份证号); #课程表1234create table course(cid int, #课程编号cname varchar( 20 ) #课程名称); #选课表1234567create table student_course(id int,sid int,cid int,score int,unique key(sid,cid) #复合唯一); 123insert into student values( 1 ,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);#成功insert into student values( 2 ,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;);#成功insert into course values( 1001 ,&#x27;Java&#x27;),( 1002 ,&#x27;MySQL&#x27;);#成功 1mysql&gt; select * from student; 3. 5 删除唯一约束添加唯一性约束的列上也会自动创建唯一索引。删除唯一约束只能通过删除唯一索引的方式删除。删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。注意：可以通过 show index from 表名称;查看表的索引+—–+——-+————-+——————–+123456| sid | sname | tel | cardid |+-----+-------+-------------+--------------------+| 1 | 张三 | 13710011002 | 101223199012015623 || 2 | 李四 | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec) 12345678mysql&gt; select * from course;+------+-------+| cid | cname |+------+-------+| 1001 | Java || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec) 12345insert into student_course values( 1 , 1 , 1001 , 89 ),( 2 , 1 , 1002 , 90 ),( 3 , 2 , 1001 , 88 ),( 4 , 2 , 1002 , 56 );#成功 12345678910mysql&gt; select * from student_course;+----+------+------+-------+| id | sid | cid | score |+----+------+------+-------+| 1 | 1 | 1001 | 89 || 2 | 1 | 1002 | 90 || 3 | 2 | 1001 | 88 || 4 | 2 | 1002 | 56 |+----+------+------+-------+4 rows in set (0.00 sec) 1insert into student_course values ( 5 , 1 , 1001 , 88 );#失败 1#ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;sid&#x27; 违反sid-cid的复合唯一 12SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; #查看都有哪些约束 ALTER TABLE USER1DROP INDEX uk_name_pwd; 4. PRIMARY KEY 约束4. 1 作用用来唯一标识表中的一行记录。4. 2 关键字primary key4. 3 特点主键约束相当于 唯一约束+非空约束的组合 ，主键约束列不允许重复，也不允许出现空值。一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。主键约束对应着表中的一列或者多列（复合主键）如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。MySQL的主键名总是PRIMARY ，就算自己命名了主键约束名也没用。当创建主键约束时，系统默认会在所在的列或列组合上建立对应的 主键索引 （能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。4. 4 添加主键约束（ 1 ）建表时指定主键约束举例：1234567891011create table 表名称(字段名 数据类型 primary key, #列级模式字段名 数据类型,字段名 数据类型);create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,[constraint 约束名] primary key(字段名) #表级模式); 1234create table temp(id int primary key,name varchar( 20 )); 12345678mysql&gt; desc temp;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int( 11 ) | NO | PRI | NULL | || name | varchar( 20 ) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) 12insert into temp values( 1 ,&#x27;张三&#x27;);#成功insert into temp values( 2 ,&#x27;李四&#x27;);#成功 12345678mysql&gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 |+----+------+2 rows in set (0.00 sec) 12insert into temp values( 1 ,&#x27;张三&#x27;);#失败ERROR 1062 ( 23000 ): Duplicate（重复） entry（键入，输入） &#x27;1&#x27; for key &#x27;PRIMARY&#x27; 12insert into temp values( 1 ,&#x27;王五&#x27;);#失败ERROR 1062 ( 23000 ): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27; 1insert into temp values( 3 ,&#x27;张三&#x27;);#成功 再举例：列级约束表级约束（ 2 ）建表后增加主键约束123456789mysql&gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 || 3 | 张三 |+----+------+3 rows in set (0.00 sec) 1insert into temp values( 4 ,null);#成功 12insert into temp values(null,&#x27;李琦&#x27;);#失败ERROR 1048 ( 23000 ): Column &#x27;id&#x27; cannot be null 12345678910mysql&gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 || 3 | 张三 || 4 | NULL |+----+------+4 rows in set (0.00 sec) #演示一个表建立两个主键约束12345create table temp(id int primary key,name varchar( 20 ) primary key);ERROR 1068 ( 42000 ): Multiple（多重的） primary key defined（定义） 1234CREATE TABLE emp4(id INT PRIMARY KEY AUTO_INCREMENT ,NAME VARCHAR( 20 )); 123456CREATE TABLE emp5(id INT NOT NULL AUTO_INCREMENT,NAME VARCHAR( 20 ),pwd VARCHAR( 15 ),CONSTRAINT emp5_id_pk PRIMARY KEY(id)); ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键4. 5 关于复合主键1ALTER TABLE student ADD PRIMARY KEY (sid); 1ALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd); 123456create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,primary key(字段名1,字段名2) #表示字段 1 和字段 2 的组合是唯一的，也可以有更多个字段); #学生表1234create table student(sid int primary key, #学号sname varchar( 20 ) #学生姓名); #课程表1234create table course(cid int primary key, #课程编号cname varchar( 20 ) #课程名称); #选课表123456create table student_course(sid int,cid int,score int,primary key(sid,cid) #复合主键); 12insert into student values( 1 ,&#x27;张三&#x27;),( 2 ,&#x27;李四&#x27;);insert into course values( 1001 ,&#x27;Java&#x27;),( 1002 ,&#x27;MySQL&#x27;); 12345678mysql&gt; select * from student;+-----+-------+| sid | sname |+-----+-------+| 1 | 张三 || 2 | 李四 |+-----+-------+2 rows in set (0.00 sec) 12345678mysql&gt; select * from course;+------+-------+| cid | cname |+------+-------+| 1001 | Java || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec) 1insert into student_course values( 1 , 1001 , 89 ),( 1 , 1002 , 90 ),( 2 , 1001 , 88 ),( 2 , 1002 , 56 ); 再举例4. 6 删除主键约束举例：说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。5. 自增列：AUTO_INCREMENT12345678910mysql&gt; select * from student_course;+-----+------+-------+| sid | cid | score |+-----+------+-------+| 1 | 1001 | 89 || 1 | 1002 | 90 || 2 | 1001 | 88 || 2 | 1002 | 56 |+-----+------+-------+4 rows in set (0.00 sec) 12insert into student_course values( 1 , 1001 , 100 );ERROR 1062 ( 23000 ): Duplicate entry &#x27;1-1001&#x27; for key &#x27;PRIMARY&#x27; 123456789mysql&gt; desc student_course;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| sid | int( 11 ) | NO | PRI | NULL | || cid | int( 11 ) | NO | PRI | NULL | || score | int( 11 ) | YES | | NULL | |+-------+---------+------+-----+---------+-------+3 rows in set (0.00 sec) 123456CREATE TABLE emp6(id INT NOT NULL,NAME VARCHAR( 20 ),pwd VARCHAR( 15 ),CONSTRAINT emp7_pk PRIMARY KEY(NAME,pwd)); 1alter table 表名称 drop primary key; 1ALTER TABLE student DROP PRIMARY KEY; 1ALTER TABLE emp5 DROP PRIMARY KEY; 5. 1 作用某个字段的值自增5. 2 关键字auto_increment5. 3 特点和要求（ 1 ）一个表最多只能有一个自增长列（ 2 ）当需要产生唯一标识符或顺序值时，可设置自增长（ 3 ）自增长列约束的列必须是键列（主键列，唯一键列）（ 4 ）自增约束的列的数据类型必须是整数类型（ 5 ）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。错误演示：5. 4 如何指定自增约束（ 1 ）建表时123456create table employee(eid int auto_increment,ename varchar( 20 ));# ERROR 1075 (42000): Incorrect table definition; there can be only one auto columnand it must be defined as a key 123456create table employee(eid int primary key,ename varchar( 20 ) unique key auto_increment);# ERROR 1063 (42000): Incorrect column specifier for column &#x27;ename&#x27; 因为ename不是整数类型 123456789101112create table 表名称(字段名 数据类型 primary key auto_increment,字段名 数据类型 unique key not null,字段名 数据类型 unique key,字段名 数据类型 not null default 默认值,);create table 表名称(字段名 数据类型 default 默认值 ,字段名 数据类型 unique key auto_increment,字段名 数据类型 not null default 默认值,,primary key(字段名)); 1234create table employee(eid int primary key auto_increment,ename varchar( 20 )); （ 2 ）建表后例如：5. 5 如何删除自增约束5. 6 MySQL 8. 0 新特性—自增变量的持久化在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT&#x3D;max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 在MySQL 5.7版本中，测试步骤如下： 创建的数据表中包含自增主键的id字段，语句如下：12345678mysql&gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| eid | int( 11 ) | NO | PRI | NULL | auto_increment || ename | varchar( 20 ) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec) 1alter table 表名称 modify 字段名 数据类型 auto_increment; 1234create table employee(eid int primary key ,ename varchar( 20 )); 1alter table employee modify eid int auto_increment; 12345678mysql&gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| eid | int( 11 ) | NO | PRI | NULL | auto_increment || ename | varchar( 20 ) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec) 1#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束 1alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除 1alter table employee modify eid int; 12345678mysql&gt; desc employee;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) 插入 4 个空值，执行如下：查询数据表test1中的数据，结果如下：删除id为 4 的记录，语句如下：再次插入一个空值，语句如下：查询此时数据表test1中的数据，结果如下：从结果可以看出，虽然删除了id为 4 的记录，但是再次插入空值时，并没有重用被删除的 4 ，而是分配了5 。 删除id为 5 的记录，结果如下：重启数据库 ，重新插入一个空值。再次查询数据表test1中的数据，结果如下：123CREATE TABLE test1(id INT PRIMARY KEY AUTO_INCREMENT); 12INSERT INTO testVALUES( 0 ),( 0 ),( 0 ),( 0 ); 12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec) 1DELETE FROM test1 WHERE id = 4 ; 1INSERT INTO test1 VALUES( 0 ); 12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 5 |+----+4 rows in set (0.00 sec) 1DELETE FROM test1 where id= 5 ; 1INSERT INTO test1 values( 0 ); 从结果可以看出，新插入的 0 值分配的是 4 ，按照重启前的操作逻辑，此处应该分配 6 。出现上述结果的主要原因是自增主键没有持久化。 在MySQL 5. 7 系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个计数器来决定的，而该计数器只在内存中维护，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。在MySQL 8. 0 版本中，上述测试步骤最后一步的结果如下：从结果可以看出，自增变量已经持久化了。MySQL 8. 0 将自增主键的计数器持久化到重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。6. FOREIGN KEY 约束6. 1 作用限定某个表的某个字段的引用完整性。比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec) 12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 6 |+----+4 rows in set (0.00 sec) 6. 2 关键字FOREIGN KEY6. 3 主表和从表&#x2F;父表和子表主表（父表）：被引用的表，被参考的表从表（子表）：引用别人的表，参考别人的表例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。6. 4 特点（ 1 ）从表的外键列，必须引用&#x2F;参考主表的主键或唯一约束的列为什么？因为被依赖&#x2F;被参考的值必须是唯一的（ 2 ）在创建外键约束时，如果不给外键约束命名， 默认名不是列名，而是自动产生一个外键名 （例如student_ibfk_1;），也可以指定外键约束名。（ 3 ）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表（ 4 ）删表时，先删从表（或先删除外键约束），再删除主表（ 5 ）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据（ 6 ）在“从表”中指定外键约束，并且一个表可以建立多个外键约束（ 7 ）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t createtable’database.tablename’(errno: 150)”。例如：都是表示部门编号，都是int类型。（ 8 ） 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引 。但是索引名是外键的约束名。（根据外键查询效率很高）（ 9 ）删除外键约束后，必须手动删除对应的索引6. 5 添加外键约束（ 1 ）建表时（ 2 ）建表后一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。格式：举例：1234create table 主表名称(字段 1 数据类型 primary key,字段 2 数据类型); 1234567create table 从表名称(字段 1 数据类型 primary key,字段 2 数据类型,[CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段));#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样 – FOREIGN KEY: 在表级指定子表中的列– REFERENCES: 标示在父表中的列1234create table dept( #主表did int primary key, #部门编号dname varchar( 50 ) #部门名称); 1234567create table emp(#从表eid int primary key, #员工编号ename varchar( 5 ), #员工姓名deptid int, #员工所在的部门foreign key (deptid) references dept(did) #在从表中指定外键约束#emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号); 说明：12（ 1 ）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。（ 2 ）删除表时，先删除从表emp，再删除主表dept ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用1字段) [on update xx][on delete xx]; 12ALTER TABLE empADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id); 举例：6. 6 演示问题（ 1 ）失败：不是键列（ 2 ）失败：数据类型不一致（ 3 ）成功，两个表字段名一样1234create table dept(did int primary key, #部门编号dname varchar( 50 ) #部门名称); 123456create table emp(eid int primary key, #员工编号ename varchar( 5 ), #员工姓名deptid int #员工所在的部门);#这两个表创建时，没有指定外键的话，那么创建顺序是随意 1alter table emp add foreign key (deptid) references dept(did); 1234create table dept(did int , #部门编号dname varchar( 50 ) #部门名称); 1234567create table emp(eid int primary key, #员工编号ename varchar( 5 ), #员工姓名deptid int, #员工所在的部门foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是dept的did不是键列 1234create table dept(did int primary key, #部门编号dname varchar( 50 ) #部门名称); 12345678create table emp(eid int primary key, #员工编号ename varchar( 5 ), #员工姓名deptid char, #员工所在的部门foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是从表的deptid字段和主表的did字段的数据类型不一致，并且要它俩的逻辑意义一致 （ 4 ）添加、删除、修改问题1234create table dept(did int primary key, #部门编号dname varchar( 50 ) #部门名称); 12345678create table emp(eid int primary key, #员工编号ename varchar( 5 ), #员工姓名did int, #员工所在的部门foreign key (did) references dept(did)#emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号#是否重名没问题，因为两个did在不同的表中); 1234create table dept(did int primary key, #部门编号dname varchar( 50 ) #部门名称); 1234567create table emp(eid int primary key, #员工编号ename varchar( 5 ), #员工姓名deptid int, #员工所在的部门foreign key (deptid) references dept(did)#emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号); 12insert into dept values( 1001 ,&#x27;教学部&#x27;);insert into dept values( 1003 , &#x27;财务部&#x27;); 1insert into emp values( 1 ,&#x27;张三&#x27;, 1001 ); #添加从表记录成功，在添加这条记录时，要求部门表有 1001 部门 1234insert into emp values( 2 ,&#x27;李四&#x27;, 1005 );#添加从表记录失败ERROR 1452 ( 23000 ): Cannot add（添加） or update（修改） a child row: a foreign keyconstraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`)REFERENCES `dept` (`did`)) 从表emp添加记录失败，因为主表dept没有 1005 部门 12345678mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 财务部 |+------+--------+2 rows in set (0.00 sec) 1234567mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 |+-----+-------+--------+1 row in set (0.00 sec) 总结：约束关系是针对双方的添加了外键约束后，主表的修改和删除数据受约束添加了外键约束后，从表的添加和修改数据受约束在从表上建立外键，要求主表必须存在删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除6. 7 约束等级Cascade方式：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录Set null方式：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not nullNo action方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作Restrict方式：同no action， 都是立即检查外键约束Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别如果没有指定等级，就相当于Restrict方式。对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式。（ 1 ）演示 1 ：on update cascade on delete set null12345update emp set deptid = 1002 where eid = 1 ;#修改从表失败ERROR 1452 ( 23000 ): Cannot add（添加） or update（修改） a child row（子表的记录）: aforeign key constraint fails（外键约束失败） (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1`FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #部门表did字段现在没有 1002 的值，所以员工表中不能修改员工所在部门deptid为 1002 12345update dept set did = 1002 where did = 1001 ;#修改主表失败ERROR 1451 ( 23000 ): Cannot delete（删除） or update（修改） a parent row（父表的记录）: aforeign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY(`deptid`) REFERENCES `dept` (`did`)) #部门表did的 1001 字段已经被emp引用了，所以部门表的 1001 字段就不能修改了。 12update dept set did = 1002 where did = 1003 ;#修改主表成功 因为部门表的 1003 部门没有被emp表引用，所以可以修改 12345delete from dept where did= 1001 ; #删除主表失败ERROR 1451 ( 23000 ): Cannot delete（删除） or update（修改） a parent row（父表记录）: aforeign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY(`deptid`) REFERENCES `dept` (`did`)) #因为部门表did的 1001 字段已经被emp引用了，所以部门表的1001 字段对应的记录就不能被删除 1234create table dept(did int primary key, #部门编号dname varchar( 50 ) #部门名称); 1234567create table emp(eid int primary key, #员工编号ename varchar( 5 ), #员工姓名deptid int, #员工所在的部门foreign key (deptid) references dept(did) on update cascade on delete set null#把修改操作设置为级联修改等级，把删除操作设置为set null等级); insert into dept values( 1001 ,’教学部’);insert into dept values( 1002 , ‘财务部’);insert into dept values( 1003 , ‘咨询部’); insert into emp values( 1 ,’张三’, 1001 ); #在添加这条记录时，要求部门表有 1001 部门insert into emp values( 2 ,’李四’, 1001 );insert into emp values( 3 ,’王五’, 1002 ); mysql&gt; select * from dept; mysql&gt; select * from emp; #修改主表成功，从表也跟着修改，修改了主表被引用的字段 1002 为 1004 ，从表的引用字段就跟着修改为 1004 了mysql&gt; update dept set did &#x3D; 1004 where did &#x3D; 1002 ;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from dept;+——+——–+| did | dname |+——+——–+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #原来是 1002 ，修改为 1004+——+——–+3 rows in set (0.00 sec) mysql&gt; select * from emp;+—–+——-+——–+| eid | ename | deptid |+—–+——-+——–+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1004 | #原来是 1002 ，跟着修改为 1004+—–+——-+——–+3 rows in set (0.00 sec) #删除主表的记录成功，从表对应的字段的值被修改为nullmysql&gt; delete from dept where did &#x3D; 1001 ;Query OK, 1 row affected (0.01 sec) mysql&gt; select * from dept;+——+——–+| did | dname | #记录 1001 部门被删除了+——+——–+| 1003 | 咨询部 || 1004 | 财务部 |+——+——–+2 rows in set (0.00 sec) mysql&gt; select * from emp;+—–+——-+——–+| eid | ename | deptid |+—–+——-+——–+ （ 2 ）演示 2 ：on update set null on delete cascade12345| 1 | 张三 | NULL | #原来引用 1001 部门的员工，deptid字段变为null| 2 | 李四 | NULL || 3 | 王五 | 1004 |+-----+-------+--------+3 rows in set (0.00 sec) 1234create table dept(did int primary key, #部门编号dname varchar( 50 ) #部门名称); 1234567create table emp(eid int primary key, #员工编号ename varchar( 5 ), #员工姓名deptid int, #员工所在的部门foreign key (deptid) references dept(did) on update set null on delete cascade#把修改操作设置为set null等级，把删除操作设置为级联删除等级); 123insert into dept values( 1001 ,&#x27;教学部&#x27;);insert into dept values( 1002 , &#x27;财务部&#x27;);insert into dept values( 1003 , &#x27;咨询部&#x27;); 123insert into emp values( 1 ,&#x27;张三&#x27;, 1001 ); #在添加这条记录时，要求部门表有 1001 部门insert into emp values( 2 ,&#x27;李四&#x27;, 1001 );insert into emp values( 3 ,&#x27;王五&#x27;, 1002 ); 123456789mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+------+--------+3 rows in set (0.00 sec) 123456789mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1002 |+-----+-------+--------+3 rows in set (0.00 sec) 1234#修改主表，从表对应的字段设置为nullmysql&gt; update dept set did = 1004 where did = 1002 ;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 123mysql&gt; select * from dept;+------+--------+| did | dname | （ 3 ）演示：on update cascade on delete cascade+——+——–+| 1001 | 教学部 || 1003 | 咨询部 |123| 1004 | 财务部 | #原来did是 1002+------+--------+3 rows in set (0.00 sec) 12345678910mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | NULL | #原来deptid是 1002 ，因为部门表 1002 被修改了， 1002 没有对应的了，就设置为null+-----+-------+--------+3 rows in set (0.00 sec) #删除主表的记录成功，主表的 1001 行被删除了，从表相应的记录也被删除了12mysql&gt; delete from dept where did= 1001 ;Query OK, 1 row affected (0.00 sec) 12345678mysql&gt; select * from dept;+------+--------+| did | dname | #部门表中 1001 部门被删除+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec) 1234567mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |#原来 1001 部门的员工也被删除了+-----+-------+--------+| 3 | 王五 | NULL |+-----+-------+--------+1 row in set (0.00 sec) 1234create table dept(did int primary key, #部门编号dname varchar( 50 ) #部门名称); 1234567create table emp(eid int primary key, #员工编号ename varchar( 5 ), #员工姓名deptid int, #员工所在的部门foreign key (deptid) references dept(did) on update cascade on delete cascade#把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级); insert into dept values( 1001 ,’教学部’);insert into dept values( 1002 , ‘财务部’);insert into dept values( 1003 , ‘咨询部’); insert into emp values( 1 ,’张三’, 1001 ); #在添加这条记录时，要求部门表有 1001 部门insert into emp values( 2 ,’李四’, 1001 );insert into emp values( 3 ,’王五’, 1002 ); mysql&gt; select * from dept;+——+——–+| did | dname |+——+——–+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+——+——–+3 rows in set (0.00 sec) mysql&gt; select * from emp;+—–+——-+——–+| eid | ename | deptid |+—–+——-+——–+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1002 |+—–+——-+——–+3 rows in set (0.00 sec) #修改主表，从表对应的字段自动修改mysql&gt; update dept set did &#x3D; 1004 where did &#x3D; 1002 ;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from dept;+——+——–+| did | dname |+——+——–+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #部门 1002 修改为 1004+——+——–+3 rows in set (0.00 sec) mysql&gt; select * from emp;+—–+——-+——–+| eid | ename | deptid |+—–+——-+——–+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1004 | #级联修改+—–+——-+——–+3 rows in set (0.00 sec) #删除主表的记录成功，主表的 1001 行被删除了，从表相应的记录也被删除了mysql&gt; delete from dept where did&#x3D; 1001 ;Query OK, 1 row affected (0.00 sec) 6. 8 删除外键约束流程如下：举例：12345678mysql&gt; select * from dept;+------+--------+| did | dname | #1001部门被删除了+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec) 1234567mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid | #1001部门的员工也被删除了+-----+-------+--------+| 3 | 王五 | 1004 |+-----+-------+--------+1 row in set (0.00 sec) ( 1 )第一步先查看约束名和删除外键约束12SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;#查看某个表的约束名 ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;（ 2 ）第二步查看索引名和删除索引。（注意，只能手动删除）SHOW INDEX FROM 表名称; #查看某个表的索引名ALTER TABLE 从表名 DROP INDEX 索引名;1mysql&gt; SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;emp&#x27;; 123mysql&gt; alter table emp drop foreign key emp_ibfk_1;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 1mysql&gt; show index from emp; 123mysql&gt; alter table emp drop index deptid;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0 1mysql&gt; show index from emp; 6. 9 开发场景问题 1 ：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？答：不是的问题 2 ：建和不建外键约束有什么区别？答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的引用完整性，只能依靠程序员的自觉，或者是在Java程序中进行限定。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。问题 3 ：那么建和不建外键约束和查询有没有关系？答：没有在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢。所以， MySQL 允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。6. 10 阿里开发规范【强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。7. CHECK 约束7. 1 作用检查某个字段的值是否符号xx要求，一般指的是值的范围2 、关键字CHECK3 、说明：MySQL 5. 7 不支持MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告但是 MySQL 8.0中可以使用check约束了 。再举例再举例再举例8. DEFAULT约束8. 1 作用给某个字段&#x2F;某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。8. 2 关键字DEFAULT8. 3 如何给字段加默认值（ 1 ）建表时12345create table employee(eid int primary key,ename varchar( 5 ),gender char check (&#x27;男&#x27; or &#x27;女&#x27;)); 1insert into employee values( 1 ,&#x27;张三&#x27;,&#x27;妖&#x27;); 1234567mysql&gt; select * from employee;+-----+-------+--------+| eid | ename | gender |+-----+-------+--------+| 1 | 张三 | 妖 |+-----+-------+--------+1 row in set (0.00 sec) 123456CREATE TABLE temp(id INT AUTO_INCREMENT,NAME VARCHAR( 20 ),age INT CHECK(age &gt; 20 ),PRIMARY KEY(id)); 1age tinyint check(age &gt; 20 ) 或 sex char( 2 ) check(sex in(‘男’,’女’)) 1CHECK(height&gt;= 0 AND height&lt; 3 ) 1234567create table 表名称(字段名 数据类型 primary key,字段名 数据类型 unique key not null,字段名 数据类型 unique key,字段名 数据类型 not null default 默认值,);create table 表名称( 再举例：123456字段名 数据类型 default 默认值 ,字段名 数据类型 not null default 默认值,字段名 数据类型 not null default 默认值,primary key(字段名),unique key(字段名)); 说明：默认值约束一般不在唯一键和主键列上加123456create table employee(eid int primary key,ename varchar( 20 ) not null,gender char default &#x27;男&#x27;,tel char( 11 ) not null default &#x27;&#x27; #默认是空字符串); 12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | NO | | NULL | || gender | char( 1 ) | YES | | 男 | || tel | char( 11 ) | NO | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 1insert into employee values( 1 ,&#x27;汪飞&#x27;,&#x27;男&#x27;,&#x27;13700102535&#x27;); #成功 1234567mysql&gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel |+-----+-------+--------+-------------+| 1 | 汪飞 | 男 | 13700102535 |+-----+-------+--------+-------------+1 row in set (0.00 sec) 1insert into employee(eid,ename) values( 2 ,&#x27;天琪&#x27;); #成功 12345678mysql&gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel |+-----+-------+--------+-------------+| 1 | 汪飞 | 男 | 13700102535 || 2 | 天琪 | 男 | |+-----+-------+--------+-------------+2 rows in set (0.00 sec) 123insert into employee(eid,ename) values( 3 ,&#x27;二虎&#x27;);#ERROR 1062 (23000): Duplicate entry &#x27;&#x27; for key &#x27;tel&#x27;#如果tel有唯一性约束的话会报错，如果tel没有唯一性约束，可以添加成功 （ 2 ）建表后12345CREATE TABLE myemp(id INT AUTO_INCREMENT PRIMARY KEY,NAME VARCHAR( 15 ),salary DOUBLE( 10 , 2 ) DEFAULT 2000); 1alter table 表名称 modify 字段名 数据类型 default 默认值; #如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了123#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了alter table 表名称 modify 字段名 数据类型 default 默认值 not null; 123456create table employee(eid int primary key,ename varchar( 20 ),gender char,tel char( 11 ) not null); 12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | || gender | char( 1 ) | YES | | NULL | || tel | char( 11 ) | NO | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 12alter table employee modify gender char default &#x27;男&#x27;; #给gender字段增加默认值约束alter table employee modify tel char( 11 ) default &#x27;&#x27;; #给tel字段增加默认值约束 12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | || gender | char( 1 ) | YES | | 男 | || tel | char( 11 ) | YES | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 12alter table employee modify tel char( 11 ) default &#x27;&#x27; not null;#给tel字段增加默认值约束，并保留非空约束 8. 4 如何删除默认值约束9. 面试面试 1 、为什么建表时，加 not null default ‘’ 或 default 0答：不想让表中出现null值。面试 2 、为什么不想要 null 的值答:（ 1 ）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。（ 2 ）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0面试 3 、带AUTO_INCREMENT约束的字段值是从 1 开始的吗？ 在MySQL中，默认AUTO_INCREMENT的初始值是 1 ，每新增一条记录，字段值自动加 1 。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为 5 ，则以后插入的记录的id值就会从 6 开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。面试 4 、并不是每个表都可以任意选择存储引擎？ 外键约束（FOREIGN KEY）不能跨引擎使用。MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | || gender | char( 1 ) | YES | | 男 | || tel | char( 11 ) | NO | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 1alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束 1alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束 12alter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除alter table employee modify tel char( 11 ) not null;#删除tel字段默认值约束，保留非空约束 12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int( 11 ) | NO | PRI | NULL | || ename | varchar( 20 ) | YES | | NULL | || gender | char( 1 ) | YES | | NULL | || tel | char( 11 ) | NO | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"9.mysql第12章数据类型精讲","slug":"mysql/9.mysql第12章数据类型精讲","date":"2019-10-03T09:00:00.000Z","updated":"2024-11-02T15:56:09.089Z","comments":true,"path":"2019/10/03/mysql/9.mysql第12章数据类型精讲/","link":"","permalink":"https://protonlml.github.io/2019/10/03/mysql/9.mysql%E7%AC%AC12%E7%AB%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/","excerpt":"","text":"数据类型精讲 1. MySQL中的数据类型 常见数据类型的属性,如下: 2. 整数类型2.1 类型介绍整数类型一共有 5 种,包括 TINYINT、SMALLINT、MEDIUMINT、INT(INTEGER)和 BIGINT。 它们的区别如下表所示: 2.2 适用场景 TINYINT :一般用于枚举数据,比如系统设定取值范围很小且固定的场景。SMALLINT :可以用于较小范围的统计数据,比如统计工厂的固定资产库存数量等。MEDIUMINT :用于较大整数的计算,比如车站每日的客流量等。INT、INTEGER :取值范围足够大,一般情况下不用考虑超限问题,用得最多。比如商品编号。BIGINT :只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。 2.4 如何选择?在评估用哪种整数类型的时候,你需要考虑 存储空间 和 可靠性 的平衡问题:一方 面,用占用字节数少的整数类型可以节省存储空间;另一方面,要是为了节省存储空间, 使用的整数类型取值范围太小,一旦遇到超出取值范围的情况,就可能引起 系统错误 ,影响可靠性。举个例子,商品编号采用的数据类型是 INT。原因就在于,客户门店中流通的商品种类较多,而且,每天都有旧商品下架,新商品上架,这样不断迭代,日积月累。如果使用 SMALLINT 类型,虽然占用字节数比 INT 类型的整数少,但是却不能保证数据不会超出范围65535。相反,使用 INT,就能确保有足够大的取值范围,不用担心数据超出范围影响可靠性的问题。你要注意的是,在实际工作中,系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。因此,我建议你首先确保数据不会超过取值范围,在这个前提之下,再去考虑如何节省存储空间。 3.浮点类型3.1 类型介绍浮点数和定点数类型的特点是可以 处理小数 ,你可以把整数看成小数的一个特例。因此,浮点数和定点数的使用场景,比整数大多了。 MySQL支持的浮点数类型,分别是 FLOAT、DOUBLE、REAL。 FLOAT 表示单精度浮点数; DOUBLE 表示双精度浮点数; REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ REAL_AS_FLOAT ”,那 么,MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”,可以通过以下 SQL 语句实现: SET sql_mode = “REAL_AS_FLOAT”; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&gt; - 问题1:FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢?&gt; - FLOAT 占用字节数少,取值范围小;DOUBLE 占用字节数多,取值范围也大。&gt; - 问题2:为什么浮点数类型的无符号数取值范围,只相当于有符号数取值范围的一半,也就是只相当于有符号数取值范围大于等于零的部分呢?&gt; - MySQL 存储浮点数的格式为: 符号(S) 、 尾数(M) 和 阶码(E) 。因此,无论有没有符号,MySQL 的浮&gt; 点数都会存储表示符号的部分。因此, 所谓的无符号数取值范围,其实就是有符号数取值范围大于等于&gt; 零的部分。### 3.2 数据精度说明对于浮点类型,在MySQL中单精度值使用 4 个字节,双精度值使用 8 个字节。从MySQL 8.0.17开始,FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用,将来可能被移除。另外,关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了,将来也可能被移除。### 3.3 精度误差说明浮点数类型有个缺陷,就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如,我们设计一个表,有f1这个字段,插入值分别为0.47,0.44,0.19,我们期待的运行结果是:0.47 + 0.44 + 0.19 =1.1。而使用sum之后查询:​ 查询结果是 1.0999999999999999。看到了吗?虽然误差很小,但确实有误差。 你也可以尝试把数据类型改成 FLOAT,然后运行求和查询,得到的是, 1.0999999940395355。显然,误差更大了。​ 那么,为什么会存在这样的误差呢?问题还是出在 MySQL 对浮点类型数据的存储方式上。​ MySQL 用 4 个字节存储 FLOAT 类型数据,用 8 个字节来存储 DOUBLE 类型数据。无论哪个,都是采用二进制的方式来进行存储的。比如 9.625,用二进制来表达,就是 1001.101,或者表达成 1.001101×2^3。如果尾数不是 0 或 5(比如 9.624),你就无法用一个二进制数来精确表达。进而,就只好在取值允许的范围内进行四舍五入。​ 在编程中,如果用到浮点数,要特别注意误差问题,==因为浮点数是不准确的,所以我们要避免使用“=”来判断两个数是否相等。==同时,在一些对精确度要求较高的项目中,千万不要使用浮点数,不然会导致结果错误,甚至是造成不可挽回的损失。那么,MySQL 有没有精准的数据类型呢?当然有,这就是定点数类型: DECIMAL 。## 4. 定点数类型### 4.1 类型介绍- MySQL中的定点数类型只有 DECIMAL 一种类型。- ![image-20241102233224592](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022332185.png)使用 DECIMAL(M,D) 的方式表示高精度小数。其中,M被称为精度,D被称为标度。0&lt;=M&lt;=65,0&lt;=D&lt;=30,D&lt;M。例如,定义DECIMAL(5,2)的类型,表示该列取值范围是-999.99~999.99。- ==DECIMAL(M,D)的最大取值范围与DOUBLE类型一样==,但是有效的数据范围是由M和D决定的。 DECIMAL 的存储空间并不是固定的,由精度值M决定,总共占用的存储空间为M+2个字节。也就是说,在一些对精度要求不高的场景下,比起占用同样字节长度的定点数,浮点数表达的数值范围可以更大一些。- 定点数在MySQL内部是以 ==字符串== 的形式进行存储,这就决定了它一定是精准的。- 当DECIMAL类型不指定精度和标度时,其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时,则MySQL同样会进行四舍五入处理。- ==浮点数 vs 定点数== - 浮点数相对于定点数的优点是在长度一定的情况下,浮点类型取值范围大,但是不精准,适用于需要取值范围大,又可以容忍微小误差的科学计算场景(比如计算化学、分子建模、流体动力学等) - 定点数类型取值范围相对小,但是精准,没有误差,适合于对精度要求极高的场景 (比如涉及金额计算的场景)### 4.2 开发中经验&gt; “由于 DECIMAL 数据类型的精准性,在我们的项目中,除了极少数(比如商品编号)用到整数类型外,其他的数值都用的是 DECIMAL,原因就是这个项目所处的零售行业,要求精准,一分钱也不能差。 ” ——来自某项目经理## 5. 位类型:BITBIT类型中存储的是二进制值,类似010110。![image-20241102233413752](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022334206.png)BIT类型,如果没有指定(M),默认是1位。这个1位,表示只能存1位的二进制值。这里(M)是表示二进制的位数,位数最小值为1,最大值为64。使用SELECT命令查询位字段时,可以用 ==BIN()== 或 ==HEX()== 函数进行读取。## 6. 日期与时间类型日期与时间是重要的信息,在我们的系统中,几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签,从而进行数据查询、统计和处理MySQL有多种表示日期和时间的数据类型,不同的版本可能有所差异,MySQL8.0版本支持的日期和时间类型主要有:YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。- YEAR 类型通常用来表示年- DATE 类型通常用来表示年、月、日\\- TIME 类型通常用来表示时、分、秒- DATETIME 类型通常用来表示年、月、日、时、分、秒- TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒![image-20241102233649031](https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202411022338787.png)可以看到,不同数据类型表示的时间内容不同、取值范围不同,而且占用的字节数也不一样,你要根据实际需要灵活选取。为什么时间类型 TIME 的取值范围不是 -23:59:59~23:59:59 呢?原因是 MySQL 设计的 TIME 类型,不光表示一天之内的时间,而且可以用来表示一个时间间隔,这个时间间隔可以超过 24 小时。### 6.1 YEAR类型YEAR类型用来表示年份,在所有的日期时间类型中所占用的存储空间最小,只需要 1个字节 的存储空间。在MySQL中,YEAR有以下几种存储格式:- 以4位字符串或数字格式表示YEAR类型,其格式为YYYY,最小值为1901,最大值为2155。- 以2位字符串格式表示YEAR类型,最小值为00,最大值为99。 - 当取值为01到69时,表示2001到2069; - 当取值为70到99时,表示1970到1999; - 当取值整数的0或00添加的话,那么是0000年; - 当取值是日期/字符串的&#x27;0&#x27;添加的话,是2000年。==从MySQL5.5.27开始,2位格式的YEAR已经不推荐使用==。YEAR默认格式就是“YYYY”,没必要写成YEAR(4),从MySQL 8.0.19开始,不推荐使用指定显示宽度的YEAR(4)数据类型。### 6.2 DATE类型DATE类型表示日期,没有时间部分,格式为 YYYY-MM-DD ,其中,YYYY表示年份,MM表示月份,DD表示日期。需要 3个字节 的存储空间。在向DATE类型的字段插入数据时,同样需要满足一定的格式条件。- 以 YYYY-MM-DD 格式或者 YYYYMMDD 格式表示的字符串日期,其最小取值为1000-01-01,最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。- 以 YY-MM-DD 格式或者 YYMMDD 格式表示的字符串日期,此格式中,年份为两位数值或字符串满足YEAR类型的格式条件为:当年份取值为00到69时,会被转化为2000到2069;当年份取值为70到99时,会被转化为1970到1999。- 使用 CURRENT_DATE() 或者 NOW() 函数,会插入当前系统的日期。### 6.4 DATETIME类型DATETIME类型在所有的日期时间类型中占用的存储空间最大,总共需要 8 个字节的存储空间。在格式上为DATE类型和TIME类型的组合,可以表示为 YYYY-MM-DD HH:MM:SS ,其中YYYY表示年份,MM表示月份,DD表示日期,HH表示小时,MM表示分钟,SS表示秒。在向DATETIME类型的字段插入数据时,同样需要满足一定的格式条件。- 以==YYYY-MM-DD HH:MM:SS== 格式或者 ==YYYYMMDDHHMMSS== 格式的字符串插入DATETIME类型的字段时,最小值为1000-01-01 00:00:00,最大值为9999-12-03 23:59:59。 - 以YYYYMMDDHHMMSS格式的数字插入DATETIME==类型的字段时,会被转化为YYYY-MM-DD HH:MM:SS格式。- 以 ==YY-MM-DD HH:MM:SS== 格式或者 ==YYMMDDHHMMSS== 格式的字符串插入DATETIME类型的字段时,两位 数的年份规则符合YEAR类型的规则,00到69表示2000到2069;70到99表示1970到1999。- 使用函数 ==CURRENT_TIMESTAMP()== 和 ==NOW()== ,可以向DATETIME类型的字段插入系统的当前日期和 时间。#### 举例 ```mysql#创建数据表,表中包含一个DATETIME类型的字段dt。CREATE TABLE test_datetime1(dt DATETIME);Query OK, 0 rows affected (0.02 sec)# 插入数据INSERT INTO test_datetime1VALUES (&#x27;2021-01-01 06:50:30&#x27;), (&#x27;20210101065030&#x27;);INSERT INTO test_datetime1VALUES (&#x27;99-01-01 00:00:00&#x27;), (&#x27;990101000000&#x27;), (&#x27;20-01-01 00:00:00&#x27;),(&#x27;200101000000&#x27;);INSERT INTO test_datetime1VALUES (20200101000000), (200101000000), (19990101000000), (990101000000);INSERT INTO test_datetime1VALUES (CURRENT_TIMESTAMP()), (NOW()); 6.6 开发中经验​ 用得最多的日期时间类型,就是 DATETIME 。虽然 MySQL 也支持 YEAR(年)、 TIME(时间)、DATE(日期),以及 TIMESTAMP 类型,但是在实际项目中,尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息,取值范围也最大,使用起来比较方便。毕竟,如果日期时间信息分散在好几个字段,很不容易记,而且查询的时候,SQL 语句也会更加复杂。 此外,一般存注册时间、商品发布时间等,不建议使用DATETIME存储,而是使用 时间戳 ,因为DATETIME虽然直观,但不便于计算。 7. 文本字符串类型在实际的项目中,我们还经常遇到一种数据,就是字符串数据。MySQL中,文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、LONGTEXT 、 ENUM 、 SET 等类型。 7.1 CHAR与VARCHAR类型CHAR和VARCHAR类型都可以存储比较短的字符串。 CHAR类型: CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M),则表示长度默认是1个字符。 如果保存时,数据的实际长度比CHAR类型声明的长度小,则会在 右侧填充 空格以达到指定的长度。当MySQL检索CHAR类型的数据时,CHAR类型的字段会去除尾部的空格。 定义CHAR类型字段时,声明的字段长度即为CHAR类型字段所占的存储空间的字节数。 12345CREATE TABLE test_char1(c1 CHAR,c2 CHAR(5));DESC test_char1; VARCHAR类型: VARCHAR(M) 定义时, 必须指定 长度M,否则报错。 MySQL4.0版本以下,varchar(20):指的是20字节,如果存放UTF8汉字时,只能存6个(每个汉字3字节) ;MySQL5.0版本以上,varchar(20):指的是20字符。 检索VARCHAR类型的字段数据时,会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。 12345CREATE TABLE test_varchar3(NAME VARCHAR(5));INSERT INTO test_varchar3VALUES(&#x27;尚硅谷&#x27;),(&#x27;尚硅谷教育&#x27;); &#x3D;&#x3D;哪些情况使用 CHAR 或 VARCHAR 更好&#x3D;&#x3D; 情况1: 存储很短的信息。比如门牌号码101,201……这样很短的信息应该用char,因为varchar还要占个byte用于存储信息长度,本来打算节约存储的,结果得不偿失。 情况2:固定长度的。比如使用uuid作为主键,那用char应该更合适。因为他固定长度,varchar动态根据长度的特性就消失了,而且还要占个长度信息。情况3:十分频繁改变的column。因为varchar每次存储都要有额外的计算,得到长度等工作,如果一个非常频繁改变的,那就要有很多的精力用于计算,而这些对于char来说是不需要的。情况4:具体存储引擎中的情况: &#x3D;&#x3D;MyISAM&#x3D;&#x3D; 数据存储引擎和数据列:MyISAM数据表,最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化,从而使 &#x3D;&#x3D;数据检索更快&#x3D;&#x3D; ,用空间换时间。 &#x3D;&#x3D;MEMORY&#x3D;&#x3D; 存储引擎和数据列:MEMORY数据表目前都使用固定长度的数据行存储,因此无论使用CHAR或VARCHAR列都没有关系,两者都是作为CHAR类型处理的。 &#x3D;&#x3D;InnoDB&#x3D;&#x3D; 存储引擎,建议使用VARCHAR类型。因为对于InnoDB数据表,内部的行存储格式并没有区分固定长度和可变长度列(所有数据行都使用指向数据列值的头指针),而且&#x3D;&#x3D;主要影响性能的因素是数据行使用的存储总量&#x3D;&#x3D;,由于char平均占用的空间多于varchar,所以除了简短并且固定长度的,其他考虑varchar。这样节省空间,对磁盘I&#x2F;O和数据存储总量比较好。 7.2 TEXT类型在MySQL中,TEXT用来保存文本类型的字符串,总共包含4种类型,分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。在向TEXT类型的字段保存和查询数据时,系统自动按照实际长度存储,不需要预先定义长度。这一点和VARCHAR类型相同。每种TEXT类型保存的数据长度和所占用的存储空间不同,如下: 由于实际存储的长度不确定,MySQL 不允许 TEXT 类型的字段做主键。遇到这种情况,你只能采用CHAR(M),或者 VARCHAR(M)。 举例:1234567891011# 创建数据表:CREATE TABLE test_text(tx TEXT);#插入数据INSERT INTO test_textVALUES(&#x27;atguigu &#x27;);SELECT CHAR_LENGTH(tx)FROM test_text; #10# 说明在保存和查询数据时,并没有删除TEXT类型的数据尾部的空格。 开发中经验:TEXT文本类型,可以存比较大的文本段,搜索速度稍慢,因此如果不是特别大的内容,建议使用CHAR,VARCHAR来代替。还有TEXT类型不用加默认值,加了也没用。而且text和blob类型的数据删除后容易导致“空洞”,使得文件碎片比较多,所以频繁使用的表不建议包含TEXT类型字段,建议单独分出去,单独用一个表。 8. ENUM类型ENUM类型也叫作枚举类型,ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时,ENUM类型只允许从成员中选取单个值,不能一次选取多个值。其所需要的存储空间由定义ENUM类型时指定的成员个数决定。 当ENUM类型包含1~255个成员时,需要1个字节的存储空间; 当ENUM类型包含256~65535个成员时,需要2个字节的存储空间。 ENUM类型的成员个数的上限为65535个。 举例:12345678910111213141516171819# 创建表如下CREATE TABLE test_enum(season ENUM(&#x27;春&#x27;,&#x27;夏&#x27;,&#x27;秋&#x27;,&#x27;冬&#x27;,&#x27;unknow&#x27;));# 添加数据INSERT INTO test_enumVALUES(&#x27;春&#x27;),(&#x27;秋&#x27;);# 忽略大小写INSERT INTO test_enumVALUES(&#x27;UNKNOW&#x27;);# 允许按照角标的方式获取指定索引位置的枚举值INSERT INTO test_enumVALUES(&#x27;1&#x27;),(3);# Data truncated for column &#x27;season&#x27; at row 1INSERT INTO test_enumVALUES(&#x27;ab&#x27;);# 当ENUM类型的字段没有声明为NOT NULL时,插入NULL也是有效的INSERT INTO test_enumVALUES(NULL); 13. 小结及选择建议在定义数据类型时,如果确定是 &#x3D;&#x3D;整数&#x3D;&#x3D; ,就用 &#x3D;&#x3D;INT&#x3D;&#x3D; ; 如果是 &#x3D;&#x3D;小数&#x3D;&#x3D; ,一定用定点数类型&#x3D;&#x3D;DECIMAL(M,D)&#x3D;&#x3D; ; 如果是&#x3D;&#x3D;日期与时间&#x3D;&#x3D;,就用 &#x3D;&#x3D;DATETIME&#x3D;&#x3D; 。这样做的好处是,首先确保你的系统不会因为数据类型定义出错。不过,凡事都是有两面的,可靠性好,并不意味着高效。比如,TEXT 虽然使用方便,但是效率不如 CHAR(M) 和 VARCHAR(M)。 关于字符串的选择,建议参考如下阿里巴巴的《Java开发手册》规范: &#x3D;&#x3D;阿里巴巴《Java开发手册》之MySQL数据库:&#x3D;&#x3D; 任何字段如果为非负数,必须是 UNSIGNED 【 &#x3D;&#x3D;强制&#x3D;&#x3D; 】小数类型为 DECIMAL,禁止使用 FLOAT 和 DOUBLE。说明:在存储的时候,FLOAT 和 DOUBLE 都存在精度损失的问题,很可能在比较值的时候,得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围,建议将数据拆成整数和小数并分开存储。 【 &#x3D;&#x3D;强制&#x3D;&#x3D; 】如果存储的字符串长度几乎相等,使用 CHAR 定长字符串类型。 【 &#x3D;&#x3D;强制&#x3D;&#x3D; 】VARCHAR 是可变长字符串,不预先分配存储空间,长度不要超过 5000。如果存储长度大于此值,定义字段类型为 TEXT,独立出来一张表,用主键来对应,避免影响其它字段索引效率。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"8.mysql第11章数据处理之增删改","slug":"mysql/8.mysql第11章数据处理之增删改","date":"2019-10-03T08:00:00.000Z","updated":"2024-11-02T14:36:15.521Z","comments":true,"path":"2019/10/03/mysql/8.mysql第11章数据处理之增删改/","link":"","permalink":"https://protonlml.github.io/2019/10/03/mysql/8.mysql%E7%AC%AC11%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/","excerpt":"","text":"表中数据处理之增删改 1.增加一条记录1.1 语句 1234567891011121314151617181920212223242526272829303132333435&gt;方式一：一次插入一行&gt;insert into pet(name, owner, species, sex,birth, death)&gt;values (&#x27;Fluffy&#x27;, &#x27;harold&#x27;, &#x27;Cat&#x27;, &#x27;f&#x27;, 2003, 2010);&gt;insert into pet(name, owner, species, sex,birth) values (&#x27;Claws&#x27;, &#x27;gwen&#x27;, &#x27;Cat&#x27;, &#x27;m&#x27;, 2004);&gt;方式二：一次插入多行&gt;insert into books(name, authors, price, pubdate, note, num)&gt;values (&#x27;Tal of AAA&#x27;,&#x27;Dickes&#x27;,23,1995,&#x27;novel&#x27;,11), (&#x27;EmmaT&#x27;,&#x27;Jane lura&#x27;,35,1993,&#x27;joke&#x27;,22), (&#x27;Story of Jane&#x27;,&#x27;Jane Tim&#x27;,40,2001,&#x27;novel&#x27;,0), (&#x27;Lovey Day&#x27;,&#x27;George Byron&#x27;,20,2005,&#x27;novel&#x27;,30), (&#x27;Old land&#x27;,&#x27;Honore Blade&#x27;,30,2010,&#x27;law&#x27;,0), (&#x27;The Battle&#x27;,&#x27;Upton Sara&#x27;,30,1999,&#x27;medicine&#x27;,40), (&#x27;Rose Hood&#x27;,&#x27;Richard haggard&#x27;,28,2008,&#x27;cartoon&#x27;,28); &gt;一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句,但是多行的INSERT语句&gt;在处理过程中 效率更高 。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句&gt;快,所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。 &gt;方式三：直接复制一个已有的表INSERT INTO emp2(employee_id, last_name,email ,salary,hire_date ,commission_pct)&gt;SELECT employee_id, last_name, email,hire_date,salary, commission_pct&gt;FROM atguigudb.employees&gt;在 INSERT 语句中加入子查询。&gt;不必书写 VALUES 子句。&gt;子查询中的值列表应与 INSERT 子句中的列名对应。&gt;方式四：直接复制一个已有表，但是不要其中的数据，只要字段以及其的类型INSERT INTO emp2(employee_id, last_name,email ,salary,hire_date ,commission_pct)&gt;SELECT employee_id, last_name, email,hire_date,salary, commission_pct&gt;FROM atguigudb.employees&gt;where 1=2; 小结: VALUES 也可以写成 VALUE ,但是VALUES是标准写法。 字符和日期型数据应包含在单引号中。 2. 更新一条记录语法： 1234567891011&gt;UPDATE table_name&gt;SET column1=value1, column2=value2, ... , column=valuen&gt;[WHERE condition]&gt;#更改数据,一次更新多条数据&gt;update student&gt;set class=&#x27;五年级一班&#x27;,num=&#x27;501025&#x27;&gt;where id=2;&gt;可以一次更新多条数据。&gt;如果需要回滚数据,需要保证在DML前,进行设置:SET AUTOCOMMIT = FALSE; 3.删除记录语法： 123456&gt;DELETE FROM table_name [WHERE &lt;condition&gt;];&gt;table_name指定要执行删除操作的表;“[WHERE ]”为可选参数,指定删除条件,如果没有WHERE子句,&gt;DELETE语句将删除表中的所有记录。&gt;delete 操作删除数据，是可以回滚的，前提是在当前会话中，提前设置了SET AUTOCOMMIT = FALSE; 当然也只能回滚到前一条操作。 练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192# 第11章数据处理之增删改#创建数据库create database IF not exists test;#删除数据库drop database if exists test;# 创建数据库同时设置字符集create database if not exists test1 character set utf8mb4;#使用数据库use test1;#修改数据库alter database test character set gbk;# 查看指定数据库信息show create database test;# 查看当前mysql服务器上面，有多少数据库show databases;# 删除数据库drop database if exists test;#使用test1数据库use test1;# 创建表create table empl( id int primary key auto_increment, # 主键约束 就包括 （非空 唯一） auto_increment自动递增 name varchar(15) not null , age int not null , email varchar(10) unique , #邮件不能重复 phone varchar(11) unique #手机号不能重复);# 查看表desc empl;#给表中插入数据insert into empl ( name, age, email, phone)values (&#x27;张三&#x27;,15,&#x27;71@qq.com&#x27;,&#x27;13456789920&#x27;);insert into empl ( name, age, email, phone)values (&#x27;张三&#x27;,15,&#x27;rtwrt@qq.com&#x27;,&#x27;13443256789920&#x27;);desc empl;# 修改表（修改的是表中的列）（对未创建表。的约束不能修改）# 修改表中某个字段名alter table emplmodify phone varchar(15) unique;#增加列alter table empladd addres Varchar(75) default &#x27;暂时未填写&#x27;; # 增加地址列，同时添加唯一约束，设置默认值# 删除某一列alter table empldrop addres;# 查询表中的数据select * from empl;# 删除表中的数据delete from empl;# 删除表drop table empl; # 直接将整个表从数据库中删除，且不能恢复#------------------------------DML的操作---------------------------------------------------------# 数据处理之增删改# 如果需要回滚数据,需要保证在DML前,进行设置:SET AUTOCOMMIT = FALSE;# 增加一条数据# 1.为表的指定字段插入数据,就是在INSERT语句中只向部分字段中插入值,而其他字段的值为表定义时的默认值。# 在 INSERT 子句中随意列出列名,但是一旦列出,VALUES中要插入的value1,....valuen需要与 column1,...columnn列一一对应。如果类型不同,将无法插入,并且MySQL会产生错误。create table student( id int primary key auto_increment, name varchar(15) not null , class varchar(10) not null , num int unique #学号可以为空);select * from student;# 1.插入数据，字段和值要匹配insert into student( name, class, num)values (&#x27;小明&#x27;,&#x27;一年级三班&#x27;,103015);insert into student( name, class)values (&#x27;小明&#x27;,&#x27;一年级三班&#x27;);# 2.同时插入多条记录/** INSERT INTO table_nameVALUES(value1 [,value2, ..., valuen]),(value1 [,value2, ..., valuen]),......(value1 [,value2, ..., valuen]); 或者 INSERT INTO table_name(column1 [, column2, ..., columnn])VALUES(value1 [,value2, ..., valuen]),(value1 [,value2, ..., valuen]),......(value1 [,value2, ..., valuen]); *//** 小结： VALUES 也可以写成 VALUE ,但是VALUES是标准写法。 字符和日期型数据应包含在单引号中。 *//** 1.3 方式2:将查询结果插入到表中INSERT还可以将SELECT语句查询的结果插入到表中,此时不需要把每一条记录的值一个一个输入,只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。基本语法格式如下:INSERT INTO 目标表名(tar_column1 [, tar_column2, ..., tar_columnn])SELECT(src_column1 [, src_column2, ..., src_columnn])FROM 源表名[WHERE condition] *//** 一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句,但是多行的INSERT语句在处理过程中 效率更高 。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快,所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。 */# 复制一张表过来(只要字段，不要数据)create table emp2select * from atguigudb.employees where 1=2;alter table emp2modify salary int;desc emp2;select * from emp2;# emp2数据表，快速插入数据(将employees)表中数据全部都插入进来了insert into emp2select * from atguigudb.employees ;INSERT INTO emp2(employee_id, last_name,email ,salary,hire_date ,commission_pct)SELECT employee_id, last_name, email,hire_date,salary, commission_pctFROM atguigudb.employeesWHERE job_id LIKE &#x27;%REP%&#x27;;select * from student;#更改数据,一次更新多条数据update studentset class=&#x27;五年级一班&#x27;,num=&#x27;501025&#x27;where id=2;select * from student;rollback ; # 回滚（只能回滚到上一次提交之后）select * from student;#----------------------------------------------# 删除一条数据delete from studentwhere id=1;select * from student;# 清空表中的所有数据delete from student; DDL 和 DML综合案列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#------------DDL和DML的综合练习----------------------------#练习# 1.创建数据库create database if not exists test01_library character set utf8mb4;#查看数据库信息show create database test01_library;#使用数库use test01_library;# 2.创建表 bookscreate table books( id int primary key auto_increment comment &#x27;书编号&#x27;,#主键自增 name varchar(50) not null unique comment &#x27;书名&#x27;, authors varchar(100) not null comment &#x27;作者&#x27;, price float not null comment &#x27;价格&#x27;, pubdate year comment &#x27;出版日期 格式 YYYY&#x27;, note varchar(100) comment &#x27;说明&#x27;, num int not null comment &#x27;库存&#x27;);desc books;select * from books;# 向books表中插入记录# # 1)不指定字段名称,插入第一条记录insert into booksvalues (1,&#x27;成功学&#x27;,&#x27;张三&#x27;,65.80,2024,&#x27;这是一部现代哲学史诗&#x27;,500);# 2)指定所有字段名称,插入第二记录insert into books (id, name, authors, price, pubdate, note, num)values (2,&#x27;前行者&#x27;,&#x27;李四&#x27;,99.2,2001,&#x27;前进的道路总有坎坷，只有强者才能勇攀高峰&#x27;,800);# 3)同时插入多条记录(剩下的所有记录)insert into books(name, authors, price, pubdate, note, num)values (&#x27;铜墙铁壁&#x27;,&#x27;王伟&#x27;,99.2,2001,&#x27;铜墙铁壁是保护色&#x27;,264), (&#x27;路途&#x27;,&#x27;增益&#x27;,99.2,2001,&#x27;路途犹如迷途，人生之道就在其中&#x27;,545), (&#x27;高高兴兴&#x27;,&#x27;王晓燕&#x27;,99.2,2001,&#x27;高高兴兴干好每一件事&#x27;,851);insert into books(name, authors, price, pubdate, note, num)values (&#x27;Tal of AAA&#x27;,&#x27;Dickes&#x27;,23,1995,&#x27;novel&#x27;,11), (&#x27;EmmaT&#x27;,&#x27;Jane lura&#x27;,35,1993,&#x27;joke&#x27;,22), (&#x27;Story of Jane&#x27;,&#x27;Jane Tim&#x27;,40,2001,&#x27;novel&#x27;,0), (&#x27;Lovey Day&#x27;,&#x27;George Byron&#x27;,20,2005,&#x27;novel&#x27;,30), (&#x27;Old land&#x27;,&#x27;Honore Blade&#x27;,30,2010,&#x27;law&#x27;,0), (&#x27;The Battle&#x27;,&#x27;Upton Sara&#x27;,30,1999,&#x27;medicine&#x27;,40), (&#x27;Rose Hood&#x27;,&#x27;Richard haggard&#x27;,28,2008,&#x27;cartoon&#x27;,28);select * from books where note=&#x27;novel&#x27;;# 4、将小说类型(novel)的书的价格都增加5。update books set price=price+5 where note=&#x27;novel&#x27;;# 5、将名称为EmmaT的书的价格改为40,并将说明改为drama。update booksset price=40,note=&#x27;drama&#x27;where name=&#x27;EmmaT&#x27;;select * from books where name=&#x27;EmmaT&#x27;;# 6、删除库存为0的记录。delete from books where num=&#x27;0&#x27;;select * from books;# 7、统计书名中包含a字母的书select *from bookswhere name like &#x27;%a%&#x27;;# 8、统计书名中包含a字母的书的数量和库存总量select count(1) , sum(num)from bookswhere name like &#x27;%a%&#x27;;# 9、找出“novel”类型的书,按照价格降序排列select * from bookswhere note=&#x27;novel&#x27;order by price desc;# 10、查询图书信息,按照库存量降序排列,如果库存量相同的按照note升序排列select *from booksorder by num desc , note asc;# 11、按照note分类统计书的数量select note, count(1)from booksgroup by note;# 12、按照note分类统计书的库存量,显示库存量超过30本的select note,sum(num)from booksgroup by notehaving sum(num)&gt;30;# 13、查询所有图书,每页显示5本,显示第二页select * from books;select * from bookslimit 5,5;# 14、按照note分类统计书的库存量,显示库存量最多的select note,sum(num)from booksgroup by noteorder by sum(num) desclimit 0,1;# 15、查询书名达到10个字符的书,不包括里面的空格select * from bookswhere char_length(replace(name,&#x27; &#x27;,&#x27;&#x27;))&gt;=10;# 16、查询书名和类型,其中note值为novel显示小说,law显示法律,medicine显示医药,cartoon显示卡通,joke显示笑话select name as &#x27;书名&#x27;, case note when &#x27;novel&#x27; then &#x27;小说&#x27; when &#x27;law&#x27; then &#x27;法律&#x27; when &#x27;medicine&#x27; then &#x27;医药&#x27; when &#x27;cartoon&#x27; then &#x27;卡通&#x27; when &#x27;joke&#x27; then &#x27;笑话&#x27; else &#x27;普通书籍&#x27; end as &#x27;类型&#x27;from books;# 17、查询书名、库存,其中num值超过30本的,显示滞销,大于0并低于10的,显示畅销,为0的显示需要无货select * from books;select name , num , case when num&gt;30 then &#x27;滞销&#x27; when num&gt;0 and num&lt;10 then &#x27;畅销&#x27; when num=0 then &#x27;需要补货&#x27; else &#x27;正常&#x27; end as &#x27;状态&#x27;from books;# 18、统计每一种note的库存量,并合计总量# 生成汇总行 WITH ROLLUPselect IFNULL(note,&#x27;合计库存总量&#x27;) note,sum(num)from booksgroup by note WITH ROLLUP;# 19、统计每一种note的数量,并合计总量select IFNULL(note,&#x27;合计总量&#x27;), count(note)from booksgroup by note with rollup ;# 20、统计库存量前三名的图书select * from booksorder by num desclimit 0,3;# 21、找出最早出版的一本书select *from booksorder by pubdatelimit 0,1;# 22、找出novel中价格最高的一本书select * from bookswhere note=&#x27;novel&#x27;order by price desclimit 0,1;# 23、找出书名中字数最多的一本书,不含空格SELECT * FROM books ORDER BY CHAR_LENGTH(REPLACE(name,&#x27; &#x27;,&#x27;&#x27;)) DESC LIMIT 0,1; 课后练习题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#-----------------------数据处理之增删改课后练习题------------------------------------------------------------#-----------------------练习一---------------------------------#1. 创建数据库dbtest11create database if not exists dbtest11;use dbtest11;#2. 运行以下脚本创建表my_employeesCREATE TABLE my_employees(id INT(10),first_name VARCHAR(10),last_name VARCHAR(10),userid VARCHAR(10),salary DOUBLE(10,2));CREATE TABLE users(id INT,userid VARCHAR(10),department_id INT);#3. 显示表my_employees的结构desc my_employees;#4. 向my_employees表中插入下列数据/**ID FIRST_NAME LAST_NAME USERID SALARY1 patel Ralph Rpatel 8952 Dancs Betty Bdancs 8603 Biri Ben Bbiri 11004 Newman Chad Cnewman 7505 Ropeburn Audrey Aropebur1550 */select * from my_employees;insert into my_employees(first_name, last_name, userid, salary)values (&#x27;patel&#x27;, &#x27;Ralph&#x27;, &#x27;Rpatel&#x27;, 895), (&#x27;Dancs&#x27;, &#x27;Betty&#x27;, &#x27;Bdancs&#x27;, 860), (&#x27;Biri&#x27;, &#x27;Ben&#x27;, &#x27;Bbiri&#x27;, 1100), (&#x27;Newman&#x27;, &#x27;Chad&#x27;, &#x27;Cnewman&#x27;, 750), (&#x27;Ropeburn&#x27;, &#x27;Audrey&#x27;, &#x27;Aropebur&#x27;, 1550);delete from my_employees;alter table my_employeesmodify id int primary key auto_increment;desc my_employees;#5. 向users表中插入数据/**1 Rpatel 102 Bdancs 103 Bbiri 204 Cnewman 305 Aropebur 40 */insert into users(id, userid, department_id)values (1, &#x27;Rpatel&#x27;, 10), (2, &#x27;Bdancs&#x27;, 10), (3, &#x27;Bbiri&#x27;, 20), (4, &#x27;Cnewman&#x27;, 30), (5, &#x27;Aropebur&#x27;, 40);#6. 将3号员工的last_name修改为“drelxer”update my_employeesset last_name=&#x27;drelxer&#x27;where id=3;select * from my_employees;#7. 将所有工资少于900的员工的工资修改为1000select * from my_employees;update my_employeesset salary=1000where salary&lt;900;#8. 将userid为Bbiri的user表和my_employees表的记录全部删除DELETE u,eFROM users uJOIN my_employees e ON u.`userid`=e.`Userid`WHERE u.`userid`=&#x27;Bbiri&#x27;;delete from my_employeeswhere userid=&#x27;Bbiri&#x27;;delete from userswhere userid=&#x27;Bbiri&#x27;;select * from users;#9. 删除my_employees、users表所有数据delete from my_employees;delete from users;#10. 检查所作的修正select * from my_employees;select * from users;#11. 清空表my_employees#这个清空不能回滚了truncate table my_employees;#-----------------------练习二---------------------------------# 1. 使用现有数据库dbtest11use dbtest11;# 2. 创建表petcreate table if not exists pet( id bigint primary key auto_increment, name varchar(20) comment &#x27;宠物名称&#x27;, owner varchar(20) not null unique comment &#x27;宠物主人&#x27;, species varchar(20) not null comment &#x27;种类&#x27;, birth year not null comment &#x27;出生日期&#x27;, death year not null comment &#x27;死亡日期&#x27;);alter table petmodify death year comment &#x27;死亡日期&#x27;;alter table petmodify owner varchar(20) comment &#x27;宠物主人&#x27;;alter table petadd sex char(1) not null comment &#x27;性别&#x27;;alter table petmodify sex char(1) not null comment &#x27;性别&#x27; after species;desc pet;select * from pet;# 3. 添加记录insert into pet(name, owner, species, sex,birth, death)values (&#x27;Fluffy&#x27;, &#x27;harold&#x27;, &#x27;Cat&#x27;, &#x27;f&#x27;, 2003, 2010);insert into pet(name, owner, species, sex,birth) values (&#x27;Claws&#x27;, &#x27;gwen&#x27;, &#x27;Cat&#x27;, &#x27;m&#x27;, 2004);insert into pet(name, species, sex,birth) values (&#x27;Buffy&#x27;, &#x27;Dog&#x27;, &#x27;f&#x27;, 2009);insert into pet(name, owner, species, sex,birth) values (&#x27;Fang&#x27;, &#x27;benny&#x27;, &#x27;Dog &#x27;, &#x27;m&#x27;, 2000);insert into pet(name, owner, species, sex,birth, death) values (&#x27;bowser&#x27;, &#x27;diane&#x27;, &#x27;Dog&#x27;, &#x27;m&#x27;, 2003, 2009);insert into pet(name, species, sex,birth) values (&#x27;Chirpy&#x27;, &#x27;Bird&#x27; ,&#x27;f&#x27;, 2008);select * from pet;# 4. 添加字段:主人的生日owner_birth DATE类型。alter table petadd owner_birth date comment &#x27;主人生日&#x27;;desc pet;# 5. 将名称为Claws的猫的主人改为kevinupdate petset owner=&#x27;kevin&#x27;where name=&#x27;Claws&#x27;;select * from pet;# 6. 将没有死的狗的主人改为duck/*alter table petmodify owner varchar(20) comment &#x27;宠物主人&#x27;;desc pet;*/update petset owner=&#x27;duck&#x27;where death is null;select * from petwhere death is null;# 7. 查询没有主人的宠物的名字;select * from petwhere owner is null ;# 8. 查询已经死了的cat的姓名,主人,以及去世时间;select * from pet;select name,owner,death from petwhere death is not null and species=&#x27;Cat&#x27;;# 9. 删除已经死亡的狗delete from petwhere species=&#x27;Dog&#x27; and death is not null;# 10. 查询所有宠物信息select * from pet;#-----------------------练习三---------------------------------# 1. 使用已有的数据库dbtest11use dbtest11;# 2. 创建表employee,并添加记录create table if not exists employee( id int primary key comment &#x27;id&#x27;, name varchar(20) comment &#x27;姓名&#x27;, sex char(1) comment &#x27;性别&#x27;, tel varchar(20) comment &#x27;联系电话&#x27;, addr varchar(50) comment &#x27;地址&#x27;, salary decimal(10,2) comment &#x27;工资&#x27;);desc employee;insert into employee(id, name, sex, tel, addr, salary)values (10001, &#x27;张一一&#x27;, &#x27;男&#x27;, &#x27;13456789000&#x27;, &#x27;山东青岛&#x27;, 1001.58), (10002, &#x27;刘小红&#x27;, &#x27;女&#x27;, 13454319000, &#x27;河北保定&#x27;, 1201.21), (10003, &#x27;李四&#x27;, &#x27;男&#x27;, 0751 - 1234567, &#x27;广东佛山&#x27;, 1004.11), (10004, &#x27;刘小强&#x27;, &#x27;男&#x27;, 0755 - 5555555, &#x27;广东深圳&#x27;, 1501.23), (10005, &#x27;王艳&#x27;, &#x27;女 &#x27;, 020 - 1232133, &#x27;广东广州&#x27;, 1405.16);# 3. 查询出薪资在1200~1300之间的员工信息。select * from employee;select * from employeewhere salary between 1200 and 1300;# 4. 查询出姓“刘”的员工的工号,姓名,家庭住址。select * from employeewhere name like &#x27;刘%&#x27;;# 5. 将“李四”的家庭住址改为“广东韶关”update employeeset addr=&#x27;广东韶关&#x27;where name=&#x27;李四&#x27;;select * from employee;# 6. 查询出名字中带“小”的员工select * from employeewhere name like &#x27;%小%&#x27;; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"7.mysql第10章创建和管理（数据库与表）","slug":"mysql/7.mysql第10章创建和管理（数据库与表）","date":"2019-10-03T07:00:00.000Z","updated":"2024-10-31T17:35:09.506Z","comments":true,"path":"2019/10/03/mysql/7.mysql第10章创建和管理（数据库与表）/","link":"","permalink":"https://protonlml.github.io/2019/10/03/mysql/7.mysql%E7%AC%AC10%E7%AB%A0%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%A1%A8%EF%BC%89/","excerpt":"","text":"创建和管理表 2.-创建和管理数据库12345678910111213141516171819202122232425262728/** 数据库的创建，修改与删除. */# 1.创建数据库create database test1 ;# 2.:判断数据库是否已经存在,不存在则创建数据库( 推荐 ) 指定字符集create database IF NOT EXISTS test2 character set utf8mb4;# 3.查看所有数据库show databases;# 4.查看当前正在使用的数据库select database();# 使用指定数据库use test2;# 5. 查看指定数据库下面的所有表show tables from atguigudb;# 6.查看数据库的创建信息show create database test2;# 7.更改数据库字符集alter database test2 character set gbk;show create database test2;# 8.删除指定数据库(不可逆)drop database test2;# 8.1 删除数据库，如果存在drop database if exists test2; 1-.创建和管理表123456789101112131415161718192021222324252627282930313233## ---------------------------------------------------------------create database if not exists test2 character set utf8mb4;use test2;show create database test2;# 1.创建表（创建的是一张空白表，白手起家）create table if not exists student ( id int not null unique primary key , # 非空约束，唯一约束，主键约束 name varchar(15) not null , # 非空约束 age int not null , gender enum(&#x27;男&#x27;,&#x27;女&#x27;), identity int not null unique);desc student;delete from student;# 2.插入数据insert into student (id, name, age, gender, identity)values (1,&#x27;小明&#x27;,15,&#x27;男&#x27;,&#x27;413026185502654897&#x27;);insert into student (id, name, age, gender, identity)values (2,&#x27;小绿&#x27;,29,&#x27;女&#x27;,&#x27;4130265641502654897&#x27;);select * from student; 2-.创建一张表的两种方式 2.1 1234567891011121314151617181920#2.创建一张表，表数据从已知表数据获取（相当于复制表）#2.1.复制一张表CREATE TABLE stu1 AS SELECT * FROM student;select * from stu1;#2.2.创建的表，只有字段，没有值CREATE TABLE stu2 AS SELECT * FROM student WHERE 1=2; -- 创建的emp2是空表select * from stu2;#2.3. 创建表，指定复制那几个字段，和数据CREATE TABLE stu80AS SELECT id, name, age, gender, identity FROM student WHERE id = 2;select * from stu80;DESCRIBE stu80; 3-.表的修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# 3. 修改table表的字段类型(修改一列)alter table studentmodify identity bigint;alter table studentmodify identity bigint default 111111111111111111;# 4.追加一列alter table studentadd iphone int ;desc student;#5.重命名一个列alter table studentchange name student_name varchar(15);#6.删除一个列alter table studentdrop column iphone;# 7.查询表数据select * from student;# 8.重命名表rename table student to students;show tables ;# 9.删除表/**在MySQL中,当一张数据表 没有与其他任何数据表形成关联关系 时,可以将当前数据表直接删除。数据和结构都被删除所有正在运行的相关事务被提交所有相关索引被删除 IF EXISTS 的含义为:如果当前数据库中存在相应的数据表,则删除数据表;如果当前数据库中不存在相应的数据表,则忽略删除语句,不再执行删除数据表的操作。 */drop table if exists students;# 10.清空表# TRUNCATE TABLE detail_dept;# TRUNCATE 删除表中的所有数据，且不能回滚select *from student;desc student;insert into student (id, name, age, gender, identity)values (1,&#x27;夏红&#x27;,25,&#x27;女&#x27;,125442121244);#修改字段类型alter table student modify identity bigint;# 创建表 修改表 重命名表 删除表# create table 表名 alter table 表名 rename table drop table 表名select * from student;## -------------------------------------------# 设置 自动提交关闭， delete 表 删除所有数据后，紧接着可以回滚到上一步。SET autocommit = FALSE;delete from student;rollback ;select * from student;# 如果是TRUNCATE TABLE 截断表清空表数据，不管设不设置SET autocommit = FALSE; 都不能回滚。（开发最好别用）truncate student;select * from student;rollback ; # 即使是执行回滚，也不能回滚了。select * from student;/**拓展2:如何理解清空表、删除表等操作需谨慎?!表删除 操作将把表的定义和表中的数据一起删除,并且MySQL在执行删除操作时,不会有任何的确认信息提示,因此执行删除操时应当慎重。在删除表前,最好对表中的数据进行 备份 ,这样当操作失误时可以对数据进行恢复,以免造成无法挽回的后果。同样的,在使用 ALTER TABLE 进行表的基本修改操作时,在执行操作过程之前,也应该确保对数据进行完整的 备份 ,因为数据库的改变是 无法撤销 的,如果添加了一个不需要的字段,可以将其删除;相同的,如果删除了一个需要的列,该列下面的所有数据都将会丢失。 */ 5-.注意：清空表、删除表等操作需谨慎!表删除 操作将把表的定义和表中的数据一起删除,并且MySQL在执行删除操作时,不会有任何的确认信息提示,因此执行删除操时应当慎重。在删除表前,最好对表中的数据进行 备份 ,这样当操作失误时可以对数据进行恢复,以免造成无法挽回的后果。同样的,在使用 ALTER TABLE 进行表的基本修改操作时,在执行操作过程之前,也应该确保对数据进行完整的 备份 ,因为数据库的改变是 无法撤销 的,如果添加了一个不需要的字段,可以将其删除;相同的,如果删除了一个需要的列,该列下面的所有数据都将会丢失。 练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#第10章_创建和管理表# 练习1：#1. 创建数据库test01_office,指明字符集为utf8。并在此数据库下执行下述操作create database if not exists test01_office character set utf8mb4;# 使用数据库use test01_office;#2. 创建表dept01/*字段 类型id INT(7)NAME VARCHAR(25)*/create table if not exists dept01( id int primary key auto_increment, name varchar(25));select * from dept01;#3. 将表departments中的数据插入新表dept02中create table if not exists dept02 ASselect * from atguigudb.departments;select * from dept02;#4. 创建表emp01/*字段 类型id INT(7)first_name VARCHAR (25)last_name VARCHAR(25)dept_id INT(7)*/create table if not exists emp01( id int(7) primary key auto_increment comment &#x27;id&#x27;, first_name varchar(25) not null comment &#x27;姓&#x27;, last_name varchar(25) not null comment &#x27;名字&#x27;, dept_id int(7) comment &#x27;部门id&#x27;);desc emp01;#5. 将列last_name的长度增加到50alter table emp01modify last_name varchar(50) not null comment &#x27;名字&#x27;;#6. 根据表employees创建emp02create table if not exists emp02select * from atguigudb.employeeswhere 1=2;#7. 删除表emp01drop table emp01;#8. 将表emp02重命名为emp01alter table emp02 rename emp01;#9.在表dept02和emp01中添加新列test_column,并检查所作的操作alter table dept02add test_column varchar(15);alter table emp01add test_column varchar(15);#10.直接删除表emp01中的列 department_idalter table emp01drop column department_id;select *from emp01;/** 重命名表 RENAME TABLE emp TO myemp; 对于表中字段的操作 添加一个列 add 修改一个列字段的属性 modify 重命名一个列的名称 change 改变 删除一列 drop */#练习2：# 1、创建数据库 test02_marketcreate database if not exists test02_market character set utf8mb4;use test02_market;# 2、创建数据表 customerscreate table if not exists customers( c_num int primary key auto_increment, c_name varchar(50) not null comment &#x27;姓名&#x27;, c_contact varchar(50) , c_city varchar(50) comment &#x27;城市&#x27;, c_birth date comment &#x27;生日&#x27;);# 3、将 c_contact 字段移动到 c_birth 字段后面alter table customersmodify c_contact varchar(50) after c_birth;select * from customers;# 4、将 c_name 字段数据类型改为 varchar(70)alter table customersmodify c_name varchar(70);desc customers;# 5、将c_contact字段改名为c_phonealter table customerschange c_contact c_phone varchar(50);desc customers;# 6、增加c_gender字段到c_name后面,数据类型为char(1)alter table customersadd c_gender char(1) after c_name;desc customers;# 7、将表名改为customers_inforename table customers to customers_info;# 8、删除字段c_cityalter table customers_infodrop c_city;desc customers_info;# 练习3：# 1、创建数据库test03_companycreate database if not exists test03_company character set utf8mb4;use test03_company;# 2、创建表officescreate table if not exists offices( officeCode int primary key auto_increment, city varchar(30), address varchar(50), country varchar(50), postalCode varchar(25));# 3、创建表employeescreate table if not exists employees(empNum int primary key auto_increment,lastName varchar(50) not null comment &#x27;名字&#x27;,firstName varchar(50) not null comment &#x27;姓&#x27;,mobile varchar(25) unique not null comment &#x27;手机号&#x27;,code int unique comment &#x27;代码&#x27;,jobTitle varchar(50) not null comment &#x27;工作名称&#x27;,birth date comment &#x27;生日&#x27;,note varchar(255) default &#x27;普通员工&#x27; comment &#x27;笔记&#x27;,sex varchar(5) not null comment &#x27;性别&#x27;);select * from employees;desc employees;# 4、将表employees的mobile字段修改到code字段后面alter table employeesmodify mobile varchar(50) after code;desc employees;# 5、将表employees的birth字段改名为birthdayalter table employeeschange birth birthday date;desc employees;# 6、修改sex字段,数据类型为char(1)alter table employeesmodify sex char(1);desc employees;# 7、删除字段notealter table employeesdrop note;desc employees;# 8、增加字段名favoriate_activity,数据类型为varchar(100)alter table employeesadd favoriate_activity varchar(100) comment &#x27;喜欢的活动&#x27;;# 9、将表employees的名称修改为 employees_inforename table employees to employees_info; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"6.mysql第09章子查询","slug":"mysql/6.mysql第09章子查询","date":"2019-10-03T06:00:00.000Z","updated":"2024-10-26T13:50:46.147Z","comments":true,"path":"2019/10/03/mysql/6.mysql第09章子查询/","link":"","permalink":"https://protonlml.github.io/2019/10/03/mysql/6.mysql%E7%AC%AC09%E7%AB%A0%E5%AD%90%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"子查询 一、子查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241/** 子查询: */# 需求：员工表中，比Abel的工资高的都有那些select last_name,salaryfrom employeeswhere salary&gt;(select salary from employees where last_name=&#x27;Abel&#x27;);/** 子查询的分类 我们按内查询的结果返回一条还是多条记录,将子查询分为 单行子查询 、 多行子查询 。 *//** 单行子查询： 因为，单行子查询的返回结果，只有一行，就一个值，所以可使用 = &gt; &gt;= &lt; &lt;= &lt;&gt; 进行比较操作 例如： 题目:查询工资大于149号员工工资的员工的信息 */select last_name,salaryfrom employeeswhere salary&gt;( select salary from employees where employee_id=&#x27;149&#x27; #10500 );# 题目:返回job_id与141号员工相同,salary比143号员工多的员工姓名,job_id和工资select last_name,job_id,salaryfrom employeeswhere job_id=(select job_id from employees where employee_id=&#x27;141&#x27;)and salary&gt;(select salary from employees where employee_id=&#x27;141&#x27;);# 题目:返回公司工资最少的员工的last_name,job_id和salaryselect last_name,job_id,salaryfrom employeeswhere salary=( select min(salary) from employees );# 题目:查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id, manager_id,department_idselect employee_id,manager_id,department_idfrom employeeswhere manager_id in (select manager_id from employees where employee_id in(141,174))and department_id in (select department_id from employees where employee_id in(141,174))and employee_id not in (141,174);/** HAVING 中的子查询 首先执行子查询。 向主查询中的HAVING 子句返回结果。 */# 题目:查询最低工资# 大于 50号部门最低工资# 的部门 id和其最低工资select department_id,min(salary)from employees egroup by department_idhaving min(salary) &gt; ( select min(salary) from employees where department_id=50 group by department_id );/** CASE中的子查询 在CASE表达式中使用单列子查询: */## 题目:显式员工的 employee_id,last_name和location。# 其中,若员工department_id# 与 location_id为1800 的department_id相同,20# 则location为’Canada’,其余则为’USA’。select employee_id,last_name, (case department_id when ( select department_id from departments where location_id=1800 ) then &#x27;Canada&#x27; else &#x27;USA&#x27; end ) locationfrom employees;/*-------------------------------------------------------------------------------------------------------*//** 多行子查询 子查询的结果，是多行的，所以使用多行比较操作符多行比较操作符 in 等于列表中的任意一个 ANY 需要和单行比较操作符一起使用,和子查询返回的某一个值比较 ALL 需要和单行比较操作符一起使用,和子查询返回的所有值比较 SOME 实际上是ANY的别名,作用相同,一般常使用ANY */# 题目:返回# 其它job_id中比 job_id为‘IT_PROG’部门 任一工资低# 的 员工的员工号、姓名、job_id 以及salary## select d.department_id,e.salary# from employees e join departments d# on e.department_id=d.department_id# where e.job_id=&#x27;IT_PROG&#x27;;select employee_id,last_name,job_id,salaryfrom employeeswhere salary&lt; any( select salary from employees where job_id=&#x27;IT_PROG&#x27; )and job_id &lt;&gt; &#x27;IT_PROG&#x27;;select * from departments;# 题目:查询平均工资最低的部门id# 将 虚拟表。作为 from后面的表进行查询# 查询了员工所在的所有部门的 平均工资select department_id,avg(salary) t_dep_gr_avgsalaryfrom employeesgroup by department_id;# 平均工资最低是多少select min(t_dep_gr_avgsalary)from (select avg(salary) t_dep_gr_avgsalaryfrom employeesgroup by department_id) dept_avg_sal ;select department_id,avg(salary) t_dep_gr_avgsalaryfrom employeesgroup by department_idhaving avg(salary) = (select min(t_dep_gr_avgsalary)from (select avg(salary) t_dep_gr_avgsalaryfrom employeesgroup by department_id) dept_avg_sal);/** 相关子查询：外部的表，存在于内部子查询当中 如果子查询的执行依赖于外部查询,通常情况下都是因为子查询中的表用到了外部的表,并进行了条件 关联,因此每执行一次外部查询,子查询都要重新计算一次,这样的子查询就称之为 关联子查询 。 步骤是： 1.外查询，先查询到了107条记录。 2.将第一条记录取出来，送进子查询中，送进来的这条记录，使用外表的这条记录，获取到employee_id。查出子查询的结果 3.将子查询的结果，返回到外查询，继续外查询语句的过滤条件，得到最终结果 题目:查询员工中工资 大于 本部门平均工资的员工的last_name,salary和其department_id :这里的相关子查询，子查询中使用主查询中的列 */select last_name, e.employee_id ,salaryfrom employees ewhere salary &gt; (select avg(salary) from employees em where em.department_id=e.employee_id);/** 相关子查询， 子查询在 from 后面 from型的子查询:子查询是作为from的一部分,子查询要用()引起来,并且要给这个子查询取别 名, 把它当成一张“临时的虚拟的表”来使用。 */ #:查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_idSELECT last_name,salary,e1.department_idFROM employees e1,( SELECT department_id,AVG(salary) dept_avg_sal FROM employees GROUP BY department_id) e2WHERE e1.`department_id` = e2.department_idAND e2.dept_avg_sal &lt; e1.`salary`;/** 在ORDER BY 中使用 相关子查询: 题目:查询员工的id,salary,按照department_name 排序 */select distinct department_namefrom employees e2 left join departments don e2.department_id = d.department_id;# select e1.last_name, e1.employee_id,e1.salary# from employees e1# order by (select distinct department_name# from employees e2 left join departments d# on e2.department_id = d.department_id# where e1.employee_id=e2.employee_id) asc;SELECT employee_id, salaryFROM employees eORDER BY ( SELECT department_name FROM departments d WHERE e.`department_id` = d.`department_id` );/** EXISTS 与 NOT EXISTS关键字 关联子查询通常也会和 EXISTS操作符一起来使用,用来检查在子查询中是否存在满足条件的行。 如果在子查询中不存在满足条件的行: 条件返回 FALSE 继续在子查询中查找 如果在子查询中存在满足条件的行: 不在子查询中继续查找 条件返回 TRUE NOT EXISTS关键字表示如果不存在某种条件,则返回TRUE,否则返回FALSE。 */# 题目:查询公司 管理者的 employee_id, last_name, job_id,department_id 信息# 方法一：表自连接SELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_idFROM employees e1 JOIN employees e2WHERE e1.employee_id = e2.manager_id;# 方法二、SELECT employee_id, last_name, job_id, department_idFROM employees e1WHERE EXISTS(SELECT * FROM employees e2 WHERE e2.manager_id = e1.employee_id);# 查询 departments表 中 不存在于 employees表中的部门 的department_id和department_nameSELECT department_id, department_nameFROM departments dWHERE NOT EXISTS (SELECT &#x27;X&#x27;FROM employeesWHERE department_id = d.department_id); 子查询练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424/** ------------------------------------------------------------------------ 子查询练习 */#1.查询和Zlotkey相同部门的员工姓名和工资select e1.department_id ,e1.last_name,e1.salary from employees e1where e1.department_id =(select department_id from employees e2 where e2.last_name=&#x27;Zlotkey&#x27;);#2.查询 工资比公司平均工资高的 员工的员工号,姓名和工资。select employee_id,last_name,salaryfrom employeeswhere salary&gt;(select avg(salary) from employees);#公司的平均工资select avg(salary) from employees;#3.选择工资大于 所有JOB_ID = &#x27;SA_MAN&#x27;的员工的工资 的员工的last_name, job_id, salaryselect last_name,job_id,salaryfrom employeeswhere salary&gt; all(select salary from employeeswhere job_id=&#x27;SA_MAN&#x27;);#所有JOB_ID = &#x27;SA_MAN&#x27;的员工的工资select salary from employeeswhere job_id=&#x27;SA_MAN&#x27;;#4.查询 和姓名中包含字母u的员工 在 相同部门 的员工 的员工号和姓名select employee_id,last_namefrom employeeswhere department_id in (select distinct department_id from employeeswhere last_name like &#x27;%U%&#x27;);# 查询和 姓名中包含字母u的员工 在相同部门的员工# 查询姓名中包含字母u的员工 的部门idselect distinct department_id from employeeswhere last_name like &#x27;%U%&#x27;;#5.查询在 部门的location_id为1700的部门工作的 员工的员工号select employee_id ,last_namefrom employeeswhere department_id in( select department_id from departments where location_id=&#x27;1700&#x27; );# 查询 location_id为1700的部门id号select department_idfrom departmentswhere location_id=&#x27;1700&#x27;;#6.查询管理者是King的员工姓名和工资select last_name, salary,manager_idfrom employeeswhere manager_id=(select employee_idfrom employeeswhere last_name=&#x27;King&#x27; and manager_id is null);# 查询King 管理者的 employee_idselect employee_idfrom employeeswhere last_name=&#x27;King&#x27; and manager_id is null ;#7.查询工资最低的员工信息: last_name, salaryselect last_name,salaryfrom employeeswhere salary=(select min(salary) from employees);#查询员工表的最低工资是多少select min(salary)from employees;#8.查询平均工资 最低的部门信息#查找各个部门的平均工资select avg(salary) avg_salaryfrom employeesgroup by department_id;# 查找部门的最低工资select min(avg_salary)from (select avg(salary) avg_salaryfrom employeesgroup by department_id) t_avg_em;# 查找最低工资的部门select *from departmentswhere department_id=( select department_id from employees group by department_id having avg(salary)=( select min(avg_salary) from ( select avg(salary) avg_salary from employees group by department_id) t_avg_em ) );#9.查询平均工资 最低的部门 信息 和 该部门的平均工资(相关子查询)select department_id,avg(salary)from employeesgroup by department_idhaving avg(salary)&lt;=ALL ( #求出每个部门的平均工资 select avg(salary) from employees group by department_id);# 记住一点：这种子查询，就抓住，子查询后出来的值#10.查询平均工资最高的 job 信息# 注意：看题目，题目要查job信息，肯定是 from jobs表,然后再去凑条件select * from jobs;# 查询每个工种的 平均工资select job_id,avg(salary)from employeesgroup by job_id;# 查询 平均工资最高的 工种 job_idselect job_idfrom employeesgroup by job_idhaving avg(salary)&gt;=ALL ( select avg(salary) from employees group by job_id);#最终select * from jobswhere job_id=(select job_idfrom employeesgroup by job_idhaving avg(salary)&gt;=ALL ( select avg(salary) from employees group by job_id));#11.查询 平均工资 高于 公司平均工资 的部门有哪些?select * fromdepartments;#查询公司的平均工资select avg(salary)from employees;# 查询部门的平均工资select department_id,avg(salary)from employeesgroup by department_id;# 查询 平均工资 高于 公司平均工资 的部门有哪些?select department_id,avg(salary)from employeeswhere department_id is not nullgroup by department_idhaving avg(salary) &gt;( select avg(salary) from employees ) ;#12.查询出公司中所有 manager(管理者) 的详细信息# manager也是员工# 这题只要是，将employees表，想象成两张表，一张是员工表，一张是 管理者表。# 只要 员工表的 员工id=管理者表中的 管理id ,那么这个人这条记录就是管理者# 自连接查询select * from employees;select DISTINCT em.employee_id, em.last_name, em.salaryfrom employees em join employees maon em.employee_id=ma.manager_id;#方法2SELECT employee_id, last_name, salaryFROM employeesWHERE employee_id IN ( SELECT DISTINCT manager_id FROM employees);#相关子查询 查询第一行时， 外查询的条件，进入到内查询，内查询执行使用外查询条件。完毕。 跳出内查询，到外查询继续执行#方式3: where 后面判断 存在 EXISTS 存在返回trueSELECT employee_id, last_name, salaryFROM employees e1WHERE EXISTS(SELECT * FROM employees e2 WHERE e2.manager_id = e1.employee_id);#13.各个部门中 最高工资中 最低的那个部门的 最低工资是多少?# 求各个部门的最高工资# 将各个部门的最高工资进行比较，最低的那个部门的工资是多少#从最高工资中找到最低工资select min(mx_salary)from ( # 求各个部门的最高工资 select max(salary) mx_salary from employees group by department_id ) a;# 抓住核心思想，求什么就先把字段写好，后面再往上面凑select department_id, salaryfrom employeeswhere department_id =(select department_idfrom employeesgroup by department_idhaving max(salary) = (select max(salary) m_sa from employees group by department_id order by m_sa limit 0,1 ));#14.查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary# 求平均工资最高的部门idselect department_idfrom employeesgroup by department_idhaving avg(salary)&gt;=ALL ( select avg(salary) from employees group by department_id);#求这个平均工资最高的部门中，多个管理者的 idselect distinct manager_idfrom employeeswhere department_id =( #查询平均工资最高的部门 select department_id from employees group by department_id having avg(salary) &gt;= ALL ( #每个部门的平均工资 select avg(salary) from employees group by department_id ));# 查询员工表select employee_id, last_name, department_id, email, salaryfrom employeeswhere employee_id in ( select distinct manager_id from employees where department_id = ( #查询平均工资最高的部门 select department_id from employees group by department_id having avg(salary) &gt;= ALL ( #每个部门的平均工资 select avg(salary) from employees group by department_id ) ));#15. 查询部门的部门号,其中不包括job_id是&quot;ST_CLERK&quot;的部门号# 查询所有部门，然后排除 Job_id是&quot;ST_CLERK&quot;的部门# 查询 Job_id是&quot;ST_CLERK&quot;的 所有部门idselect department_idfrom employeesgroup by department_id,job_idhaving job_id=&#x27;ST_CLERK&#x27;;select department_idfrom departmentswhere department_id not in( select department_id from employees group by department_id,job_id having job_id=&#x27;ST_CLERK&#x27; );#相关子查询，将部门表作为主体，条件来判断是不是为真。满足就输出，不满足就继续下一行SELECT department_idFROM departments dWHERE NOT EXISTS( SELECT * FROM employees e WHERE d.`department_id` = e.`department_id` AND job_id = &#x27;ST_CLERK&#x27; );#16. 选择所有 没有管理者的员工的last_name# 查询 管理者的id为null的 员工信息select *from employeeswhere manager_id is null ;# 查询所有管理者的id# 员工的管理者，与其匹配，不在里面的 记录一行select *from employees e1 # e1看作员工表where not exists( select * from employees e2 #e2看作管理员表 where e1.manager_id=e2.employee_id );#17.查询员工号、姓名、雇用时间、工资, 其中员工的 管理者为 &#x27;De Haan&#x27;# 查询 last_name=&#x27;De Haan&#x27;的员工号select * from employees where last_name=&#x27;De Haan&#x27;;# employee_id =102select employee_id,last_name,hire_date,salaryfrom employeeswhere manager_id=( select employee_id from employees where last_name=&#x27;De Haan&#x27; );#18.查询 各部门中工资 比本部门平均工资高 的员工的员工号, 姓名和工资(相关子查询)#查询各个部门中的工资(所有人的工资)# 必须以部门和人分组，不能以部门和工资分组，工资有可能 两个人一样的。也被合并了。错误的select employee_id, last_name, salaryfrom employees e1group by department_id, employee_idhaving salary&gt;( select AVG(salary) from employees e2 where e1.department_id=e2.department_id group by department_id );# 错误的分组select department_id,salaryfrom employeesgroup by department_id, salary;# 查询各个部门的 平均工资select department_id,AVG(salary)from employeesgroup by department_id;#19.查询每个部门下的部门人数大于 5 的部门名称(相关子查询)# 查询每个部门，部门下的 人数# 思考，部门表，和 员工表 相关查询select *from departments dwhere 5&lt;( select count(1) from employees e where d.department_id=e.department_id ) ;# 某个部门下的人数select count(1)from employeeswhere department_id=&#x27;90&#x27;;#20.查询每个国家下的部门个数大于 2 的国家编号(相关子查询)select * from countries;# 查看部门在哪国家select *from departments;select *from locations;# 查询国家countries表select * from countries cwhere 2&lt;( select count(1) from departments d join locations l on d.location_id=l.location_id where c.country_id=l.country_id );# 所有部门所在的城市select d.department_id,l.country_idfrom departments d join locations lon d.location_id=l.location_id;SELECT country_idFROM locations lWHERE 2 &lt; ( SELECT COUNT(*) FROM departments d WHERE l.`location_id` = d.`location_id`); © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"5.mysql第8章聚合函数","slug":"mysql/5.mysql第8章聚合函数","date":"2019-10-03T05:00:00.000Z","updated":"2024-11-03T12:30:50.888Z","comments":true,"path":"2019/10/03/mysql/5.mysql第8章聚合函数/","link":"","permalink":"https://protonlml.github.io/2019/10/03/mysql/5.mysql%E7%AC%AC8%E7%AB%A0%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/","excerpt":"","text":"聚合函数 1.聚合函数类型（记住聚合函数就这5种） AVG(字段) 求平均值 SUM(字段) 求和 MAX(字段) 求最大值 MIN(字段) 求最小值 COUNT(某字段) 求字段有多少个 注意1：聚合函数一般是配合 group by 分组 来使用的 select MAX(salary) from employees; 注意2：where 后面不能跟 聚合函数 注意3：聚合函数不能嵌套使用 123456789101112131415161718192021222324252627282930313233343536373839/** 五、聚合函数类型（记住聚合函数就这5种） AVG(字段) 求平均值 SUM(字段) 求和 MAX(字段) 求最大值 MIN(字段) 求最小值 COUNT(某字段) 求字段有多少个 注意1：聚合函数一般是配合 group by 分组 来使用的 select MAX(salary) from employees; 注意2：where 后面不能跟 聚合函数 注意3：聚合函数不能嵌套使用# 练习： 求 所有人中，最高工资的那个人 错误的写法： 有矛盾之处，查这张员工表，求出 最大工资的那个，应该是1个结果，而字段中还有last_name字段是表示显示表employees中所有人的姓名，有冲突 select last_name, MAX(salary) from employees; # 正确写法：求 所有人中，最高工资的那个人( 用到子查询) select employee_id, last_name, salary from employees where salary=(select max(salary)from employees); */select * from employees;select MAX(salary) from employees;# 求 所有人中，最高工资的那个人( 用到子查询)select employee_id, last_name, salary from employeeswhere salary=(select max(salary)from employees);#聚合函数，配合group by 使用：按照部门分组，求出每个部门中最高工资select department_id,MAX(salary) from employeesgroup by department_id;/** 统计个数的字段 COUNT() # 字段commission_pct有35行有值，null不统计 */select COUNT(commission_pct) from employees; 2.group—by可以使用GROUP BY子句将表中的数据分成若干组12345678SELECT column, group_function(column)FROM table[WHERE condition][GROUP BY group_by_expression][ORDER BY column]; 明确:WHERE一定放在FROM后面 ☆☆☆group….by… 的sql语句理解☆☆☆这里也要思考表与表之间的对应关系123456select department_id ,avg(salary) # select 读作 这一个部门中 工资的平均值from employeesgroup by department_id; # 通过select 后面的 语句，就可以看出分组后的 表张什么样子了# 这里 肯定是 每一个部门 在第一列， 第二列是 每个部门的 平均工资#如下图 1234567select department_id,job_id ,avg(salary) from employeesgroup by department_id,job_id;# 每个部门分组后， 部门里面再按照 工种id(job_id) 进行分组.# 可以预见查出来的表 ,一个部门，要分多行了，因为一个部门里面有多个工种，每个工种在进行算工资平均值# 如下图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** --------------------------------------group---by----字段分组的使用------------------------------------------------- *//** 分组：对于 group by 分组的理解# 结论1：在select 后面声明的 字段，除了组函数之外的字段，一定要出现在 group by 后面;# 反之group by 后面声明的 字段，不一定要出现在 select 后面# 反正就是，只要出现了分组， 在select 后面声明的字段 ，在 group by 后面要全部都给写上，并且select 后面一定要有一个聚合函数，来计算组意图结果。# 结论2：group by 声明在from后面、where后面, order by 排序前面、limit 分页前面。 （可以理解，结果集群都都处理完毕，在进行排序，和分页）--------------------------------------------------select department_id,avg(salary)from employeesgroup by department_id,job_id;--------------------------------------------------select department_id,job_id ,avg(salary)from employeesgroup by department_id,job_id; */select * from employees;# 求所有员工的 工资平均值 AVG = SUM / COUNT(1)select SUM(salary) / count(1) from employees;# 求所有员工的 工资平均值select avg(salary)from employees;## 查询 每个部门 有多少人# 先找到employees表# 然后group by 按照department_id 部门分组，有null,10，20，30，40，50，60，70，80，90，100这12个部门,此时结果集已经形成12条数据，12个部门# 随后 count(1) 再次限定结果集，将每个部门多少人求出来select department_id ,count(1)from employeesgroup by department_id;# 每个部门中 的 平均工资是多少# 求每个部门的 平均工资select department_id ,avg(salary)from employeesgroup by department_id;# 先找到employees表# 然后group by 按照department_id 部门分组，在按照 工种job_id 进行 分组。# 比如90号部门的AD_PRES 在一行，90号部门的AD_VP工种 在一行，求平均工资值。select department_id,job_id ,avg(salary)from employeesgroup by department_id,job_id;#错误写法 这种错误就是 按照 department_id分组后的结果集，# 在select 后面的语句，并没有进行操作，只要显示last_name# 这里 按照 department_id分组后，展示字段last_name ，不可能的事情，是错误的写法select department_id ,last_namefrom employeesgroup by department_id;# 错误写法# 只按照 department_id 进行分组，不能查到job_id 字段select department_id,job_id,avg(salary)from employeesgroup by department_id;# 结论：在select 后面声明的 字段，除了组函数之外的字段，一定要出现在 group by 后面;# 反之group by 后面声明的 字段，不一定要出现在 select 后面/** # 结论3.只要看见sql语句中有group by 就要想，结果集是 进行分组的结果， select 后面的字段，就是分组的字段，聚合函数就是对这分组后的操作。 如果分组后的结果继续筛选，就要使用having 进行筛选， 后面跟的是聚合函数。 这里不能使用where ,where 可以直接使用表中的字段作为筛选条件,但不能使用分组中的 聚合函数 作为筛选条件; HAVING 必须要与 GROUP BY 配合使用,可以把分组计算的聚合函数和分组字段作为筛选条件。 */#按照部门分组，部门有 null,10,20,30,40,50,60,70,80,90,100,110select department_id from employeesgroup by department_id;#按照 部门和工资分组# 一个部门中有很多人工资不一样，一样的分为一组 如：90号部门工资有两种24000，17000select department_id ,salary from employeesgroup by department_id,salary;#求 每个部门中 工资最高是多少select department_id , max(salary) from employeesgroup by department_id;# 需求： 查询出 每个部门中最高工资 ，且最高工资超过10000的部门。select department_id, MAX(salary)from employeesGROUP BY department_idhaving MAX(salary)&gt;10000 ; # 对分组再进行筛选# 需求： 查询出 50，90，110 部门中，最高工资超过10000的部门是那几个。# 这里 where 后面的条件 是先筛选 符合条件的部门，提高了查询速度# having 后面的筛选条件，记住就跟聚合函数select department_id, MAX(salary)from employeeswhere department_id in(50,90,110)GROUP BY department_idhaving MAX(salary)&gt;10000 ; # 对分组再进行筛选# ----------------牢记sql语句的执行过程---------------------- 练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 第八章，聚合函数的练习#组函数，又叫聚合函数#1.where子句可否使用组函数（聚合函数）进行过滤?# 答：不能，where 后面过滤条件不能跟聚合函数， 而having 后面可以跟聚合函数#2.查询公司员工 工资的 最大值,最小值,平均值,总和select max(salary),min(salary),avg(salary),sum(salary)from employees;#3.查询各job_id的员工 工资的 最大值,最小值,平均值,总和select job_id,max(salary),min(salary),avg(salary),sum(salary)from employeesgroup by job_id;#4.选择具有各个job_id的员工人数select job_id , count(1)from employeesgroup by job_id;# 5.查询员工最高工资和最低工资的差距(DIFFERENCE) select max(salary)-min(salary) as &#x27;差距&#x27; from employees;# 6.查询各个管理者手下 员工的 最低工资,其中最低工资不能低于6000, 没有管理者的员工不计算在内/*select distinct e1.employee_id from employees e1join employees e2 on e1.manager_id=e2.department_id;select * from(select distinct e1.employee_id ma_id from employees e1 join employees e2 on e1.manager_id=e2.department_id) agroup by a.ma_id;select manager_id, employee_id from employeeswhere manager_id is not nullgroup by manager_id ,employee_id;*/select manager_id , min(salary)from employeeswhere manager_id is not nullgroup by manager_idhaving min(salary)&gt;6000;# 7.查询 所有部门 的名字,location_id,员工数量 和 平均工资, 并按平均工资降序select * from departments;select e.department_id,d.department_name,d.location_id,count(e.employee_id),avg(e.salary) avg_salaryfrom departments dleft join employees eon d.department_id=e.department_idgroup by d.department_idorder by avg_salary desc ;# 8.查询 每个工种、每个部门的部门名、工种名 和 最低工资select d.department_name ,e.job_id,min(salary)from departments d join employees e on e.department_id = d.department_idgroup by d.department_name ,e.job_id; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"4.mysql第7章单行函数.md","slug":"mysql/4.mysql第7章单行函数","date":"2019-10-03T03:00:00.000Z","updated":"2024-10-13T16:34:27.467Z","comments":true,"path":"2019/10/03/mysql/4.mysql第7章单行函数/","link":"","permalink":"https://protonlml.github.io/2019/10/03/mysql/4.mysql%E7%AC%AC7%E7%AB%A0%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/","excerpt":"","text":"单行函数 MySQL中的函数这里我将这些丰富的内置函数再分为两类：单行函数 、 聚合函数(或分组函数) 单行函数 操作数据对象 接受参数返回一个结果 只对一行进行变换 每行返回一个结果 可以嵌套 参数可以是一列或一个值 一、单行函数有哪些？ 1.常用数值函数 123456789101112131415161718192021222324252627282930313233343536373839404142/** 一、数值函数 */#1.返回绝对值select ABS(-12) from dual; # 12# 2.返回数字的符号select SIGN(-9) from dual; # -1# 3.返回圆周率的值select PI() from dual; # 3.141593#4.返回大于或等于某个值的最小整数select CEIL(12) from dual; #12select CEIL(0.1) from dual; # 1select CEILING(-0.1) from dual;#0#5.返回列表中的最小值、select least(11,12,3,0) from dual;#6.返回列表中的最大值select greatest(12,23,55) from dual;#7.求余数，取模(工资与3取模) MOD()select last_name,salary, MOD(salary,3) from employees;/** ROUND(x) 返回一个对x的值进行四舍五入后,最接近于X的整数 */select ROUND(15.6)from dual;/** ROUND(x,y) 返回一个对x的值进行四舍五入后最接近X的值,并保留到小数点后面Y位 */select ROUND(12.346,2) from dual;# 8.返回数字x截断为y位小数的结果select TRUNCATE(12.5334,2) from dual; 2.常用字符串的操作1234567891011121314151617181920212223242526272829303132333435363738394041/** ------------------------------------------------------------------------------------------------------------ 二、字符串的操作注意:MySQL中,字符串的位置是从1开始的。*/# 1.CONCAT(s1,s2,......,sn) 连接s1,s2,......,sn为一个字符串select concat(&#x27;abc&#x27;,&#x27;def&#x27;) from dual; # abcdef# 2.CONCAT_WS(x,s1,s2,......,sn) 同CONCAT(s1,s2,...)函数,但是每个字符串s1,s2,s3...之间要加上x连接select concat_ws(&#x27;a&#x27;,&#x27;123&#x27;,&#x27;456&#x27;) from dual; # 123a456# 3.INSERT(str, idx, len,replacestr) 将字符串str从第idx位置开始,len个字符长的子串替换为字符串replacestrselect insert(&#x27;hello&#x27;,2,3,&#x27;www&#x27;)from dual; # hwwwo# 4.UPPER(s) 或 UCASE(s) 将字符串s的所有字母转成大写字母select UPPER(&#x27;abc&#x27;)from dual;#ABC# 5.LOWER(s) 或LCASE(s) 将字符串s的所有字母转成小写字母select LOWER(&#x27;ABC&#x27;)from dual;# 6.LEFT(str,n) 返回字符串str最左边的n个字符select LEFT(&#x27;hello&#x27;,4) from dual; # hell# 7.RIGHT(str,n) 返回字符串str最右边的n个字符select RIGHT(&#x27;world&#x27;,3)from dual; # rld# 8.LTRIM(s)去掉字符串s左侧的空格select LTRIM(&#x27; hello&#x27;)from dual; #hello# 9.FIELD(s,s1,s2,...,sn) 返回字符串s在字符串列表中第一次出现的位置select FIELD(&#x27;a&#x27;,&#x27;vcf&#x27;,&#x27;asc&#x27;,&#x27;baf&#x27;,&#x27;a&#x27;)from dual; # 4# 10.REVERSE(s) 返回s 反转后的字符串select reverse(&#x27;lmn&#x27;) from dual; #nml# 11. NULLIF(value1,value2) 比较两个字符串,如果value1与value2相等,则返回NULL,否则返回value1select NULLIF(&#x27;a&#x27;,&#x27;a&#x27;) from dual;# 注意:MySQL中,字符串的位置是从1开始的。 3.时间日期函数123456789101112131415/** 三、时间日期函数1. CURDATE() ,CURRENT_DATE() 返回当前日期,只包含年、月、日# CURDATE 获取当前时间， 年-月-日2. CURTIME() , CURRENT_TIME() 返回当前时间,只包含时、分、秒3. NOW() / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP() 返回当前系统日期和时间4. UTC_DATE() 返回UTC(世界标准时间)日期5. UTC_TIME() 返回UTC(世界标准时间)时间# DATEDIFF(当前时间,已知时间) 时间间隔多少天# DATEDIFF(CURDATE(),&#x27;1997-01-01&#x27;) 时间间隔多少天 */ 练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** 练习 */# 1.显示系统时间(注:日期+时间) select now() from dual;# 2.查询员工号,姓名,工资,以及工资提高百分之20%后的结果(new salary)select employee_id &quot;工号&quot; , last_name &quot;姓名&quot; , salary &quot;工资&quot; , salary *(1+0.2) &quot;new salary&quot;from employees;# 3.将员工的姓名按首字母排序,并写出姓名的长度(length)select e.last_name, length(e.last_name)from employees eorder by e.last_name asc;# 4.查询员工id,last_name,salary,并作为一个列输出,别名为OUT_PUT# CONCAT(s1,s2,......,sn) 连接s1,s2,......,sn为一个字符串 将几个字段连接起来，CONCAT(,,)select CONCAT(employee_id ,&#x27;,&#x27;,last_name ,&#x27;,&#x27;, salary ) as OUT_PUT from employees;# 5.查询公司各员工工作的年数、工作的天数,并按工作年数的降序排序# ROUND() 保留整数，四舍五入，# DATEDIFF(date1,date2) 返回date1 - date2的日期间隔天数select now()from dual;# now() 返回当前日期,只包含年、月、日 时、分、秒;select CURDATE() from dual;# CURDATE() 返回当前日期,只包含年、月、日 2024-10-13select employee_id,last_name, ROUND(DATEDIFF(CURDATE(),hire_date)/365) &quot;worked_year&quot;,DATEDIFF(CURDATE(),hire_date) &quot;worked_days&quot;from employeesorder by worked_year desc;;# 6.查询员工姓名,hire_date , department_id,满足以下条件:# 雇用时间在1997年之后,department_id 为80 或 90 或110, commission_pct不为空# STR_TO_DATE(str, fmt) 按照字符串fmt格式&#x27;%Y-%m-%d&#x27; 对str进行解析,解析为一个日期# hire_date&gt;=STR_TO_DATE(&#x27;1997-01-01&#x27;,&#x27;%Y-%m-%d&#x27;);select last_name,hire_date,department_id from employeeswhere department_id in(80,90,110) and commission_pct IS NOT NULL# and hire_date &gt;=&#x27;1997-01-01&#x27;; # 直接也可以写，隐式转换and hire_date&gt;=STR_TO_DATE(&#x27;1997-01-01&#x27;,&#x27;%Y-%m-%d&#x27;);# 7.查询公司中入职超过10000天的员工姓名、入职时间select last_name,hire_datefrom employeeswhere DATEDIFF(CURDATE(),hire_date) &gt;= 10000;/** 连接字符串 # 8.做一个查询,产生下面的结果-- 字符串-&lt;last_name&gt; earns `&lt;salary&gt;` monthly but wants &lt;salary*3&gt;-- Dream Salary-- King earns 24000 monthly but wants 72000 */ select CONCAT(last_name,&#x27; earns &#x27;,salary,&#x27; monthly but wants &#x27;,salary*3) as &quot;Dream salary&quot; from employees;# DATEDIFF(当前时间,已知时间) 时间间隔多少天# DATEDIFF(CURDATE(),&#x27;1997-01-01&#x27;) 时间间隔多少天# CURDATE 获取当前时间， 年-月-日# CONCAT(s1,s2,s3) 连接字符串s1s2s3# ROUND(12.5) #13 四舍五入不保留小数 4.流程控制函数流程处理函数可以根据不同的条件,执行不同的处理流程,可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。 CASE WHEN …判断逻辑… THEN ….结果 CASE WHEN …… THEN …. 相当于Java的if…else if…else… CASE 字段 WHEN ‘要匹配的值’ THEN 操作逻辑 修订工资 要求：工作名称为 IT_PROG 工资 1.10*salary CASE 字段 WHEN ‘要匹配的值’ THEN 操作逻辑 相当于 Java 的 switch…case… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** 四、流程处理函数可以根据不同的条件,执行不同的处理流程 练习 CASE ... WHEN ... THEN ... 相当于Java的switch...case... 9.使用CASE-WHEN,按照下面的条件:--job grade--AD_PRES A--ST_MAN B--IT_PROG C--SA_REP D--ST_CLERK E-- 产生下面的结果-- Last_name Job_id Grade-- king AD_PRES A */SELECT last_name Last_name, job_id Job_id, CASE job_id WHEN &#x27;AD_PRES&#x27; THEN &#x27;A&#x27;WHEN &#x27;ST_MAN&#x27; THEN &#x27;B&#x27;WHEN &#x27;IT_PROG&#x27; THEN &#x27;C&#x27;WHEN &#x27;SA_REP&#x27; THEN &#x27;D&#x27;WHEN &#x27;ST_CLERK&#x27; THEN &#x27;E&#x27;ELSE &#x27;F&#x27;END &quot;grade&quot;FROM employees;/** CASE WHEN ...... THEN .... 相当于Java的if...else if...else... */ SELECT employee_id,salary, CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27;WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27;ELSE &#x27;草根&#x27; END &quot;描述&quot;FROM employees;/** 修订工资 要求：工作名称为 IT_PROG 工资 1.10*salary ........ CASE 字段 WHEN &#x27;要匹配的值&#x27; THEN 操作逻辑 相当于Java的switch...case... */SELECT last_name, job_id, salary,CASE job_id WHEN &#x27;IT_PROG&#x27; THEN 1.10*salaryWHEN &#x27;ST_CLERK&#x27; THEN 1.15*salaryWHEN &#x27;SA_REP&#x27; THEN 1.20*salaryELSE salaryEND &quot;REVISED_SALARY&quot;FROM employees; 5.聚合函数类型（记住聚合函数就这5种） AVG(字段) 求平均值 SUM(字段) 求和 MAX(字段) 求最大值 MIN(字段) 求最小值 COUNT(某字段) 求字段有多少个 注意1：聚合函数一般是配合 group by 分组 来使用的 select MAX(salary) from employees; 注意2：where 后面不能跟 聚合函数 注意3：聚合函数不能嵌套使用 123456789101112131415161718192021222324252627282930313233343536373839/** 五、聚合函数类型（记住聚合函数就这5种） AVG(字段) 求平均值 SUM(字段) 求和 MAX(字段) 求最大值 MIN(字段) 求最小值 COUNT(某字段) 求字段有多少个 注意1：聚合函数一般是配合 group by 分组 来使用的 select MAX(salary) from employees; 注意2：where 后面不能跟 聚合函数 注意3：聚合函数不能嵌套使用# 练习： 求 所有人中，最高工资的那个人 错误的写法： 有矛盾之处，查这张员工表，求出 最大工资的那个，应该是1个结果，而字段中还有last_name字段是表示显示表employees中所有人的姓名，有冲突 select last_name, MAX(salary) from employees; # 正确写法：求 所有人中，最高工资的那个人( 用到子查询) select employee_id, last_name, salary from employees where salary=(select max(salary)from employees); */select * from employees;select MAX(salary) from employees;# 求 所有人中，最高工资的那个人( 用到子查询)select employee_id, last_name, salary from employeeswhere salary=(select max(salary)from employees);#聚合函数，配合group by 使用：按照部门分组，求出每个部门中最高工资select department_id,MAX(salary) from employeesgroup by department_id;/** 统计个数的字段 COUNT() # 字段commission_pct有35行有值，null不统计 */select COUNT(commission_pct) from employees; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128select e.last_name, CASE d.department_id WHEN 10 THEN e.salary * 1.1 when 20 then e.salary * 1.2 ELSE e.salary ENDfrom employees e join departments d on e.department_id = d.department_idwhere d.department_id in (10, 20, 30);/** --------------------------------------group---by----字段分组的使用------------------------------------------------- *//** 分组：对于 group by 分组的理解# 结论1：在select 后面声明的 字段，除了组函数之外的字段，一定要出现在 group by 后面;# 反之group by 后面声明的 字段，不一定要出现在 select 后面# 反正就是，只要出现了分组， 在select 后面声明的字段 ，在 group by 后面要全部都给写上，并且select 后面一定要有一个聚合函数，来计算组意图结果。# 结论2：group by 声明在from后面、where后面, order by 排序前面、limit 分页前面。 （可以理解，结果集群都都处理完毕，在进行排序，和分页）--------------------------------------------------select department_id,avg(salary)from employeesgroup by department_id,job_id;--------------------------------------------------select department_id,job_id ,avg(salary)from employeesgroup by department_id,job_id; */select * from employees;# 求所有员工的 工资平均值 AVG = SUM / COUNT(1)select SUM(salary) / count(1) from employees;# 求所有员工的 工资平均值select avg(salary)from employees;## 查询 每个部门 有多少人# 先找到employees表# 然后group by 按照department_id 部门分组，有null,10，20，30，40，50，60，70，80，90，100这12个部门,此时结果集已经形成12条数据，12个部门# 随后 count(1) 再次限定结果集，将每个部门多少人求出来select department_id ,count(1)from employeesgroup by department_id;# 每个部门中 的 平均工资是多少# 求每个部门的 平均工资select department_id ,avg(salary)from employeesgroup by department_id;# 先找到employees表# 然后group by 按照department_id 部门分组，在按照 工种job_id 进行 分组。# 比如90号部门的AD_PRES 在一行，90号部门的AD_VP工种 在一行，求平均工资值。select department_id,job_id ,avg(salary)from employeesgroup by department_id,job_id;#错误写法 这种错误就是 按照 department_id分组后的结果集，# 在select 后面的语句，并没有进行操作，只要显示last_name# 这里 按照 department_id分组后，展示字段last_name ，不可能的事情，是错误的写法select department_id ,last_namefrom employeesgroup by department_id;# 错误写法# 只按照 department_id 进行分组，不能查到job_id 字段select department_id,job_id,avg(salary)from employeesgroup by department_id;# 结论：在select 后面声明的 字段，除了组函数之外的字段，一定要出现在 group by 后面;# 反之group by 后面声明的 字段，不一定要出现在 select 后面/** # 结论3.只要看见sql语句中有group by 就要想，结果集是 进行分组的结果， select 后面的字段，就是分组的字段，聚合函数就是对这分组后的操作。 如果分组后的结果继续筛选，就要使用having 进行筛选， 后面跟的是聚合函数。 这里不能使用where ,where 可以直接使用表中的字段作为筛选条件,但不能使用分组中的 聚合函数 作为筛选条件; HAVING 必须要与 GROUP BY 配合使用,可以把分组计算的聚合函数和分组字段作为筛选条件。 */#按照部门分组，部门有 null,10,20,30,40,50,60,70,80,90,100,110select department_id from employeesgroup by department_id;#按照 部门和工资分组# 一个部门中有很多人工资不一样，一样的分为一组 如：90号部门工资有两种24000，17000select department_id ,salary from employeesgroup by department_id,salary;#求 每个部门中 工资最高是多少select department_id , max(salary) from employeesgroup by department_id;# 需求： 查询出 每个部门中最高工资 ，且最高工资超过10000的部门。select department_id, MAX(salary)from employeesGROUP BY department_idhaving MAX(salary)&gt;10000 ; # 对分组再进行筛选# 需求： 查询出 50，90，110 部门中，最高工资超过10000的部门是那几个。# 这里 where 后面的条件 是先筛选 符合条件的部门，提高了查询速度# having 后面的筛选条件，记住就跟聚合函数select department_id, MAX(salary)from employeeswhere department_id in(50,90,110)GROUP BY department_idhaving MAX(salary)&gt;10000 ; # 对分组再进行筛选# ----------------牢记sql语句的执行过程---------------------- © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"3.mysql第6章多表联合查询","slug":"mysql/3.mysql第6章多表联合查询","date":"2019-10-03T02:00:00.000Z","updated":"2024-10-15T15:07:20.009Z","comments":true,"path":"2019/10/03/mysql/3.mysql第6章多表联合查询/","link":"","permalink":"https://protonlml.github.io/2019/10/03/mysql/3.mysql%E7%AC%AC6%E7%AB%A0%E5%A4%9A%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"多表联合查询.md 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** 第六章：多表联查 在现实情况中，查询字段不在同一张表中，就需要多张表进行联合查询 多表联查，需要有 连接条件 注意：在多表联查的时候，多张表请务必取别名，使用别名，指定字段是哪个表中的，这样提高查询的速度 sql 的执行顺序是： 1.先执行from 挑出表 from 表1，表2.(挑出这两个表来) 2.执行where 筛选条件，以及后面的语句 where 筛选条件 order by limit 0,10; 3.最后挑选出需要的字段 select 指定字段 所以在from 后面给表起了别名，就会覆盖原表名，在后续的order by ...等等的语句中，必须使用表的别名来指定 */## 查询员工表select *from employees;## 查询部门表select *from departments;/** sql 99版本的写法 多表联查 两个 交表，又叫两个表联查 多表查询的分类 角度1： 等值连接 vs 非等值连接 角度2： 自连接 vs 非自连接 角度3： 内连接 VS 外连接 */## 将 员工表和部门表进行联合查询## 这种92写法 不用## 等值连接select *from employees e, departments dwhere e.department_id = d.department_id;## 非等值连接select *from employees e, job_grades jgwhere e.salary between jg.lowest_sal and jg.highest_sal; 自连接12345678910111213/** 自连接 VS 非自连接 表：表，自己连接自己 */# 自连接，练习：查询员工id 员工姓名 及其管理者id以及姓名# 思路：管理者也是员工，员工表自己连接自己，将一张表看作是 员工表，另一张表看作是 管理者表# 内连接：使用 join on (取两个表交集的结果，满足on 条件的所有结果)# 得到的结果是 满足on 后面的 条件的select e.employee_id, e.last_name, e.manager_id, gl.employee_id, gl.last_name, gl.manager_idfrom employees e join employees gl on e.employee_id = gl.manager_idorder by e.salary desc; 内连接 表1 join 表2 外连接 左外连接 left …join…on.. 右外连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** 内连接vs外连接 内连接：合并具有同一列的两个以上的表的行，结果集中 不包含一个表与另一个表不匹配的行 外连接：合并具有同一列的两个以上的表的行,结果集中除了包含一个表与另一个表匹配的行之外,还查询到了左表或右表中不匹配的行。 左外连接：查询的结果集中，包含左表的所有值(左表中不匹配的行,也会存在)，以及on后面条件，两个表之间匹配的行 右外连接：查询的结果集中，包含右表的所有值(右表中不匹配的行,也会存在)，以及on后面条件，两个表之间匹配的行 满外连接：左表，右表所有的匹配的行取出来，也包括有 左表不匹配的行，以及右表不匹配的行。 左外连接:两个表在连接过程中除了返回满足连接条件的行以外，还返回左表中不满足条件的行。 右外连接:两个表在连接过程中除了返回满足连接条件的行以外，还返回右表中不满足条件的行。 *//** 内连接 employees员工表107行数据。 departments是 部门表 # 下面语句结果集有106行，因为employees员工表中有一个人的 department_id为null 它没有部门，所以结果中没有它 # 其他所有人都有 department_id ，所有人都有部门。所以结果 106条（取两表匹配的行组成结果集，取交集） 练习：查询员工 last name 姓名 ,department_name部门姓名 信息（这里面是查询员工的，部门信息，有的员工没有存在任何一个部门那么结果就不返回，这里是内连接取交集） */select *from employees e join departments d on e.department_id = d.department_id;/** # 左外连接 employees员工表107行数据。 departments是 部门表 练习：查询所有的员工 last name 姓名 ,department_name部门姓名 信息 （这里面是查询所有员工的，部门信息，即使员工不存在部门，员工信息也要返回，所以是 左外连接 查询，查询结果是 所有员工匹配所有部门的行，以及包括不存在部门的员工信息行也在结果集中）# 结果是 左表所有值，以及 满足条件的交集值# 结果107行，虽然employees员工表中King的 department_id为null 它没有部门，但是这个left join 左表所有员工都展示出来，交表部分没有值就null 着# department_id# 178,Kimberely,Grant,KGRANT,011.44.1644.429263,1999-05-24,SA_REP,7000,0.15,149, null, null,null,null, */select *from employees e left join departments d on e.department_id = d.department_id;/** 满外连接 mysql 不支持满外连接 FULL JOIN ON 可以通过其他方式实现满外链接 一般在使用满外链接，使用到合并多个结果集的操作 使用 UNION 操作符 合并查询结果 UNION操作符返回两个查询的结果集的并集,去除重复记录.（多一步去重操作） 开发中一般使用 UNION ALL 进行 两个查询结果集求并集，不去重，效率高结论:如果明确知道合并数据后的结果数据不存在重复数据,或者不需要去除重复的数据，则尽量使用UMION ALL语句,以提高数据查询的效率 */ 注意点：在思考外连接还是内连接的时候，左外还是右外的时候，一定要先思考两个表之间的关系，是一对多，还是多对多，还是多对一二、七种JOIN的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 中图：内连接（只要两表之间的共同满足条件的部分）select e.employee_id,d.department_namefrom employees e join departments don e.department_id = d.department_id;# 左上图：左外连接select e.employee_id,d.department_namefrom employees e left join departments d on e.department_id = d.department_id;# 右上图：右外连接select e.employee_id,d.department_namefrom employees e right join departments d on d.department_id = e.department_id;# 左中图select e.employee_id,d.department_namefrom employees e left join departments don e.department_id=d.department_idwhere d.department_id is NULL;#右中图select e.employee_id,d.department_name fromemployees e right join departments don e.department_id = d.department_idwhere e.department_id is null;# 左下图：满外链接# 实现满外链接查询# 方法一： 使用 左上图和右中图，进行UNIN ALL 合并结果集，并给这两个图没有重复部分，所以可以使用UNIN ALL 不用去重操作，效率还快select e.employee_id,d.department_name fromemployees eleft join departments don e.department_id=d.department_id # (左外连接)UNION ALLselect e.employee_id,d.department_namefrom employees e right join departments d on d.department_id = e.department_idwhere e.department_id is null ;# 方法二：# 左中图和右上图 合并select e.last_name, e.manager_id, e.department_id, d.department_name, d.department_idfrom employees e left join departments d on e.employee_id = d.manager_id # 左外连接 去除结果中匹配的行，只剩下一个不匹配的where e.department_id is nullUNION ALL# 合并结果集select e.last_name, e.manager_id, e.department_id, d.department_name, d.department_idfrom employees e right join departments d on e.department_id = d.department_id;# 右外连接，得到满足条件的所有行，以及右表的所有数据# 上面两个结果及合并，正好是满外链接。上面两个结果集，不存在重复的数据，直接使用UNION ALL 就可以还提升效率# 右下图：满外链接，去除 满足条件的中间公共部分# 使用左中图和右中图进行合并 UNION ALLselect e.employee_id,d.department_name from employees eleft join departments don e.department_id=d.department_idwhere e.department_id is nullUNION ALLselect e.employee_id,d.department_name from employees eright join departments don d.department_id=e.department_idwhere e.department_id is null ; 注意:我们要 控制连接表的数量 。多表连接就相当于嵌套 for 循环一样,非常消耗资源,会让 SQL 查询性能下降得很严重,因此不要连接不必要的表。在许多 DBMS 中,也都会有最大连接表的限制。 【强制】超过三个表禁止 join。需要 join 的字段,数据类型保持绝对一致;多表关联查询时, 保证被关联的字段需要有索引。说明:即使双表 join 也要注意表索引、SQL 性能。来源:阿里巴巴《Java开发手册》 多表查询的理解12345678910111213141516171819# 8. 查询哪个城市没有部门desc locations;desc departments;select l.city,d.location_idfrom departments d right join locations l on d.location_id = l.location_idwhere d.location_id is null;# 从from 后面 开始读,departments 部门表和 locations 地址表 连接# (on 后面的条件 可先想两个表之间是 多对多 还是 1对多,如上 部门可以存在 多个 城市中,on后面是取部门在这个城市的行, 部门也可以不在这个城市 部门的locationid也可以是null 如果是left join 表示 部门不存在城市中的值也要 )# on 后面的意思是# 部门表中 有 location_id 地址id 的数据全部取出来.# 如果 部门表中的某一行中的 地址id 是null 这个部门没有对应的城市# 反之: join 表示 location 表中的 部门存在的数据 全部取出来# right join 表示地址表 location 表 的所有数据取出来,包括有城市,不存在部门,部门id为null的数据也取出来.# where d.location_id is null; 表示交表后结果集取出,部门是null的数据,就是城市没有部门的数据 多表查询练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** # 练习:# 1.显示所有员工的姓名,部门号和部门名称。# 2.查询90号部门员工的job_id和90号部门的location_id# 3.选择所有有奖金的员工的 last_name , department_name , location_id , city# 4.选择city在Toronto工作的员工的 last_name , job_id , department_id , department_name# 5.查询员工所在的部门名称、部门地址、姓名、工作、工资,其中员工所在部门的部门名称为’Executive’# 6.选择指定员工的姓名,员工号,以及他的管理者的姓名和员工号,结果类似于下面的格式# 7.查询哪些部门没有员工# 8. 查询哪个城市没有部门# 9. 查询部门名为 Sales 或 IT 的员工信息 */ # 1.显示所有员工的姓名,部门号和部门名称。# 注意这里是所有员工,就要求 员工表的所有数据都显示出来select * from employees;select * from departments;select e.last_name,e.department_id,d.department_namefrom employees e left join departments don e.department_id=d.department_id;# 工作职位等级,最低最高工资select * from job_grades;# 工作时间记录 入职时间,离职时间select * from job_history;# 工作表 工作名称 最高工资,最低工资select * from jobs;#实际住址表select * from locations;# 2.查询 90号部门 员工的job_id和90号部门的location_id# 思路 内连接 员工表和部门表,找到所有员工存在部门的数据集# 员工表中有 部门id, 部门表 departments 中 有 location_id 地址idselect e.job_id,d.location_idfrom departments d join employees eon d.department_id=e.department_idwhere d.department_id=90;# 3.查询所有 有奖金的员工的 last_name , department_name , location_id , city# 这里面 有个人,有奖金,但是没有部门,也要显示出来,对应也没有城市,也要显示出来# 所以都是左外连接select e.last_name,d.department_name,l.location_id,l.cityfrom employees eleft join departments don e.department_id=d.department_idleft join locations lon d.location_id=l.location_idwhere e.commission_pct is not null ;#4.选择city在Toronto 工作的员工的 last_name , job_id , department_id , department_nameselect e.last_name,e.job_id,e.department_id,d.department_namefrom employees e join departments don e.department_id=d.department_id join locations l on d.location_id = l.location_idwhere l.city=&#x27;Toronto&#x27;;# 总结: 写多表联查的时候,先看字段来自于哪些表,再看表与表之间用什么字段连接, 先直接写join on 连接,写完后再考虑是外连接还是内连接;# 5.查询员工所在的 部门名称、部门地址、姓名、工作、工资, 其中员工所在部门的部门名称为’Executive’select d.department_name,l.street_address,e.last_name,e.job_id,e.salaryfrom departments d join employees e on d.department_id = e.department_idjoin locations l on d.location_id = l.location_idwhere d.department_name=&#x27;Executive&#x27;;# 6.选择 指定员工 的姓名,员工号,以及他的管理者的姓名和员工号,结果类似于下面的格式# employees Emp # manager Mgr## kochhar 101 king 100select * from employees;# 员工表的自连接select Emp.last_name,Emp.employee_id,Mgr.last_name,Mgr.employee_idfrom employees Emp left join employees Mgron Emp.manager_id=Mgr.employee_id;# 7.查询哪些部门没有员工select * from employees e right join departments d on e.department_id = d.department_idwhere e.employee_id is null;# 8. 查询哪个城市没有部门desc locations;desc departments;select l.city,d.location_idfrom departments d right join locations l on d.location_id = l.location_idwhere d.location_id is null;# 从from 后面 开始读,departments 部门表和 locations 地址表 连接# (on 后面的条件 可先想两个表之间是 多对多 还是 1对多,如上 部门可以存在 多个 城市中,on后面是取部门在这个城市的行, 部门也可以不在这个城市 部门的locationid也可以是null 如果是left join 表示 部门不存在城市中的值也要 )# on 后面的意思是# 部门表中 有 location_id 地址id 的数据全部取出来.# 如果 部门表中的某一行中的 地址id 是null 这个部门没有对应的城市# 反之: join 表示 location 表中的 部门存在的数据 全部取出来# right join 表示地址表 location 表 的所有数据取出来,包括有城市,不存在部门,部门id为null的数据也取出来.# where d.location_id is null; 表示交表后结果集取出,部门是null的数据,就是城市没有部门的数据select * from locations;# 9. 查询 部门名为 Sales 或 IT 的 员工信息select e.last_name,d.department_namefrom employees e join departments d on e.department_id=d.department_idwhere d.department_name in (&#x27;Sales&#x27;,&#x27;IT&#x27;); 练习 二12345678910111213 #1.所有有门派的人员信息# ( A、B两表共有)select * from t_dept;# 门派表select * from t_emp;# 人员表select * fromt_dept d left join t_emp eon d.id=e.deptId;# on 后面 读作 门派中有 人 的数据 取出来.# 题目中要求所有门派,那么门派中也可能没有人,所以使用的是 left join 左外连接, 将所有门派给取出来.# 门派中有人,门派中没人都取出来 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"2.mysql第5章排序和分页","slug":"mysql/2.mysql第5章排序和分页","date":"2019-10-03T01:00:00.000Z","updated":"2024-10-08T15:27:18.886Z","comments":true,"path":"2019/10/03/mysql/2.mysql第5章排序和分页/","link":"","permalink":"https://protonlml.github.io/2019/10/03/mysql/2.mysql%E7%AC%AC5%E7%AB%A0%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/","excerpt":"","text":"排序和分页 123456789101112131415161718192021222324252627282930313233343536/** 第五章：排序 order by asc(升序默认) desc(降序) 与 分页 limit 偏移量，每页展示条数 pageNO 表示当前页码 limit (pageNO-1)*pageSize, pageSize; */## 排序 order by 和 limit 0,10 一般都是在sql语句最后，sql结果集，进行排序，排完序进行分页## 按照salary 降序排列select * from employeesorder by salary desc ;# 显示第1页，每页显示10条select * from employeeslimit 0,10;# 显示员工表 第32条第33条的信息select * from employeeslimit 31,2;# where ... order by ... limit# 使用顺序,limit 是最后的。# 下面的执行顺序是select employee_id,last_name,salaryfrom employeeswhere salary&gt;6000order by salary desclimit 10,10; 排序分页练习12345678910111213141516171819202122232425262728293031/** 练习 #1. 查询员工的姓名和部门号和年薪,按年薪降序,按姓名升序显示 #2. 选择工资不在 8000 到 17000 的员工的姓名和工资,按工资降序,显示第21到40位置的数据 #3. 查询邮箱中包含 e 的员工信息,并先按邮箱的字节数降序,再按部门号升序 */ #1. 查询员工的 姓名和 部门号和 年薪, 按年薪降序, 按姓名升序显示select last_name name ,department_id bm, salary*(1+IFNULL(commission_pct,0))*12 nxfrom employeesorder by nx desc,name asc;#2. 选择工资不在 8000 到 17000 的员工的姓名和工资,按工资降序,显示第21到40位置的数据select last_name,salary from employeeswhere salary not between 8000 and 17000order by salary desclimit 20 ,20;#3. 查询邮箱中包含 e 的员工信息,并先按邮箱的字节数降序,再按部门号升序select *from employeeswhere email like &#x27;%e%&#x27;order by length(email) desc, department_id asc; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"1.mysql1~4章学习","slug":"mysql/1.mysql1~4章学习","date":"2019-10-02T01:00:00.000Z","updated":"2024-10-20T15:25:23.256Z","comments":true,"path":"2019/10/02/mysql/1.mysql1~4章学习/","link":"","permalink":"https://protonlml.github.io/2019/10/02/mysql/1.mysql1~4%E7%AB%A0%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"MySQL 一、SQL 语句的注意事项 &#x2F;* SQL 语句的注意事项 MySQL 在 Windows 环境下是大小写不敏感的 MySQL 在 Linux 环境下是大小写敏感的 数据库名、表名、表的别名、变量名是严格区分大小写的 关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。 推荐采用统一的书写规范: 数据库名、表名、表别名、字段名、字段别名等都小写 SQL 关键字、函数名、绑定变量等都大写 一句写完使用 ; 结尾 关于标点符号 必须保证所有的()、单引号、双引号是成对结束的 必须使用英文状态下的半角输入方式 字符串型和日期时间类型的数据可以使用单引号(‘ ‘)表示 列的别名,尽量使用双引号(“ “),而且不建议省略as select id as “编号”, name as “姓名” from t_stu; #起别名时,as都可以省略 select id as 编号, name as 姓名 from t_stu; #如果字段别名中没有空格,那么可以省略”” select id as 编 号, name as 姓 名 from t_stu; #错误,如果字段别名中有空格,那么不能省略”” *&#x2F; 二、着重号’ ‘ 由于 order by 是排序关键字，而数据库中又有order表，此时若想查询此表 查询的时候要加入 ‘’ 单引号，来告诉Mysql这是一个表 select * from ‘order&#96;; 三、desc 表名（查看表结构） 查看表结构 desc 表名; DESC employees; 四、求最大值，最小值 求最大，最小值 least(字段1，字段2) greatest(字段1，字段2) 取字段的最大最小值 select least(salary,employee_id) from employees; 五、范围查找 范围查找 求区间的值 100 -10000 之间的 关键字：between 100 and 10000; 相当于 “&gt;&#x3D; 100 &amp;&amp; &lt;&#x3D;10000;” select * from employees where salary&gt;&#x3D;100 &amp;&amp; salary&lt;&#x3D;10000 ;select * from employees where salary between 100 and 10000;&amp;&amp; 相当于 andselect * from employees where salary &gt;&#x3D;1000 and salary&lt;&#x3D;10000; 六、 in (set) &#x2F; not in (set) 在 或 不在 in (set) &#x2F; not in (set) 在 或 不在 离散值的查找 某个值在不在这个集合中 练习1： 查找部门为 10，20，30的部门员工信息 select * from employees where department_id in (10,20,30);– where department_id&#x3D;10 or department_id&#x3D;20 or department_id&#x3D;30; 七、非符号类型的运算符 IS NULL ; IS NOT NULL ; ISNULL() 函数select * from employees where commission_pct is null ;select * from employees where ISNULL(commission_pct);select * from employees where commission_pct &lt;&#x3D;&gt; NULL; 八 、distinct 字段 去除重复的 字段。 在SELECT语句中使用关键字DISTINCT去除重复行&#x2F;SELECT DISTINCT department_id FROM employees;&#x2F; 针对于： SELECT DISTINCT department_id,salary FROM employees;这里有两点需要注意: DISTINCT 需要放到所有列名的前面,如果写成 SELECT salary, DISTINCT department_idFROM employees 会报错。 DISTINCT 其实是对后面所有列名的组合进行去重,你能看到最后的结果是 74 条,因为这 74 个部门id不同,都有 salary 这个属性值。如果你想要看都有哪些不同的部门(department_id),只需要写 DISTINCT department_id 即可,后面不需要再加其他的列名了。 九、 like 模糊查询 % 表示匹配 不确定个数的字符（0个，1个，或者多个） 练习: 查询last_name 中包含字符’a’ 的员工信息select * from employees where last_name like ‘%a%’; 十、 IFNULL(字段,0) 解释：字段为null 则以0参与运算 查询基本薪资不在9000-12000之间的员工编号和基本薪资SELECT employee_id,salary FROM employees WHERE NOT (salary &gt;&#x3D; 9000 AND salary &lt;&#x3D; 12000);查询员工一年的工资 （工资+奖金）*12 （有的员工的奖金是null 所以结果是 null ）正确写法： select last_name, first_name, salary,salary * (1 + IFNULL(commission_pct,0)) * 12 “一年工资 “from employees; 十、字段中求最大值，最小值 求最大，最小值 least(字段1，字段2) greatest(字段1，字段2) 最小值运算符 语法格式为:LEAST(值1,值2,…,值n)。其中,“值n”表示参数列表中有n个值。在有两个或多个参数的情况下,返回最小值。 SELECT LEAST (1,0,2), LEAST(‘b’,’a’,’c’), LEAST(1,NULL,2); 12345&gt;+---------------+--------------------+-----------------+&gt;| LEAST (1,0,2) | LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | LEAST(1,NULL,2) |&gt;+---------------+--------------------+-----------------+&gt;| 0 | a | NULL |&gt;+---------------+--------------------+-----------------+ 由结果可以看到,当参数是整数或者浮点数时,LEAST将返回其中最小的值;当参数为字符串时,返回字母表中顺序最靠前的字符;当比较值列表中有NULL时,不能判断大小,返回值为NULL。 最大值运算符 语法格式为:GREATEST(值1,值2,…,值n)。其中,n表示参数列表中有n个值。当有两个或多个参数时,返回值为最大值。假如任意一个自变量为NULL,则GREATEST()的返回值为NULL。 SELECT GREATEST(1,0,2), GREATEST(‘b’,’a’,’c’), GREATEST(1,NULL,2); 结果： 12345&gt;+-----------------+-----------------------+--------------------+&gt;| GREATEST(1,0,2) | GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | GREATEST(1,NULL,2) |&gt;+-----------------+-----------------------+--------------------+&gt;| 2 | c | NULL |&gt;+-----------------+-----------------------+--------------------+ 由结果可以看到,当参数中是整数或者浮点数时,GREATEST将返回其中最大的值;当参数为字符串时,返回字母表中顺序最靠后的字符;当比较值列表中有NULL时,不能判断大小,返回值为NULL。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311/** 1.查询语句 select * from 表名 */select 1+12 from dual; # dual 是一个伪表的概念;select * from employees;select employee_id,employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, manager_id, department_id from employees;/** 2.查询 字段 的别名(列的别名) (作用：查询出来的表字段和java对象中的属性值相对应) 字段名 as &quot;别名&quot; 简写: 字段名 别名 （别名中不能有空格） */## 取别名，给 每个字段 取别名desc employees;# 1直接在字段后面跟着 别名 2 使用 as 关键字来取别名 3 如果别名上面有空格，那么这个别名要使用&quot;&quot; 引起来select first_name 名字 , last_name 姓氏 , email as 邮箱 , phone_number &quot;手 机号&quot; from employees;/** 3. 查询结果 去重 distinct 字段 */select distinct department_id from employees;/** 4. 空值参与运算，null 只要字段是null值，那么结果一定是 null 实际开发中，某个字段值是null 我们想将其看作是 0 ,使用 IFNULL(字段,0); */ # 查询员工一年的工资 （工资+奖金）*12 （有的员工的奖金是null 所以结果是 null ）select last_name, first_name, salary * (1 + commission_pct) * 12 一年工资from employees;# 正确写法：select last_name, first_name, salary,salary * (1 + IFNULL(commission_pct,0)) * 12 一年工资from employees;/** 5. 查询常数 特殊场景需要： 查询时，某个字段在每一条记录中都存在，但是又没有表中的字段与之对应。 需要返回的结果集中，每一条记录都带有这个常数 */select &#x27;尚硅谷&#x27;, employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, manager_id, department_id from employees;/** 6. 过滤数据 where 声明在from 后面 select * from 表名 where 过滤条件 在MySql中 where 后面的 语句 是一个可以计算得出结果的，条件成立 返回1，条件不成立返回0 */select *from employeeswhere job_id = &#x27;SH_CLERK&#x27;;/** --select 查询的基本练习 1.查询员工12个月的工资总和，并起别名为 ANNUAL SALARY 2.查询employees表中去除重复的job id以后的数居 3.查询工资大于12000的 员工姓名和工资 4.查询员工号为176的员工的姓名和部门号 5.显示表departments的结构，并查而其中的全部数据 */ ## 1.查询员工12个月的工资总和，并起别名为 ANNUAL SALARY select salary*(1+IFNULL(commission_pct,0))*12 &quot;ANNUAL SALARY&quot; from employees;## 2.查询employees表中去除重复的job_id 以后的数据select distinct job_idfrom employees;## 3.查询工资大于12000的 员工姓名和工资select last_name,first_name,salary from employeeswhere salary &gt; 12000;## 4.查询员工号为176的员工的姓名和部门号select * from employeeswhere employee_id=176;## 5.显示表departments的结构，并查而其中的全部数据desc departments;select * from departments;/** select * from jobs;select * from job_grades;select * from job_history; */## -----------------------------------------------------------------------##/** 运算符 + - * / div(除) % mod(取模) */ ## 6. + - 运算符,浮点数参与运算，结果就是浮点型select 12+11, 22-0, 50+13.2 , 55-33.8 from dual;select 78+&#x27;12&#x27; from dual;## + 表示 加号，‘’单引号中的数字，隐式转换为数字1select 12+&#x27;e&#x27; from dual;## &#x27;e&#x27; 看作是0## 7. * /(div)SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2, 100 + 2 * 5 / 2, 100 / 3, 100 DIV 0FROM dual;## 练习：查询员工的ID 为偶数的员工信息select * from employeeswhere employee_id%2=0;/** 比较运算符 = &lt;=&gt; （安全等于，为null而生的） &lt;&gt; != (不等于) &lt; &lt;= &gt; &gt;=比较运算符，返回的是真或者假， 这里真是1 假是0 */ select 1=2,1!=2,2&lt;&gt;3 from dual;## 8.NULL 参与运算，结果还是NULL## where 后面跟的结果是 nullselect * from employeeswhere commission_pct=null;## 9.非符号类型的运算符## IS NULL ; IS NOT NULL ; ISNULL() 函数select * from employeeswhere commission_pct is null ;select * from employeeswhere ISNULL(commission_pct);select * from employeeswhere commission_pct &lt;=&gt; NULL;/** 查询工资不在100-10000 之间的员工信息 */select * from employeeswhere NOT salary between 100 and 10000;select * from employeeswhere salary &lt;100 || salary&gt;10000;## || 相当于 orselect * from employeeswhere salary &lt;100 or salary&gt;10000;## 练习2：查询员工工资不是 6000 7000 8000 的员工信息select * from employeeswhere salary not in(6000,7000,8000);/** like 模糊查询 % 表示匹配 不确定个数的字符（0个，1个，或者多个） */## 练习: 查询last_name 中包含字符&#x27;a&#x27; 的员工信息select * from employeeswhere last_name like &#x27;%a%&#x27;;## 练习: 查询last_name 中 第一个是字符&#x27;a&#x27; 的员工信息select * from employeeswhere last_name like &#x27;a%&#x27;;## 练习：查咨last_name 中 第二个是字符&#x27;a&#x27; 的员工信息## 这里 _ 表示任意字符占第一个位值，select * from employeeswhere last_name like &#x27;_a%&#x27;;## 练习：查询last_name 中包含a 又包含 e 的 员工信息select * from employeeswhere last_name like &#x27;%a%&#x27; and last_name like &#x27;%e%&#x27;;## 练习： 查询 第二个字符是_ 且 第三个字符是a 的员工信息## like &#x27;_/_a%&#x27;; 表示 第一个字符是任意字符占第一个位置，第二个字符是_ 这里使用 \\ 转义了就表示_ ， 第三个字符就是a ，后面%模糊匹配select * from employeeswhere last_name like &#x27;_\\_a%&#x27;;/** 正则表达式 ^s 表示以s开始 t$ 表示以t结尾 用到了查表 */ SELECT &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;;/** 逻辑运算符 and 与 or 或 not 非 XOR 异或（两边取不同，左真右假，左假右真，追求的就是这个异） */SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;## 在10和20部门员工，且工资小于8000的 员工信息## 不在10和20部门员工，且工资大于8000的员工信息select last_name,department_id,salaryfrom employeeswhere department_id in (10,20) XOR salary &gt; 8000;/** 记住 () 的优先级最高 以后要想先运算谁，就用() 给它包起来 */# 记住 least Greatest 只能用在 select 后面的 字段上面。# where 后面跟的条件，sql先执行where后面的条件，成立返回1，不成立返回0.# 这里面where 后面跟的 条件根本不能成立select * from employees where 0;/** 对字段进行限定的 关键词 distinct 字段 去除重复的 字段。 IFNULL(字段,0) 字段为null 则以0参与运算 求最大，最小值 least(字段1，字段2) greatest(字段1，字段2) *//** 练习 */# 1.选择工资不在5000到12000的员工的姓名和工资select last_name 姓名, salary 工资 from employeeswhere salary not between 5000 and 12000;# 2.选择在20或50号部门工作的员工姓名和部门号select * from employees emwhere em.department_id =20|| em.department_id=50;select * from employeeswhere department_id in(20,50);# 3.选择公司中没有管理者的员工姓名及job_idselect * from employeeswhere manager_id is null;# where manager_id &lt;=&gt; null;# 4.选择公司中有奖金的员工姓名,工资和奖金级别select * from employeeswhere commission_pct is not null;# 5.选择员工姓名的第三个字母是a的员工姓名select * from employeeswhere last_name like &#x27;__a%&#x27;;# 6.选择姓名中有字母a和k的员工姓名select * from employeeswhere last_name like &#x27;%a%&#x27;and last_name like &#x27;%k%&#x27;;# 7.显示出表 employees 表中 first_name 以 &#x27;e&#x27;结尾的员工信息## 正则表达式select * from employeeswhere first_name regexp &#x27;e$&#x27;;select * from employeeswhere first_name like &#x27;%e&#x27;;# 8.显示出表 employees 部门编号在 80-100 之间的姓名、工种select * from employeeswhere department_id between 80 and 100;# 9.显示出表 employees 的 manager_id 是 100,101,110 的员工姓名、工资、管理者idselect * from employeeswhere manager_id in(100,101,110); © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"javaScript","slug":"java基础/javascript","date":"2019-10-01T04:00:00.000Z","updated":"2024-06-16T02:11:23.105Z","comments":true,"path":"2019/10/01/java基础/javascript/","link":"","permalink":"https://protonlml.github.io/2019/10/01/java%E5%9F%BA%E7%A1%80/javascript/","excerpt":"","text":"javaScript 静态网页资源的三剑客：HTML（文本），CSS（样式），JavaScript（行为）。把后面两个效果，加在HTML文本上，就会呈现出很好看的网页界面。 程序设计有两种架构：1 c&#x2F;s架构，是客户端和服务器端，要开发两个程序。2 b&#x2F;s架构，是浏览器和服务端。只用浏览器来申请服务器端的资源，再展示出来就好了。只用开发服务器端一个软件。 javaWeb开发，是B&#x2F;S架构的。 事件：事件是什么意思？通俗的理解，HTML中的元素组件，被某个动作（事件的属性），触动后，会发生一定的变化。（执行了另一个js代码）。 将HTML，CSS，JavaScript分别独立出来，可以降低耦合度， javaScript最初被设计用于浏览器中，他和java语言没有关系，他是客户端脚本语言 javaScript语言运行出错，要在浏览器控制台上面查看。F12打开控制台。 - 一、javaScript 注意：在一个html的页面中，可以定义多个script的标签，而且存放的位置是任意的，但是会影响运行的先后顺序，一般都是等html页面元素全部加载完毕，再运行js代码，并且是一种等待状态。当在html中的某个位置，触发了某个事件，此时对应的js等待代码，就会执行。从而产生行为效果 1.javascript与HTML的关联方式： 内部关联 外部关联 2.javascript的数据类型 原始数据类型： 1. number：数字 。 整数/小数/ NAN （not a number 一个不是数字的数字类型） 2. string ：字符串。字符串 &quot;abc&quot; &quot;a&quot; &#39;abc&#39; 3. boolean：true 和 false 4. null：一个对象为空的占位符 5. undefined：未定义，如果一个变量没有给他初始化值，则会被默认赋值为undefined 注意：NaN是number类型，他是（不是数字的数字）。在js当中，运算符，后面的运算数，不是运算符要求的类型，js就会自动的将运算数进行类型转换。比如：numb&#x3D; +”abc”;此时：number根据”+”运算符，如果是数字，就会直接转换成数字，但是转换符后面跟的不是数字类型，则会转换成不是数字的数字类型。值为NaN. 3.JavaScript的变量 什么是变量：变量就是内存空间中的一小片区域。有类型，有名称，有值。比如：int a&#x3D;3; JavaScript的变量是弱类型的，什么叫弱类型，就是不管定义什么类型的变量，都用var开头。 而java中定义整型用int，定义字符型用char 。所以java是强类型的。 ☆ 通过typeof(变量名)可以得到变量的类型 注释:你也许会问,为什么typeof运算符对于nul值会返回”object”.这实际上是javaScript最初实现中的个错误,然后被ECMAScript沿用了,现在,null被认为是 对象的占位符,从而解释了这一矛盾,但从技求上来说,它仍是原始值。 4.javascript中的运算符 ①一元运算符：就是只有一个运运算数的运算符。 ++ 、–、+（正号）、-（负号） “++（–）”在前，先自增（自减），再运算。 “++（–）”在后，先运算，再自增（自减）。 +（-）（正负号） ②算数运算符：“+”，“-”，“* ”，“&#x2F;” ，“%”（和java中使用方法相同） ③赋值运算符：“+&#x3D;”，“-&#x3D;”“&#x3D;”（和java中使用方法相同） ④ 比较运算符：“&gt;”，“&lt;”，“&gt;&#x3D;”，“&lt;&#x3D;”，“&#x3D;&#x3D;”， “&#x3D; &#x3D;&#x3D;（全等于）” “&#x3D; &#x3D;”是比较两个数是否相等，“&#x3D;&#x3D;&#x3D;全等于”是加上了类型的比较。 ⑤ 逻辑运算符：“&amp;&amp;”，“||”，“！” ⑥ 三元运算符“ ？：表达式” 二、javascript 中的特殊语法.(了解一下就好，但是要和java规范一样写代码，不要省“；”，也不要省“var”，带var的变量，是局部变量，不带var的变量是全局变量 。) 三、流程控制语句 练习 ：javascript（9x9乘法表） 四、BOM对象： 概念：Browser object Model 浏览器对象模型。将浏览器各个组成部分封装为对象。 BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。① window窗口对象。 window窗口的第一类方法：弹窗有关的方法 window窗口的第二类方法：打开关闭窗口的方法。 window窗口的第三类方法：与定时器有关的方法 Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（.html文件对象）。直接写就可以用 ②、 Location地址栏对象 Location 对象的方法。reload().用来刷新当前页面。 属性：href Location地址栏对象，他的一个属性href。有两个作用，设置当前页面的URL和获取当前页面的完整的URL.（这里面的设置和获取URL都是针对当前页面的。设置的话，就是重新赋值，设置为新的地址，这样当前页面就会跳转到设置的地址页面中去） 倒计时跳转网页案例 ③、 history当前页面历史记录对象。 属性：length：history.length；返回的是。历史记录的个数。 方法：back();加载history列表中的上一个URL。绑定单击事件，就可以做一个后退的按钮。 方法： forword(); 加载history列表中的下一个URL。绑定单击事件，就可以做一个前进的按钮。 方法：go(); 加载history列表中的某一个具体页面。 五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML DOM对象。） ☆ DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。 ☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。 DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析） DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。 ①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element(其他标签对象)对象。或者是创建Element (其他标签对象)对象。 document.write(““) 向页面上写出一条横线（就是往页面写出信息的） 1.1 document对象：获取element对象的方法。 getElementById（） ：根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName （） ：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName （）：根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName（）：根据name属性值获取元素对象们。返回值是一个数组 1.2 document对象：创建其他DOM对象： createElement（“标签名”）：创建元素节点（记住） createAttribute（name）：创建拥有指定名称的属性节点，并返回新的Attr对象。（了解） createComment（）：创建注释节点。（了解） createTextNode（）：创建文本节点。（了解） ②：Element对象（元素标签对象） 1，获取&#x2F;创建：通过document来获取和创建 2.方法： removeAttribute（“”） ：删除属性 setAttribute（“属性名”，“属性值”） ：设置属性值。 补充：input框框，有个value属性，用其节点对象.value可以得到，文本框里面的内容。 ③：Node对象 （是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。 appendchild（节点对象名） ：向节点的子节点列表的结尾添加新的子节点。（增） removechild（节点对象名） ：删除（并返回）当前节点的指定子节点。（删） replacechild（节点对象名） ：用新节点替换一个子节点。（改，不常用）。 属性：父节点&#x3D;当前节点.parentNode; 返回当前节点的父节点。 六、☆javascript 中的几个对象的学习。 1.☆ function函数方法对象、Array数组对象。 function对象，在javascript 中，定义方法，是用function对象，来定义方法的。 语法：function 方法名（参数列表）{方法体} &#x2F;&#x2F; javascript中定义方法，的写法和java类似。 但是是用的function对象定义的方法 &#x2F;&#x2F; js中用function定义的方法，参数列表不用写类型，返回值不用写类型 &#x2F;&#x2F; js中用function定义的方法，如果有多个同名的方法，那么后面的同名方法，会覆盖前面的同名方法， &#x2F;&#x2F; js中用function定义的方法，在调用方法时，只要方法名确定就会调用最后面的同名不同参数的方法。他和参数列表无关。 &#x2F;* js中用function定义的方法，参数列表的括号里面隐藏了一个内置对象，是一个arguments的数组。 所以当参数列表中不写形式参数时，function add(){ 方法体} 括号里面就是一个可变形参 每一个传递过来的实参，都存在arguments[0].arguments[1]……..等数组中。 *&#x2F; 2.☆ Array数组对象 3.☆ Date日期对象 4.☆Math数学对象 5.☆ regExp：正则表达式对象。 先了解什么是正则表达式 正则表达式就是定义字符串的组成规则（通用的规则，在Java中或者其他语言中都可以使用）。在表单的输入框的地方，实现校验输入的字符串是不是符合正则表达式的规则。不符合校验失败，阻止表单的提交。 ☆ Javascript对表单的校验，是依赖于正则表达式的。 正则表达式对象。regExp 6.☆全局对象 在javascript中，有一个全局对象Global，他不用创建对象，直接用其内部的方法，就可以实现对应的功能，一般有字符串的URL编解码方法。 七、 事件绑定的方式 得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。 八、HTML DOM：是关于如何获取、修改、添加或删除HTML元素的标准 ☆①所有的节点对象都有的关键的属性innerHTML innerHTML。是获取节点对象，里面的所有内容。就是获取了，一对“&lt;&gt;标签体&lt;&#x2F;&gt;”中的标签体的内容。标签体可以是一段文字，也可以是其他标签。 通过给innerHTML赋值或者追加值，可以改表标签体的内容。如下图 上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。 ☆②所有的节点对象都有的关键的属性style。 1.给style属性赋值，就可以改变其样式。 注意：两个单词的写法 2. 改变节点对象的class值。用className属性。 3.要想设置和修改，节点的属性值。查Api文档。例如： 标签图片标签，每出现一次，一个 Image 对象就会被创建。找image对象的属性，src设置或返回图像的 URL 九、事件 事件分类 1.点击事件 onclick：单机事件 ondblclick ：双击事件 2.焦点事件 onblur：失去焦点 一般用于表单验证,当光标不在输入框时，就会失去焦点，触发onblur事件发生。 onfocus：元素获得焦点 3.加载事件 onload：一张页面或者一幅图像完成加载 内部加载方式：script标签如果写在head标签里面，在上面的话，要使用窗口的事件机制，加载事件来控制，js 代码，在HTML页面加载完全，才运行。 如下图 4.鼠标事件 onmousedown ：标按钮披按下. 定义方法时,定义一个形参,接受 event 对象. eventi对象的button属性可以获取鼠标按钮键被点击了. onmouseup ：鼠标按键被松开. onmousemove ：鼠标被移动. onmouseover：鼠标移到某元素之上. onmouseout：鼠标从某元素移开. 5.键盘事件 onkeydown： 某个键盘按键被按下. onkeyup ：某个键盘按键被松开. onkeypress： 某个键盘按键被按下并松开. 6.选择和改变事件 onchange：域的内容被改变. ☆ 当在选择的下拉列表上，选择某个选项会触发该事件。 onselect：文本被选中. 7.表单事件: onsubmit：确认按钮被点击. 可以阻止表单的提交 方法返回falsel则表单被阻止提交. 写法： onreset：重置按钮被点击. 练习：动态表格案例 ☆动态表格案例总结：用DOM对象在内存层面你，不管创建了多少子节点或者父节点，这些结构都是在内存层面上的，在浏览器页面上不能够直接显示，要想显示，必须有html的已有标签对象。先获取已有的html标签对象节点，将内存层面上的节点，appendChild为已有节点的子节点。同时，属性的样式会关联到css样式表中，只要和css表中的选择器对应的上，就可以显示样式。 ☆ 技巧：怎样获取当前标签的对象，直接在html标签后面，加上事件属性。绑定事件方式一，事件调用指定方法，括号里面写this。 那么就可以在方法声明的地方，形式参数就是当前对象。如下图： 总结1： 怎么来理解BOM对象和DOM对象以及HTML DOM对象？ 1 . BOM对象，就是将浏览器各个组成部分，封装为对象。有显示器对象、浏览器对象、windows窗口对象、URL地址栏对象、以及历史记录对象，这5个BOM对象。windows窗口对象，是BOM对象中的主要对象，因为其他对象都在一个窗口当中。可以通过windows对象来获取，其他4个BOM对象。 2 .在windows窗口获取的document对象，是DOM对象。 document对象是DOM对象的主要对象。DOM对象也在窗口内，但是只有document对象（.html文件对象）是通过窗口获取，其他DOM对象是通过document对象获取的。 3 .document对象，他是将整个文档封装成一个document对象。对应着HTML里面最外层标签。他可以获取其他节点对象 document.getElementById()；。或者对象们；另外也可以创建其他DOM对象。 4.有了一些基础的DOM对象，也就是有了某个标签的（节点）的对象之后。然后用HTML DOM来、对这个对象进行获取、修改、添加或删除操作。 5.从上往下看，一层一层的，从窗口(window)——&gt;文本对象(document)——&gt;单个文本元素对象(element)——&gt;单个文本元素操作（HTML DOM）这样方便记忆。也便于理解。 节点：在HTML中所有的单个元件，就是单个节点。对应着一对，一对的标签。 子节点：外标签包着内标签，也就是节点包着子节点。例如：文字 超链接。 Node 节点对象：他可以认为是虚有的，它里面的方法用来“CRUDdom树” 其实就是所有的DOM对象，都是一个节点，DOM对象本身，就可以增加节点，删除节点，替换节点，查询节点。 有了DOM这些对象，用他们的功能。就可以用javaScript语言对HTML的标签进行操作。 要记住：虽然能用，JavaScript语言来操作，内存层面的HTML的元素对象代码，使其在浏览器上面显示样式。但是他和HTML里面的标签没有，任何关系。 执行了“JavaScript语言操作的元件对象，比如添加节点，删除节点”不会再HTML文档中自动生成，HTML代码。 理解、标签、标签体、标签属性、控制元素的样式。 1.1标签: 标签就是一对对的&lt;&gt;&lt;&#x2F;&gt;。例如：&lt;img&gt; &lt;/img&gt; 1.2标签体:一对标签里面的内容。例如：&lt;img&gt;这是标签体，可以是子标签也可以是文字 &lt;/img&gt; 1.3 标签属性: 定义在标签&lt;&gt;里面的。例如：&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt; 1.4 标签控制样式: 总结2： 一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求 &lt;script&gt;js代码&lt;/script&gt;，标签一般都写在&lt;body&gt;......&lt;script&gt;&lt;/body&gt;body标签的最下面。 js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://protonlml.github.io/tags/javaScript/"}],"author":"𝚲𝚳𝚲"},{"title":"0.Docker中安装mysql8.0.22","slug":"mysql/0.Docker中安装mysql8.0.22","date":"2019-09-30T17:00:00.000Z","updated":"2024-07-22T16:09:20.799Z","comments":true,"path":"2019/10/01/mysql/0.Docker中安装mysql8.0.22/","link":"","permalink":"https://protonlml.github.io/2019/10/01/mysql/0.Docker%E4%B8%AD%E5%AE%89%E8%A3%85mysql8.0.22/","excerpt":"","text":"Docker中安装mysql8.0.22 一、下载安装 第一步：在hub.docker.com上搜索mysql镜像 第二步：拉取指定版本的mysql 也可以指定拉取版本 1sudo docker pull mysql:8.0.22 第三步：检查mysql镜像 1sudo docker images 第四步：启动运行mysql镜像 (docker run 用于启动一个容器) 1234567docker run -p 3310:3306 --name mysql8 \\-v /usr/local/docker/mysql8/mysql-files:/var/lib/mysql-files \\-v /usr/local/docker/mysql8/conf:/etc/mysql/conf.d \\-v /usr/local/docker/mysql8/logs:/var/log/mysql \\-v /usr/local/docker/mysql8/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=PCfan0906. \\-d mysql:8.0.22 第四步解释 将端口号映射为3310 容器名字为 mysql8 -v 表示挂载的卷，conf,logs,data都挂在到主机中 修改登陆密码：PCfan0906.（默认是root 最好是修改个密码，要不然后面使用Navacat连接会有问题） -d 启动mysql:8.0.22 假如安装过程中失败了，则可通过docker ps -a 查看以前的容器，假如已存在，则通过docker rm 镜像id 删除再重新安装即可。 第五步：停止mysql8服务（可选） 执行完第四个步骤（启动运行mysql镜像），mysql就会自动启动了，假如需要停止这个 服务可以执行： 1docker stop mysql8 第六步：启动mysql服务 假如mysql8服务没有启动运行，但是mysql8容器是存在的，可以通过如下方式启动mysql8。 1docker start mysql8 假如希望查看mysql8启动时的日志，可以执行 docker container logs mysql8 这个指令 第七步：查看docker启动的服务 1docker ps 第八步：进入容器 (退出容器用exit) 1sudo docker exec -it mysql8 bash 第九步：登陆(默认密码root)，一定要先进入mysql容器。 1mysql -uroot -pPCfan0906. 第十步：设置mysql开机自启动（可选） 1docker update mysql8 --restart=always 如何重启mysql服务？ 1docker restart mysql8 查看MySQL安装到哪了? 1whereis mysql8 二、连接MySQL时要注意 第一步：关闭linux宿主机的防火墙 (假如直击连接),命令忘了可以通过搜索引擎查。 1sudo systemctl stop firewalld.service 第二步：重启docker 1sudo systemctl restart docker 第三步：启动mysql 1docker start mysql8 三、Navacat连接MySQL连接mysql如果遇到以下问题可以这样解决 问题描述： 11251-client does not support authentication protocol requesred by server;consider upgrading MySQL Client 解决办法： （1）mysql容器内部 1sudo docker exec -it mysql8 bash （2）进入mysql 1mysql -uroot -pPCfan0906. 输入密码 PCfan0906. （3）查看用户信息 1select host,user,plugin,authentication_string from mysql.user; 备注：host为 % 表示不限制ip localhost表示本机使用 plugin非mysql_native_password 则需要修改密码 （5）修改用户密码 1ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;; （6）更新user为root，host为% 的密码为123456 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;; 更新user为root，host为localhost 的密码为123456 7）再次连接即可成功 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"对Mysql中的sql语句的理解","slug":"mysql/对Mysql中的sql语句的理解","date":"2019-09-30T16:00:00.000Z","updated":"2025-01-24T16:00:34.682Z","comments":true,"path":"2019/10/01/mysql/对Mysql中的sql语句的理解/","link":"","permalink":"https://protonlml.github.io/2019/10/01/mysql/%E5%AF%B9Mysql%E4%B8%AD%E7%9A%84sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"对Mysql中的sql语句的理解 理解SQL语句的执行顺序 1.理解sql的执行顺序，对理解整个sql语句想要表达的什么内容，尤为重要。 上图 ④和⑤颠倒一下顺序 123# where或者on 后面的过滤条件,可以读作,得到 满足 条件所存在的行.如下# on 后面可以读作, e员工表中有 部门的行,取出来. 通用句式 表中 有 xxx 的值取出来 。 一般使用，左外连接 left join on 左边是 1 右边是 多 1234567891011121314151617181920# 在join 交表的时候，要思考。 一对多的关系# 一般使用 左外连接 left join 左边是1右边是多# 如下：部门表 left join 员工表# 一个部门 对应 多个员工# 查询的结果，是left join ,左表部门表所有数据,以及满足条件的右表 员工表在所有部门 的 成员# 所有部门，有的部门可能没有员工，那么 员工列就为null# 查询 没有员工的 部门select d.department_name,e.employee_idfrom departments d left join employees e on d.department_id = e.department_id # 员工在当前这个部门中的 所有员工记录 where e.department_id is null ;#看到on 后面这个条件 就想， 结果大概是什么样子， 1对多的关系# 因为是1对多，1个部门 有多个员工， 那么结果集数据表中， 右边多个员工列 可能在同一个部门中，所以左边部门列 字段会有重复# 又因为left join 左外连接 左表部门表中，是所有部门列都查出来了，可能有的部门没有员工，那么右边员工列 字段会有null 你需要记住 SELECT 查询时的两个顺序:1. 关键字的顺序是不能颠倒的:SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...2.SELECT 语句的执行顺序(在 MySQL 和 Oracle 中,SELECT 执行顺序基本相同):FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT3.比如你写了一个 SQL 语句,那么它的关键字顺序和执行顺序是下面这样的:1234567SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5FROM player JOIN team ON player.team_id = team.team_id # 顺序 1WHERE height &gt; 1.80 # 顺序 2GROUP BY player.team_id # 顺序 3HAVING num &gt; 2 # 顺序 4ORDER BY num DESC # 顺序 6LIMIT 2 # 顺序 7 在 SELECT 语句执行这些步骤的时候,每个步骤都会产生一个 虚拟表 ,然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是,这些步骤隐含在 SQL 的执行过程中,对于我们来说是不可见的。 同时因为 SQL 是一门类似英语的结构化查询语言,所以我们在写 SELECT 语句的时候,还要注意相应的关键字顺序,所谓底层运行的原理,就是我们刚才讲到的执行顺序。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"}],"tags":[{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"}],"author":"𝚲𝚳𝚲"},{"title":"59.动态代理","slug":"java基础/59.动态代理","date":"2019-09-30T15:38:00.000Z","updated":"2025-01-07T15:58:19.661Z","comments":true,"path":"2019/09/30/java基础/59.动态代理/","link":"","permalink":"https://protonlml.github.io/2019/09/30/java%E5%9F%BA%E7%A1%80/59.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"动态代理 一、动态代理; 为什么要有动态代理对象？ 因为在已有的项目的老代码中，我们不可能去修改，某个对象中的方法。修改了之后可能会导致整体项目崩溃。 那么我们在新业务中又想用这个已有老对象中的老方法，但是这个方法，它功能太落后了。我想给它添加一些其他功能，而且又不能修改原有代码。 解决办法; 非侵入式增加功能。 1.我们可以将这个对象中要用到，需要增强功能的多个方法，给抽象到一个接口当中。然后将这个对象所在类实现这个接口。 2.然后生成一个代理对象，这个代理对象也要实现这个接口，重写接口中的方法，这样这个代理对象就有了需要用到的所有方法。并且可以在其中添加增强功能的代码，然后真正的核心代码还是调用老对象中的老方法来实现。代理对象中，只做了增强功能的代码，核心还是原来老对象的方法。 注意：代理对象在java中是有固定对象的，newProxyInstance(); 所以我们要创建一个生成动态代理对象的工具类，在这个工具类中定义生成某个对象的代理对象方法。 动态代理的写法","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"58.反射","slug":"java基础/58.反射","date":"2019-09-29T14:38:00.000Z","updated":"2024-07-20T14:58:43.828Z","comments":true,"path":"2019/09/29/java基础/58.反射/","link":"","permalink":"https://protonlml.github.io/2019/09/29/java%E5%9F%BA%E7%A1%80/58.%E5%8F%8D%E5%B0%84/","excerpt":"","text":"反射 一、反射 二、获取class对象的三种方式123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atlml.reflex;import java.lang.reflect.InvocationTargetException;/** * 获取反射的 class对象的三种方式 */public class ReflexDemo &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; /** * 获取class字节码对象的三种方式 * * 1.Class.forName(全限定类名); * 2.类名.class * 3.对象.getclass */ //1.Class.forName(); // 最为常用 Class clazz = Class.forName(&quot;com.atlml.reflex.Student&quot;); System.out.println(clazz); //2.类名.class //当作参数传递 /* synchronized (Student.class)&#123; &#125; */ Class&lt;Student&gt; studentClass = Student.class; System.out.println(studentClass); //3. 对象.getClass //有局限性，当只有 对象 才能使用 Student student = new Student(); Class&lt;? extends Student&gt; aClass = student.getClass(); System.out.println(aClass); //class com.atlml.reflex.Student //class com.atlml.reflex.Student //class com.atlml.reflex.Student &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.atlml.reflex;import java.io.IOException;public class Student extends Teacher &#123; //年级 这个成员变量是 公共的 public String grade; //性别 公共的 public String gender; private Integer age; private String name; public Student() &#123; &#125; public Student(Integer age) &#123; this.age = age; &#125; public Student(String name) &#123; this.name = name; &#125; /** * 私有的全参构造器 * * @param age * @param name */ Student(Integer age, String name) &#123; this.age = age; this.name = name; &#125; /** * 公有的静态方法， */ public static void lookbook(String book) &#123; System.out.println(&quot;公有的静态方法，学生看&quot; + book + &quot;书&quot;); &#125; /** * 私有的静态方法 */ private static void shopping() &#123; System.out.println(&quot;私有的静态方法，学生购物&quot;); &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; /** * 学生学习方法 */ public void study() &#123; System.out.println(&quot;这是公有的方法，学生学习&quot;); &#125; /** * 私有的 吃饭方法 */ private String eat(String fan, Integer price) throws IOException, NullPointerException, RuntimeException &#123; return &quot;这是私有的方法，学生吃&quot; + fan + &quot;饭,花了&quot; + price + &quot;元&quot;; &#125;&#125; 三、利用反射获取构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.atlml.reflex;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;import java.util.Arrays;import java.util.List;/** * 利用反射获取构造方法 */public class ReflexDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //通过反射 获取Student 的字节码class对象 Class clazz = Class.forName(&quot;com.atlml.reflex.Student&quot;); //获取 student类中的 构造器 try &#123; Constructor[] declaredConstructors = clazz.getDeclaredConstructors(); //1.获取所有公有的构造器方法 Constructor[] constructors1 = clazz.getConstructors(); System.out.println(Arrays.asList(constructors1)); //[public com.atlml.reflex.Student(), public com.atlml.reflex.Student(java.lang.Integer), public com.atlml.reflex.Student(java.lang.String)] // 2.获取所有构造器，包括私有的 List&lt;Constructor&gt; constructors = Arrays.asList(declaredConstructors); System.out.println(constructors); //[public com.atlml.reflex.Student(), private com.atlml.reflex.Student(java.lang.Integer,java.lang.String), public com.atlml.reflex.Student(java.lang.String), public com.atlml.reflex.Student(java.lang.Integer)] /* 使用Declared 表示当前构造方法是私有的也可以被获取 直接使用 getConstructor() 获取单个构造器，只能是公共的 如果获取的不是公共的，或报错 */ //3.获取单个构造器(空参的) Constructor constructor = clazz.getDeclaredConstructor(); System.out.println(constructor); //public com.atlml.reflex.Student() //4.获取单个构造器，一个参数的 // 参数是 构造器参数是 ，参数类型的字节码 Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class); System.out.println(declaredConstructor); //public com.atlml.reflex.Student(java.lang.String) //5.获取单个构造器，一个参数的 // 参数是 构造器参数是 ，参数类型的字节码 Constructor declaredConstructor1 = clazz.getDeclaredConstructor(Integer.class); System.out.println(declaredConstructor1); //public com.atlml.reflex.Student(java.lang.Integer) //6.获取单个构造器，一个参数的 // 参数是 构造器参数是 ，参数类型的字节码 Constructor declaredConstructor2 = clazz.getDeclaredConstructor(Integer.class, String.class); System.out.println(declaredConstructor2); //private com.atlml.reflex.Student(java.lang.Integer,java.lang.String) /** * 构造方法获取到了，就能获取 构造方法上的所有内容 * 1.权限修饰符 * 2.获取所有形参 * 3.能创建这个类的对象 */ // 7.通过反射来获取 构造方法中的所有内容 //7.获取权限修饰符 int modifiers = declaredConstructor2.getModifiers(); System.out.println(modifiers);//2 // private-&gt; 2 ，public-&gt;1 //8. 获取当前构造函数的所有参数 Parameter[] parameters = declaredConstructor2.getParameters(); System.out.println(Arrays.toString(parameters)); //[java.lang.Integer arg0, java.lang.String arg1] //9. 通过构造方法，创建对象 // 注意：这个方法是private私有的 //临时取消权限的校验,没有下面这句话会报错（暴力反射） declaredConstructor2.setAccessible(true); Student student = (Student) declaredConstructor2.newInstance(23,&quot;张三&quot;); System.out.println(student); //Student&#123;age=23, name=&#x27;张三&#x27;&#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 五、利用反射获取成员变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.atlml.reflex;import java.lang.reflect.Field;import java.util.Arrays;/** * 利用反射获取成员变量 */public class ReflexDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; try &#123; // 获取 反射 字节码文件 Class clazz = Class.forName(&quot;com.atlml.reflex.Student&quot;); //1.返回所有 公共的 成员变量 Field[] fields = clazz.getFields(); System.out.println(Arrays.toString(fields)); //[public java.lang.String com.atlml.reflex.Student.grade, public java.lang.String com.atlml.reflex.Student.gender] // 2.返回所有成员变量对象的数组(公有，私有) Field[] declaredFields = clazz.getDeclaredFields(); System.out.println(Arrays.toString(declaredFields)); //[public java.lang.String com.atlml.reflex.Student.grade, public java.lang.String com.atlml.reflex.Student.gender, private java.lang.Integer com.atlml.reflex.Student.age, private java.lang.String com.atlml.reflex.Student.name] //3.返回单个公共成员变量对象 Field field = clazz.getField(&quot;gender&quot;); System.out.println(field); //public java.lang.String com.atlml.reflex.Student.gender //4.返回单个成员变量对象 Field name = clazz.getDeclaredField(&quot;name&quot;); //5.获取成员变量 修饰符 int modifiers = name.getModifiers(); // 6.获取成员变量 名 String n = name.getName(); // 7.获取成员变量 数据类型 Class&lt;?&gt; type = name.getType(); System.out.println(type);//String System.out.println(n);//name System.out.println(modifiers);// 2 System.out.println(name);//private java.lang.String com.atlml.reflex.Student.name //8.获取成员变量 记录的值 Student s = new Student(12, &quot;张三&quot;); name.setAccessible(true);//临时获取权限 //9.获取 s 这个对象，name记录的值 Object value = name.get(s); System.out.println(value);//张三 //9.修改name成员变量，对象里面记录的值 name.set(s, &quot;王一平&quot;); System.out.println(s); //Student&#123;age=12, name=&#x27;王一平&#x27;&#125; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 六、利用反射获取成员方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atlml.reflex;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Parameter;import java.util.Arrays;/** * 利用反射 获取 成员方法 */public class ReflexDemo3 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Class clazz = Class.forName(&quot;com.atlml.reflex.Student&quot;); //1.返回所有 公共成员方法 的数组，包括继承的 Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; System.out.println(method); &#125; System.out.println(&quot;----------------------------------------------&quot;); //2.返回所有 成员方法 的数组，不包括继承的 Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) &#123; System.out.println(declaredMethod); &#125; System.out.println(&quot;----------------------------------------------&quot;); //3.返回单个公共成员方法对象(这个方法必须是公有的) // 参数一：方法的名字， // 参数二、方法的形参类型，可以是多个（为了方法的重载） Method lookbook = clazz.getMethod(&quot;lookbook&quot;, String.class); System.out.println(lookbook); //public static void com.atlml.reflex.Student.lookbook(java.lang.String) // 运行当前的方法 Student student = new Student(); //参数1：是哪个学生对象，调用方法的形参是什么 Object a = lookbook.invoke(student, &quot;鲁宾孙漂流记&quot;); System.out.println(a);//没有返回值 null System.out.println(&quot;----------------------------------------------&quot;); //4.返回单个成员方法对象(私有的，公有的都能获取) // 参数一：方法的名字， // 参数二、方法的形参类型，可以是多个（为了方法的重载） //eat 是私有的 Method eat = clazz.getDeclaredMethod(&quot;eat&quot;,String.class,Integer.class); System.out.println(eat); //4.1获取当前方法的权限修饰 int modifiers = eat.getModifiers(); System.out.println(modifiers); //2 私有的 //4.2 获取方法名 String name = eat.getName(); System.out.println(name); //eat //4.3 获取方法的形参,这里两个参数 Parameter[] parameters = eat.getParameters(); System.out.println(Arrays.toString(parameters)); // [java.lang.String arg0, java.lang.Integer arg1] //4.4 获取方法的抛出的异常 Class&lt;?&gt;[] exceptionTypes = eat.getExceptionTypes(); for (Class&lt;?&gt; exceptionType : exceptionTypes) &#123; System.out.println(exceptionType); &#125; //class java.io.IOException //class java.lang.NullPointerException //class java.lang.RuntimeException //4.5 运行当前方法 Student student1 = new Student(&quot;小明&quot;); eat.setAccessible(true);//临时获取访问权限（eat是私有的方法） String result = (String) eat.invoke(student1, &quot;鱼香肉丝&quot;,18); System.out.println(result);//这是私有的方法，学生吃鱼香肉丝饭,花了18元 &#125;&#125; 七、反射的作用获取一个类里面所有的信息，获取到了之后，再执行其他的业务逻辑结合配置文件，动态的创建对象并调用方法练习1：对于任意一个对象，都可以把对象所有的字段名和值，保存到文件中去12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atlml.reflex;import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Field;/** * 练习1 * 对于任意一个对象，都可以 * 把对象所有的字段名和值， * 保存到文件中去 */public class Practice1 &#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, IOException &#123; Student student = new Student(&quot;小A&quot;, 23, &#x27;女&#x27;, 167.5, &quot;睡觉&quot;); Teacher teacher = new Teacher(&quot;波妞&quot;, 10000); // 思路// 利用反射，来获取某个对象中的私有成员变量 信息 saveToFile(student); saveToFile(teacher); &#125; /** * 将 对象 中的信息 保存到本地文件中 */ public static void saveToFile(Object o) throws NoSuchMethodException, IllegalAccessException, IOException &#123; Class&lt;?&gt; aClass = o.getClass(); /* //获取构造方法数组 Constructor[] declaredConstructors = aClass.getDeclaredConstructors(); for (Constructor declaredConstructor : declaredConstructors) &#123; System.out.println(declaredConstructor); &#125;*/ //写到本地文件中 BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(new File(&quot;javabasis\\\\aaa\\\\ObjectMemberVariable.txt&quot;), true));//追加 //获取所有的 成员变量（公有，私有都存在） Field[] declaredFields = aClass.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; //临时取消私有权限 declaredField.setAccessible(true); String name = declaredField.getName(); //name Object value = declaredField.get(o);//value //成员变量值，每个值都拿出来 System.out.println(name + &quot;=&quot; + value.toString()); bufferedWriter.write(name + &quot;=&quot; + value.toString()); bufferedWriter.newLine();//换一行 &#125; bufferedWriter.close(); &#125;&#125; 练习2：反射可以跟配置文件结合的方式，动态的创建对象，并调用方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atlml.reflex;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;/** * * 练习二 * 反射可以跟配置文件结合的方式，动态的创建对象，并调用方法 */public class Practice2 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; //1.将配置文件加载到内存中 // Properties 的父类是一个map集合 Properties properties = new Properties(); properties.load(new FileInputStream(new File(&quot;javabasis\\\\src\\\\main\\\\resources\\\\properties.properties&quot;))); System.out.println(properties);//&#123;classname=com.atlml.reflex.Student, method=study&#125; //2.输出配置文件中的内容 //3.根据配置文件中的全限定类名，反射创建对象，调用方法 Class clazz = Class.forName(properties.getProperty(&quot;classname&quot;)); //获取构造函数 Constructor declaredConstructor = clazz.getDeclaredConstructor(); declaredConstructor.setAccessible(true);//创建对象 Student student = (Student) declaredConstructor.newInstance(); System.out.println(student); //获取成员方法,并调用。从配置文件中拿到方法名 Method study = clazz.getDeclaredMethod(properties.getProperty(&quot;method&quot;)); Object invoke = study.invoke(student);//这是公有的方法，学生正在学习 &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"57.多线程","slug":"java基础/57.多线程","date":"2019-09-28T01:38:00.000Z","updated":"2024-07-20T14:58:48.429Z","comments":true,"path":"2019/09/28/java基础/57.多线程/","link":"","permalink":"https://protonlml.github.io/2019/09/28/java%E5%9F%BA%E7%A1%80/57.%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"多线程 一、多线程 多线程： 一个软件运行了，就相当于一个“进程”，然后软件中，有很多独立的功能，多个功能就是多个线程。 比如：腾讯电脑管家运行了，他是一个进程，里面的“病毒查杀”“垃圾清理”“电脑加速”等功能分别是多个线程，他们可以同时在这个“电脑管家”进程中，同步进行。并列执行。这就是多线程 （比如：手机启动游戏的时候，有线程是加载本地文件，有的线程是加载背景音乐，有的线程是加载动态背景图，多个线程并行运行） 开发中，需要用到多线程的时候，当前模块项目就是一个进程，里面有很多独立的业务流程，他们是可以并行执行的。不一定都是单线程的，执行了这个功能，需要等待执行完才能执行下一个功能。这样是很慢的。所以需要多线程。当业务代码中需要多线程的时候，我们用代码手动创建另一个或者多个线程，将不同的业务代码流程，分别写在多个线程内部。当执行这个软件的时候，执行到此部分多线程业务时，会自动的开多线程并行执行多个业务功能，同时产生结果，最终返回给主线程。、项目主业务流程都是在，main中开始的线程，就是主线程。当需要执行其他的业务流程时，需要从main其中开启其他线程的。（比如：手机启动游戏的时候，有线程是加载本地文件，有的线程是加载背景音乐，有的线程是加载动态背景图，多个线程并行运行）&#x2F;&#x2F;一般java中有线程池，我们使用线程池来拿线程就行了，然后进行使用。目的是：线程也是资源，每次都要创建需要耗费时间，如果某个线程一直不释放，就会占用很长时间的资源内存。所以我们写代码时，不要自己创建，java已经给创建好了，我们只需要从线程池中拿线程对象来开启新线程。并且java也会自动管理这个线程。&#x2F;&#x2F; CPU 执行多个线程，单核cpu就是，执行1线程，然后又去执行2线程，执行3线程，多个线程交替执行，由于cpu速度非常快，感觉几个线程是，同时并行执行的，其实不是。CPU多核多线程，如4核8线程，指的是CPU能够同时一下8个线程同时并行执行，每个线程都是独立的，速度更快。如果此时开启了16个线程，那么它也是8个线程，和另8个线程交替执行。 并发：在同一时刻，多个指令在单个CPU上交替执行。并行：在同一时刻。有多个指令在多个CPU上同时执行。二、多线程三种实现方式 第一种 第二种 第三种 三、Thread中常见的成员方法 线程的优先级 设置线程 的优先级，线程默认的优先级是5，主线程main线程默认的也是5，如果设置的优先级越高，线程抢到Cpu的概率就越高 守护线程 线程设置为守护线程（备胎线程），当其他的非守护线程执行完毕，守护线程会陆续结束。 例如：线程1是正常线程，线程2是守护线程，（线程1，线程2并行，同时抢占CPU线程）如果线程1中的要执行的业务结束了，那么线程2也会慢慢的结束掉自己的线程。线程2不是立马结束的。 应用场景 qq聊天，同时传输完毕，聊天是线程1，传输文件是线程2，聊天窗口结束了，传输文件也没必要存在了，会陆续结束 出让线程 出让当前线程的执行权，当前线程抢到了cpu资源，执行完线程中的代码，最下面可以出让当前cpu资源，这样就尽可能的保证每个线程都运行均匀的，每个线程执行是平均的（了解） 插入线程 将其他线程，插入到当前线程。（了解） 四、线程的生命周期 五、线程安全问题： 1.出现线程安全的例子 比如，卖100张票，创建了3个线程假设为3个窗口，3个线程中执行的业务代码是一样的，3个线程都要对这同100张票进行售卖。 这里100张票，属于3个线程的共享数据，共享数据只能有一份。某个线程对这个共享数据进行修改了，都会影响到其他线程中使用这个数据。 这里static 修饰的ticket变量作为“电影票变量” 在 线程任务对象中，只有一份，不管创建几个同种任务对象，都共享这个变量的值ticket,因为其是static的，属于类，类加载就加载了在方法区，只有一份。以后每次new的任务对象都在堆中，所以可以共享。（静态变量可以作数据共享，如所有学生对象，有同一个静态变量老师） 但是，在每个线程中，操作共享数据的代码，每个线程是抢夺cpu调度的，也就是说，线程1在操作这个共享ticket数据时，刚改完，线程2可能就抢到了cpu调度，线程2又把这个共享ticket数据给改了，那就会导致最终的共享数据是错误的。 2.解决办法 就是，将线程中，操作共享数据的这部分代码，给锁起来。如：线程1抢到了cpu调度时，执行操作共享数据这部分代码时，给包裹起来，此时只有线程1能执行它线程中这部分代码。其他线程都得等线程1执行完共享数据的操作，开锁了。其他线程才可以抢cpu调度 {执行操作共享数据的代码}。 这样就保证了，多线程共享数据的安全性，只有当某个线程全部操作完共享数据的代码，就是改完了确定改好了，才让其他线程去改。 这个锁就是同步代码块，让同步代码块里面的代码是线程轮流执行的 3.同步代码块 示例 4.同步方法 我们想要把一个方法中所有的代码都锁起来，直接在方法上加关键字synchronized 字符串拼接的时候StringBuffer 是线程安全的 StringBuffer 是线程安全的，它的所有方法，都是synchronized修饰的，同步方法，所以它线程安全（一个线程执行当前方法，其他任何线程只能等着我当前线程执行完毕，才释放）这种运行慢 StringBuilder 是线程不安全的 六、Lock锁 七、死锁是一个错误 以后在写锁得时候，千万千万不能让几个锁嵌套在一起了，之所以出现死锁是因为将，锁嵌套的写了。 八、等待唤醒机制（生产者，消费者) 8.1.（使用阻塞队列）实现消息唤醒 连接生产者与消费者之间的管道 厨师往队列中放一个，吃货从队列中吃一个 九、线程的6种状态 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"56.zip文件的导入导出","slug":"java基础/56.zip文件的导入导出","date":"2019-09-26T03:40:00.000Z","updated":"2024-07-20T14:53:41.462Z","comments":true,"path":"2019/09/26/java基础/56.zip文件的导入导出/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/56.zip%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"zip文件的导入导出 一、 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"55.压缩、解压缩流","slug":"java基础/55.压缩，解压缩流","date":"2019-09-26T02:40:00.000Z","updated":"2024-07-21T16:01:09.472Z","comments":true,"path":"2019/09/26/java基础/55.压缩，解压缩流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/55.%E5%8E%8B%E7%BC%A9%EF%BC%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%B5%81/","excerpt":"","text":"压缩、解压缩流 一、体系 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"54.字节打印流&字符打印流","slug":"java基础/54.字节打印流&字符打印流","date":"2019-09-26T01:50:00.000Z","updated":"2024-07-21T15:59:59.222Z","comments":true,"path":"2019/09/26/java基础/54.字节打印流&字符打印流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/54.%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81&%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81/","excerpt":"","text":"字节打印流&字符打印流 一、打印流不能读，只能写，他只有输出流 一、字节打印流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.atlml.io_stream.myprintstream;import java.io.FileNotFoundException;import java.io.PrintStream;import java.util.Date;public class PrintStreamDemo2 &#123; public static void main(String[] args) throws FileNotFoundException &#123; PrintStream ps = new PrintStream(&quot;a.txt&quot;); //% n表示换行 ps.printf(&quot;我叫%s %n&quot;, &quot;阿玮&quot;); ps.printf(&quot;%s喜欢%s %n&quot;, &quot;阿珍&quot;, &quot;阿强&quot;); ps.printf(&quot;字母H的大写：%c %n&quot;, &#x27;H&#x27;); ps.printf(&quot;8&gt;3的结果是：%b %n&quot;, 8 &gt; 3); ps.printf(&quot;100的一半是：%d %n&quot;, 100 / 2); ps.printf(&quot;100的16进制数是：%x %n&quot;, 100); ps.printf(&quot;100的8进制数是：%o %n&quot;, 100); ps.printf(&quot;50元的书打8.5折扣是：%f元%n&quot;, 50 * 0.85); ps.printf(&quot;计算的结果转16进制：%a %n&quot;, 50 * 0.85); ps.printf(&quot;计算的结果转科学计数法表示：%e %n&quot;, 50 * 0.85); ps.printf(&quot;计算的结果转成指数和浮点数，结果的长度较短的是：%g %n&quot;, 50 * 0.85); ps.printf(&quot;带有百分号的符号表示法，以百分之85为例：%d%% %n&quot;, 85); ps.println(&quot;---------------------&quot;); double num1 = 1.0; ps.printf(&quot;num: %.4g %n&quot;, num1); ps.printf(&quot;num: %.5g %n&quot;, num1); ps.printf(&quot;num: %.6g %n&quot;, num1); float num2 = 1.0F; ps.printf(&quot;num: %.4f %n&quot;, num2); ps.printf(&quot;num: %.5f %n&quot;, num2); ps.printf(&quot;num: %.6f %n&quot;, num2); ps.println(&quot;---------------------&quot;); ps.printf(&quot;数字前面带有0的表示方式：%03d %n&quot;, 7); ps.printf(&quot;数字前面带有0的表示方式：%04d %n&quot;, 7); ps.printf(&quot;数字前面带有空格的表示方式：% 8d %n&quot;, 7); ps.printf(&quot;整数分组的效果是：%,d %n&quot;, 9989997); ps.println(&quot;---------------------&quot;); //最终结果是10位，小数点后面是5位，不够在前面补空格，补满10位 //如果实际数字小数点后面过长，但是只规定两位，会四舍五入 //如果整数部分过长，超出规定的总长度，会以实际为准 ps.printf(&quot;一本书的价格是：%2.5f元%n&quot;, 49.8); ps.printf(&quot;%(f%n&quot;, -76.04); //%f，默认小数点后面7位， //&lt;，表示采取跟前面一样的内容 ps.printf(&quot;%f和%3.2f %n&quot;, 86.04, 1.789651); ps.printf(&quot;%f和%&lt;3.2f %n&quot;, 86.04, 1.789651); ps.println(&quot;---------------------&quot;); Date date = new Date(); // %t 表示时间，但是不能单独出现，要指定时间的格式 // %tc 周二 12月 06 22:08:40 CST 2022 // %tD 斜线隔开 // %tF 冒号隔开（12小时制） // %tr 冒号隔开（24小时制） // %tT 冒号隔开（24小时制，带时分秒） ps.printf(&quot;全部日期和时间信息：%tc %n&quot;, date); ps.printf(&quot;月/日/年格式：%tD %n&quot;, date); ps.printf(&quot;年-月-日格式：%tF %n&quot;, date); ps.printf(&quot;HH:MM:SS PM格式(12时制)：%tr %n&quot;, date); ps.printf(&quot;HH:MM格式(24时制)：%tR %n&quot;, date); ps.printf(&quot;HH:MM:SS格式(24时制)：%tT %n&quot;, date); System.out.println(&quot;---------------------&quot;); ps.printf(&quot;星期的简称：%ta %n&quot;, date); ps.printf(&quot;星期的全称：%tA %n&quot;, date); ps.printf(&quot;英文月份简称：%tb %n&quot;, date); ps.printf(&quot;英文月份全称：%tB %n&quot;, date); ps.printf(&quot;年的前两位数字(不足两位前面补0)：%tC %n&quot;, date); ps.printf(&quot;年的后两位数字(不足两位前面补0)：%ty %n&quot;, date); ps.printf(&quot;一年中的第几天：%tj %n&quot;, date); ps.printf(&quot;两位数字的月份(不足两位前面补0)：%tm %n&quot;, date); ps.printf(&quot;两位数字的日(不足两位前面补0)：%td %n&quot;, date); ps.printf(&quot;月份的日(前面不补0)：%te %n&quot;, date); System.out.println(&quot;---------------------&quot;); ps.printf(&quot;两位数字24时制的小时(不足2位前面补0):%tH %n&quot;, date); ps.printf(&quot;两位数字12时制的小时(不足2位前面补0):%tI %n&quot;, date); ps.printf(&quot;两位数字24时制的小时(前面不补0):%tk %n&quot;, date); ps.printf(&quot;两位数字12时制的小时(前面不补0):%tl %n&quot;, date); ps.printf(&quot;两位数字的分钟(不足2位前面补0):%tM %n&quot;, date); ps.printf(&quot;两位数字的秒(不足2位前面补0):%tS %n&quot;, date); ps.printf(&quot;三位数字的毫秒(不足3位前面补0):%tL %n&quot;, date); ps.printf(&quot;九位数字的毫秒数(不足9位前面补0):%tN %n&quot;, date); ps.printf(&quot;小写字母的上午或下午标记(英)：%tp %n&quot;, date); ps.printf(&quot;小写字母的上午或下午标记(中)：%tp %n&quot;, date); ps.printf(&quot;相对于GMT的偏移量:%tz %n&quot;, date); ps.printf(&quot;时区缩写字符串:%tZ%n&quot;, date); ps.printf(&quot;1970-1-1 00:00:00 到现在所经过的秒数：%ts %n&quot;, date); ps.printf(&quot;1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ %n&quot;, date); ps.close(); &#125;&#125; 二、字符打印流 字符打印流，它是带有缓冲区的，打印效率更高一点 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"53.序列化流反序列化流","slug":"java基础/53.序列化流反序列化流","date":"2019-09-26T01:40:00.000Z","updated":"2024-07-21T14:25:50.380Z","comments":true,"path":"2019/09/26/java基础/53.序列化流反序列化流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/53.%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/","excerpt":"","text":"序列化流反序列化流 序列化流（对象操作输出流） 一、可以把java中的对象写到本地文件中 写到本地文件中的对象信息，我们是看不懂的，需要进行反序列化，读取到内存中，即可成为对象 二、为什么不直接将对象属性值，给保存到本地文件中呢，非得使用序列化给序列到本地文件中，还是看不懂的？ 比如游戏中的关键信息，不使用序列化的话，在本地直接明文展示，那就会被修改了，游戏中的属性也就被修改了 三、序列化流的细节 使用对象输出流将对象保存到文件时会出现NotSerializableException异常 解决方案：需要让javabean类实现Serializable接口,同时自动生成版本号UID 反序列化流一、本地文件中的序列化对象，反序列化到内存 细节： 一个对象实现了Serializable接口，说明这个类的对象可以被序列化的 java底层会根据这个类的成员变量，静态变量，构造方法，成员方法，简单的说就是根据这个类中的所有内容计算出一个long类型的序列号。这个序列号，就是这个类的版本号。 在将对象序列化，以及反序列化的时候，使用的UID是唯一的 练习 将多个对象序列化到本地，再反序列化到内存 使用ArrayList集合来装多个对象，然后再进行序列化和反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.atlml.Serialized_stream;import java.io.Serial;import java.io.Serializable;/** * 小狗类 */public class Dog implements Serializable &#123; @Serial private static final long serialVersionUID = 5061231638733610552L; private Integer age; private String name; public Dog() &#123; &#125; public Dog(Integer age, String name) &#123; this.age = age; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.atlml.Serialized_stream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.util.ArrayList;/** * 将多个自定义对象序列化到文件中，但是由于对象的个数不确定，反序列化流该如何读取呢？ */public class SerializedStream2 &#123; public static void main(String[] args) throws IOException &#123; /** * 如果在代码中，一次需要将多个对象序列化到本地文件中， * 我们一般会采用，将多个对象放在集合当中 * 我们将这个集合给序列化到本地文件中 * 取得时候，也是直接取一个集合。 * 然后再遍历 */ Dog bozai = new Dog(5, &quot;波仔&quot;); Dog keji = new Dog(3, &quot;柯基&quot;); Dog tudou = new Dog(1, &quot;土豆&quot;); ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); dogs.add(bozai); dogs.add(keji); dogs.add(tudou); //序列化流，将多个对象 序列化到 本地文件中去 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;javabasis\\\\aaa\\\\myio\\\\a.txt&quot;)); objectOutputStream.writeObject(dogs);//序列化集合 objectOutputStream.close(); &#125; &#125; 123456789101112131415161718192021222324252627282930package com.atlml.Serialized_stream;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.util.ArrayList;/** * 反序列化， * 将保存在本地的 对象。 反序列化到程序中 * 这里是将 ArrayList 集合反序列化到内存中 * List集合中，存放了多个对象 */public class SerializedStream3 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //反序列化一个集合 ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;javabasis\\\\aaa\\\\myio\\\\a.txt&quot;)); ArrayList doglist = (ArrayList) objectInputStream.readObject(); doglist.forEach(d-&gt; System.out.println(d)); //Dog&#123;age=5, name=&#x27;波仔&#x27;&#125; //Dog&#123;age=3, name=&#x27;柯基&#x27;&#125; //Dog&#123;age=1, name=&#x27;土豆&#x27;&#125; &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"52.IO流-转换流","slug":"java基础/52.IO流-转换流","date":"2019-09-26T01:38:00.000Z","updated":"2024-07-22T13:22:44.712Z","comments":true,"path":"2019/09/26/java基础/52.IO流-转换流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/52.IO%E6%B5%81-%E8%BD%AC%E6%8D%A2%E6%B5%81/","excerpt":"","text":"IO流-转换流 一、转换流 转换流：是字节流，与字符流之间的桥梁 练习 转换文件编码 需求1：手动创建一个GBK的文件，把文件中的中文读取到内存中，不能出现乱码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atlml.io_stream;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.nio.charset.Charset;/** * 输入 转换流 */public class InputStreamReadDemo extends ConversionFlowTest &#123; public static void main(String[] args) throws IOException &#123; /** * 需求1：手动创建一个GBK的文件，把文件中的中文读取到内存中，不能出现乱码 * 了解 一下， 这种方式在JDK11时 被淘汰了 * */ // gbkcsb.txt 文件在本地就是GBK编码 /* InputStreamReader gbk = new InputStreamReader(new FileInputStream(&quot;javabasis/aaa/gbkcsb.txt&quot;),&quot;GBK&quot;); int len; char[] chars = new char[8192]; while ((len=gbk.read(chars))!=-1)&#123; for (char aChar : chars) &#123; System.out.print(aChar); &#125; &#125; gbk.close(); */ /** * 替代方案 * 直接使用 FileReader 来指定 编码读取文本 */ FileReader fr = new FileReader(&quot;javabasis/aaa/gbkcsb.txt&quot;, Charset.forName(&quot;GBK&quot;)); BufferedReader bfr = new BufferedReader(fr); String line; while ((line = bfr.readLine()) != null) &#123; System.out.println(line); &#125; bfr.close(); &#125;&#125; 需求2：把一段中文按照GBK的方式写到本地文件1234567891011121314151617181920212223242526package com.atlml.io_stream;import java.io.BufferedWriter;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;/** * 输出 转换流 */public class OutPutStreamWriteDemo extends ConversionFlowTest &#123; public static void main(String[] args) throws IOException &#123; /** * 需求2：把一段中文按照GBK的方式写到本地文件 * 这里是追加到 gbkcsb.txt文本文件后面 */ OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;javabasis/aaa/gbkcsb.txt&quot;, true), &quot;GBK&quot;); BufferedWriter bufferedWriter = new BufferedWriter(osw);//使用字符缓冲流包一下 bufferedWriter.newLine();//可以使用 换行 bufferedWriter.write(&quot;出师表，诸葛亮，躬耕南阳，采菊东篱&quot;); bufferedWriter.close(); osw.close(); &#125;&#125; 需求3：将本地文件中的GBK文件，转成UTF-8123456789101112131415161718192021222324252627282930313233343536373839404142package com.atlml.io_stream;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.nio.charset.Charset;public class EncodingConversion extends ConversionFlowTest &#123; public static void main(String[] args) throws IOException &#123; /** * 需求3：将本地文件中的GBK文件，转成UTF-8 */ // 1.JDK11之前的写法 /*BufferedReader bfr = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;javabasis/aaa/gbkcsb.txt&quot;), &quot;GBK&quot;)); BufferedWriter bfw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;javabasis/aaa/utf-8csb.txt&quot;), &quot;UTF-8&quot;)); String line; while ((line=bfr.readLine())!=null)&#123; bfw.newLine(); bfw.write(line); &#125; bfw.close(); bfr.close(); */ // JDK11之后的写法 BufferedReader bfr = new BufferedReader(new FileReader(&quot;javabasis/aaa/gbkcsb.txt&quot;, Charset.forName(&quot;GBK&quot;))); BufferedWriter bfw = new BufferedWriter(new FileWriter(&quot;javabasis/aaa/utf-8csb.txt&quot;, Charset.forName(&quot;UTF-8&quot;))); String line; while ((line = bfr.readLine()) != null) &#123; bfw.write(line); bfw.newLine(); &#125; bfw.close(); bfr.close(); &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"51.IO流-字节缓冲流与字符缓冲流","slug":"java基础/51.IO流-字节缓冲流与字符缓冲流","date":"2019-09-26T01:35:00.000Z","updated":"2024-07-08T17:33:11.722Z","comments":true,"path":"2019/09/26/java基础/51.IO流-字节缓冲流与字符缓冲流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/51.IO%E6%B5%81-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81/","excerpt":"","text":"IO流-字节缓冲流与字符缓冲流 一、字节缓冲流与字符缓冲流体系 1.为什么使用缓冲流 缓冲流底层自带了一个数组8192个字节，一次能读8192个字节。到缓冲区 所以，为了提高读取和写出的效率，使用缓冲流 2.怎么使用 直接包在字节流，或者字符流的外面就行了 虽然“字符流”已经有了缓冲区，包与不包读取写出区别不大，但是它中有特有方法，可以对纯文本文件更好的操作，所以说也有包的必要 二、字节缓冲流提高效率的原理 三、实操 四、字符缓冲流 特殊方法的使用 readLine()方法的细节 readLine方法在读取的时候，一次读一整行，遇到回车换行结束 但是他不会把回车换行读到内存当中 总结 练习1234567891011121314151617181920212223242526272829303132333435363738394041package com.atlml.io_stream;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Map;import java.util.Set;import java.util.TreeMap;public class Test01 &#123; public static void main(String[] args) throws IOException &#123; /** * 将出师表csb.txt文章中的顺序恢复 */ BufferedReader br = new BufferedReader(new FileReader(&quot;javabasis/aaa/csb.txt&quot;)); TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;(); //使用treeMap 排序 String line; while ((line=br.readLine())!=null)&#123; String[] strs = line.split(&quot;\\\\.&quot;); //读取一行，进行排序 map.put(Integer.parseInt(strs[0]),strs[1]); &#125; System.out.println(map); br.close(); //写出到本地文件中 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;javabasis/aaa/result.txt&quot;)); Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;Integer, String&gt; entry : entries) &#123; bw.write(entry.getValue()); bw.newLine(); &#125; bw.close(); &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"50.IO（字节流&字符流）","slug":"java基础/50.IO（字节流&字符流）","date":"2019-09-26T01:31:00.000Z","updated":"2024-07-08T17:28:30.086Z","comments":true,"path":"2019/09/26/java基础/50.IO（字节流&字符流）/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/50.IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81&%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/","excerpt":"","text":"IO（字节流&字符流） 一、什么是IO流？ 存储和读取数据的解决方案 只要项目中，需要对本地文件进行读取和写入操作，肯定是需要用到IO流处理 二、IO流体系 IO流的使用原则 随用随创建 什么时候不用，什么时候关闭 切记，不要上来就把所有的流都创建在代码的最上面。 1.字节流 1. 字节输出流 FileOutputStream 操作本地文件的字节输出流，可以把程序中的数据写到本地文件中。 续写： 2. 字节输入流 FileInputStream 操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来。 这里面要记住，循环读取的套路书写方法 一次读一个字节，效率太慢了，一次读多个字节？ 注意：一次读一个字节数组的数据，每次读取会尽可能把数组装满。 (循环读，就能读取本地文件中的所有内容) 练习 拷贝文件 拷贝大文件 注意： 字节流读取文件的时候，文件中不要有中文 使用字节流读取纯文本文件时，内容中有 “汉字” 读取到系统内存之后，会有乱码。 因为：字节流 FileinputStream的read方法，读取文件时，是一个字节一个字节读取的，而一个汉字，在计算机中占用3个字节，Unicode组织制定的（GBK是2个字节），有可能读取的时候，字节没有读取完整。 但是拷贝纯文本文件没有问题，因为是全部字节循环读取，最终都会被读取完毕，再写到目标文件中也是完整的。 字节流：一次只能读取一个字节 在计算机中，一个字母正好是一个字节（不管是ASCII 还是Unicode字符集） 但是在Unicode字符集中，规定一个汉字占用了3个字节。（Unicode组织制定的，全世界通用） 在GBK字符集中，一个汉字占用了两个字节（我国自己指定的） 所以使用字节流来读取文本文件(内部是汉字)会出现乱码，因为一次只读取了一个字节。 在系统中使用的Unicode字符集，是通用的，需要使用UTF-8来编解码。 2. 字符流 字符流，最适合操作纯文本文件，遇到中文也不会出现乱码 2.1 字符输入流FileReader 就是从本地文件中，读取内容 字符输入流，就是从本地文件中读取文本内容到系统中。 原理是，在创建字符输入流的时候，它会在底层创建一个字节数组长度为8192，read一次就会尽可能的将这个字节数组给填满。（他就是缓冲区）。下一次读，就会直接在缓冲区中读，缓冲区中读取完了，再将本地文本再次加载到缓冲区。（提高读取文件的效率） 字节输入流，没有这个缓冲区 2.2 字符输出流 FileWriter 就是将程序中的数据，写出到本地文件中。（write的两种方式） 字符流的底层原理（有缓冲区） 字符输入流的底层原理 字符输出流的底层原理 使用场景 练习拷贝文件夹中的所有文件（包括子文件夹） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.atlml.io_stream;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * 练习一： * &lt;p&gt; * 拷贝： * 拷贝一个文件夹，考虑子文件夹 */public class Practice1 &#123; public static void main(String[] args) throws IOException &#123; /** * 将一个文件夹中的所有 内容拷贝 * */ //源文件路径 File src = new File(&quot;javabasis\\\\aaa&quot;); // 目标文件路径 File to = new File(&quot;javabasis\\\\copy_directorys&quot;); //拷贝就想 使用 字节流 来操作 long l = System.currentTimeMillis(); copyDirectorys(src, to); long l1 = System.currentTimeMillis(); System.out.println(&quot;拷贝完成用时&quot; + (l1 - l) + &quot;豪秒&quot;); &#125; /** * @param src 文件夹源路径 * @param to 目标路径 * @return 是否成功 */ private static void copyDirectorys(File src, File to) throws IOException &#123; //由于目的地文件夹如果不存在，会报错。所以先创建。即使目的文件夹有，也没关系不报错 to.mkdir(); // src 从源文件夹中 拿出所有的文件包括文件夹 File[] files = src.listFiles(); if (files != null) &#123; for (File file : files) &#123; if (file.isFile()) &#123; FileInputStream fis = new FileInputStream(file); //使用缓冲流包一下，目的是流 读到 缓冲区，再从缓冲区往外写 效率速度提高 BufferedInputStream bfis = new BufferedInputStream(fis); // FileOutputStream fos = new FileOutputStream(new File(to, file.getName())); //使用缓冲流包一下，目的是流先 写到缓冲区，再从缓冲区写到文本中 效率速度提高 BufferedOutputStream bfos = new BufferedOutputStream(fos); //是文件直接拷贝 /** * 一个字节，一个字节的读，一个字节一个字节的写 * 非常慢 * 等了好久也没结束 */ /*int b; while ((b = fis.read()) != -1) &#123; fos.write(b); //读多少就写多少 &#125; fos.close(); fis.close();*/ /*-----------------------------------------*/ /* * 使用字节数组，指定一次读取 0.5M * * 因为都是小文件，中间的容器创建太大，导致空间浪费，速度反而慢 * * 最终 拷贝完成用时 577~668豪秒 */ /*int len; byte[] b = new byte[1024 * 1024 * 1/2]; //0.5M大小 while ((len = fis.read(b)) != -1) &#123; fos.write(b, 0, len); //读多少就写多少 &#125; fos.close(); fis.close();*/ /*-----------------------------------------*/ /** * 使用缓冲流包一下，速度快了一点 * * 最终 拷贝完成用时797豪秒 */ /* int b; while ((b=bfis.read())!=-1)&#123; bfos.write(b); &#125; bfos.close(); bfis.close(); */ /*-----------------------------------------*/ /** * 使用缓冲流， * 同时加上 还指定一次读0.5M数组 * 更快 * * 最终：拷贝完成用时 511~616 豪秒 * * 最快的 */ int len; byte[] b = new byte[1024 * 1024 * 1 / 2]; //一次读取 0.5M 大小到数组中 while ((len = bfis.read(b)) != -1) &#123; bfos.write(b, 0, len);//一次写出 0.5M 到本地文件中 &#125; bfos.close(); bfis.close(); &#125; else &#123; //是文件夹，进入再拷贝 copyDirectorys(file, new File(to, file.getName())); &#125; &#125; &#125; &#125;&#125; 二、文件加密 利用(^异或) （如：100^10&#x3D;110；110^10&#x3D;100） 一个十进制数异或同一个数字两次，可以得到原数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atlml.io_stream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class Practice2 &#123; public static void main(String[] args) throws IOException &#123; /** * 对文件进行加密 * * 将一个文件读出来之后，对其字节进行操作 * 字节流 */ File src = new File(&quot;javabasis\\\\aaa\\\\aaa.mp4&quot;); File ency = new File(&quot;javabasis\\\\aaa\\\\bbbbbbbb.mp4&quot;); //文件加密 存到 本地 fileEncryption(src,ency); //文件解密 // fileEncryption(ency,src); &#125; /** * 加密/解密 * @param src * @param ency * @throws IOException */ private static void fileEncryption(File src,File ency) throws IOException &#123; FileInputStream fileInputStream = new FileInputStream(src); FileOutputStream fileOutputStream = new FileOutputStream(ency); byte[] b = new byte[1024*1024/2]; //0.5M 的 转移 容器 int len;//每次转移的字节数量 byte myb=10; //声明一个字节默认值是 10 while ((len=fileInputStream.read(b))!=-1)&#123; for (int i = 0; i &lt;len; i++) &#123; b[i]= (byte) (b[i]^myb);//将每个字节异或操作后，在存到字节数组中（加密） &#125; fileOutputStream.write(b,0,len); &#125; fileOutputStream.close(); fileInputStream.close(); &#125;&#125; 三、文件排序123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws IOException &#123; /* * * 文本文件中有以下的数据： * 2-1-9-4-7-8 * 将文件中的数据进行排序，变成以下的数据： * 1-2-4-7-8-9 */ File file = new File(&quot;javabasis\\\\aaa\\\\num.txt&quot;); FileReader fr = new FileReader(file);//字符输入流 FileWriter fw = new FileWriter(&quot;javabasis\\\\aaa\\\\numSort.txt&quot;); ArrayList&lt;String&gt; str = new ArrayList&lt;&gt;(); char[] ch = new char[2]; int len; while ((len = fr.read(ch)) != -1) &#123; for (int i = 0; i &lt; len; i++) &#123; String s = String.valueOf(ch[i]); if (!&quot;-&quot;.equals(s)) &#123; str.add(s); //不是&quot;-&quot;横线 &#125; &#125; &#125; Collections.sort(str);//从小到大排序 StringJoiner stringJoiner = new StringJoiner(&quot;-&quot;, &quot;&quot;, &quot;&quot;); for (String s : str) &#123; stringJoiner.add(s); &#125; fw.write(stringJoiner.toString()); fw.close(); fr.close(); &#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"51.IO流-其他流","slug":"java基础/51.IO流（其他流）","date":"2019-09-26T01:11:00.000Z","updated":"2024-07-22T13:22:57.360Z","comments":true,"path":"2019/09/26/java基础/51.IO流（其他流）/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/51.IO%E6%B5%81%EF%BC%88%E5%85%B6%E4%BB%96%E6%B5%81%EF%BC%89/","excerpt":"","text":"IO流-其他流 1. 缓冲流昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。 1.1 概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 1.2 字节缓冲流构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;)); 效率测试查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。 基本流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream(&quot;jdk9.exe&quot;); FileOutputStream fos = new FileOutputStream(&quot;copy.exe&quot;) )&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;十几分钟过去了... 缓冲流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;)); )&#123; // 读写数据 int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;缓冲流复制时间:8016 毫秒 如何更快呢？ 使用数组的方式，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;)); )&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;缓冲流使用数组复制时间:666 毫秒 1.3 字符缓冲流构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(&quot;br.txt&quot;));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)); 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示，代码如下： 123456789101112131415public class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;)); // 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) &#123; System.out.print(line); System.out.println(&quot;------&quot;); &#125; // 释放资源 br.close(); &#125;&#125; newLine方法演示，代码如下： 1234567891011121314151617181920public class BufferedWriterDemo throws IOException &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;)); // 写出数据 bw.write(&quot;黑马&quot;); // 写出换行 bw.newLine(); bw.write(&quot;程序&quot;); bw.newLine(); bw.write(&quot;员&quot;); bw.newLine(); // 释放资源 bw.close(); &#125;&#125;输出效果:黑马程序员 1.4 练习:文本排序请将文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 案例分析 逐行读取文本信息。 把读取到的文本存储到集合中 对集合中的文本进行排序 遍历集合，按顺序，写出文本信息。 案例实现1234567891011121314151617181920212223242526272829303132333435363738public class Demo05Test &#123; public static void main(String[] args) throws IOException &#123; //1.创建ArrayList集合,泛型使用String ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //2.创建BufferedReader对象,构造方法中传递FileReader对象 BufferedReader br = new BufferedReader(new FileReader(&quot;10_IO\\\\in.txt&quot;)); //3.创建BufferedWriter对象,构造方法中传递FileWriter对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;10_IO\\\\out.txt&quot;)); //4.使用BufferedReader对象中的方法readLine,以行的方式读取文本 String line; while((line = br.readLine())!=null)&#123; //5.把读取到的文本存储到ArrayList集合中 list.add(line); &#125; //6.使用Collections集合工具类中的方法sort,对集合中的元素按照自定义规则排序 Collections.sort(list, new Comparator&lt;String&gt;() &#123; /* o1-o2:升序 o2-o1:降序 */ @Override public int compare(String o1, String o2) &#123; //依次比较集合中两个元素的首字母,升序排序 return o1.charAt(0)-o2.charAt(0); &#125; &#125;); //7.遍历ArrayList集合,获取每一个元素 for (String s : list) &#123; //8.使用BufferedWriter对象中的方法wirte,把遍历得到的元素写入到文本中(内存缓冲区中) bw.write(s); //9.写换行 bw.newLine(); &#125; //10.释放资源 bw.close(); br.close(); &#125;&#125; 2. 转换流2.1 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 编码:字符(能看懂的)–字节(看不懂的) 解码:字节(看不懂的)–&gt;字符(能看懂的) 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 编码表:生活中文字和计算机中二进制的对应规则 字符集 **字符集 Charset**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 2.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 123456789101112public class ReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader(&quot;E:\\\\File_GBK.txt&quot;); int read; while ((read = fileReader.read()) != -1) &#123; System.out.print((char)read); &#125; fileReader.close(); &#125;&#125;输出结果：��� 那么如何读取GBK编码的文件呢？ 2.3 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;); 指定编码读取1234567891011121314151617181920212223public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = &quot;E:\\\\file_gbk.txt&quot;; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , &quot;GBK&quot;); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; 2.4 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;); 指定编码写出12345678910111213141516171819public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = &quot;E:\\\\out.txt&quot;; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(&quot;你好&quot;); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = &quot;E:\\\\out2.txt&quot;; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;); // 写出数据 osw2.write(&quot;你好&quot;);// 保存为4个字节 osw2.close(); &#125;&#125; 转换流理解图解转换流是字节与字符间的桥梁！ 2.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 案例实现12345678910111213141516171819202122232425public class TransDemo &#123; public static void main(String[] args) &#123; // 1.定义文件路径 String srcFile = &quot;file_gbk.txt&quot;; String destFile = &quot;file_utf8.txt&quot;; // 2.创建流对象 // 2.1 转换输入流,指定GBK编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , &quot;GBK&quot;); // 2.2 转换输出流,默认utf8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile)); // 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) &#123; // 循环写出 osw.write(cbuf,0,len); &#125; // 4.释放资源 osw.close(); isr.close(); &#125;&#125; 3. 序列化3.1 概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： 3.2 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out) ： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream(&quot;employee.txt&quot;);ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 12345678public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println(&quot;Address check : &quot; + name + &quot; -- &quot; + address); &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 12345678910111213141516171819202122public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = &quot;zhangsan&quot;; e.address = &quot;beiqinglu&quot;; e.age = 20; try &#123; // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;)); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。 &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125;输出结果：Serialized data is saved 3.3 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728public class DeserializeDemo &#123; public static void main(String [] args) &#123; Employee e = null; try &#123; // 创建反序列化流 FileInputStream fileIn = new FileInputStream(&quot;employee.txt&quot;); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close(); &#125;catch(IOException i) &#123; // 捕获其他异常 i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; // 捕获类找不到异常 System.out.println(&quot;Employee class not found&quot;); c.printStackTrace(); return; &#125; // 无异常,直接打印输出 System.out.println(&quot;Name: &quot; + e.name); // zhangsan System.out.println(&quot;Address: &quot; + e.address); // beiqinglu System.out.println(&quot;age: &quot; + e.age); // 0 &#125;&#125; 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 123456789101112public class Employee implements java.io.Serializable &#123; // 加入序列版本号 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() &#123; System.out.println(&quot;Address check : &quot; + name + &quot; -- &quot; + address); &#125;&#125; 3.4 练习：序列化集合 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。 案例分析 把若干学生对象 ，保存到集合中。 把集合序列化。 反序列化读取时，只需要读取一次，转换为集合类型。 遍历集合，可以打印所有的学生信息 案例实现12345678910111213141516171819202122232425262728293031323334public class SerTest &#123; public static void main(String[] args) throws Exception &#123; // 创建 学生对象 Student student = new Student(&quot;老王&quot;, &quot;laow&quot;); Student student2 = new Student(&quot;老张&quot;, &quot;laoz&quot;); Student student3 = new Student(&quot;老李&quot;, &quot;laol&quot;); ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(student); arrayList.add(student2); arrayList.add(student3); // 序列化操作 // serializ(arrayList); // 反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;)); // 读取对象,强转为ArrayList类型 ArrayList&lt;Student&gt; list = (ArrayList&lt;Student&gt;)ois.readObject(); for (int i = 0; i &lt; list.size(); i++ )&#123; Student s = list.get(i); System.out.println(s.getName()+&quot;--&quot;+ s.getPwd()); &#125; &#125; private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123; // 创建 序列化流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;)); // 写出对象 oos.writeObject(arrayList); // 释放资源 oos.close(); &#125;&#125; 4. 打印流4.1 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 4.2 PrintStream类构造方法 public PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： 1PrintStream ps = new PrintStream(&quot;ps.txt&quot;)； 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。 1234567891011121314public class PrintDemo &#123; public static void main(String[] args) throws IOException &#123; // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(&quot;ps.txt&quot;); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); &#125;&#125; 5. 压缩流和解压缩流压缩流： ​ 负责压缩文件或者文件夹 解压缩流： ​ 负责把压缩包中的文件和文件夹解压出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** 解压缩流** */public class ZipStreamDemo1 &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个File表示要解压的压缩包 File src = new File(&quot;D:\\\\aaa.zip&quot;); //2.创建一个File表示解压的目的地 File dest = new File(&quot;D:\\\\&quot;); //调用方法 unzip(src,dest); &#125; //定义一个方法用来解压 public static void unzip(File src,File dest) throws IOException &#123; //解压的本质：把压缩包里面的每一个文件或者文件夹读取出来，按照层级拷贝到目的地当中 //创建一个解压缩流用来读取压缩包中的数据 ZipInputStream zip = new ZipInputStream(new FileInputStream(src)); //要先获取到压缩包里面的每一个zipentry对象 //表示当前在压缩包中获取到的文件或者文件夹 ZipEntry entry; while((entry = zip.getNextEntry()) != null)&#123; System.out.println(entry); if(entry.isDirectory())&#123; //文件夹：需要在目的地dest处创建一个同样的文件夹 File file = new File(dest,entry.toString()); file.mkdirs(); &#125;else&#123; //文件：需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放） FileOutputStream fos = new FileOutputStream(new File(dest,entry.toString())); int b; while((b = zip.read()) != -1)&#123; //写到目的地 fos.write(b); &#125; fos.close(); //表示在压缩包中的一个文件处理完毕了。 zip.closeEntry(); &#125; &#125; zip.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class ZipStreamDemo2 &#123; public static void main(String[] args) throws IOException &#123; /* * 压缩流 * 需求： * 把D:\\\\a.txt打包成一个压缩包 * */ //1.创建File对象表示要压缩的文件 File src = new File(&quot;D:\\\\a.txt&quot;); //2.创建File对象表示压缩包的位置 File dest = new File(&quot;D:\\\\&quot;); //3.调用方法用来压缩 toZip(src,dest); &#125; /* * 作用：压缩 * 参数一：表示要压缩的文件 * 参数二：表示压缩包的位置 * */ public static void toZip(File src,File dest) throws IOException &#123; //1.创建压缩流关联压缩包 ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest,&quot;a.zip&quot;))); //2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹 //参数：压缩包里面的路径 ZipEntry entry = new ZipEntry(&quot;aaa\\\\bbb\\\\a.txt&quot;); //3.把ZipEntry对象放到压缩包当中 zos.putNextEntry(entry); //4.把src文件中的数据写到压缩包当中 FileInputStream fis = new FileInputStream(src); int b; while((b = fis.read()) != -1)&#123; zos.write(b); &#125; zos.closeEntry(); zos.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ZipStreamDemo3 &#123; public static void main(String[] args) throws IOException &#123; /* * 压缩流 * 需求： * 把D:\\\\aaa文件夹压缩成一个压缩包 * */ //1.创建File对象表示要压缩的文件夹 File src = new File(&quot;D:\\\\aaa&quot;); //2.创建File对象表示压缩包放在哪里（压缩包的父级路径） File destParent = src.getParentFile();//D:\\\\ //3.创建File对象表示压缩包的路径 File dest = new File(destParent,src.getName() + &quot;.zip&quot;); //4.创建压缩流关联压缩包 ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest)); //5.获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中 toZip(src,zos,src.getName());//aaa //6.释放资源 zos.close(); &#125; /* * 作用：获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中 * 参数一：数据源 * 参数二：压缩流 * 参数三：压缩包内部的路径 * */ public static void toZip(File src,ZipOutputStream zos,String name) throws IOException &#123; //1.进入src文件夹 File[] files = src.listFiles(); //2.遍历数组 for (File file : files) &#123; if(file.isFile())&#123; //3.判断-文件，变成ZipEntry对象，放入到压缩包当中 ZipEntry entry = new ZipEntry(name + &quot;\\\\&quot; + file.getName());//aaa\\\\no1\\\\a.txt zos.putNextEntry(entry); //读取文件中的数据，写到压缩包 FileInputStream fis = new FileInputStream(file); int b; while((b = fis.read()) != -1)&#123; zos.write(b); &#125; fis.close(); zos.closeEntry(); &#125;else&#123; //4.判断-文件夹，递归 toZip(file,zos,name + &quot;\\\\&quot; + file.getName()); // no1 aaa \\\\ no1 &#125; &#125; &#125;&#125; 6. 工具包（Commons-io）介绍： ​ Commons是apache开源基金组织提供的工具包，里面有很多帮助我们提高开发效率的API 比如： ​ StringUtils 字符串工具类 ​ NumberUtils 数字工具类 ​ ArrayUtils 数组工具类 ​ RandomUtils 随机数工具类 ​ DateUtils 日期工具类 ​ StopWatch 秒表工具类 ​ ClassUtils 反射工具类 ​ SystemUtils 系统工具类 ​ MapUtils 集合工具类 ​ Beanutils bean工具类 ​ Commons-io io的工具类 ​ 等等….. 其中：Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。 作用：提高IO流的开发效率。 使用方式： 1，新建lib文件夹 2，把第三方jar包粘贴到文件夹中 3，右键点击add as a library 代码示例： 12345678910111213141516171819202122232425262728293031323334353637public class CommonsIODemo1 &#123; public static void main(String[] args) throws IOException &#123; /* FileUtils类 static void copyFile(File srcFile, File destFile) 复制文件 static void copyDirectory(File srcDir, File destDir) 复制文件夹 static void copyDirectoryToDirectory(File srcDir, File destDir) 复制文件夹 static void deleteDirectory(File directory) 删除文件夹 static void cleanDirectory(File directory) 清空文件夹 static String readFileToString(File file, Charset encoding) 读取文件中的数据变成成字符串 static void write(File file, CharSequence data, String encoding) 写出数据 IOUtils类 public static int copy(InputStream input, OutputStream output) 复制文件 public static int copyLarge(Reader input, Writer output) 复制大文件 public static String readLines(Reader input) 读取数据 public static void write(String data, OutputStream output) 写出数据 */ /* File src = new File(&quot;myio\\\\a.txt&quot;); File dest = new File(&quot;myio\\\\copy.txt&quot;); FileUtils.copyFile(src,dest);*/ /*File src = new File(&quot;D:\\\\aaa&quot;); File dest = new File(&quot;D:\\\\bbb&quot;); FileUtils.copyDirectoryToDirectory(src,dest);*/ /*File src = new File(&quot;D:\\\\bbb&quot;); FileUtils.cleanDirectory(src);*/ &#125;&#125; 7. 工具包（hutool）介绍： ​ Commons是国人开发的开源工具包，里面有很多帮助我们提高开发效率的API 比如： ​ DateUtil 日期时间工具类 ​ TimeInterval 计时器工具类 ​ StrUtil 字符串工具类 ​ HexUtil 16进制工具类 ​ HashUtil Hash算法类 ​ ObjectUtil 对象工具类 ​ ReflectUtil 反射工具类 ​ TypeUtil 泛型类型工具类 ​ PageUtil 分页工具类 ​ NumberUtil 数字工具类 使用方式： 1，新建lib文件夹 2，把第三方jar包粘贴到文件夹中 3，右键点击add as a library 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test1 &#123; public static void main(String[] args) &#123; /* FileUtil类: file：根据参数创建一个file对象 touch：根据参数创建文件 writeLines：把集合中的数据写出到文件中，覆盖模式。 appendLines：把集合中的数据写出到文件中，续写模式。 readLines：指定字符编码，把文件中的数据，读到集合中。 readUtf8Lines：按照UTF-8的形式，把文件中的数据，读到集合中 copy：拷贝文件或者文件夹 */ /* File file1 = FileUtil.file(&quot;D:\\\\&quot;, &quot;aaa&quot;, &quot;bbb&quot;, &quot;a.txt&quot;); System.out.println(file1);//D:\\aaa\\bbb\\a.txt File touch = FileUtil.touch(file1); System.out.println(touch); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); File file2 = FileUtil.writeLines(list, &quot;D:\\\\a.txt&quot;, &quot;UTF-8&quot;); System.out.println(file2);*/ /* ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); File file3 = FileUtil.appendLines(list, &quot;D:\\\\a.txt&quot;, &quot;UTF-8&quot;); System.out.println(file3);*/ List&lt;String&gt; list = FileUtil.readLines(&quot;D:\\\\a.txt&quot;, &quot;UTF-8&quot;); System.out.println(list); &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"49.File类","slug":"java基础/49.File","date":"2019-09-26T00:31:00.000Z","updated":"2025-01-04T12:23:21.922Z","comments":true,"path":"2019/09/26/java基础/49.File/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/49.File/","excerpt":"","text":"File类 一、File 对File的理解 将字符串表示的路径，变成file对象 目的就是为了使用file中的方法，对文件进行操作。 new File(“路径”) 1.形参中是文件的绝对路径（此时就表示一个文件） 2.形参中是文件夹的绝对路径（此时就表示一个文件夹） new File(形参) 形参：D:\\aaa\\bb\\a.txt D:\\aaa\\cc （）中形参：如果表示的是已经存在的真实文件夹或者真实存在的真实文件，那么就表示文件与File匹配。然后通过File中的方法来操作，这个文件或者文件夹 ( ) 中形参：表示的如果不是真实的存在的文件或者文件夹，就可以用File的方法进行创建文件或者文件夹 为什么要用File类，就是为了表述系统中的文件，使用File类中的方法，对当前File进行操作。 二、File 的方法 练习1.file获取文件名f.getName()带后缀名1234567891011121314151617181920212223242526272829/** * 定义一个方法找某一个文件夹中，是否有以 avi 结尾的电影。 * （暂时不需要考虑子文件夹） */public class FileDemo4 &#123; public static void main(String[] args) &#123; File file = new File(&quot;C:\\\\Users\\\\lml\\\\Downloads\\\\aaa&quot;); boolean b = existAvi(file); System.out.println(b); &#125; public static boolean existAvi(File file)&#123; // C:\\Users\\lml\\Downloads\\aaa 文件夹 File[] files = file.listFiles(); for (File f : files) &#123; // 遍历aaa文件夹下的 文件夹以及文件的路径 if(f.isFile()&amp;&amp;f.getName().endsWith(&quot;.avi&quot;))&#123; return true; &#125; &#125; return false; &#125; &#125; 2.涉及到多级文件夹，需要递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.atlml.file_demo;import java.io.File;/** * 找到电脑中所有以avi结尾的电影。 * (需要考虑子文件夹） * * * 思想：把大问题拆分，拆到某一个文件夹中不包含其他文件夹为止 * * 递归思想，就是将大的问题，拆成小的问题去解决 * * 凡事要考虑文件夹里面的内容了，就使用下面的套路 * 写递归方法的套路 * 套路： * 1.进入文件夹 * 2.遍历数组 * 2.1.遍历内部：判断，如果是文件 就执行题目的业务逻辑 * 2.2.遍历内部：判断，如果不是文件，他就是文件夹，继续调用当前方法，递归 * */public class FileDemo5 &#123; public static void main(String[] args) &#123; /* File file = new File(&quot;C:\\\\&quot;); //C盘 findAVI(file);*/ findAVI(); &#125; /** * 查询电脑上 所有盘符 中 avi文件的路径 */ public static void findAVI()&#123; File[] files = File.listRoots(); //获取系统中所有的盘符 for (File file : files) &#123; findAVI(file); &#125; &#125; /** * 递归方法 * 递归查询 指定文件夹 中的内容 */ public static void findAVI(File file)&#123; //1.进入文件夹,找到当前文件夹下面 所有的路径 // 包含当前文件夹下的 所有文件夹，文件 File[] files = file.listFiles(); //注意细节：file可能为null 因为盘符有权限可能进不去 if(files!=null)&#123; //2.遍历数组 for (File src : files) &#123; //3.判断，如果是文件就执行题目的业务逻辑 if(src.isFile())&#123; if(src.getName().endsWith(&quot;.avi&quot;))&#123; System.out.println(src); &#125; &#125;else &#123; //4.判断，如果不是文件，他就是文件夹，继续调用当前方法，递归 // 注意 src 一定是 file 的下级目录 findAVI(src); &#125; &#125; &#125; &#125;&#125; 3.删除多级文件夹1234567891011121314151617181920212223242526272829303132/** * 删除多级文件夹 */public class FileDemo6 &#123; public static void main(String[] args) &#123; /** * 先思考删除一个文件夹内的内容怎么删 * 如果 当前文件夹下面 还有文件夹 再调用 */ File file = new File(&quot;C:\\\\Users\\\\lml\\\\Downloads\\\\aaa\\\\eee&quot;); deleteMultilevelDirectory(file); &#125; /** * @param src 文件夹地址 * @return 删除成功与否 */ public static void deleteMultilevelDirectory(File src) &#123; File[] files = src.listFiles(); if (files != null) &#123; for (File file : files) &#123; if(file.isFile())&#123; //是文件直接删除 file.delete(); &#125;else &#123; //是文件夹，且文件夹不是空的 递归 deleteMultilevelDirectory(file); &#125; &#125; &#125; // 自己也删 src.delete(); &#125; 4.递归多级目录，递归方法中的局部变量怎么统计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹） * &lt;p&gt; * ① 打印格式如下： * ② txt：3个 * ③ doc：4个 * ④ jpg：6个 * 。。。。 */public class FileDemo7 &#123; public static void main(String[] args) &#123; File file = new File(&quot;C:\\\\Users\\\\lml\\\\Downloads\\\\aaa&quot;); Map&lt;String, Integer&gt; count = getCount(file); System.out.println(count); //&#123;jpg=9, txt=4, xlsx=1, avi=1, doc=4&#125; &#125; /** * 统计文件夹下面的 各种文件格式 个数 * 并打印 * * 使用了 map 的统计思想 * * 因为是递归方法， * 所以其中的 局部变量怎么能产生关系? * * 就是在调用递归之后，回到当前方法，把递归的值，返回给当前 * */ public static Map&lt;String, Integer&gt; getCount(File src) &#123; HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;(); File[] files = src.listFiles(); if (files != null) &#123; for (File file : files) &#123; if (file.isFile()) &#123; //如果当前是文件，判断文件的 格式 并记录 String name = file.getName(); //注意这里的截取 点 要加 双反斜线 String[] split = name.split(&quot;\\\\.&quot;); if (split.length &gt;= 2) &#123; //这里是有后缀名的文件才进行统计 //a.txt 统计 //a.a.b,txt 统计 // aaa无后缀名 不统计 //利用Map 进行统计 String suffix = split[split.length - 1]; //后缀 if (hm.containsKey(suffix)) &#123; //map中已经存在这个 格式 如：txt Integer count = hm.get(suffix); count++; hm.put(suffix, count); &#125; else &#123; //第一次添加 hm.put(suffix, 1); &#125; &#125; &#125; else &#123; //不是文件，是文件夹（递归）结果是子文件夹的统计 // hm &#123;txt=3,doc=4,jpg=1 &#125; // map&#123;txt=1,doc=1,jpg=1,xlsx=1&#125; Map&lt;String, Integer&gt; map = getCount(file); //走到这一步，下面就先不看，再旁边想象新的方法，结果放在这里 //遍历map map.forEach((k, v) -&gt; &#123; if (hm.containsKey(k)) &#123; Integer count = hm.get(k); // 说明已经有 这个后缀 hm.put(k, v + count); &#125; else &#123; //这里表示hm中不存在的 key格式值 hm.put(k, v); &#125; &#125;); &#125; &#125; &#125; return hm; &#125;&#125; 5.递归方法中的局部变量怎么处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 统计一个文件夹内所有文件的总大小 */public class FileDemo8 &#123; public static void main(String[] args) &#123; /** * * 1.先路径定义到 这个文件夹 * 2. 将文件夹展开 * 如果是文件直接统计大小 * 如果是文件夹，继续递归第2步 * 最终将所有的文件大小加在一起 * 3.返回统计值 * * */ //这里统计 aaa文件夹总大小 File file = new File(&quot;C:\\\\Users\\\\lml\\\\Downloads\\\\aaa&quot;); Long size = countTotalSize(file); System.out.println(size); &#125; private static Long countTotalSize(File src) &#123; //注意这个length是局部变量，第二次递归的时候，这个值就又变成了0 // 怎么解决？把递归的结果加在第一次执行时length上面。 // 执行到递归时，就想旁边有一个一模一样的方法，它的计算和 当前方法执行 没有关系 long length = 0; File[] files = src.listFiles(); if (files != null) &#123; for (File file : files) &#123; if (file.isFile()) &#123; //如果是文件，直接算出大小 length = length + file.length(); &#125; else &#123; length = length + countTotalSize(file); &#125; &#125; &#125; return length; &#125; &#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"47.方法引用","slug":"java基础/47.方法引用","date":"2019-09-26T00:30:00.000Z","updated":"2024-07-02T07:48:13.556Z","comments":true,"path":"2019/09/26/java基础/47.方法引用/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/47.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"方法引用 一、方法引用 二、方法引用的分类 1.引用静态方法 例： 2.引用成员方法 3.引用构造方法 三、方法引用的理解 （大小写转换） 四、数组构造器引用 以后stream流收集为Array数组的时候，就可以使用”数组的构造器引用” 练习创建一个student类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.atlml.stream_demo;public class Student &#123; private String name; private Integer age; public Student() &#123; &#125; /** * 自定义构造器 * @param str */ public Student(String str) &#123; this.name = str.split(&quot;,&quot;)[0]; this.age = Integer.parseInt(str.split(&quot;,&quot;)[1]); &#125; public Student(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; /** * 拼接数据 * 把姓名和年龄拼接成：张三-23的字符串 * @return */ public static String splicing(Student student)&#123; return student.getName()+&quot;-&quot;+student.getAge(); &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 使用Student构造器方法引用123456789101112131415161718192021222324public static void main(String[] args) &#123; /** * 集合中存储一些字符串的数据，比如：张三，23。 * 收集到Student：类型的数组当中（使用方法引用完成） */ ArrayList&lt;String&gt; manName = new ArrayList&lt;&gt;(); Collections.addAll(manName, &quot;蔡徐坤,23&quot;, &quot;吴京,29&quot;, &quot;林根锡,15&quot;, &quot;顾佳,66&quot;, &quot;叶问,54&quot;, &quot;洪金宝,32&quot;); Student[] students = manName.stream() // 下面这句话怎么理解， 就是stream上的 每个元素，都调用了，new Student() 方法，并且又将结果返回给 stream流上。 // map处理过后，stream流上面全是student对象 .map(Student::new) //使用 student的构造器方法 引用 .toArray(Student[]::new);// 使用student 数组构造引用 for (Student student : students) &#123; System.out.println(student); &#125; &#125; 使用Student中成员方法引用1234567891011121314151617181920public static void main(String[] args) &#123; /** * 创建集合添加学生对象，学生对象属性：name,age * 只获取姓名并放到数组当中（使用方法引用完成） * &quot;蔡徐坤,23&quot;, &quot;吴京,29&quot;, &quot;林根锡,15&quot;, &quot;顾佳,66&quot;, &quot;叶问,54&quot;, &quot;洪金宝,32&quot; */ ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); students.add(new Student(&quot;蔡徐坤&quot;,23)); students.add(new Student(&quot;吴京&quot;,29)); students.add(new Student(&quot;林根锡&quot;,15)); students.add(new Student(&quot;顾佳&quot;,66)); students.add(new Student(&quot;叶问&quot;,54)); String[] names = students.stream() .map(Student::getName) .toArray(String[]::new); Arrays.stream(names).forEach(n-&gt; System.out.println(n)); &#125; 使用Student中静态方法引用1234567891011121314151617181920public static void main(String[] args) &#123; /** *创建集合添加学生对象，学生对象属性：name,age * 把姓名和年龄拼接成：张三-23的字符串，并放到数组当中（使用方法引用完成） */ ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); students.add(new Student(&quot;蔡徐坤&quot;,23)); students.add(new Student(&quot;吴京&quot;,29)); students.add(new Student(&quot;林根锡&quot;,15)); students.add(new Student(&quot;顾佳&quot;,66)); students.add(new Student(&quot;叶问&quot;,54)); String[] students1 = students.stream() .map(Student::splicing) .toArray(String[]::new); String s = Arrays.toString(students1); System.out.println(s);//[蔡徐坤-23, 吴京-29, 林根锡-15, 顾佳-66, 叶问-54] &#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"48.异常体系","slug":"java基础/48.异常体系","date":"2019-09-26T00:30:00.000Z","updated":"2024-12-31T17:11:13.759Z","comments":true,"path":"2019/09/26/java基础/48.异常体系/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/48.%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/","excerpt":"","text":"异常体系 一、异常体系 二、捕获异常 在代码中将可能存在异常的部分，使用 try-catch包裹住，在catch中捕获异常，并进行处理（可以记录到日志） 目的：当代码出现异常时，可以让程序继续往下执行，而不是交给虚拟机默认处理，给系统停止了 三、异常类中的常见方法 四、异常的抛出处理 例如： 五、自定义异常类（类名要见名知意） 意义：就是为了让控制台的报错信息更加见名知意 目的是：在Java中，没有一个异常能够完美 表示 当前出现的问题 自定义一个异常类，表示当前出现问题的异常类 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"46.stream流","slug":"java基础/46.stream流","date":"2019-09-26T00:22:00.000Z","updated":"2024-07-02T08:28:17.181Z","comments":true,"path":"2019/09/26/java基础/46.stream流/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/46.stream%E6%B5%81/","excerpt":"","text":"stream流 一、流的思想 二、为什么要用stream流 目的是为了，简化 集合、数组的操作（配合Lambda表达式使用） 三、获取Stream流 这个stream流，一般就是用来简化集合的操作的，所以它和集合是分不开的，使用集合可以直接调用stream方法，来上流 实现 四、Stream流的中间方法 具体实现 五、Stream流中的终结方法 收集到集合当中（List集合，以及Map集合） 练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.atlml.stream_demo;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class StreamDemo5 &#123; public static void main(String[] args) &#123; /** * 现在有两个ArrayList集合， * 第一个集合中：存储6名男演员的名字和年龄。 * 第二个集合中：存储6名女演员的名字和年龄。 * * 姓名和年龄中间用逗号隔开。比如：张三,23 * 要求完成如下的操作： * 1，男演员只要名字为 3个字的 前两人 * 2，女演员只要姓杨的，并且不要第一个 * 3，把过滤后的男演员姓名和女演员姓名合并到一起 * 4，将上一步的演员信息封装成Actor对象。 * 5，将所有的演员对象都保存到List集合中。 * 备注：演员类Actor，属性有：name,age */ ArrayList&lt;String&gt; manName = new ArrayList&lt;&gt;(); Collections.addAll(manName, &quot;蔡徐坤,23&quot;, &quot;吴京,29&quot;, &quot;林根锡,15&quot;, &quot;顾佳,66&quot;, &quot;叶问,54&quot;, &quot;洪金宝,32&quot;); ArrayList&lt;String&gt; girlName = new ArrayList&lt;&gt;(); Collections.addAll(girlName, &quot;杨幂,20&quot;, &quot;刘诗诗,28&quot;, &quot;赵丽颖,22&quot;, &quot;高圆圆,29&quot;, &quot;张甜甜,33&quot;, &quot;杨政馨,46&quot;); List&lt;String&gt; list1 = manName.stream() .filter(s -&gt; (s.split(&quot;,&quot;)[0]).length() == 3) .limit(2) .collect(Collectors.toList()); List&lt;String&gt; list2 = girlName.stream() .filter(s -&gt; s.startsWith(&quot;杨&quot;)) .skip(1) .collect(Collectors.toList()); /* ArrayList&lt;Actor&gt; actors = new ArrayList&lt;&gt;(); Stream.concat(list1.stream(), list2.stream()) .forEach(l -&gt; &#123; String[] split = l.split(&quot;,&quot;); String name = split[0]; int age = Integer.parseInt(split[1]); actors.add(new Actor(name, age)); &#125;);*/ List&lt;Actor&gt; actors = Stream.concat(list1.stream(), list2.stream()) .map(s -&gt; new Actor(s.split(&quot;,&quot;)[0], Integer.parseInt(s.split(&quot;,&quot;)[1]))) .collect(Collectors.toList()); System.out.println(actors);//[Actor&#123;name=&#x27;蔡徐坤&#x27;, age=23&#125;, Actor&#123;name=&#x27;林根锡&#x27;, age=15&#125;, Actor&#123;name=&#x27;杨政馨&#x27;, age=46&#125;] &#125;&#125; © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"50.字符集详解","slug":"java基础/50.字符集详解","date":"2019-09-25T19:00:00.000Z","updated":"2024-07-05T17:28:06.085Z","comments":true,"path":"2019/09/26/java基础/50.字符集详解/","link":"","permalink":"https://protonlml.github.io/2019/09/26/java%E5%9F%BA%E7%A1%80/50.%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"字符集详解 java中的编解码 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"45.集合进阶-12-TreeMap","slug":"java基础/45.集合进阶-12-TreeMap","date":"2019-09-25T00:22:00.000Z","updated":"2024-06-28T09:05:07.988Z","comments":true,"path":"2019/09/25/java基础/45.集合进阶-12-TreeMap/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/45.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-12-TreeMap/","excerpt":"","text":"TreeMap 1.第一种排序规则 2.第二种排序规则 练习使用Map 来进行统计 这里使用TreeMap因为结果有 字母升序排列 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"44.集合进阶-11-LinkedHashMap","slug":"java基础/44.集合进阶-11-LinkedHashMap","date":"2019-09-25T00:20:00.000Z","updated":"2024-06-28T08:35:55.935Z","comments":true,"path":"2019/09/25/java基础/44.集合进阶-11-LinkedHashMap/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/44.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-11-LinkedHashMap/","excerpt":"","text":"LinkedHashMap © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"43.集合进阶-10-HashMap","slug":"java基础/43.集合进阶-10-HashMap","date":"2019-09-25T00:18:00.000Z","updated":"2024-06-28T08:31:56.325Z","comments":true,"path":"2019/09/25/java基础/43.集合进阶-10-HashMap/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/43.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-10-HashMap/","excerpt":"","text":"HashMap © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"42.集合进阶-09-双列集合Map、常用API、三种遍历方式","slug":"java基础/42.集合进阶-09-Map特点、常用API、三种遍历方式","date":"2019-09-25T00:10:00.000Z","updated":"2024-06-28T08:21:57.091Z","comments":true,"path":"2019/09/25/java基础/42.集合进阶-09-Map特点、常用API、三种遍历方式/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/42.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-09-Map%E7%89%B9%E7%82%B9%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%81%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/","excerpt":"","text":"双列集合Map 一、双列集合的特点 二、Map中常见的API 三、Map的三种遍历方式 1.键找值 2.键值对Entry对象 3.Lambda表达式遍历 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"34.Hutool工具包","slug":"工具类/34.Hutool工具包","date":"2019-09-24T23:32:00.000Z","updated":"2024-07-09T18:35:33.839Z","comments":true,"path":"2019/09/25/工具类/34.Hutool工具包/","link":"","permalink":"https://protonlml.github.io/2019/09/25/%E5%B7%A5%E5%85%B7%E7%B1%BB/34.Hutool%E5%B7%A5%E5%85%B7%E5%8C%85/","excerpt":"","text":"Hutool工具包 Hutool🍬官网Hutool工具包操作文档API文档 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"33.commons-io工具类","slug":"工具类/33.commons-io工具类","date":"2019-09-24T23:30:00.000Z","updated":"2024-07-09T18:17:19.288Z","comments":true,"path":"2019/09/25/工具类/33.commons-io工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/25/%E5%B7%A5%E5%85%B7%E7%B1%BB/33.commons-io%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"commons-io工具类 Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。作用：提高IO流的开发效率。 1，IOUtils（数据相关）拷贝方法：copy方法有多个重载方法，满足不同的输入输出流 IOUtils.copy(InputStream input, OutputStream output) IOUtils.copy(InputStream input, OutputStream output, int bufferSize)&#x2F;&#x2F;可指定缓冲区大小 IOUtils.copy(InputStream input, Writer output, String inputEncoding)&#x2F;&#x2F;可指定输入流的编码表 IOUtils.copy(Reader input, Writer output) IOUtils.copy(Reader input, OutputStream output, String outputEncoding)&#x2F;&#x2F;可指定输出流的编码表 拷贝大文件的方法：&#x2F;&#x2F; 这个方法适合拷贝较大的数据流，比如2G以上 IOUtils.copyLarge(Reader input, Writer output) &#x2F;&#x2F; 默认会用1024*4的buffer来读取 IOUtils.copyLarge(Reader input, Writer output, char[] buffer)&#x2F;&#x2F;可指定缓冲区大小 将输入流转换成字符串IOUtils.toString(Reader input) IOUtils.toString(byte[] input, String encoding) IOUtils.toString(InputStream input, Charset encoding) IOUtils.toString(InputStream input, String encoding) IOUtils.toString(URI uri, String encoding) IOUtils.toString(URL url, String encoding) 将输入流转换成字符数组IOUtils.toByteArray(InputStream input) IOUtils.toByteArray(InputStream input, int size) IOUtils.toByteArray(URI uri) IOUtils.toByteArray(URL url) IOUtils.toByteArray(URLConnection urlConn) IOUtils.toByteArray(Reader input, String encoding) 字符串读写IOUtils.readLines(Reader input) IOUtils.readLines(InputStream input, Charset encoding) IOUtils.readLines(InputStream input, String encoding) IOUtils.writeLines(Collection&lt;?&gt; lines, String lineEnding, Writer writer) IOUtils.writeLines(Collection&lt;?&gt; lines, String lineEnding, OutputStream output, Charset encoding) IOUtils.writeLines(Collection&lt;?&gt; lines, String lineEnding, OutputStream output, String encoding) 从一个流中读取内容IOUtils.read(InputStream input, byte[] buffer) IOUtils.read(InputStream input, byte[] buffer, int offset, int length) IOUtils.read(Reader input, char[] buffer) IOUtils.read(Reader input, char[] buffer, int offset, int length) 把数据写入到输出流中IOUtils.write(byte[] data, OutputStream output) IOUtils.write(byte[] data, Writer output, Charset encoding) IOUtils.write(byte[] data, Writer output, String encoding) IOUtils.write(char[] data, Writer output) IOUtils.write(char[] data, OutputStream output, Charset encoding) IOUtils.write(char[] data, OutputStream output, String encoding) IOUtils.write(String data, Writer output) IOUtils.write(CharSequence data, Writer output) 从一个流中读取内容，如果读取的长度不够，就会抛出异常IOUtils.readFully(InputStream input, int length) IOUtils.readFully(InputStream input, byte[] buffer) IOUtils.readFully(InputStream input, byte[] buffer, int offset, int length) IOUtils.readFully(Reader input, char[] buffer) IOUtils.readFully(Reader input, char[] buffer, int offset, int length) 比较IOUtils.contentEquals(InputStream input1, InputStream input2) &#x2F;&#x2F; 比较两个流是否相等 IOUtils.contentEquals(Reader input1, Reader input2) IOUtils.contentEqualsIgnoreEOL(Reader input1, Reader input2) &#x2F;&#x2F; 比较两个流，忽略换行符 其他方法IOUtils.skip(InputStream input, long toSkip) &#x2F;&#x2F; 跳过指定长度的流 IOUtils.skip(Reader input, long toSkip) IOUtils.skipFully(InputStream input, long toSkip) &#x2F;&#x2F; 如果忽略的长度大于现有的长度，就会抛出异常 IOUtils.skipFully(Reader input, long toSkip) 2，FileUtils（文件&#x2F;文件夹相关）复制文件夹FileUtils.copyDirectory(File srcDir, File destDir) &#x2F;&#x2F; 复制文件夹（文件夹里面的文件内容也会复制） FileUtils.copyDirectory(File srcDir, File destDir, FileFilter filter) &#x2F;&#x2F; 复制文件夹，带有文件过滤功能 FileUtils.copyDirectoryToDirectory(File srcDir, File destDir) &#x2F;&#x2F; 以子目录的形式将文件夹复制到到另一个文件夹下 复制文件FileUtils.copyFile(File srcFile, File destFile) &#x2F;&#x2F; 复制文件 FileUtils.copyFile(File input, OutputStream output) &#x2F;&#x2F; 复制文件到输出流 FileUtils.copyFileToDirectory(File srcFile, File destDir) &#x2F;&#x2F; 复制文件到一个指定的目录 FileUtils.copyInputStreamToFile(InputStream source, File destination) &#x2F;&#x2F; 把输入流里面的内容复制到指定文件 FileUtils.copyURLToFile(URL source, File destination) &#x2F;&#x2F; 把URL 里面内容复制到文件(可以下载文件) FileUtils.copyURLToFile(URL source, File destination, int connectionTimeout, int readTimeout) 把字符串写入文件FileUtils.writeStringToFile(File file, String data, String encoding) FileUtils.writeStringToFile(File file, String data, String encoding, boolean append) 把字节数组写入文件FileUtils.writeByteArrayToFile(File file, byte[] data) FileUtils.writeByteArrayToFile(File file, byte[] data, boolean append) FileUtils.writeByteArrayToFile(File file, byte[] data, int off, int len) FileUtils.writeByteArrayToFile(File file, byte[] data, int off, int len, boolean append) 把集合里面的内容写入文件&#x2F;&#x2F; encoding：文件编码，lineEnding：每行以什么结尾 FileUtils.writeLines(File file, Collection&lt;?&gt; lines) FileUtils.writeLines(File file, Collection&lt;?&gt; lines, boolean append) FileUtils.writeLines(File file, Collection&lt;?&gt; lines, String lineEnding) FileUtils.writeLines(File file, Collection&lt;?&gt; lines, String lineEnding, boolean append) FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines) FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines, boolean append) FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines, String lineEnding) FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines, String lineEnding, boolean append) 往文件里面写内容FileUtils.write(File file, CharSequence data, Charset encoding) FileUtils.write(File file, CharSequence data, Charset encoding, boolean append) FileUtils.write(File file, CharSequence data, String encoding) FileUtils.write(File file, CharSequence data, String encoding, boolean append) 文件移动FileUtils.moveDirectory(File srcDir, File destDir) &#x2F;&#x2F; 文件夹在内的所有文件都将移动FileUtils.moveDirectoryToDirectory(File src, File destDir, boolean createDestDir) &#x2F;&#x2F; 以子文件夹的形式移动到另外一个文件下 FileUtils.moveFile(File srcFile, File destFile) &#x2F;&#x2F; 移动文件 FileUtils.moveFileToDirectory(File srcFile, File destDir, boolean createDestDir) &#x2F;&#x2F; 以子文件的形式移动到另外一个文件夹下 FileUtils.moveToDirectory(File src, File destDir, boolean createDestDir) &#x2F;&#x2F; 移动文件或者目录到指定的文件夹内 清空和删除文件夹FileUtils.deleteDirectory(File directory) &#x2F;&#x2F; 删除文件夹，包括文件夹和文件夹里面所有的文件 FileUtils.cleanDirectory(File directory) &#x2F;&#x2F; 清空文件夹里面的所有的内容 FileUtils.forceDelete(File file) &#x2F;&#x2F; 删除，会抛出异常 FileUtils.deleteQuietly(File file) &#x2F;&#x2F; 删除，不会抛出异常 创建文件夹FileUtils.forceMkdir(File directory) &#x2F;&#x2F; 创建文件夹(可创建多级) FileUtils.forceMkdirParent(File file) &#x2F;&#x2F; 创建文件的父级目录 获取文件输入&#x2F;输出流FileUtils.openInputStream(File file) FileUtils.openOutputStream(File file) 读取文件FileUtils.readFileToByteArray(File file) &#x2F;&#x2F; 把文件读取到字节数组 FileUtils.readFileToString(File file, Charset encoding) &#x2F;&#x2F; 把文件读取成字符串 FileUtils.readFileToString(File file, String encoding) FileUtils.readLines(File file, Charset encoding) &#x2F;&#x2F; 把文件读取成字符串集合 FileUtils.readLines(File file, String encoding) 测试两个文件的修改时间FileUtils.isFileNewer(File file, Date date) FileUtils.isFileNewer(File file, File reference) FileUtils.isFileNewer(File file, long timeMillis) FileUtils.isFileOlder(File file, Date date) FileUtils.isFileOlder(File file, File reference) FileUtils.isFileOlder(File file, long timeMillis) 文件&#x2F;文件夹的迭代FileUtils.iterateFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) FileUtils.iterateFiles(File directory, String[] extensions, boolean recursive) FileUtils.iterateFilesAndDirs(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) FileUtils.lineIterator(File file) FileUtils.lineIterator(File file, String encoding) FileUtils.listFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) FileUtils.listFiles(File directory, String[] extensions, boolean recursive) FileUtils.listFilesAndDirs(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) 其他FileUtils.isSymlink(File file) &#x2F;&#x2F; 判断是否是符号链接 FileUtils.directoryContains(File directory, File child) &#x2F;&#x2F; 判断文件夹内是否包含某个文件或者文件夹 FileUtils.sizeOf(File file) &#x2F;&#x2F; 获取文件或者文件夹的大小 FileUtils.getTempDirectory()&#x2F;&#x2F; 获取临时目录文件 FileUtils.getTempDirectoryPath()&#x2F;&#x2F; 获取临时目录路径 FileUtils.getUserDirectory()&#x2F;&#x2F; 获取用户目录文件 FileUtils.getUserDirectoryPath()&#x2F;&#x2F; 获取用户目录路径 FileUtils.touch(File file) &#x2F;&#x2F; 创建文件 FileUtils.contentEquals(File file1, File file2) &#x2F;&#x2F; 比较两个文件内容是否相同 FilenameUtils（文件名&#x2F;后缀名相关）FilenameUtils.concat(String basePath, String fullFilenameToAdd) &#x2F;&#x2F; 合并目录和文件名为文件全路径 FilenameUtils.getBaseName(String filename) &#x2F;&#x2F; 去除目录和后缀后的文件名 FilenameUtils.getExtension(String filename) &#x2F;&#x2F; 获取文件的后缀 FilenameUtils.getFullPath(String filename) &#x2F;&#x2F; 获取文件的目录 FilenameUtils.getName(String filename) &#x2F;&#x2F; 获取文件名 FilenameUtils.getPath(String filename) &#x2F;&#x2F; 去除盘符后的路径 FilenameUtils.getPrefix(String filename) &#x2F;&#x2F; 盘符 FilenameUtils.indexOfExtension(String filename) &#x2F;&#x2F; 获取最后一个.的位置 FilenameUtils.indexOfLastSeparator(String filename) &#x2F;&#x2F; 获取最后一个&#x2F;的位置 FilenameUtils.normalize(String filename) &#x2F;&#x2F; 获取当前系统格式化路径 FilenameUtils.removeExtension(String filename) &#x2F;&#x2F; 移除文件的扩展名 FilenameUtils.separatorsToSystem(String path) &#x2F;&#x2F; 转换分隔符为当前系统分隔符 FilenameUtils.separatorsToUnix(String path) &#x2F;&#x2F; 转换分隔符为linux系统分隔符 FilenameUtils.separatorsToWindows(String path) &#x2F;&#x2F; 转换分隔符为windows系统分隔符 FilenameUtils.equals(String filename1, String filename2) &#x2F;&#x2F; 判断文件路径是否相同，非格式化 FilenameUtils.equalsNormalized(String filename1, String filename2) &#x2F;&#x2F; 判断文件路径是否相同，格式化 FilenameUtils.directoryContains(String canonicalParent, String canonicalChild) &#x2F;&#x2F; 判断目录下是否包含指定文件或目录 FilenameUtils.isExtension(String filename, String extension) &#x2F;&#x2F; 判断文件扩展名是否包含在指定集合(数组、字符串)中 FilenameUtils.wildcardMatch(String filename, String wildcardMatcher) &#x2F;&#x2F; 判断文件扩展名是否和指定规则匹配 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"41.集合进阶-08-TreeSet详解","slug":"java基础/41.集合进阶-08-TreeSet详解","date":"2019-09-24T23:13:00.000Z","updated":"2024-06-28T09:08:59.726Z","comments":true,"path":"2019/09/25/java基础/41.集合进阶-08-TreeSet详解/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/41.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-08-TreeSet%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"TreeSet详解 一、TreeSet TreeSet集合，底层是红黑树结构 ★★★存入treeSet中的元素，遍历出来，默认就是按照从小到大来排序的。★★★ 1.存数值类型，然后遍历，默认就是从小到大遍历出来的。 2.存字符串，是按照字符在ASCII码表中的数字升序进行排序的 如果说字符串中的字符比较多，它是从字符串首字母按个比较的，此时和字符串的长度没有关系。例如”aaa”,”ab”,”aba” 从小到大遍历出来。它相比较前两个字符串的首字母a,一样就 再比较第二位的字母，b&gt;a 直接确定了大小关系，后面所有字母不再看了。随后进行第二个字符串和第三个字符串的比较。 3.存入自定义对象类型，该怎么比较呢？ 因为treeSet集合底层是红黑树，所以其内部自定义对象，不用再重写hashCode和equals方法。用不到哈希值。 但是，要比较两个自定义对象，得指定某个属性来比较。 TreeSet的两种比较方式 第一种 自定义类 实现Comparable接口：指定比较规则 第二种 比较器排序 使用原则：默认使用第一种，如果第一种不能满足当前需求，就是用第二种。练习123456789101112/** *学生的比较规则 *按照总分从高到低输出到控制台 *如果总分一·样，按照语文成绩排 *如果语文一样，按照数学成绩排 *如果数学成绩一样，按照英语成绩排 *如果英文成绩一样，按照年龄排 * 如果年龄一样，按照姓名的字母顺序排 *如果都一样，认为是同一个学生，不存。 * * */ © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"40.集合进阶-07-HashSet、LinkedHashSet详解","slug":"java基础/40.集合进阶-07-HashSet、LinkedHashSet详解","date":"2019-09-24T23:12:00.000Z","updated":"2024-06-26T06:33:52.102Z","comments":true,"path":"2019/09/25/java基础/40.集合进阶-07-HashSet、LinkedHashSet详解/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/40.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-07-HashSet%E3%80%81LinkedHashSet%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"HashSet、LinkedHashSet详解 HashSet、LinkedHashSet详解 哈希值 什么是哈希值？ 在java中，对象的整数表现形式，就是将对象进行计算得出来一个整数值 。 哈希值根据什么计算？ 哈希值可以用来判断两个对象是否相等，（不是地址值是否相等，而是对象中的属性值是否相等） 一般两个对象，即使是其属性完全相同，由于是两个对象，他们的地址值肯定不同，他们也必然不可能是同一个对象。 比较两个对象，它们都没有重写Object中的 hashCode方法，那么他们的哈希值就是通过他们的地址值计算得来，肯定是不相同的哈希值。即使是他么的属性值完全相同，他们也不能相等。 所以我们在比较两个对象的时候，在对象里面要重写hashCode方法，使用对象属性来计算哈希值，只要是两个对象的属性值相同，那么他们的哈希值就相等，他们也被判定为相等。（地址值不一样） HashSet底层原理（哈希表） ★★★重写hashCode的目的是：想通过对象的属性值来计算哈希值，而不是地址值计算哈希值★★★ 用来确定对象存放在数组的哪个位置 ★★★重写equals的目的是：想要对象比较的时候，比的也是对象中的属性，而不是对象地址值★★★ 确定了对像的位置，比较对象属性 ★★★只要记住存入到hashSet集合中的自定义对象，都要重写hashCode和equals方法★★★ 因为：Set 是一个不允许重复元素的集合，它使用 hashCode() 和 equals() 方法来判断元素是否相等。如果您不重写这两个方法，Set 将无法正确识别相同内容的自定义对象。 LinkedHashSet © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"39.集合进阶-06-数据结构（红黑树、红黑规则、添加节点处理方案详解）","slug":"java基础/39.集合进阶-06-数据结构（红黑树、红黑规则、添加节点处理方案详解）","date":"2019-09-24T23:11:00.000Z","updated":"2024-12-21T14:00:41.296Z","comments":true,"path":"2019/09/25/java基础/39.集合进阶-06-数据结构（红黑树、红黑规则、添加节点处理方案详解）/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/39.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E8%A7%84%E5%88%99%E3%80%81%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3%EF%BC%89/","excerpt":"","text":"红黑树、红黑规则、添加节点处理方案 红黑树、红黑规则、添加节点处理方案 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"38.集合进阶-05数据结构（平衡二叉树旋转机制）","slug":"java基础/38.集合进阶-05数据结构（平衡二叉树旋转机制）","date":"2019-09-24T23:10:00.000Z","updated":"2024-12-21T13:59:04.290Z","comments":true,"path":"2019/09/25/java基础/38.集合进阶-05数据结构（平衡二叉树旋转机制）/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/38.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-05%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC%E6%9C%BA%E5%88%B6%EF%BC%89/","excerpt":"","text":"（平衡二叉树旋转机制） 平衡二叉树为什么会平衡？ 旋转机制 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"37.集合进阶-04-数据结构(二叉树,二叉查找树,平衡二叉树)","slug":"java基础/37.集合进阶-04-数据结构(二叉树,二叉查找树,平衡二叉树)","date":"2019-09-24T23:09:00.000Z","updated":"2024-12-21T13:54:14.970Z","comments":true,"path":"2019/09/25/java基础/37.集合进阶-04-数据结构(二叉树,二叉查找树,平衡二叉树)/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/37.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C%E5%8F%89%E6%A0%91,%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91,%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)/","excerpt":"","text":"数据结构(二叉树,二叉查找树,平衡二叉树) 一、二叉树（二叉查找树为了提高查询效率） 二、二叉查找树的添加原理 三、查找节点 四、所有二叉树的遍历方式 1.前序遍历 2.中序遍历 注意：右子树，从最下面开始 3.后序遍历 4.层序遍历 怎么记？前序遍历，中序遍历，后序遍历 顺序：当前节点-&gt;左子节点-&gt;右子节点 （当前节点 在最前面，前序遍历） 五、二叉查找树的弊端 因为二叉查找树。有这样的弊端，所以就出现了平衡二叉树 六、平衡二叉树 下列不是平衡二叉树 二叉树结构的演变 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"36.集合进阶-03-泛型类、泛型方法、泛型接口","slug":"java基础/36.集合进阶-03-泛型类、泛型方法、泛型接口","date":"2019-09-24T23:08:00.000Z","updated":"2024-06-25T14:22:33.033Z","comments":true,"path":"2019/09/25/java基础/36.集合进阶-03-泛型类、泛型方法、泛型接口/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/36.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-03-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"泛型类、泛型方法、泛型接口 一、泛型是什么 ArrayList strs&#x3D;new ArrayList&lt;&gt;(); 这里面的尖括号 ,就是指泛型. 说白了，就是用来限定集合中存入数据的类型，不能随便存，只能存泛型指定的类型。 二、为什么要用泛型 因为： 如果我]没有给集合指定类型，默认认为所有的数据类型都是Object类型此时可以往集合添加任意的数据类型。带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。 泛型类 泛型方法 可变形参的写法 泛型接口 泛型的通配符 “?” 泛型的通配符是一个问号： “?” ， © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"35.LIst集合进阶-02-List集合","slug":"java基础/35.LIst集合进阶-02-List集合","date":"2019-09-24T23:06:00.000Z","updated":"2024-06-28T02:51:36.275Z","comments":true,"path":"2019/09/25/java基础/35.LIst集合进阶-02-List集合/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/35.LIst%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-02-List%E9%9B%86%E5%90%88/","excerpt":"","text":"List集合 List接口的实现类一、理解什么是数据结构 数据结构是：计算机存储数据，组织数据的方式 不同的业务场景要选择不同的数据结构（数据多怎么存取，数据少怎么存取） ArrayList 、LinkedList 、Vector 在底层java用到了不同的数据结构，所以说，你不知道数据结构，你根本不知道什么时候用哪种集合。 二、8种数据结构 1. 栈、队列 2. 数组 3.链表 ArrayList 一、ArrayList底层是数组 ArrayList 集合中判断某个元素是否存在 array.contains(元素)； 注意：底层使用的就是equals() 方法,所以在判断自定义对象是否存在，对象要重写equals方法。 包装类 String 和 Integer中都已经重写了equals方法，所以直接拿来用如 indexs.contains(index) LinkedList 迭代器 底层源码 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"34.集合进阶-01-单列集合顶层接口Collection及其遍历方法","slug":"java基础/34.集合进阶-01-单列集合顶层接口Collection及其遍历方法","date":"2019-09-24T23:05:00.000Z","updated":"2024-06-26T08:35:17.614Z","comments":true,"path":"2019/09/25/java基础/34.集合进阶-01-单列集合顶层接口Collection及其遍历方法/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/34.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-01-%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E9%A1%B6%E5%B1%82%E6%8E%A5%E5%8F%A3Collection%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"单列集合顶层接口Collection 单列集合的使用时机： 集合集合分为 ： 单列集合，和双列集合 一、单列集合体系结构 二、collection 集合父接口的通用方法 三、细节 四、Collection这个系列的通用遍历方式（List 系列和Set系列通用的） 1.为什么不能使用之前的普通for循环遍历呢？ 当然List系列集合可以使用for i 循环遍历， 但是set系列集合，没有索引，他就不能通过普通for 来遍历。 2.迭代器遍历 注意点： 通过Collection集合，来获取一个迭代器对象，使用迭代器进行遍历 迭代器不依赖索引的 3.增强for遍历 4.Lambda表达式遍历 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"33.五道经典算法题","slug":"常见算法/33.五道经典算法题","date":"2019-09-24T23:02:00.000Z","updated":"2024-06-23T09:48:44.874Z","comments":true,"path":"2019/09/25/常见算法/33.五道经典算法题/","link":"","permalink":"https://protonlml.github.io/2019/09/25/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/33.%E4%BA%94%E9%81%93%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"","text":"五道经典算法题 五道经典算法题 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"32.lambda表达式","slug":"java基础/32.lambda表达式","date":"2019-09-24T23:01:00.000Z","updated":"2024-06-24T07:02:15.977Z","comments":true,"path":"2019/09/25/java基础/32.lambda表达式/","link":"","permalink":"https://protonlml.github.io/2019/09/25/java%E5%9F%BA%E7%A1%80/32.lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"lambda表达式 一、lambda表达式就是用来（简化匿名内部类的写法） 二、函数式编程 通俗理解：就是代码中，只写实现功能的部分，不new对象，不管创建的对象是谁，只专注于写方法体。 123456789101112** 要记住：出现Lambda 表达式，就是为了简化 匿名内部类的写法** 这个匿名内部类，是有要求的，它是 函数式接口的 匿名内部类。** 函数式接口：指的是只有一个抽象方法的接口。** 为什么只能是一个抽象方法的接口，来实现 Lambda表达式的简化写法?* 因为：（）-&gt;&#123; &#125; Lanbda 表达式 后面的 &#123;&#125; 就表示 方法体。* 这个方法体，如果接口中有两个抽象方法，那么它就不知道* 实现哪一个抽象方法的方法体 三、函数式接口：只有一个抽象方法的接口 四、Lamdba 表达式的 省略写法 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"32.Collections 集合 工具类","slug":"工具类/32.Collections 集合 工具类","date":"2019-09-24T23:01:00.000Z","updated":"2024-06-27T23:11:10.361Z","comments":true,"path":"2019/09/25/工具类/32.Collections 集合 工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/25/%E5%B7%A5%E5%85%B7%E7%B1%BB/32.Collections%20%E9%9B%86%E5%90%88%20%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Collections 集合 工具类 Collections 集合 工具类 binarySearch 的使用细节 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"31.Arrays 数组 工具类","slug":"工具类/31.Arrays工具类","date":"2019-09-24T23:00:00.000Z","updated":"2024-06-27T10:10:27.746Z","comments":true,"path":"2019/09/25/工具类/31.Arrays工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/25/%E5%B7%A5%E5%85%B7%E7%B1%BB/31.Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Arrays工具类（数组工具类） Arrays工具类（数组工具类） Arrays.asList() 方法的详解 1.要点】该方法是将数组转化成List集合的方法。其长度是不可变的，不能使用add方法 List list &#x3D; Arrays.asList(“a”,”b”,”c”); 注意： （1）该方法适用于对象型数据的数组（String、Integer…） （2）该方法不使用于基本数据类型的数组（byte,short,int,long,float,double,boolean） （3）该方法将数组与List列表链接起来：当更新其一个时，另一个自动更新 （4）不支持add()、remove()、clear()等方法 注意：参数必须是对象或者对象数组Arrays.asList()的参数必须是对象或者对象数组错误做法：使用基础类型 12345int[] it = &#123;1,2,3&#125;;List&lt;int[]&gt; ints = Arrays.asList(it);System.out.println(ints); 输出为[[I@59f95c5d] 正确做法：使用int的包装类Integer 12345Integer[] it = &#123;1,2,3&#125;;List&lt;Integer&gt; ints = Arrays.asList(it);System.out.println(ints); 输出为[1, 2, 3] 2.Arrays.asList()是个坑 用此方法得到的List的长度是不可改变的， 当你向这个List添加或删除一个元素时（例如 list.add(“d”);）程序就会抛出异常（java.lang.UnsupportedOperationException）。 怎么会这样？只需要看看asList()方法是怎么实现的就行了： public static List asList(T… a) {return new ArrayList&lt;&gt;(a);} 当你看到这段代码时可能觉得没啥问题啊，不就是返回了一个ArrayList对象吗？问题就出在这里。 这个ArrayList不是java.util包下的，而是java.util.Arrays.ArrayList 它是Arrays类自己定义的一个静态内部类，这个内部类没有实现add()、remove()方法，而是直接使用它的父类AbstractList的相应方法。 而AbstractList中的add()和remove()是直接抛出java.lang.UnsupportedOperationException异常的！ public void add(int index, E element) { throw new UnsupportedOperationException();} public E remove(int index) {throw new UnsupportedOperationException();} 总结：如果你的List只是用来遍历，就用Arrays.asList()。 如果你的List还要添加或删除元素，还是乖乖地new一个java.util.ArrayList，然后一个一个的添加元素 数组排序 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"30.常见算法05(快速排序)","slug":"常见算法/30.常见算法05(快速排序)","date":"2019-09-24T14:51:00.000Z","updated":"2024-06-23T09:31:05.524Z","comments":true,"path":"2019/09/24/常见算法/30.常见算法05(快速排序)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/30.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9505(%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)/","excerpt":"","text":"常见算法05 30.常见算法05(快速排序) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"29.常见算法04(插入排序、递归算法)","slug":"常见算法/29.常见算法04(插入排序、递归算法)","date":"2019-09-24T14:50:00.000Z","updated":"2024-06-23T09:30:28.058Z","comments":true,"path":"2019/09/24/常见算法/29.常见算法04(插入排序、递归算法)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/29.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9504(%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95)/","excerpt":"","text":"常见算法04 29.常见算法04(插入排序、递归算法) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"28.常见算法03(冒泡排序、选择排序)","slug":"常见算法/28.常见算法03(冒泡排序、选择排序)","date":"2019-09-24T14:49:00.000Z","updated":"2024-06-23T09:29:44.510Z","comments":true,"path":"2019/09/24/常见算法/28.常见算法03(冒泡排序、选择排序)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/28.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9503(%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)/","excerpt":"","text":"常见算法03 常见算法03(冒泡排序、选择排序) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"27. 常见算法02(分块、分块扩展、哈希查找)","slug":"常见算法/27.常见算法02(分块、分块扩展、哈希查找)","date":"2019-09-24T14:48:00.000Z","updated":"2024-06-23T09:29:39.775Z","comments":true,"path":"2019/09/24/常见算法/27.常见算法02(分块、分块扩展、哈希查找)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/27.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9502(%E5%88%86%E5%9D%97%E3%80%81%E5%88%86%E5%9D%97%E6%89%A9%E5%B1%95%E3%80%81%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE)/","excerpt":"","text":"常见算法02 常见算法02(分块、分块扩展、哈希查找) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"26.常见算法01(基本、二分、插值、斐波那契查找)","slug":"常见算法/26.常见算法01(基本、二分、插值、斐波那契查找)","date":"2019-09-24T14:47:00.000Z","updated":"2024-06-23T09:29:34.820Z","comments":true,"path":"2019/09/24/常见算法/26.常见算法01(基本、二分、插值、斐波那契查找)/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/26.%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%9501(%E5%9F%BA%E6%9C%AC%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E6%8F%92%E5%80%BC%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE)/","excerpt":"","text":"常见算法01 (基本、二分、插值、斐波那契查找) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}],"author":"𝚲𝚳𝚲"},{"title":"25.包装类","slug":"java基础/25.包装类","date":"2019-09-24T14:46:00.000Z","updated":"2024-06-23T02:56:06.801Z","comments":true,"path":"2019/09/24/java基础/25.包装类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/25.%E5%8C%85%E8%A3%85%E7%B1%BB/","excerpt":"","text":"包装类 包装类一、什么是包装类 二、为什么使用包装类 因为：再java中，万事万物皆对象，方法的参数如果是Object，那么 基本数据类型就不能传进来。有局限性，其次是，多态性。 集合中也只能存储对象，不能存储基本数据类型。 注意点： 自动装箱，自动拆箱： 总结 三、Integer 包装类的 成员方法 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"24.Date时间相关类","slug":"工具类/24.时间相关类","date":"2019-09-24T14:43:00.000Z","updated":"2024-06-23T02:13:19.901Z","comments":true,"path":"2019/09/24/工具类/24.时间相关类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B7%A5%E5%85%B7%E7%B1%BB/24.%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB/","excerpt":"","text":"时间相关类 JDK7以前时间相关类一、Date (时间类) 1.空参创建Date，直接打印 2.有参数创建date，打印指定时间（时间原点） 3.getTime &amp; setTime 二、 SimpleDateFormat SimpleDateFormat 的使用 格式化： 解析： 三、Calendar 日历对象 JDK8新增时间相关类一、 二、JDK8新增的时间类 1. ZoneId 时区类 2.Instant时间戳类 3.ZoneDateTime 带时区的时间类 4.DateTimeFormatter时间格式化和解析 5.LocalDate、LocalTime、LocalDateTime日历类 三个对象的获取方式 判断今天是不是你生日 判断是闰年还是平年 6. Duration、Period、ChronoUnit（时间间隔对象） Period 对象 计算 （年月日）之间的时间间隔（了解） Duration对象 计算 （年月日时分秒）之间的时间间隔（了解） ChronoUnit对象 计算 （两个日期）间隔（掌握常用）所有的都能计算出来 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"23.正则表达式","slug":"工具类/23.正则表达式","date":"2019-09-24T14:41:00.000Z","updated":"2024-06-20T00:55:50.778Z","comments":true,"path":"2019/09/24/工具类/23.正则表达式/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B7%A5%E5%85%B7%E7%B1%BB/23.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式 一、校验字符串 工作中怎么使用 1.IDEA中下载插件any-rule 2.在代码中，定义一个字符串，然后右键使用 二、在一段文本中，查找满足要求的内容（爬虫） 使用到两个对象 1.Pattern(正则表达式对象) 2.Matcher（文本匹配器对象） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"22.Biglnteger 和BigDecimal","slug":"工具类/22.Biglnteger 和BigDecimal","date":"2019-09-24T14:40:00.000Z","updated":"2024-06-19T22:26:30.654Z","comments":true,"path":"2019/09/24/工具类/22.Biglnteger 和BigDecimal/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B7%A5%E5%85%B7%E7%B1%BB/22.Biglnteger%20%E5%92%8CBigDecimal/","excerpt":"","text":"Biglnteger 和BigDecimal Biglnteger (大整数)（取值范围大）为什么要有BigInteger? 一、BigInteger构造方法创建对象 1. 随机获取一个大整数，构造参数为(num ,random) 结果为[0~ 2^num-1] ![image-20240620031429030](22.Biglnteger 和BigDecimal.assets&#x2F;image-20240620031429030.png) 2.获取一个指定的大整数（常用） 3.获取一个指定进制的大整数（了解） 4.静态方法 获取BigIntegerl的对象,内部有优化（在Long类型范围内常用） 5.对象一旦创建内部的数据不能发生改变 二、BigInteger常见的成员方法（用来计算的） ![image-20240620034732920](22.Biglnteger 和BigDecimal.assets&#x2F;image-20240620034732920.png) BigDecimal（大小数）（取值范围大）为什么要有BigDecimal? 我们为了精确计算，就要使用这个BigDecimal对象 用来表示很大的小数 一、BigDecimal构造方法创建对象 1.使用 参数为double 的 构造方法创建（不推荐） 细节： 这种方式可能是不精确的，所以不建议使用 2.使用参数为string的 构造方法（推荐）非常精确 细节：放心用，非常精确 3. 通过静态方法获取对象 细节： 1.如果要表示的数字不大,没有超出doub1e的取值范围,建议使用静态方法 2.如果要表示的数字比较大,超出了double的取值范围,建议使用String参数的构造方法 3.如果我们传递的是0~10之间的整数,包含0,包含10,那么方法会返回已经创建好的对象,不会重新new ![image-20240620042153353](22.Biglnteger 和BigDecimal.assets&#x2F;image-20240620042153353.png) 二、BigDecimal常见的成员方法（用来计算的） 注意：使用divide 来进行数据的除运算，如果不指定取几位小数，以及舍入模式的话，如果除不整是会报错的。所以我们一般除运算，会给全部参数的。 三、BigDecimal底层存储方式 总结 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"21.Object 和 Objects","slug":"工具类/21.Object和Objects","date":"2019-09-24T14:38:00.000Z","updated":"2024-06-19T18:59:45.629Z","comments":true,"path":"2019/09/24/工具类/21.Object和Objects/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B7%A5%E5%85%B7%E7%B1%BB/21.Object%E5%92%8CObjects/","excerpt":"","text":"Object 和 Objects Object Object类是java中所有对象的父亲，每个类都默认继承ObjectObject 中没有属性值，因为定义父类，就是为了抽取子类共有的属性以及方法，所以作为顶级父类，没法写属性值Object 中只有空参构造器，因为其没有属性，所有子类都有空参构造器，就是重写的Object的 内部有隐藏的super();Object 中的tostring() 方法查看源码就是打印的对象地址值。子类要想展示属性，只有在子类内部重写tostring()方法 注意：Object 中的克隆是浅克隆，只要原来的对象中的属性值改变了，则克隆后的对象中属性值也会被改变。总结 Objects © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"19.System工具类","slug":"工具类/19.System工具类","date":"2019-09-24T14:36:00.000Z","updated":"2024-06-19T08:47:09.806Z","comments":true,"path":"2019/09/24/工具类/19.System工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B7%A5%E5%85%B7%E7%B1%BB/19.System%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"System工具类 System 类 拷贝数组，注意的细节 总结 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"20.Runtime工具类","slug":"工具类/20.Runtime工具类","date":"2019-09-24T14:36:00.000Z","updated":"2024-06-19T15:12:38.391Z","comments":true,"path":"2019/09/24/工具类/20.Runtime工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B7%A5%E5%85%B7%E7%B1%BB/20.Runtime%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Runtime工具类 Runtime类需要用到java代码，来监控虚拟机的内存时，使用这个类 表示当前虚拟机的运行环境（它是单例的）外界不能创建多个，只能创建一个。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"18.Math工具类","slug":"工具类/18.Math工具类","date":"2019-09-24T14:35:00.000Z","updated":"2024-07-04T14:10:26.614Z","comments":true,"path":"2019/09/24/工具类/18.Math工具类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/%E5%B7%A5%E5%85%B7%E7%B1%BB/18.Math%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Math工具类 Math 类 1.是一个帮助我们用于进行数学计算的工具类 2.类是final 修饰 表示最终类，不能被继承。私有构造方法（在外界不能创建），所有的成员方法都是静态的（外界使用类名调用） 常用方法 int 的 取值范围 -2147483648~2147483647 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"author":"𝚲𝚳𝚲"},{"title":"17.内部类","slug":"java基础/17.内部类","date":"2019-09-24T14:30:00.000Z","updated":"2024-12-17T11:53:10.470Z","comments":true,"path":"2019/09/24/java基础/17.内部类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/17.%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"内部类 一、概念 一、成员内部类1.成员内部类的代码如何书写（如下和成员变量是一个级别的） 2.如何创建成员内部类的对象 3.成员内部类如何获取外部类的成员变量 二、静态内部类 静态内部类只能访问外部类中的静态变量和静态方法, 静态内部类,其里面如果想要访问外部类中的非静态,需要在内部创建外部类对象 总结 三、局部内部类 四、匿名内部类 注意：匿名内部类作为参数，匿名内部类中重写的方法，会自动执行 在 Java 中，当匿名内部类作为参数传递时，它会立即执行匿名内部类中的方法。这是因为匿名内部类在创建时就会实例化，并且在方法调用时直接传递这个实例。方法在接收到这个匿名内部类实例后，会调用其实现的方法。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"15.抽象类","slug":"java基础/15.抽象类","date":"2019-09-24T14:00:00.000Z","updated":"2024-06-18T06:10:52.145Z","comments":true,"path":"2019/09/24/java基础/15.抽象类/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/15.%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"抽象类 一、概念1.把子类共性的方法，抽取到父类中之后，但是每个子类执行这个方法的方法体内容又是不一样的，（方法体不能确定）之前是每个子类重写这个方法，实现功能，有弊端，子类不重写这个方法也能调用就可能产生错误。2.所以我们将抽取到父类中的共性方法，只定义方法名，不写方法体，这个就是抽象方法。3.抽象方法，所在的类，就叫抽象类4.在继承父类之后的子类，必须实现抽象方法，不实现会报错。 二、抽象类的定义 三、注意事项 总结：父类中的抽象方法，强制了在子类创建时，用统一的格式来重写这个抽象方法，目的是，让每个子类的这个方法都是统一的，在调用的时候很方便，不用再去每个子类中，找每个此功能方法的名称。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"16.接口","slug":"java基础/16.接口","date":"2019-09-24T14:00:00.000Z","updated":"2024-07-06T16:01:20.651Z","comments":true,"path":"2019/09/24/java基础/16.接口/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/16.%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口 一、概念 接口就是将行为抽象出去，所有的类都可以实现其中的方法，好比游泳这个行为，人可以游，动物也可以游泳。可以多实现而抽象类，是同一种类别的对象，将共同方法抽象到父类抽象类中。只能单继承。 抽象类，都是指父类，抽取子类共同的方法，定义为抽象方法。子类实现重写。抽象方法所在的类就是抽象类接口：就是一种规则，它把一些方法抽象出去，谁要用，谁就来实现这个接口，对其内部的方法进行重写接口：其实也是对方法名进行规范，项目中有很多类，都可以去实现接口，每个类实现了接口中的方法，名称是一样的，将来不管是哪个对象来调用（这个接口任意的实现类，的实现方法，名称都是统一的。） 二、接口的定义和使用 三、接口中成员的特点 四、接口和类之间的关系 接口拓展一、JDK8开始接口中新增的方法、 1.默认方法 为什么要在接口中定义 默认方法因为：接口会有升级，在后续的开发中，接口中的抽象方法会越来越多，只要接口中发生了变化，那么所有的实现类就不得不来跟着去改变。对于已经实现的很多实现类，都要修改无疑是很麻烦的事情。所以：在接口中定义一个默认方法，其所有的实现类，都可以直接调用，不需要重写。 2.静态方法 接口中的静态方法，只与当前接口有关系，是不能够被其实现类重写的，调用也是通过接口来调用的 3.JDK9在接口中可以写私有方法 a.接口中为什么会有私有方法？ 起因：在接口中，我们定义了一些默认的方法，但是有些默认方法中有重复代码，我们就想在接口中提取出来一个方法来写这些重发代码。这些重复代码又仅仅是接口内部为default修饰的默认方法服务的。不想被外界使用。所以加了个private 修饰 b.私有方法有两种： 私有方法 静态私有方法 二、接口的应用 总结 三、适配器设计模式 总结 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"14.面向对象细节性的知识点","slug":"java基础/14.面向对象细节性的知识点","date":"2019-09-24T13:50:00.000Z","updated":"2024-06-18T05:21:21.280Z","comments":true,"path":"2019/09/24/java基础/14.面向对象细节性的知识点/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%86%E8%8A%82%E6%80%A7%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"面向对象细节性的知识点 面向对象细节性的知识点 1.对象总结：在java中，一个java文件，一般就写一个class类，一个类就代表一类对象。 2.类中有成员变量，成员方法，以及构造器。 3.有两种类： 一般javaBen 这种类，只是为了描述对象使用，内部不会使用static来修饰成员变量，或者成员方法。 另一种类，就是工具类，里面的成员方法比较多，而且是static修饰的，目的是方便用类进行调用 static 修饰的成员方法，或者成员变量，都是与类相关，随着类加载而加载。 4.类与类之间，可以实现单继承，多层继承。 子类继承父类中所有公有的成员变量以及成员方法，子类都可以使用。子类还有自己的方法，这样子类的功能就变强大了。 子类中，如果定义了与父类中相同的方法，那么就称子类中，对该方法进行了重写。（这就是方法重写）目的是个性化子类当前方法功能 5.有了继承，那么就有很多类，共同继承同一个父类，此时就形成一种关系叫做多态 多态：目的是，在某个方法形式参数中，使用一类对象，来进行调用。参数可以使用父类来充当。只要继承了当前这个父类，那么其子类都能赋值于这某个方法形参上面进行使用 包一、什么是包 二、总结 final关键字一、final 修饰，方法，类，变量 权限修饰符 代码块代码块：局部代码块，构造代码块，静态代码块一、局部代码块（淘汰了，了解） 1.局部代码就是写在方法里面的一对单独的 { } 2.本质的作用就是节约内存 二、构造代码块（淘汰了，了解） 1.构造代码块，就是在类中，写在成员位置的代码块，当我们创建本类对象时，会优先于构造方法执行。 2. 将多个构造方法中，重复的代码，写在构造代码块中（弊端：每次创建本类对象，都会执行一次，有局限性） 三、静态代码块 当一个类被加载时，静态代码块会被执行。这个过程通常在首次创建类的实例之前发生，或者在访问类的静态成员变量或静态方法之前发生。静态代码块可以用来初始化静态成员变量，执行静态方法，加载静态资源，或者进行其他静态的初始化操作。 静态代码块的特点 执行顺序：静态代码块在类被加载时执行，按照它们在类中出现的顺序执行。如果一个类中有多个静态代码块，它们会按照在源代码中的顺序依次执行。 只执行一次：静态代码块只会执行一次，即使类被加载多次也是如此。这意味着静态代码块中的代码在整个应用程序的生命周期中只会执行一次。 访问权限：静态代码块可以访问类的静态成员变量和静态方法，但是不能直接访问非静态成员变量和非静态方法。非静态成员变量和非静态方法只有在类的实例被创建后才能被访问。 异常处理：静态代码块中的异常可以通过捕获并处理来防止类加载失败。如果静态代码块中发生了异常，并且没有被处理，类加载过程将被终止，导致类加载失败。 总结： © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"13.多态","slug":"java基础/13.多态","date":"2019-09-24T13:40:00.000Z","updated":"2024-06-18T08:57:53.199Z","comments":true,"path":"2019/09/24/java基础/13.多态/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/13.%E5%A4%9A%E6%80%81/","excerpt":"","text":"多态 面向对象三大特征封装 继承 多态 一、什么是多态 多态：父类的引用，指向子类的对象 二、多态调用成员的特点 三、多态的优势与弊端 多态的弊端 就是 不能使用子类中特有的方法（因为使用的是父类的引用，创建的子类对象，调用方法时，用的是父引用 在父类中找成员变量，和找 子类重写的成员方法） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"12.继承","slug":"java基础/12.继承","date":"2019-09-24T13:30:00.000Z","updated":"2024-06-18T08:59:05.889Z","comments":true,"path":"2019/09/24/java基础/12.继承/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/12.%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承 面向对象三大特征封装 继承 多态 一、封装 二、什么时继承，继承有哪些好处 注意： 三、继承的特点 注意：一个父类中所有的子类，需要是同一种事物 四、子类到底能继承父类中的哪些内容 五、继承中：成员变量的访问特点 六、继承中：成员方法的访问特点 七、方法的重写&#x3D;&#x3D;当父类方法，不能满足子类现在的需求时，需要进行方法重写&#x3D;&#x3D; 八、继承中：构造方法的访问特点 创建对象的时候，给其属性设置默认值（使用构造器来设置） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"11.static静态关键字","slug":"java基础/11.static静态变量","date":"2019-09-24T12:30:00.000Z","updated":"2024-07-04T17:15:15.229Z","comments":true,"path":"2019/09/24/java基础/11.static静态变量/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/11.static%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/","excerpt":"","text":"static静态关键字 一、在类中，对成员变量进行修饰（静态变量） 例如： 学生对象，创建student的类时，可以将 teacherName 设置为 静态的，因为其所有的student的teacherName 是一样的 在Java中，静态成员变量（也称为类变量）是属于类的，而不是任何特定实例的。这意味着无论创建了多少个类的实例（或对象），静态变量只有一份副本，所有的实例都共享这个变量。 这是因为静态变量在类加载时就被初始化，存储在Java的方法区内，而不是与类的每个实例一起存储在堆内存中。因此，无论创建多少个对象，静态变量都只占用一份内存空间，所有对象都可以访问它。 这就是为什么Java类中的静态成员变量是所有对象共享的原因。这种特性使得静态变量非常适合在需要所有对象共享相同信息的情况下使用，例如计数器、常量或配置信息等。但是，需要注意的是，由于所有对象共享静态变量，所以一个对象对静态变量的修改会影响到所有其他对象。因此，在使用静态变量时需要谨慎处理。 二、在类中，对成员方法进行修饰（静态方法）static修饰的成员变量，或者成员方法，因为其都使用了static 关键字修饰，随着类加载而加载，和某个new出来的对象无关 三、一般我们在javaBen中很少用static修饰，工具类或者测试类中，使用的较多 四、重新认识main方法 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"10.集合","slug":"java基础/10.集合","date":"2019-09-24T12:00:00.000Z","updated":"2024-06-22T02:34:26.384Z","comments":true,"path":"2019/09/24/java基础/10.集合/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/10.%E9%9B%86%E5%90%88/","excerpt":"","text":"集合 一、集合和数组都是存数据的容器 1.集合和数组的区别 数组：长度是固定的，可以存储基本数据类型，也可以存储引用数据类型 集合： 长度是可变的，只能存储引用数据类型。 二、集合的基本操作（增删改查） 对容器类的对象的操作，基本上就是增删改查 1.创建集合对象（&lt;&gt; 中表示泛型） 三、基本数据类型对应的包装类 四、集合综合练习 五、知识点（标号的使用） © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"9.字符串综合练习","slug":"java基础/9.字符串综合练习","date":"2019-09-24T11:00:00.000Z","updated":"2024-06-16T15:08:20.268Z","comments":true,"path":"2019/09/24/java基础/9.字符串综合练习/","link":"","permalink":"https://protonlml.github.io/2019/09/24/java%E5%9F%BA%E7%A1%80/9.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/","excerpt":"","text":"字符串综合练习 一、转换罗马数字 使用到了 string 字符串 转 char[] :方法是toCharArray() 使用到将 char[i] 某个char字符，转为 数字 ：方法使用 Character.getNumericValue(chars[i]); 使用jdk12中 的 switch的写法进行匹配 二、调整字符串 1. © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"8.String字符串","slug":"java基础/8.字符串","date":"2019-09-23T08:00:00.000Z","updated":"2024-07-10T14:46:12.113Z","comments":true,"path":"2019/09/23/java基础/8.字符串/","link":"","permalink":"https://protonlml.github.io/2019/09/23/java%E5%9F%BA%E7%A1%80/8.%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"String字符串 一、字符串构造方法 二、字符串创建方式 0.直接赋值（最常用），这种赋值后，字符串会放在“字符串常量池”，再次声明这个字符串，可以直接复用，节省内存 1.使用字符数组作为参数，构建String 字符串 2.使用，字节码数组作为构造参数 三、字符串的操作 1.字符串的比较（”&#x3D;&#x3D;” 比较的是地址值，”equals”比较的是内容） 注意点：通过Scanner对象，从键盘录入的字符串是 new出来的，放在堆里 2.字符串，提取指定的字符charAt( )方法 3.字符串的截取 subString() 4.字符串转数字（要注意字符串转为数字后的范围大不大） parseInt() 5.判断字符串是不是空字符串 isEmpty() 6. 字符串的替换 replace() 7.contains(“-“)判断字符中存不存在这个“-”字符 7. indexOf(“-“) 找到这个“-”字符的下标 7.substring(0, str2.indexOf(“-“)) 截取从[0,-角标) ：截取0到“-所在角标” 之前的字符串 1234567截取字符串 判断为空，就完美解决了，例如：String str2 = &quot;SJ202203071007&quot;;if (str2.contains(&quot;-&quot;)) &#123; String str3 = str2.substring(0, str2.indexOf(&quot;-&quot;)); System.out.println(&quot;str3=&quot;+ str3);&#125;System.out.println(&quot;str2直接输出=&quot;+ str2); 四、StringBuilder的使用 为什么使用Stringbuilder 只要涉及到字符串的 “拼接”，“替换”，“反转” 就要想到StringBuilder， 而字符串的 “截取subString”，“获取某个字符使用 charAt()”，都是String自身可以做到 五、StringJoiner（拼接字符串使用） 六、总结 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"7.封装","slug":"java基础/7.封装","date":"2019-09-23T02:30:00.000Z","updated":"2024-06-17T07:22:38.471Z","comments":true,"path":"2019/09/23/java基础/7.封装/","link":"","permalink":"https://protonlml.github.io/2019/09/23/java%E5%9F%BA%E7%A1%80/7.%E5%B0%81%E8%A3%85/","excerpt":"","text":"对象的封装 面向对象三大特征封装 继承 多态 一、对象封装 二、对象中 “成员变量”,”成员方法”. 类中的方法叫做成员方法，类中方法外的变量叫做成员变量。类中方法内的变量，是局部变量。 this 关键字 作用：就是用来区分成员变量，与局部变量重名的。 三、构造方法，构造器 四、构造函数私有化 构造方法，被private修饰，进行私有化，那么标志这个类，在外部是不能够被new 出来的。一般的工具类构造函数都是私有化的，为了防止在外部被创建。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"6.面向对象","slug":"java基础/6.面向对象","date":"2019-09-22T06:00:00.000Z","updated":"2024-06-16T02:44:42.211Z","comments":true,"path":"2019/09/22/java基础/6.面向对象/","link":"","permalink":"https://protonlml.github.io/2019/09/22/java%E5%9F%BA%E7%A1%80/6.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象 一、 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"4.二维数组","slug":"java基础/4.二维数组","date":"2019-09-22T05:00:00.000Z","updated":"2024-06-16T02:56:51.375Z","comments":true,"path":"2019/09/22/java基础/4.二维数组/","link":"","permalink":"https://protonlml.github.io/2019/09/22/java%E5%9F%BA%E7%A1%80/4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","excerpt":"","text":"二维数组 一、二维数组的静态初始化 二、获取二维数组中的某个值 三、二维数组遍历 四、二维数组动态初始化 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"5.方法与数据类型","slug":"java基础/5.方法","date":"2019-09-22T05:00:00.000Z","updated":"2024-06-16T02:44:04.540Z","comments":true,"path":"2019/09/22/java基础/5.方法/","link":"","permalink":"https://protonlml.github.io/2019/09/22/java%E5%9F%BA%E7%A1%80/5.%E6%96%B9%E6%B3%95/","excerpt":"","text":"方法与数据类型 一、方法 二、数据类型1.基本数据类型（变量中存储的是真实的数据）在栈中 四类八种 整数数据类型 （bat , short , int , long ） 浮点数据类型(float , double) 布尔数据类型（char ） 字符数据类型( boolean) 2.引用数据类型（只要是new出来的都是引用数据类型）在堆中 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"3.数组","slug":"java基础/3.数组","date":"2019-09-22T04:00:00.000Z","updated":"2024-07-25T14:58:33.351Z","comments":true,"path":"2019/09/22/java基础/3.数组/","link":"","permalink":"https://protonlml.github.io/2019/09/22/java%E5%9F%BA%E7%A1%80/3.%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组 一、什么是数组 二、数组的静态初始化 三、数组的动态初始化 数组默认初始化值的规律 整数类型:默认初始化值 0 小数类型:默认初始化值 0.0 字符类型:默认初始化值 ‘\\u0000’ 空格 布尔类型:默认初始化值 false 引用数据类型: 默认初始化值 null (引⽤数据类型包括：类、接⼝类型、数组类型、枚举类型、注解类型，字符串型) 四、数组的静态初始化和动态初始化的区别 五、索引 数组元素访问 数组元素访问的格式为：数组名[ 索引]； 索引：也叫做下标，角标； 索引特点：从0开始，逐个+1增长，连续不间断 （我们可以通过索引把数组中的元素拿出来用，也可以把元素添加到数组当中去） 六、数组角标越界异常 访问了数组不存在索引，就会引发数组角标越界异常 避免：知道索引的范围 七、数组常见操作 1.求最值 2.求和 3.交换数据 4.打乱数据 5.冒泡排序 6.数组拷贝 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"2.判断和循环","slug":"java基础/2.判断和循环","date":"2019-09-21T04:00:00.000Z","updated":"2024-06-16T02:37:32.559Z","comments":true,"path":"2019/09/21/java基础/2.判断和循环/","link":"","permalink":"https://protonlml.github.io/2019/09/21/java%E5%9F%BA%E7%A1%80/2.%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"一、判断if语句 switch语句1234/** * 如果说，要对一个范围进行判断，则需要使用if * 如果对，有限个结果，一一列举出来，任选其一，则需要使用switch */ 注意 1.switch正常执行流程 执行流程 首先还是会拿着小括号中表达式的值跟下面每一个case进行匹配.如果匹配上了,就会执行对应的语句体,如果此时发现了break,那么结束整个switch语句:如果没有发现break,那么程序会继续执行下一个case的语句体,一直遇到break.或者右大括号为止.使用场景:如果多个case的语句体重复了,那么我们考虑利用case穿透去简化代码 2.switch新特性（JDK12） 3.case穿透 就是语句体中没有写break导致的: 应用场景 4. default的位置和省略 位置:default 不一定是写在最下面的 ,我们可以写在任意位置.只不过习惯会写在最下面 省略:default可以省略,语法不会有问题,但是不建议省略. 二、循环 在实际开发中，我们需要重复的执行某段代码，会选择循环来实现 1.for循环 2.while循环 3.for 和while的区别 4.无限循环 循环一直停不下来 注意事项 在无限循环的下面，不能再写其他代码了，因为循环永远停不下来，那么下面的代码永远执行不到 5.跳转控制语句 1.continue:跳过本次循环,继续执行下次循环. 2. break:结束整个循环. © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"1.运算符以及类型转换","slug":"java基础/1.运算符以及类型转换","date":"2019-09-21T03:00:00.000Z","updated":"2024-11-03T12:34:01.646Z","comments":true,"path":"2019/09/21/java基础/1.运算符以及类型转换/","link":"","permalink":"https://protonlml.github.io/2019/09/21/java%E5%9F%BA%E7%A1%80/1.%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"计算机中 能够存的数据的最小单位是 “字节” 1个字节是8个bit位1024个字节是1kb1024kb是1M1024M是1G 一、算数运算符 二、类型转换1.隐式转换 隐式转换的两种提升规则 取值范围小的,和取值范围大的进行运算,小的会先提升为大的,再进行运算 byte short char三种类型的数据在运算的时候,都会直接先提升为int,然后再进行运算 2.隐式转换小结 取值范围 byte&gt;short&gt;int&gt;long&gt;float&gt;double 什么时候转换 数据类型不一样，不能进行计算，需要转换成一样的才可以计算 转换规则1： 取值范围小的，和取值范围大的进行运算，小的会先提升为大的在进行计算 转换规则2 byte short char 三种类型的数据在运算的时候，都会直接提升为int ，然后再进行运算 三、强制转换 如果把一个取值范围大的数值，赋值给取值范围小的变量。是不允许直接赋值的。如果一定要这么做就需要加入强制转换 格式：目标数据类型 变量名&#x3D;(目标数据类型)被强转的数据 四、+ 加号运算符 “字符+字符”当”+”操作中出现字符串时,这个”+”是字符串连接符,而不是算术运算符了.会将前后的数据进行拼接,并产生一个新的字符串. “字符+数字”时,会把字符通过ASC川码表查询到对应的数字再进行计算. 五、自增自减运算符 六、赋值运算符 七、关系运算符 八、逻辑运算符 九、短路逻辑运算符 十、三元运算符 条件（三元）运算符是 Java 唯一使用三个操作数的运算符：一个条件后跟一个问号（?），如果条件为[真值]，则执行冒号（:）前的表达式；若条件为[假值]，则执行最后的表达式。该运算符经常当作 [if...else]语句的简捷形式来使用。 十一、运算符的优先级 只用记住一点“小括号( )”优先于所有，想要先算谁，就用小括号将其括上 十二、原码，反码，补码 计算机中，最小的存储单元是“一个字节” 它占8个bit位。范围从1000 0000 ~ 0111 1111 （-128~127） &#x3D;&#x3D;计算机中，数字的存储，以及运算都是以补码的形式来操作的。&#x3D;&#x3D; 理解了原码，反码，补码，的基本概念，就可以深入了解以下的内容了。 1.理解同一个数字在不同数据类型下到底有什么区别呢？bit位 &#x3D;&#x3D;就是在前面的位置“补0”&#x3D;&#x3D; 2.理解隐式转换 3.理解强制转换 4.理解数字之间使用“运算符” © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客（六）本地hexo博客恢复","slug":"博客搭建/搭建个人博客（六）本地hexo博客恢复","date":"2019-09-19T07:00:00.000Z","updated":"2024-06-16T01:38:22.286Z","comments":true,"path":"2019/09/19/博客搭建/搭建个人博客（六）本地hexo博客恢复/","link":"","permalink":"https://protonlml.github.io/2019/09/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%85%AD%EF%BC%89%E6%9C%AC%E5%9C%B0hexo%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/","excerpt":"","text":"搭建个人博客（六）本地hexo博客恢复一、使用SourceTree软件，拉取远程仓库中的博客blog 删除这个文件夹 在本地blog文件夹中,使用Git Bath 运行1234npm install hexonpm installhexo ghexo s 继续编写博客，进行hexo d 上传上传失败执行12npm install hexo-deployer-git --save 之后再上传hexo d 上传 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客(五)：编写博客文章以及上传和备份","slug":"博客搭建/搭建个人博客(五)：编写博客以及上传和备份","date":"2019-09-19T03:00:00.000Z","updated":"2024-06-16T01:41:08.271Z","comments":true,"path":"2019/09/19/博客搭建/搭建个人博客(五)：编写博客以及上传和备份/","link":"","permalink":"https://protonlml.github.io/2019/09/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E4%BA%94)%EF%BC%9A%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BB%A5%E5%8F%8A%E4%B8%8A%E4%BC%A0%E5%92%8C%E5%A4%87%E4%BB%BD/","excerpt":"","text":"搭建个人博客(五)：Typora编写博客以及上传和备份一、编写博客 1.在\\blog\\source\\ _posts目录中创建md文件 2.添加博文分类和博文标签的相关配置123456# 通过如下字段,Hexo会自动添加博文分类和博文标签的相关配置---title: title # 添加博文标题categories: categories # 添加博文分类tags: tags # 添加博文标签--- 3.博客标题，以及md文档名要一致 二、本地查看效果123hexo cleanhexo ghexo s 三、上传 按Ctrl+C暂停，随后使用命令 hexo d 推送到远程仓库的 hexo默认分支 上去了。 四、备份 通过Sourcetree备份master分支 这样做的目的是，当我们在本地blog的源文件被误删除了，我们还可以直接拉取仓库中master分支到本地，继续使用。 在Sourcetree上，只用检出master分支就行了 （我们一直都在master分支上操作） 五、每次推送后，都要对Gitee Pages 点击更新 每次推送后，都要对Gitee Pages 点击更新，然后清空浏览器缓存，访问才生效。 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床","slug":"博客搭建/Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床","date":"2019-09-18T10:00:00.000Z","updated":"2024-06-16T14:55:42.643Z","comments":true,"path":"2019/09/18/博客搭建/Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床/","link":"","permalink":"https://protonlml.github.io/2019/09/18/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Docker-Alist%E5%AE%B9%E5%99%A8+PicGoApp+%E5%A4%B8%E5%85%8B%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床 前言：在搭建自己的博客时，我们会把博文的图片上传到如：七牛云，阿里云oss，腾讯云等。这些第三方云图床上面，优点方便快捷安全。其次是使用“Typora+PicGoApp+gitee”实现远程仓库管理图片。但是作为图片的仓库是公开的，没法实现图片私密。再者就是现在自己搭建图床。 Docker-Alist容器+PicGoApp+夸克网盘搭建个人图床，这里服务端我使用的是自己电脑中的虚拟机，当然自己搭建服务器，或者搭建Nas以及购买第三方服务器都行。 一、准备工作 1.本地安装PicGOApp并且关联了Typora 具体可查看文章搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床 2.PicGo下载alist插件 3.远程服务器上面安装Alist Alist所有操作参照 AList文档 (nn.ci) 这里使用本地虚拟机Docker安装Alist，使用VSCode连接远程服务器，在bash终端使用docker命令下载镜像 1docker run -d --restart=unless-stopped -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=&quot;alist&quot; xhofe/alist:latest Alist容器运行起来，同时也下载了。使用命令查看 1docker ps 生成登陆密码，并且修改登陆密码 1234# 先随机生成一个密码docker exec -it alist ./alist admin random# 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码docker exec -it alist ./alist admin set NEW_PASSWORD 4.浏览器中访问Alist客户端 端口是5244 192.168.56.30:5244 这里我是本地服务器地址 二、挂载网盘 1.登陆Alist添加存储（将夸克网盘挂载到Alist上） 2.添加一个新的驱动，驱动选择“夸克”。挂载路径和序号根据自己需求填写，缓存过期时间填0。Webdav策略选择“本地代理”。 我们需要获取Cookie 打开电脑浏览器（使用Chrome浏览器）并登录夸克网盘账号(用网页版登录)，然后按键盘上的F12，进入开发者模式。点击上方的Network(网络)选项卡，在左侧的Name(名称)中找到“sort?pr&#x3D;u”开头的条目并选中(如果该条目没刷新出来，需要稍等几秒钟)，然后在右侧的Request Headers中，找到Cookie值并复制： 将复制的Cookie值填入alist设置页面，其他选项全部保持默认，然后点击添加即可。 3.Alist两个设置 关闭签名所有 复制令牌 7.夸克网盘挂载成功。 三、PicGo关联alist 设置配置 四、在Typora中复制一张图片测试上传 注意要将 alist设置为 默认图床 参考链接 Typora+PicGo+Alist 私人图床教程_alist 图床-CSDN博客 轻松打造智能家庭数据中心——袋鼠叔叔带你玩转绿联DX4600 (篇3—Docker中搭建Alist本地挂载阿里&#x2F;百度&#x2F;夸克网盘小白保姆教程) (zhihu.com) © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"搭建图床","slug":"搭建图床","permalink":"https://protonlml.github.io/categories/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://protonlml.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Picgo","slug":"Picgo","permalink":"https://protonlml.github.io/tags/Picgo/"},{"name":"Alist","slug":"Alist","permalink":"https://protonlml.github.io/tags/Alist/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床","slug":"博客搭建/搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床","date":"2019-09-18T07:00:00.000Z","updated":"2024-06-16T01:40:31.188Z","comments":true,"path":"2019/09/18/博客搭建/搭建个人博客（四）Typora+Picgo+Gitee搭建免费云图床/","link":"","permalink":"https://protonlml.github.io/2019/09/18/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89Typora+Picgo+Gitee%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%BA%91%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"搭建个人博客（四）Typora+Picgo+Gitee搭建云图床实现图床的方式有很多种 例如： 使用Typora+PicGo+阿里云 搭建图床 - 知乎 (zhihu.com) 这里提供一种 在编写博文的时候，需要进行插入图片，但是此时的图片是在本地的，我们要使用Typora+Picgo+Gitee实现云图床将图片放在gitee仓库中，在线访问就可以查看到。 一、创建一个仓库 初始化同时创建imgs文件夹 二、生成私人令牌 生成仓库后，点击右上角的头像-&gt;设置-&gt;私人令牌-&gt;生成私人令牌-&gt;复制-&gt;确认，保存好 三、安装PicGo软件1https://picgo.github.io/PicGo-Doc/zh/ 安装PicGo软件后，插件设置中搜索gitee-uploader安装插件 设置PicGo-Server确定一下 设置时间戳重命名，保证文件名中没有中文避免线上不显示 设置图床gitee为默认图床 设置gitee图床连接 至此PicGo设置完毕 四、关联Typora和PicGo软件 打开Typora，偏好设置-图像，关联PicGo 使用Typora编写博客的时候，复制了图片到当前文章当中，直接点击上传 在仓库文件夹中就能看到了 五、说明1.为什么不使用PicGo-Core(command line) gitee上传设置命令的的上传方式，配置了配置文件，有时候也会上传不成功出现错误。如果你已经下载了PicGo-Core(command line)插件，然后又下载了PicGoApp上传，也有可能会出现错误。解决办法：将Typora软件卸载重新安装重新配置。 Typora软件需要激活，这里提供Typora旧版本免激活使用 2.下拉框“复制图片到.&#x2F;${filename}.assests文件夹”选项说明： 复制图片到.&#x2F;${filename}.assests文件夹：以后在C:\\working\\blog\\source\\ _posts 中创建博客文章，先创建md文件，然后写博文在每次往md插入图片时，都会自动在同级目录生成assests文件夹将插入的图片拷贝一份在里面存放，这样以后拷贝文件将assests和md文件一起拷贝，就一直有效了。 上传图片：每次往md插入图片时，都会将图片上传到gitee仓库，图片名自动改为gitee仓库图片地址 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"搭建图床","slug":"搭建图床","permalink":"https://protonlml.github.io/categories/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://protonlml.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Picgo","slug":"Picgo","permalink":"https://protonlml.github.io/tags/Picgo/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客(三)：主题pure使用指南","slug":"博客搭建/搭建个人博客(三)：主题pure使用指南","date":"2019-09-17T05:00:00.000Z","updated":"2024-06-16T14:58:18.471Z","comments":true,"path":"2019/09/17/博客搭建/搭建个人博客(三)：主题pure使用指南/","link":"","permalink":"https://protonlml.github.io/2019/09/17/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E4%B8%89)%EF%BC%9A%E4%B8%BB%E9%A2%98pure%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"搭建个人博客(三)：主题pure使用指南Hexo-theme-pures是一个Hexo的主题框架 一、安装pure主题1. 在hexo根目录中的themes文件夹下克隆pure主题 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 下载完毕，删除文件夹中所有.git相关的文件 2.修改配置文件 在 Hexo 中主要有两份配置文件，其名称都是 _config.yml。 一份位于博客根目录下，主要包含 Hexo 本身的配置；另一份位于主题根目录下，主要用于配置主题相关的选项。 （1.）打开博客根目录配置文件_config.yml，做如下修改: 12language: zh-CN //设置主题为中文版，若使用英文版则不修改theme: pure //修改hexo主题 （2）在博客文件夹下打开git bash命令行窗口依次使用如下指令: 12hexo cleanhexo s 启动服务后：进入本地浏览器输入:http://localhost:4000/，如下图 3.安装pure插件在博客文件夹下打开git bash命令行窗口依次使用如下指令： 123456npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-deployer-git --save 二、配置pure主题1. 复制_source文件夹中的内容将主题目录中 &#x2F;theme&#x2F;_source&#x2F; 下的所有东西复制进博客根目录的source文件夹中 2. pure配置文件的修改： 打开主题根目录下的_config.yml配置文件： （1）配置站点左边的主目录: 1234567891011# menumenu: Home: . Archives: archives # 归档 # categories指代博客根目录的source下的categories文件夹,可进行相关配置,下同 Categories: categories # 分类 Tags: tags # 标签 Repository: repository # github repositories #Books: books # 豆瓣书单 Links: links # 友链 About: about # 关于 单个目录界面的相关配置可在博客根目录的source下的同名文件夹中进行配置 （2）配置站点标题: 1234567891011# Sitesite: logo: enabled: true width: 40 height: 40 url: ../images/logo.png title: 𝚲𝚳𝚲的博客 # 页面title favicon: ../favicon.ico board: &lt;p&gt;欢迎交流与分享经验!&lt;/p&gt; # 站点公告 copyright: true # 底部版权信息 （3）配置主题颜色: 1234567891011# configconfig: skin: theme-black # 主题颜色 theme-black theme-blue theme-green theme-purple layout: main-center # 布局方式 main-left main-center main-right toc: true # 是否开启文章章节目录导航 menu_highlight: false # 是否开启当前菜单高亮显示 thumbnail: false # 缩略图 ，enable posts thumbnail, options: true, false excerpt_link: Read More #New isNewTabLinks: false #是否链接打开新标签页 autoUnfold: true # 默认展开文章目录 （4）配置页码信息: 123456789# Paginationpagination: number: true prev: alwayShow: true next: alwayShow: true midSize: 2 # 当前页码左右到省略号显示的页码数，默认2，表现为 1 ... 4 5 6 7 8 ... 10 showContent: true # 页面文章小于2篇时显示文章内容 （5）配置页面右侧栏目 123456789# Sidebar 页面右侧栏目设置sidebar: rightwidgets: - board - category - tag # - tagcloud #隐藏“标签云” - archive - recent_posts （6）配置打赏信息 1234567891011# Donatedonate: enable: true # 微信打赏 wechatpay: qrcode: images/donate/wechatpayimg.png # 在主题目录的source文件夹中进行图片的设定 title: 微信支付 # 支付宝打赏 alipay: qrcode: images/donate/alipayimg.png # 在主题目录的source文件夹中进行图片的设定 title: 支付宝 （7）配置是否启用分享功能 123456# Share# weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedinshare: enable: false # true是否启用分享 sites: weibo,qq,wechat,facebook,twitter # PC端显示的分享图标 mobile_sites: weibo,qq,qzone # 移动端显示的分享图标 （7）开启搜索功能 1234# Searchsearch: insight: true # 内置搜索功能, baidu: false # 百度搜索功能,不可以同时使用 **（8）配置“项目”导航栏 ** 12345# Repository Info (This will override &#x27;github&#x27; option)# 项目仓库信息（将会覆盖 github 项）repository: platform: gitee # 托管平台（github | gitee） username: lmlpla # 用户名 （9）关闭评论功能 Valine一个无后端的评论框工具，其依赖于 Leancloud 开发，所以使用前需要先注册 Leancloud 账号Valine配置 12345678910111213141516comment: # type: valine # 启用哪种评论系统 valine: # Valine官方地址: https://valine.js.org appid: # 你的 leancloud 应用 appid appkey: # 你的 leancloud 应用 appkey notify: true # 是否开始评论邮件提醒, 教程: https://github.com/xCss/Valine/wiki verify: false # 是否开始验证码功能, 开始邮件提醒会自动开启验证码功能 placeholder: 说点什么... # 输入框默认内容 avatar: mm # 头像展示方式, 具体设置项教程: https://valine.js.org/configuration.html#avatar meta: nick,mail,link # 自定义评论信息 pageSize: 10 # 评论列表分页 lang: zh-cn, # 多语言支持 zh-cn | en visitor: true # 文章阅读量统计: https://valine.js.org/visitor.html highlight: true # 代码高亮 recordIP: true # 记录评论者的IP (10) 开启文章字数统计以及阅读时长预计 12345# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 （11）文章下面的个人信息修改 1234567891011# profileprofile: enabled: true # Whether to show profile bar articleSelfBlock: false # 关闭文章下方的自我介绍 avatar: images/avatar.jpg gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: 𝚲𝚳𝚲 #𝓵𝓶𝓵 author_title: ◙ author_description: 业精于勤，荒于嬉；行成于思，毁于随！ location: Shenzhen, China follow: （12）左下角链接设置 123456789101112# Social Links 左下角链接 social: links: gitee: https://gitee.com/lmlpla #github: https://github.com/cofess #weibo: http://weibo.com/cofess #twitter: https://twitter.com/iwebued # facebook: / # dribbble: / #behance: https://www.behance.net/cofess rss: atom.xml link_tooltip: true # enable the social link tooltip, options: true, false （13）“关于”导航页面的右侧栏目设置 12345678910# My Skills 技能 skills: Git: ★★☆☆☆ Java: ★★★☆☆ Javascript: ★☆☆☆☆ Vue: ★★☆☆☆ #HTML+CSS: ★★★☆☆ #Bootstrap: ★★★☆☆ #ThinkPHP: ★★★☆☆ #平面设计: ★★★☆☆ （14）“关于”导航页面的右侧栏目设置 1234567# My Personal Links 联系我链接 links: Gitee: https://gitee.com/lmlpla Blog: https://lmlpla.gitee.io/blog/ #微博: http://weibo.com/cofess #花瓣: http://huaban.com/cofess #Behance: https://www.behance.net/cofess （15）“关于”导航页面的右侧栏目设置 1234567# My Personal Labels 打标签 labels: - 音乐街舞 - 摄影生活 - - - （16）关闭不需要的设置 123456789# My Personal Works #works: # name: # link: http://www.example.com # date: 2016 # My Personal Projects #projects: # cofess/gulp-startpro: https://github.com/cofess/gulp-startpro #cofess/hexo-theme-pure: https://github.com/cofess/hexo-theme-pure （17）添加背景动画背景动画基于canvas，在themes&#x2F;pure&#x2F;layout&#x2F;layout.ejs的中面添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; （18）修改左下角的站点创建时间（直接用VS Code打开，在主题目录中搜索 publishby） （19）友情链接的配置: 选择博客根目录下 &#x2F;source&#x2F;_data&#x2F; 中的links.yml配置文件，可仿照其中样例进行配置 1234gentryhuang: link: https://gentryhuang.com/ avatar: ../images/gentryhuang-logo.png desc: 脚踏实地,步步为营 (20) 修改关于页面 找到\\blog\\source\\about\\index.md文件，添加样式 1234567891011121314151617181920212223242526272829---title: 关于我description: 集齐龙珠，召唤神兽！layout: aboutcomments: falsesidebar: custom---​```txt/**** * ┏┓ ┏┓ * ┃ ┃ + +* ┃ ━ ┃ ++ + + +* ████━████┃ 🚂🚂🚂-&lt;-&lt; 欢迎访问我的博客* ┃ ┃ + * ┃ ┻ ┃ + + * ┃ ┃ * ┗━┓ ┏━┛Code is far away from bug with the animal protecting * ┃ ┃ 神兽护体，永无bug * ┃ ┃ +* ┃ ┗━━━┓+* ┃ ┣┓ 📬 联系我：lmle_mail@163.com* ┃ ┏┛ + + * ┗┓┓┏━┳┓┏┛ +* ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */​``` 三、更新站点，查看效果 在博客文件夹下打开git bash命令行窗口依次使用如下指令： 123hexo cleanhexo ghexo s 启动服务后：进入本地浏览器输入:http://localhost:4000/ 进行查看 四、效果𝚲𝚳𝚲的博客 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客（二）：Hexo部署到 Gitee","slug":"博客搭建/搭建个人博客（二）：Hexo部署到 Gitee","date":"2019-09-17T04:00:00.000Z","updated":"2024-06-16T01:37:21.407Z","comments":true,"path":"2019/09/17/博客搭建/搭建个人博客（二）：Hexo部署到 Gitee/","link":"","permalink":"https://protonlml.github.io/2019/09/17/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AHexo%E9%83%A8%E7%BD%B2%E5%88%B0%20Gitee/","excerpt":"","text":"搭建个人博客（二）：Hexo部署到 Gitee一、新建 Gitee 仓库 新建的仓库，先不要初始化，同时仓库名要和本地博客所在文件夹名称相同。 没有初始化的仓库有命令提示 二、本地博客文件夹中使用git命令，将本地文件推送到远程仓库 1. 本地文件夹内删除已有的 .gite文件 使用Gitbash窗口 运行 如下命令，将本地文件夹绑定到远程仓库上去 12345git init git add .git commit -m &quot;first commit&quot;git remote add origin https://gitee.com/lmlpla/xxxx.git # xxxx指远程仓库名字git push -u origin &quot;master&quot; 刷新远程仓库，就可以看见本地博客文件被推送到仓库中去了 2.远程仓库创建新的分支hexo 3.设置hexo分支为默认分支 （目的是为了保存hexo博客的源文件，迁移主机，随时拉取就可以使用，再master分支上进行hexo d 命令推送编译后的文件会默认到hexo分支上） 4.使用Sourcetree管理本地博客 三、在 Gitee 中添加 SSH 公钥 使用SSH公钥可以让你在你的电脑和 Gitee 通讯的时候使用安全连接（Git的Remote要使用SSH地址） &#x3D;&#x3D;如果之前gitee上面已经添加过，就跳过第三步&#x3D;&#x3D; 检查本地电脑上是否已有 SSH，在本地打开 git bash 命令行窗口，输入以下命令1cd ~/.ssh 如果没有，显示1bash: cd: /c/Users/Administrator/.ssh: No such file or directory 如果有的话，标识本地已经有创建过的 SSH key 了 1.如果本地没有就创建 SSH key 运行如下命令 最后一个参数替换为自己的 注册Gitee时使用的邮箱，然后直接回车两次1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 2.找到生成的.ssh文件，打开将内部的公钥复制下来 3.测试 SSH 连接 输入命令 1ssh -T git@gitee.com 会得到如下输出，询问是否确认连接，输入yes回车确认 123The authenticity of host &#x27;gitee.com (180.97.125.228)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc.Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 最后连接成功会看到如下输出 12Warning: Permanently added &#x27;gitee.com,180.97.125.228&#x27; (ECDSA) to the list of known hosts.Hi dulily! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access. 在 Gitee 中添加 SSH 公钥 先在 C 盘指定目录中找到 id_rsa_pub 文件，复制内容然后打开 gitee 个人设置里面的 安全设置 - SSH公钥，标题可以随便取，把粘贴的内容复制到公钥里面，点击确定就可以 四、本地修改 _config.yml 修改hexo博客根目录中的配置文件_config.yml 安装 hexo-deployer-git（master分支操作）1npm install hexo-deployer-git --save 推送博客目录到远程 Gitee（master分支操作）12hexo g hexo d 这时候，远程仓库的 blog 目录下的文件(并且在hexo分支上会被更新一遍) 五、开启 Gitee Pages 服务 后期，如果更新了文章，使用 hexo g -d 命令就可以直接推送到远程hexo分支了，然后再更新一下就可以访问到新的博客文章 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"搭建个人博客(一)：Hexo本地的使用和配置","slug":"博客搭建/搭建个人博客(一)：Hexo本地的使用和配置","date":"2019-09-17T03:00:00.000Z","updated":"2024-06-15T06:14:53.274Z","comments":true,"path":"2019/09/17/博客搭建/搭建个人博客(一)：Hexo本地的使用和配置/","link":"","permalink":"https://protonlml.github.io/2019/09/17/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E4%B8%80)%EF%BC%9AHexo%E6%9C%AC%E5%9C%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"搭建个人博客(一)：Hexo本地的使用和配置一，准备工作1.了解hexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2. 搭建博客之前,需要安装几个工具 2.1 git版本控制工具 Git是一个免费的、开源的版本控制软件。在Windows上安装git，一般为msysgit，官方下载地址 :http://code.google.com/p/msysgit/downloads/list安装步骤下一步即可…最后在-shell窗口中输入命令 git --version 检查安装是否成功 2.2 Node.js环境 安装nodejs在官网上面，下载绿色的zip包 最好安装node-v18.16.1-win-x64.7z 详情请看本站文章“nodejs安装教程” 𝚲𝚳𝚲的博客 (gitee.io) 3.安装hexo,下载hexo 搭建博客 创建一个 Blog文件夹，在这个文件夹中,使用Git窗口,依次执行下面的命令 12345npm install -g hexo-cli # 安装hexo客户端hexo init #初始化hexonpm i #安装npm工具 hexo g # 生成hexo s # 启动服务 &#x3D;&#x3D;（注意：下载后文件夹中有.git文件夹，给删除掉，后面要上传到自己的远程仓库，进行版本控制。）&#x3D;&#x3D; 二、启动后存在的问题 1.启动hexo 创建成功后 ，浏览器 “localhost 已拒绝连接。” 不是端口问题，4000端口打不开,是因为你是从git窗口里复制的,或者直接点击的。 在url地址栏里面重新敲 localhost:4000 就行了，或者 127.0.0.1:4000 2.启动后能正常访问，访问发现白屏了，什么也没有 主要原因是 nodejs版本不兼容 导致在public文件夹下index.html文件是空白的。 重新安装nodejs 推荐node-v16.19.1-win-x64-&gt;nodejs安装教程：𝚲𝚳𝚲的博客 (gitee.io) 然后在本地启动查看结果。localhost:4000查看能不能访问, Ctrl+C 停止本地服务 重启本地服务,要先 hexo clean 清理缓存 hexo g 生成 hexo s 启动本地服务查看本地,能不能将这个项目跑起来 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"}],"author":"𝚲𝚳𝚲"},{"title":"UML类图","slug":"java基础/UML类图","date":"2019-09-10T03:00:00.000Z","updated":"2024-06-16T02:17:59.887Z","comments":true,"path":"2019/09/10/java基础/UML类图/","link":"","permalink":"https://protonlml.github.io/2019/09/10/java%E5%9F%BA%E7%A1%80/UML%E7%B1%BB%E5%9B%BE/","excerpt":"","text":"UML类图用于表示类、接口、实例等之间相互的静态关系。虽然名字叫类图，但类图中并不只有类，还可能包括权限、属性、方法等 2.1 类图关系 设计模式中的对象关系: 依赖关系 虚线箭头，箭头方向指向被依赖的部分 组合关系 实心菱形 聚合关系 空心菱形（想象成盘子，盛东西，盘子的多，另一方少） 关联关系 实线箭头，箭头指向被关联的部分 类与类的连接，（它使一个类知道另一个类的属性和方法，关联关 系一般用成员变量实现） 继承 空心三角形实线 实现 空心三角形虚线 注意： 实现接口有两种方式，一种是棒棒糖的形式，另一种是虚线空心三角形的方式 &#x3D;&#x3D; UML记忆&#x3D;&#x3D; 1. uml箭头：从子类指向父类，只有知道对方信息时才能指向对方方向2. 空心三角箭头：继承或实现，实线-继承：积极的，强关联，关联，通常一个类中有一个类的对象做属性；虚线-实现：消极的，弱关联，依赖3. 空心菱形：聚合，（注：可以看作一个盘子，可以放很多相同的东西（箭头方向所指的类），聚在一起。是has a的关系）弱关联4. 实心菱形：组合，（注：代表器皿里有实体结构存在，组合起来成为一个。是contains-a的关系）强关联 1.uml箭头：从子类指向父类，定义子类时需要通过extends关键字指定父类，只有知道对方信息时才能指向对方方向实线-继承虚线-实现 2.空心菱形-聚合(可以看作一个盘子，可以放很多相同的东西（箭头方向所指的类），聚在一起。是has a的关系）弱关联) 3.实心菱形-组合 4.组合关系中常见的数字表达 ◆常见数字表达及含义，假设有A类和B类，数字标记在A类侧◆0..1：0或1个实例 在系统某一时刻，b的实例可以与0个或1个A实例相关◆0..*：0或多个实例 在系统某一时刻，b的实例可以与0个或多个A实例相关◆1..1：1个实例. b的实例可以和1个A实例相关◆1只能有一个实例. b的实例可以和1个A实例相关◆1..*：至少有一个实例. b实例可以与一个或多个A实例相关 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"}],"tags":[{"name":"UML类图","slug":"UML类图","permalink":"https://protonlml.github.io/tags/UML%E7%B1%BB%E5%9B%BE/"}],"author":"𝚲𝚳𝚲"},{"title":"IDEA快捷键","slug":"经验/IDEA快捷键","date":"1995-09-05T03:00:00.000Z","updated":"2024-12-09T16:48:41.833Z","comments":true,"path":"1995/09/05/经验/IDEA快捷键/","link":"","permalink":"https://protonlml.github.io/1995/09/05/%E7%BB%8F%E9%AA%8C/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"IDEA快捷键 ctrl+shift+up 当前行上移 ctrl+shift+down 当前行下移 ctrl+h 显示类的继承关系 ctrl+F12 显示类中的方法 Ctrl+p 提示参数类型 Ctrl+鼠标左键 （鼠标中键） 竖向选择 © 版权声明 版权声明 本网站名称：𝚲𝚳𝚲 𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。 本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。 本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。 本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报 本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。 本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！","categories":[{"name":"IDEA快捷键","slug":"IDEA快捷键","permalink":"https://protonlml.github.io/categories/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://protonlml.github.io/tags/IDEA/"}],"author":"𝚲𝚳𝚲"}],"categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"},{"name":"框架","slug":"框架","permalink":"https://protonlml.github.io/categories/%E6%A1%86%E6%9E%B6/"},{"name":"java","slug":"java","permalink":"https://protonlml.github.io/categories/java/"},{"name":"maven","slug":"java/maven","permalink":"https://protonlml.github.io/categories/java/maven/"},{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/categories/javaweb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://protonlml.github.io/categories/Servlet/"},{"name":"vue","slug":"vue","permalink":"https://protonlml.github.io/categories/vue/"},{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/categories/mysql8-0-22/"},{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"},{"name":"搭建图床","slug":"搭建图床","permalink":"https://protonlml.github.io/categories/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"},{"name":"IDEA快捷键","slug":"IDEA快捷键","permalink":"https://protonlml.github.io/categories/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://protonlml.github.io/tags/Hexo/"},{"name":"Pure主题","slug":"Pure主题","permalink":"https://protonlml.github.io/tags/Pure%E4%B8%BB%E9%A2%98/"},{"name":"matery主题","slug":"matery主题","permalink":"https://protonlml.github.io/tags/matery%E4%B8%BB%E9%A2%98/"},{"name":"spring","slug":"spring","permalink":"https://protonlml.github.io/tags/spring/"},{"name":"maven","slug":"maven","permalink":"https://protonlml.github.io/tags/maven/"},{"name":"项目自动化构建工具","slug":"项目自动化构建工具","permalink":"https://protonlml.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"},{"name":"javaweb","slug":"javaweb","permalink":"https://protonlml.github.io/tags/javaweb/"},{"name":"mysql8.0.22","slug":"mysql8-0-22","permalink":"https://protonlml.github.io/tags/mysql8-0-22/"},{"name":"javaScript","slug":"javaScript","permalink":"https://protonlml.github.io/tags/javaScript/"},{"name":"java基础","slug":"java基础","permalink":"https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"工具类","slug":"工具类","permalink":"https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"常见算法","slug":"常见算法","permalink":"https://protonlml.github.io/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"},{"name":"图床","slug":"图床","permalink":"https://protonlml.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Picgo","slug":"Picgo","permalink":"https://protonlml.github.io/tags/Picgo/"},{"name":"Alist","slug":"Alist","permalink":"https://protonlml.github.io/tags/Alist/"},{"name":"UML类图","slug":"UML类图","permalink":"https://protonlml.github.io/tags/UML%E7%B1%BB%E5%9B%BE/"},{"name":"IDEA","slug":"IDEA","permalink":"https://protonlml.github.io/tags/IDEA/"}]}