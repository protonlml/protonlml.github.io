<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://protonlml.github.io/atom.xml" rel="self"/>
  
  <link href="https://protonlml.github.io/"/>
  <updated>2024-06-16T01:41:24.580Z</updated>
  <id>https://protonlml.github.io/</id>
  
  <author>
    <name>𝚲𝚳𝚲</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码</title>
    <link href="https://protonlml.github.io/2024/01/01/%E6%8C%82%E5%B9%B4%E5%85%BD/"/>
    <id>https://protonlml.github.io/2024/01/01/%E6%8C%82%E5%B9%B4%E5%85%BD/</id>
    <published>2024-01-01T03:00:00.000Z</published>
    <updated>2024-06-16T01:41:24.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="换新颜给博客网站右上角添加悬挂年兽-喜增龙年喜气源码"><a href="#换新颜给博客网站右上角添加悬挂年兽-喜增龙年喜气源码" class="headerlink" title="换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码"></a>换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码</h1><ul><li><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul><li>这篇文章介绍了一个在博客网站右上角添加悬挂年兽的方法。通过在CSS代码中插入相应的素材链接，可以实现在网站右上角挂上一个龙的效果。对于自定义主题的网站，可以将相关的CSS和HTML代码添加到自定义头部中。对于全屏网站，建议在CSS代码的16行左右插入一行代码以实现相应效果。</li></ul></li></ul><h1 id="一、简介-教程"><a href="#一、简介-教程" class="headerlink" title="一、简介-教程"></a>一、简介-教程</h1><blockquote><p>换新颜新气象，给网站右上角挂一个龙，吸吸龙气</p><p>css第6行放入下面素材链接（本站开了防盗所以给你也无用就放下面了）</p><p>如果你的主题是自定义，那就是主题设置自定义里面</p><p>自定义css</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">850px</span>)&#123;</span><br><span class="line">    <span class="selector-class">.NewYear</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">260px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">display</span>: inline-block;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">https://img.ly522.com/LY/uploads/2023/12/longgyaj.gif</span>) no-repeat <span class="number">50%</span>/<span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">        <span class="attribute">position</span>: fixed;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">85.8%</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">55px</span>;</span><br><span class="line">        <span class="attribute">z-index</span>: <span class="number">50</span>;</span><br><span class="line">        <span class="attribute">cursor</span>: pointer;</span><br><span class="line">        <span class="attribute">animation</span>: new-year <span class="number">1.2s</span> ease-in-out <span class="number">0s</span> infinite alternate;</span><br><span class="line">        <span class="attribute">margin-left</span>: -<span class="number">1px</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">pointer-events</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@keyframes</span> new-year&#123;</span><br><span class="line">      <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">10deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="number">100%</span>&#123;</span><br><span class="line">                <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">10deg</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="html放到你的自定义头部html即可！！"><a href="#html放到你的自定义头部html即可！！" class="headerlink" title="html放到你的自定义头部html即可！！"></a>html放到你的自定义头部html即可！！</h3></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;NewYear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：如果你的是全屏网站建议在pointer-events: none;下面加一行。即css代码16行左右哪里加</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">z-index</span>: <span class="number">999</span>;</span><br></pre></td></tr></table></figure><blockquote><h3 id="演示图"><a href="#演示图" class="headerlink" title="演示图"></a>演示图</h3></blockquote><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160941751.png" alt="image-20240118020305488"></p><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div><p>​     </p></escape>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;换新颜给博客网站右上角添加悬挂年兽-喜增龙年喜气源码&quot;&gt;&lt;a href=&quot;#换新颜给博客网站右上角添加悬挂年兽-喜增龙年喜气源码&quot; class=&quot;headerlink&quot; title=&quot;换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码&quot;&gt;&lt;/a&gt;换新颜给博客网站</summary>
      
    
    
    
    <category term="新年快乐" scheme="https://protonlml.github.io/categories/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"/>
    
    
    <category term="春节挂件" scheme="https://protonlml.github.io/tags/%E6%98%A5%E8%8A%82%E6%8C%82%E4%BB%B6/"/>
    
    <category term="技巧优化" scheme="https://protonlml.github.io/tags/%E6%8A%80%E5%B7%A7%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>matery主题的使用</title>
    <link href="https://protonlml.github.io/2020/03/17/matery%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://protonlml.github.io/2020/03/17/matery%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-17T03:00:00.000Z</published>
    <updated>2024-06-16T02:11:38.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="matery主题的使用"><a href="#matery主题的使用" class="headerlink" title="matery主题的使用"></a>matery主题的使用</h1><h1 id="一、下载matery主题"><a href="#一、下载matery主题" class="headerlink" title="一、下载matery主题"></a>一、下载matery主题</h1><ul><li><h3 id="1-GitHub源项目"><a href="#1-GitHub源项目" class="headerlink" title="1.GitHub源项目"></a>1.GitHub源项目</h3></li><li><p><a href="https://github.com/blinkfox/hexo-theme-matery">GitHub - blinkfox&#x2F;hexo-theme-matery: 一个基于材料设计和响应式设计而成的全面、美观的Hexo主题。</a></p></li><li><h3 id="2-在本地clone下来"><a href="#2-在本地clone下来" class="headerlink" title="2.在本地clone下来"></a>2.在本地clone下来</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/blinkfox/hexo-theme-matery.git</span></span><br></pre></td></tr></table></figure><h1 id="二、配置hexo根yml文件"><a href="#二、配置hexo根yml文件" class="headerlink" title="二、配置hexo根yml文件"></a>二、配置hexo根yml文件</h1><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011622.png" alt="image-20240112005024106"></li></ul><h1 id="三、自定义主题"><a href="#三、自定义主题" class="headerlink" title="三、自定义主题"></a>三、自定义主题</h1><ul><li><h3 id="1-修改导航名称和路径图标"><a href="#1-修改导航名称和路径图标" class="headerlink" title="1.修改导航名称和路径图标"></a>1.修改导航名称和路径图标</h3><ul><li><h5 id="添加导航二级菜单的写法（如下是“关于”一级菜单修改）"><a href="#添加导航二级菜单的写法（如下是“关于”一级菜单修改）" class="headerlink" title="添加导航二级菜单的写法（如下是“关于”一级菜单修改）"></a>添加导航二级菜单的写法（如下是“关于”一级菜单修改）</h5></li><li><p>注意：1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>) </p></li><li><p>​             2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找  ,线上的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">About:</span><br><span class="line">   url: /about</span><br><span class="line">   # icon: fas fa-user-circle 注释掉原来的，加上下面这一段</span><br><span class="line">   icon: fas fa-list</span><br><span class="line">   children:</span><br><span class="line">     - name: 爱的颜色</span><br><span class="line">       url: /love</span><br><span class="line">       icon: fas fa-heart</span><br><span class="line">     - name: 生日快乐</span><br><span class="line">       url: /birthday</span><br><span class="line">       icon: fas fa-cake</span><br></pre></td></tr></table></figure></li><li><h3 id="2-手机二级菜单配置"><a href="#2-手机二级菜单配置" class="headerlink" title="2.手机二级菜单配置"></a>2.手机二级菜单配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">navMenu:</span></span><br><span class="line">  <span class="attr">mleft:</span> <span class="literal">true</span>    <span class="comment">#  二级侧栏子菜单是否对齐左边</span></span><br><span class="line">  <span class="attr">bgColor:</span> <span class="string">&quot; &quot;</span>   <span class="comment">#  二级侧栏子菜单背景颜色,留空即为全局背景色</span></span><br></pre></td></tr></table></figure></li><li><h3 id="3-首页中间右侧-banner"><a href="#3-首页中间右侧-banner" class="headerlink" title="3.首页中间右侧 banner"></a>3.首页中间右侧 banner</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">githubLink:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                                   <span class="comment"># 是否开启</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/sitoi/sitoi.github.io</span>  <span class="comment"># GitHub 仓库地址</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Fork</span> <span class="string">Me</span>                                 <span class="comment"># 显示文字</span></span><br></pre></td></tr></table></figure></li><li><h3 id="4-首页轮播图相关配置"><a href="#4-首页轮播图相关配置" class="headerlink" title="4.首页轮播图相关配置"></a>4.首页轮播图相关配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">showPrevNext:</span> <span class="literal">false</span>     <span class="comment"># 是否显示左右切换按钮</span></span><br><span class="line">  <span class="attr">showIndicators:</span> <span class="literal">false</span>   <span class="comment"># 是否显示指示器</span></span><br><span class="line">  <span class="attr">autoLoop:</span> <span class="literal">false</span>         <span class="comment"># 是否自动轮播</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="number">120</span>           <span class="comment"># 切换延迟时间，默认单位 秒</span></span><br><span class="line">  <span class="attr">intervalTime:</span> <span class="number">5000</span>      <span class="comment"># 自动切换下一张的间隔时间</span></span><br></pre></td></tr></table></figure></li></ul><p>参考：</p><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐 (blinkfox.github.io)</a></p><p><a href="https://sitoi.cn/posts/63466.html">基于 Hexo GitHub 从零开始搭建个人博客（三）：Matery 主题（DIY 版）详细配置教程，附博客源码 | Sitoi</a></p><p><a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-23">(๑•̀ㅂ•́) ✧被发现了～ (sunhwee.com)</a></p><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;matery主题的使用&quot;&gt;&lt;a href=&quot;#matery主题的使用&quot; class=&quot;headerlink&quot; title=&quot;matery主题的使用&quot;&gt;&lt;/a&gt;matery主题的使用&lt;/h1&gt;&lt;h1 id=&quot;一、下载matery主题&quot;&gt;&lt;a href=&quot;#一、下载m</summary>
      
    
    
    
    <category term="博客相关" scheme="https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Hexo" scheme="https://protonlml.github.io/tags/Hexo/"/>
    
    <category term="matery主题" scheme="https://protonlml.github.io/tags/matery%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>3.git初始化仓库的两种方式</title>
    <link href="https://protonlml.github.io/2019/10/10/3.git%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://protonlml.github.io/2019/10/10/3.git%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2019-10-10T06:00:00.000Z</published>
    <updated>2024-06-16T15:09:12.803Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="bc831f648122f97fd586110c53425fec499c9d238d043689579202a0999a5f3d">5e0f427b1806d2606f470abb7dec961a1e6f0f3829a50da35d12fcf113ec95129d05f73f815986a2211f597479a8969b58363e65bacbd800fdfb55462b459655d3fa134e8cf36feb2ba4d3c811a1960a53a4d0210b81321ff5fdc037adefe49f349e0e2b2ee52be3053b1678f8b813eeeffc068d065f26dc1e573c3727e073919aa8728aa1b6a558f465623ac795a03cf3a04265133b28b8c85f3fc3f95738fdb09998672bcaa1cdca4b82ac75f87e576ec62196467a80cf3c8dc64b401438ce7876ea172c84db3a20eaae669a484ca2f7773d3a2200d64efb17973169eec80409f883b40ac910dea136c937a3de612d787c342991e6687102228fa64acda61e28915ad4c0139d466835a1ef22d2fc457e3bcbd317bb3fcb3ac5a0908eebe8247dbafd8d2d8be690f25e1df0cf1d4a5d6be59b6b434adeeefa2a630668ec5337727f1022a9bd55a00802c776092300370197f1be0480db36905ae3848c9616aa82896c46d33991939fd8ad267648580271ac551a91c7d0adc71b556173a4390c0d7f738f5213887eaf25ae34027b143e52380bb330e715124be3d658550df8ac83f7b283b369c7867945cf8217a1c66e1005253e3300c78af2c1e19704068ac35049bed41937b2336e2928b73aaf9750e39041f7bc784f598d4575d486c73eee15e92094585d15221a5d13af6e1bc9b245e9745726aa83028d1bbb05023fdd1a5a9f1361d1e0e664b02323787932cb56016bc37a6dc011c7b985e6b11bacc5f83c702211d273c856a71781230c7884b1d1bdc8ef33c2c43a8810386b735388cf7448837fbc9b6c7c78d314ded26e6843aa6043f9f287a9d8c601b62aab7d3333f769846f1577284b9e4eb6e1a9fc2be6de2d8f31de6c1edb700bb46ce2af6e2de55f0ffdc56c716607422fe20a755a043c590d2a503aeeb5fa54a469dd57c16b14318f2108cf74b90b1f7328bc9bb76604b12f73347badb214605cd00d61319438cb6b556d224ae3892a594082e2c3f12538cd83ae3ec7c487c1ce97ceb19cbf1db55c4abfdfd6f68d05481ec970717664fba0d651feb962f8364b5c554773bac1ec43c343fa9ceb55371cf85f747fcada65dff50d39bf3b56224444613c6f64da6b0a5d9fa52363636d286c17173d9268ccc58f1241fe4d17a6da161035596a50ffd129e896d68203ffaba896f60e7f9fbd90da721513a90cb734dfd9abf2df2b4ecebbdaa603caf70e89b861b1d1599928985789404e5733c2c7b73fd63fb2e34d2b506e0e1b7bd5d973e44979ba7f95648489dd361d582ac51c8f2c3ee0baaab6a041a5e0a0263defe3f1611fd3e3555133f1c3d84b387b1304b18fbb09e3aa9994ac42b4efc928ce927bec97326e9433651386310b2a57536b73cd8bd24c5e573df9987e62e212744f22779bf259ec2c9629eef065788a9db57941a8117ccb053ef6880ec48d01ee4f668de22ee60798e4cb39bef7ba7ad7480050f02ebcd469b08083ac7cb40763d35964b99e89be4f8ee4dbd765c382ddb627ed31224cb0453f1fd270ef7d74b8ab7fb4fc8ec415bfeeb1ed2846cf400b449068dc98b476419b6d1998e31e633c273a597989fd8c1b2fa88ef9ff276f275beea56095a5dfcf2d3ec46e49401e1ef51f2606367e454df284e2472ca8ba1eb366c15877cd28f4204e8b18dd7fdffdf61129cb987de1c814ed2dbe620d8a69ff71aa4f03afc71e220a500a61fd53e58842ba9a17d53d2e4514539cfa99b3f6b5a9031ade79f29189ecdccc81af75ef98b30696310b49a82d31315b8ac97d7885125c0783cbc0f4701e9139c9c35c1b4083c190d3805e60404150b9b9bb71cb3d7124cbefdc007e3a3f5303d8db70241487410955a68d12d3e5cab93a67c9c0564afe6df54f63b75f2df1cbaaa940e3c87eb346372ce39a658fad02c759d0848be86b6780b2cbc21cc12382ada68ed04c6630f776773da49ed0b4f69c329343ff5b2c74ff591dd63b7454b96b457b5bc10d36338505243694b38dd0ec10f166af71075b884c6d4a20ab4919aef911a8ea4986efe47d1d323597da9d92ef598b21d7c9e8dc7d8442acd5d4d2a706fc9b3164f21b3c5e6ddccd7e16c10f51f5e435555a8d146274c0f4dce77abeec1c36593b555b93f5a0178dcde3466a3a899945c4f1106ec107adb821fe88c59e8520a6c1a4541afedbd3410d25bd3d5b832eca05c8cd9960dc8f2e6852089083a09650422b7ff1ee2e7b664b325de2b060b7eaeb5e0767f0d3e7eb80a557e2d57037ec509ebbe165e0916ebb0f701fe8f641bc85cd91d8abd20486b71c6c4c2b30351e9b2dde1ba09f4119939e93a911151c9364c28d96a96d31b7429752c920d33f8d48eeb0428f8088d9e1e451e1fa18bc17df23eb87621e81e670909bf0f26445bb49da2d438d158d385d206ef04c746b65b5150b2c320a91c46bebe0200a1fcd7cfba04ff762039ae8b062a3f99ffdcec9382b6b4983fd3fb1633cf59fbb9905d8c5041002d09338e189bbb488e2ad534d962f8016f7946a83f1e576399b4cf6151942890776e7e32964f590a5c8b16d2f904487941d86e825bffb20e2d30d1fa3e9376f20e940bb66d6300d03ad05c67f7a7f1c170a5527294b9cfbf5036ec0ea0d29c5f2cdd7166eccd30aa6cd384dbf2ed7b616ae3ddef0a77174ad28cc11fb849f81e00d80c79fb7f17f32379dd1ce55a51ed5052cd911a6d4a6f41b980aaa295ba758e346d82db21ae6e68aad508634e2c39e2b0680ed0c1ce28de8328f4c8d3c57b1c5ab0219807606ceeb9e069229c3f5c348f0854786a0fc08eef2f14aa4590148dc40ab84ef15043194990c883eb0d79173f6147ddef7b777f9db816f0c624da04923d12dc10b2aa51d346018e814aff08de1930608268bafae995af0d9271985fd4dd20447143dbabe3c4d5ea134a2bf766583235782950a2b60f8b09c9640053f43ab1ca713345f43475d3a4fa11a8d079c5f4ec24887267d99c7588cd7f2245cc28fdaee69f59c1bc87be8a710f128237fe33e257cadf231d78e8cc78111fc6adc322e08e2699c177700e978545295b908dc604c81dbad84d99f1efb5c313da3d211c67af1db2ec19ad9cf1eac120d2ed7098dee343ddcaf8265b9e4191702542b5c2874bc40d43d48facbbdbc5ae275eea266ad7da3f9e9ea3a43a3d6a84f7906e4e9f68835377655b13932ab59631022d2945d865dba3ece14870391063789a334055e82d5b11b7ab79d4ecfe7f1ef6d245e594d3dbf2d36417ad123235f04042bdff1c1292288a10d7debc0d219ddabfb4d31b791591d077b4edc0f472baadd08c4f32a661663c41f0e8f203b89bddfcdaa36d9a7bbbf1eacfb68e1233082e617abbe3f345407c72024020e8eb1939241fb6caef86771812b3d796940642bcd768ce6dcd2f631f78c902cb659e36ac43cfbeb76c57537afd2adf08257f7672177b3837b66b8406284baafd1059a9331c1fbbb4fe498e9756f67d02fdcd449cd32838eb1f26cf739e35a01d593777004ac46a048e9a2ecd3b9debcba055cd969055c23e20024048f55e48dfbb2d282d19b55dd3b6a41d21150cead86840033743bc8b9158adadbe1d4d061da97cf4231d1e6916fb77a3488b5b73dc06e55ba749c6a84100bf72f483faef977f4af01aad2fd753c78a8ee454c08f1a6f9692e5bef16ac58780803b853e3e7db914b8ecea7a45a030ee847eafed747b1a833b32308b951a355fb962cff281311986d9232bbbc870aa1d182d3324bbca065d6967cc9e272c7d1c522f6d40f01efe5f10b64d4f4d55de7ba6e966490b561c08c6e15ff5a5c372b4ac960bd2f2c78503569380cc390d1953adb6ade723000a442842073899eb0fe443599a7b3dc9b0845047c02de98817e5a14b1b603917c17c67b72af77e39ca333b8680ce8e7ebed562ea21193bd131ec3bc8edce5d67dc459ec2d01d79fa0fab481615b779366f21581ff5c4844d5a4e36c16af208cc747b63442ecf5bf19d4bb0c44dd959fa748e26ef7752283e280c7572a9076cea8d8b3950873ecc79acb06bf2f3dcd1b2a4cf8d1381b5e2d1e1c97d8cbd67b027f9fe07dc94a2994d5347cd5ff6be7b10bc5c71b9689c74b0e4fd6881a87b377bfb11607fda606ac32405b5063e737fe4e0973fb791107037a8206c794301b3266aa7c0871d0063149d55d12c52457724bb5a41cad6cbff2f01817f115e36321ae0671832064b2d61be2b630c190f848c1c76316bc5d941b0906500ea1954c224bcac31546add270e0f7a97318c4329f26beb3ac8ab30fb2f0608fb209d36c417717de3c9ece89ba62a3c97f6eb70db472dd0347bff95980817f3c18b17952101e7874ad7a6f4a83070f4793d4a6a8e5c5dd7a315a7fb5b49659a4344251c8bcd67c592d4f5f7092f372494355502aa9d78c5877f560e3bc88f9adef10f313fbccc1202967754a7be6a7ab1368179d5f347eb05b009daac266c869f5077084bbe6340258ac2a97dd735609acd7b6b297a6cf446814403ad0a4c5feeacf082c3945aeabd3d979c36d22a1b619c3bff2b32a64dc93fd22a04937b4cbf73a4ad6946dbff6437d34e3ff3f60cc07edb3063699b768fe88a51a8c9b516a5e0a6dc0df2735da95dff0a50fe22ebef84ba0dee7de86a3c292bab83b1298e9b94eca093d084e16803008017d00fe4ce193e33a9345b762eedfb1e773304b7c2e6429e5e8c799bd49b8c76b4fe64099d2c27c70f07f6de1cf1c3771f97c28407f873069d86fd37241551f276230ba3030969e0c1096a2e8b3d5e2bcb8b7112f29a6f4824dafca4a2b8ff4231999994422ad73a5a7744eb3f8b8bcf92cb03b7bc0ce8255323f7848b741f032e5edfedebb1e4180fb382c3c66e178cf1c6802577c4487a819a26ffb1595de64216e6a8214d122a36f9a5bcfe1bf821473ca3a51c88b3f8e6ab6b2eaf6d04832177f29b3b7a6a9497e118edf5477f762b55edfb917dae111e0dad4318a5c39dff37187c7a2f2aa710df073290da8ed253d7a9541180593db5a9128a360b82ad3360b6730f297638b8f4645e632cbfd9a5c2defb91a25862247178a0419a7f00a130fc660cfeccad6fffbc25cb51d226fe2bde0a5740217e8bf91815cf248641bef02eddfceb979830680fef315428d249758ed7f4f9f26d49a9783ad470889fb3f2710bbe82f683b6b256f12ab2fc5857b650c810b4080bb183031545462568cf6bb86fb6357d36afd20828e899230c6d86383c9a26ab09246d93894adf8b563287b358f495093add03cb71e3764346ecac0a1eb4e31d03e17dc76055926a05682619d7bf73d438f01ff7d9d51834e4f8cce8b374a406d3c1d3c2d072f67c5258f67fe93a5c1c6db089f052267aef80f66401c5509b8df6274d441c3230342d58638d93d002c8ca715f020639cec69da78d780bce16ef960f5624aedb0bf3650816957bfc6094c2327e67d203db3185b2e3344fd60364ac42f78e37a62926019a2532a3332e25204847d237ef2a5d508f691147122c8900a66e2f723d53201b5957496d063177dd71eac0c34a0bebfee5412de8d7d7ed6723ef2133f373cd04025b3cc11ffe5b1bf2c3e29136721ddc53c49063be93f391e3cce89d3e134ba7c343ee0d330641bada2b869a569393e8d5ca82fc0c6ffa04aa467d839fb2b646c0c65ee35782f02a3dcf4ae4ea069cd0e8eeb2ab4e900f6a6150d0cfe042b295942bf2c2bbf4f5a699688956cad186ab18717c46990d5d27aa550dd2aae06206bbb062a555753179e0e6b385e21040655e04b36f87bf78122352a50622368141bc75b469db614aa743a54a31bd5535bd0748c57c3b24e432f24a49b7c9b6269c4b54133d223354035f335b493d1d7ab51b22dea70e386775d77eafb3eaaf74b6f8e3af88b1da19d546855b63ae7e432ea6369f452425099104faa0300f7b5e8630d3c8676e31189afb90476485fe084016e2e8159a466acc630d4fc8365660d5eb6dd52bcaf944591dfe607adbd1cf5a807604a9db921409d5a8f390c0f942d671741f8da9d2bb49783cabfc19c2d5b36ebb625d84738a57f9e4925d3475f63bc03ebeadb033cc96c134795c9a3aaa5226bed4c3ac2879d72d8b191978d9c6115acbdd87b27437b3ec2e0cd4b16340125525e4d11615db5e06cd8e1813a5836d35b6b186a0e076409a5fd5fc78c85f2e6e695a74e2649e73003ebd089d4f6812afa1d2730fb72f8c91d47aeeb7829f2bca85d34c0884c5fadc0c1566c3aa72a7411ab27366ebfac7632d21081baf6a38a48265462b077c10e869853a177c94af4526065a58cdee5f6857d7ba87294372c88eed32c5e2ce0895a72aa8c8660f0f531f6a3d8b955da7008dd66179b9c71aeb67ee90253ed2a15146b96833b05ee5148110d2c95af74472c586547daab7e67fe9262a846e231ce1538feb395de1e4e388b0fd6ecb9899bd893479da89a9ecc2fd66911f9553d6e2849d947c39d50f65f0dc054504658c3b94910a1af8f36bf369964d2ac29c8ca96bc47c9160b0a10996a5d5055ac9a5a5cd74695c78c17938a85d07315ee26e9232a55e6f198a844be374391c84f5344a6fd062b5e1d1808a02520182bb3b34218c5859258c17b1893bd1aecddb8a689f74ca4ede4fb64e385e18f8e1fc3f5824b2b58225b3a6d3560bcdb4dc2f86d99ee5417301bf33ec186074014cae8aa9b43b5e86a32271c428959b4381f6e68832dece76a517e04da53a7da761c33f7bfd2b06517e1ae650c2003d8b0baedab3dbbc6570ac82132e7b0b8043e9bdbea634d0576f9a47ce7104452df13ec31d3390d849144a41a2466e9bc333a42d1c977cb73f0bcc5e957f72d8ddef4737d9a95c51fe632b0717ada0cddc2e7d05df0c2fa0ebbd88d473980f3a091eefcbd2952a845b16be3b303ac489c2ef1f92d48c5f768801fbef19d9cb70f01f4da8f439586f7962720ac04f8c29cac77c2c91dd05205d09264ba70d977b0c0ebf189ec4d263615ed306e7624e9506092d7ac30210083eff345e21c7d06d219f397329fc3753e20b74ba0953f5cbad2cf502a98d8ed2a863cd072821f332a683059b2c2da247536bfc2634215349b3ae33ecf1e4cf93c51018d2a4c2d0716bf2833c666a20567673dcf245aad1f90175a6db7b703e99b949ae6ec0d2de240ba2283871545dda40967b8c45566a66365837d5a20312953b909ffcb80446859f30ccd1c75434acfe6037494602ed4c7e8c4dd694f4299190eb66e1db1715cdfd4a74f7448e1f402919a98522174cc8951101e3026b3a5d3ee836ad7c667dadb823712adab4a2372c3d41ebdea66941352219e2bbea3b31326320b31f55d382db639c1d8de770f1f6552171f983f63dd7c96594c2a3395ba49a6c8629f6ff0d117841a755333d78c96c26544834a1634017d50b169d22e8c46e8e31266569dfe393f2dad99b49a7baf33d78710a3c6169cc6398d3c5ab2d838341a50577b0aff7d713e2ee14e8ac87f8778f72e648f310e775952a417559e0b2d8e6b6b255b5925ebec01610d807627ee8721c91824f0e5e66ef033b7c056a01ff690a6cb064d9de02d48d7139dbc68fdca7b95b349631191f49ef872e1ee26f0ffd4cd683cac86447705e75cad64ef52153c08734ade53ff1d6cf87940fbcbd1e46af37fb790ce2991599d3386fe4b9093f01900476aaa10d7dfa1cc4fa24923f4c552796735efe05346f9195e1e2b8cbe6427b21539286f3a249f666384b38e51ddc29e32d8a90f589150584746f561bbe1c6b625d2dc589307e6c49715d0f2bcf8404d6ec27b9f53c5cb9d492e335ea36937cf82fc96fbdf789ee87c287089a7708ff85f3c7eca0040a7d40da7daf385edd5bc55d61c3f13cd9da7688301602a70d4cb00875b878c7bde9a2857b58368c1369fff556d2d381d016fef496470db073f37f7b3ca2e091d85c965fdee163bf95156c18705a302366a8929e208d6e2352eb6e13fd1aee12e3946cc45fdb1a054598b3d4b56b4559b5f15a1ba99f2518b7c6fa88dd06056de4b42b9953c515d2ea34905c326bc458b82d5e222a0a47635a0f75c9392e08f2e06bc3919b0d31b23cf49cab0e161aa8b706d9b40b9c5eda45dd41c52676e601415098727b442dfe044ebeeb13321f1da4efb3ca3a94ac33ebe0a64b173f24fc5f892a0f96b1d7742e5ad79c913bbbd4913394217e484c10aa09b45a901c0c253851352d1aedec2fd4b81012addba291f735b993afed45d593c10c05fc3f8c9dc341c4759da3b437d60434aa87c979170d7536010b7beb7e45c2db7a0d2799415244898628e7fe82ce7fd586f3ebdbbf3af1eb57d06416e7bbd3d16726e547613c355d1798ab67570e12f8674d162546afcf3b77d5a3d513f5a4b1d80db696ea3164e0548ab2cf87b880e5694f68c2ccffaa4b59225b4e1c94bed47f19c6c422e7e39fa610b06d41e562babc6cc24759bab1c9b8cb338b40005160de113afd588b807858f6e54a51ec44f9c1f611d28e0941072ab81ac7befc232252742da732d4157ed45c90e2bb6e5efc4bbef92de47c0e607c925078eb0fa2a582adcf207a12466d5a50a877269194c89d780c17049b89e8b657d657dc549a8b109707cc5063a58e8e7503ca2130be7ee69fd883ab4bf9e8f49d78aeb5e7eb2dc2264d2a839c382179bb4d964b893ea1489fba373a88a4ccea2b5c9c7ffb61e14dc7aa4009e08288b7d3b062f52e805951b9fc57b619cc90a7c700c5734ad648e75d848c5915bf3b569ff009c645a54a5d5e1663cecd5f6806bdc4f1c7ae371b5b3cd02772b6edb57e66f03878d2425d1b9a6772c2cccc2c4c7dcf7693bb708e1981676a17c740766c60da9e8edc9ed94d47276fd8f014101e2e48c6c005c041c23e3eb2462f67e145fa8dda2e7b0c3bae334290942bf275431790fcfb670dbb7ee3bd63fbb0bdab87a7eae494de4cdfa08e4c7dc44561680000728697716e774a374b0f171f4622d30192d6499e39852bdb5a8515b5fd74b31ddf5230f2f7ae49d6e8754f6de991acf1709e0d915d14da2ad36563227da59d8fb3d54a3136575d9e3ca5719f031422e653addf162a9e9072906b6ffdf85e4bea368f257e3ef0fad5fcadb8fe354473a76fc91a26ead10918953aa01420fbe51a0afcbb39c8ee3884deb662befe47e221706cc5b2d3ae8fd3c6546bb87a4ade4650a81e15dea4e2e56527e6f34afcd34794ea3211124e0aa50453ac9d4785c1c5a613996e21d06de968fe12a4bcab3ad01a4e2b33393183b498bbbcb0b0994374950197b68548a98303576b719372bbd1cd952d34b1b4077464085384bc835983d7185160cda908b833ee942ff9e4678ffbb6a64a3dab6cc596e14e1c0201b15047c55b4db60c221ccf2d9f8752f600e9e33e3b421138faa83edb630aa02e5483cccf69a2020951dfcdbf36053dd12d6f6f5d34f69f921dff02e724a7cc0d250ad120d301307e94dba5626e872becb8cfac9362cdfaea2a89a048483af384b43278380172725037c2c6dbb503716b4b9f9c06fe6a56b3da8d4841be8f3d0edb0630fe585f18e338eb91e7f3c47bbd6cdca33baad663731629d9aed3381682888029cfdf88e9b8152cd6cf88636afdee23713114e579189e769975e056c3900136e5204a6a5b683f4fd65b689f14ed3932917aa18d85e822c6ae933c55addada6a04bad0e2c7385f8ef359974f6814c0b7659b7026ee1a77786dd72257c1151af900b652e0113be5dfcb84409d5b43618ce8d14c6e83c1253ef7c59531c5b1716965a0125ba698ba0fd05d503319f03313bd2d5f488f18181faa9e98b72a9897b5defc9fd052af09cbe0b398733896fb84f07baa149d2ec3133411b6dc583b4bbd31237d9803040ce0f3d64da8f05b66e3892b90b27028737185c7b45f35d17b7db92dcb633d6430b149a175bae3153c58343ec5799a8a8a08aa10b277483355d567b6be20b1947a3df5052c14e24c9dbeba9771b53dfc2ac22a50095fd11f26cd43181a299bf0cf377beaa6db1b322b8fd6e24fcc242d4d2022f23a87aa89edc16ad4bea319e29db57511890e440682dc30c79d876ab414d6e455d4f6623246866e09584401e4adcdacef1a52395678fdab162755dc1e03fe87e087d2c271b073c3e4a999720b9ef7fe4e27bbbcfe376c1dafad6dc6f97dacfaa786e032f643b799a62c2b89a6481154cd07d084092135b2512eb359eae0a3760c651a09f252a928a4047a7d86cf1853a2321a4c7774c2c4d3308c0b61c6f2103df1b4f88673181ed36b5e07be8f9e73817ddb54027c66c5726cc62155f4b0e5e7517178f17f3e6ffc17dc3ca1e3ca17f245b3889f491b8b9beb226b520bf39f40603096ebf01d3fb33a381337a47a43c379b42cc28357d9be8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="经验" scheme="https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="经验" scheme="https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://protonlml.github.io/2019/10/10/Maven/"/>
    <id>https://protonlml.github.io/2019/10/10/Maven/</id>
    <published>2019-10-10T03:00:00.000Z</published>
    <updated>2024-06-16T02:15:54.402Z</updated>
    
    <content type="html"><![CDATA[<h1><center>Maven</center></h1><h2 id="一、Maven的一些理解"><a href="#一、Maven的一些理解" class="headerlink" title="一、Maven的一些理解"></a>一、Maven的一些理解</h2><ul><li>1.项目的构建，是指项目的“打包”，“编译”，“部署”，“运行”等一系列操作。 </li><li>2.用Maven就可以使我们的项目，能够自动化构建。 </li><li>3.maven是java项目的自动化构建工具。   </li><li>4.Maven可以，将一个大型的项目的不同功能，拆分成多个模块，分别进行开发管理。 </li><li>5.Maven可以，通过配置poom文件，来导入某个技术的jar包，同时会自动的导入这个jar包的相关依赖jar包。</li></ul><h2 id="二、Maven程序的执行原理"><a href="#二、Maven程序的执行原理" class="headerlink" title="二、Maven程序的执行原理"></a>二、Maven程序的执行原理</h2><ol><li><p>maven核心程序指的是，解压后的maven程序目录。也是maven软件的目录里面的内容。</p></li><li><p>Maven在自动构建项目的时候，使用插件会在本地仓库中找，使用依赖jar包也在本地仓库中找。本地找不到就到中央仓库中下载。 </p></li><li><p>怎么使用maven？（不用开发工具）</p><ol><li>创建一个maven规定的项目目录结构，在有poom.xml文件的目录下面，执行maven命令</li><li>当我们执行的Maven命令需要用到某些插件的时候，Maven核心程序会首先到本地仓库中查找</li><li>本地仓库的默认位置：[系统当前用户的家目录].m2\repository(Maven找插件的时候，自动创建)</li><li>Maven核心程序如果在本地仓库中找不到需要的插件的时候，那么它会自动联网，到中央仓库中下载。</li></ol></li><li><p>Maven的生命周期就是指的是“项目的构建过程”，项目的构建是有顺序的，执行的任何一个Maven命令都是从生命周期的头开始。</p></li><li><p>Maven构建项目完成之后，生成的“产品”就放在“项目src所在目录”中的“target”目录中。</p></li><li><p>Pom</p><ol><li>【1】含义：project Object Model 项目对象模型。</li><li>pom.xml对于Maven工程师核心配置文件，与构建过程相关的一切设置都在这个文件中进行</li></ol></li><li><p>Maven坐标类比一下：</p><ol><li><p>数学中可以用（x,yz）三个项量来确定一个空间的点。</p></li><li><p>Maven的pom文件中，也是使用三个项量，来在仓库中唯一定位一个Maven工程</p><ul><li>[1]：<strong>g</strong>roupid：公司或组织域名倒序+项目名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;cn.itcast&lt;/groupId&gt;</span><br></pre></td></tr></table></figure><ul><li>[2]：<strong>a</strong>rtifactid：模块名 </li><li>[3]：<strong>v</strong>ersion：版本<ul><li>只要讲“<strong>gav</strong>”就讲的是Maven的坐标。</li></ul></li><li>[4] :Maven工程的坐标与仓库中的路径对应关系。<ul><li>在Maven仓库里面。每一个Maven工程，他的坐标一定是不重复的，即标识了这个Maven工程信息，同时也决定了他在仓库中存放的目录是什么。</li></ul></li></ul></li></ol></li><li><p>仓库中保存的内容：宽泛的说就是（Maven工程项目）  </p><ul><li>主要有3大块：<ul><li>-[1]：Maven核心软件，自身所需要的一些插件</li><li>[2]：第三方框架或工具的jar包(其实就是第三方项目，打成了jar包)</li><li>[3]：我们自己开发的工程。Maven将“插件”、“框架jar包”、“我们自己的项目”都用统一的目录结构，放在了仓库中，这样就方便Maven核心程序的管理和使用。</li></ul></li></ul></li><li><p>pom.xml文件解析。</p><ul><li>创建的Maven项目中有pom.xml文件，他是Maven项目的核心配置文件。<ul><li>【1】.除了上面三个坐标用来，定位当前项目用Maven核心程序安装在仓库中的位置。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011049.png" alt="Image"></li><li>2】.中间部分是“依赖部分”，就是指当前项目，所使用的到的“其他模块项目和jar包”，在Maven仓库中的坐标。如果仓库中没有指定的依赖jar包，就会自动从私服上面下载，私服上面没有就会到中央仓库中下载。<ul><li>但是如果当前项目，用到我们自己写的模块，这时候就需要将，要使用的模块项目给“安装”到仓库中，用“ mvn install”命令进行安装。是不可能从网上下载的，因为这是我们自己写的，不是第三方jar包项目。这样我们就可以将一个大的项目，进行拆分成很多小的模块，然后各个模块之间用“依赖坐标”，来互相关联。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011083.png" alt="Image"></li></ul></li><li>【3】最下面是“插件”部分。<ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011313.png" alt="Image"></li></ul></li></ul></li></ul></li><li><p>依赖</p><ol><li>①Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。<ul><li>对于我们自己开发的Maven工程，使用mvn install命令安装后就可以进入仓库。</li></ul></li><li>②依赖的范围<ul><li>【1】在pom.xml文件中<scope>依赖的范围</scope></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012747.png" alt="Image"></li><li>依赖的范围一般常用的有三个：compile，test、provided三个。</li><li>依赖范围：意思就是，当前项目所依赖的这个“依赖”，在编译，测试，打包。过程当中时候有效。<ul><li>[1]compile范围的“依赖”（编译范围）</li><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：参与</li><li>是否 参与部署：参与</li><li>[2]test范围的“依赖”（测试范围）</li><li>对主程序是否有效：无效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li><li>典型例子：“junit依赖”它就是测试依赖，这个jar包，不参与打包，在主程序中没有。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012081.png" alt="Image"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012133.png" alt="Image"></li><li>[3]provided范围的“依赖”，通常是为web工程来添加的（不参与部署的范围）。<ul><li>说明只要加了provided范围的“依赖”，web容器中都有。比如：servlet的这个依赖，部署的时候就不需要，因为Tomcat服务器本身就有servlet的jar包。</li></ul></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012653.png" alt="Image"></li><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li><li>典型例子：servlet-api.jar</li></ul></li></ul></li></ol></li><li><p>maven命令是什么？</p><ul><li>maven这个程序，用来构建项目所使用的命令。（这些命令的顺序，就是生命周期的顺序）</li><li>比如【1】清理：mvn clean</li><li>【2】：编译主程序：mvn compile</li><li>【3】：编译测试程序：mvn test-compile</li><li>【4】：执行测试：mvn test</li><li>【5】：打包：mvn package</li><li>【6】：安装：mvn install</li><li>【7】：生成站点：mvn site这些命令，构成了Maven构建项目时的，不同生命周期，</li></ul></li><li><p>12.Maven的生命周期</p><ul><li>【1】意思：就是Maven构建项目的的，各个构建环节执行的顺序。：不能打乱顺序，必须按照既定的正确顺序来执行，是生命周期的各个阶段的命令来实现的。</li><li>【2】生命周期是在Maven的核心程序中定义了，抽象的生命周期。 生命周期中各个阶段的具体任务是由插件来完成的。</li><li>【3】有三套独立的生命周期：<ul><li>①Clean Lifecycle（清理生命周期）在进行，在真正的构建一个项目之前，必须先进行一些清理工作。</li><li>②Default lifecycle（默认的生命周期）构建的核心部分，编译，测试，打包，安装，部署等等。</li><li>③Site Lifecycle（生成站点生命周期）生成项目报告，站点，发布站点。</li></ul></li><li>【4】每个生命周期的具体实现<ul><li>比如：只执行“mvn clean 清理命令”就会进行清理生命周期。</li><li>执行“mvn install 安装命令”就会进行Maven构建项目的默认生命周期，此时Maven核心程序，会从头开始执行“clean清理”,“compile 编译”，“test-compile 编译测试”，“test 执行测试”，“package 打包”，“install 安装”这一系列的过程。</li><li>执行“site 生成站点”，也会从头开始，将所有过程进行一边。这是生成站点生命周期</li><li>Maven核心程序为了更好的实现自动化构建，按照这一的特点执行生命周期中的各个阶段：不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行。</li></ul></li><li>【5】生命周期的各个阶段仅仅定义了要执行的任务是什么（命令）完成这个命令，是由特定的Maven插件来完成的。<ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012162.png" alt="Image"></li></ul></li></ul></li><li><p>创建Maven工程之前，需要将IDEA编辑器，和本地下载的Maven程序，进行关联配置。具体操作，见文末。</p></li></ol><hr><hr><h2 id="三、使用IDEA创建普通的javaMaven工程"><a href="#三、使用IDEA创建普通的javaMaven工程" class="headerlink" title="三、使用IDEA创建普通的javaMaven工程"></a>三、使用IDEA创建普通的javaMaven工程</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012762.png" alt="Image"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012115.png" alt="Image"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012201.png" alt="Image"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013282.png" alt="Image"></p><h2 id="四、-使用IDEA创建webMaven工程（Maven要聚合模块的做法）"><a href="#四、-使用IDEA创建webMaven工程（Maven要聚合模块的做法）" class="headerlink" title="四、.使用IDEA创建webMaven工程（Maven要聚合模块的做法）"></a>四、.使用IDEA创建webMaven工程（Maven要聚合模块的做法）</h2><ul><li><p>【1】必须先创建一个空的工程。在空的工程中添加模块。（每次添加模块都要使用快捷键“ctrl+alt+shift+s”来调出<strong>Project Structure窗口，在这个窗口中添加模块，不能直接在模块上面右键添加模块。（在模块上右键模块会添加到“模块里面”）</strong>）</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013762.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013442.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013622.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013162.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013194.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014349.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014424.png" alt="Image"></p></li><li><h3 id="【标准的Maven工程，分模块的大型web项目，目录结构】"><a href="#【标准的Maven工程，分模块的大型web项目，目录结构】" class="headerlink" title="【标准的Maven工程，分模块的大型web项目，目录结构】"></a>【标准的Maven工程，分模块的大型web项目，目录结构】</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014593.png" alt="Image"></p></li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><h5 id="我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。"><a href="#我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。" class="headerlink" title="我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。"></a>我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。</h5></li></ul><h2 id="五、依赖"><a href="#五、依赖" class="headerlink" title="五、依赖"></a>五、依赖</h2><ul><li><h3 id="依赖的传递性："><a href="#依赖的传递性：" class="headerlink" title="依赖的传递性："></a>依赖的传递性：</h3><ul><li>【1】依赖的传递性是指，如果在一个大型的项目当中，各个模块相互依赖，那么在“最下面的模块（依赖关系最下面，这个模块只是被依赖，不去依赖别的模块）”中，pom.xml文件里面，配置的<strong>compile</strong>”范围的依赖jar包，其他模块的pom.xml文件虽然没有声明一样的<strong>compile</strong>”范围的依赖jar包，但是也可以使用这个依赖。</li><li>【2】前提是“<strong>compile</strong>”范围的依赖才能传递，“<strong>test</strong>”“<strong>provided</strong>”范围的依赖不能传递。所以在各个工程模块中，能够传递的依赖，只在“最下面”模块中声明一次就可以了，不能够传递的“<strong>test</strong>”“<strong>provided</strong>”范围的依赖就得各个模块中重复声明依赖。比如：servlet的依赖，他就是“provided范围的模块”，需要在每一个项目模块pom.xml文件中，都要重复声明。</li><li>【3】我们在开发项目的时候，会有一个专门的模块来负责维护这些框架jar包的依赖信息的。在这个模块中，全部都写“<strong>compile</strong>”范围的依赖”，让其他功能模块，来依赖这个“专门模块”，就可以实现“<strong>compile</strong>”范围的依赖”通用。</li><li>【4】子类继承了父类模块，也可以实现依赖传递，默认就是依赖的，不需要再在子类中，重新声明依赖父类，只在子类中声明父类就可以了。</li></ul></li><li><h3 id="依赖的排除："><a href="#依赖的排除：" class="headerlink" title="依赖的排除："></a>依赖的排除：</h3><ul><li>依赖的排除，在哪个工程里面排除的，就在哪个工程里面生效。</li><li>【1】当我们导入某些依赖jar包的时候，Maven会自动将这个jar的其他依赖jar包也一起导入到工程当中，这个时候，如果不需要这个额外的jar包，就可以用“排除依赖”来进行排除。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014762.png" alt="Image"></li><li>【2】找到要排除的依赖的ID（假如spring-jcl依赖要被排除）</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014723.png" alt="Image"></li><li>3】添加<exclusions> </exclusions>标签</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014062.png" alt="Image"></li></ul></li><li><h3 id="依赖原则："><a href="#依赖原则：" class="headerlink" title="依赖原则："></a>依赖原则：</h3><ul><li><h4 id="解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决）"><a href="#解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决）" class="headerlink" title="解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决）"></a>解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决）</h4></li><li><p>前提是因为“依赖的传递性”导致的jar包冲突问题。</p></li><li><p>冲突情景：</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015782.png" alt="Image"></p></li><li><p><img src="https://gitee.com/lmlpla/blogimages/raw/master/imgs/202401281057892.png" alt="Image"></p></li><li><p><strong>properties标签</strong>配合自定义标签声明数据的配置并。(可以利用这个标签，实现在一个页面上，同种类型的框架jar包，版本号相同，)在父模块中就更简便了</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015754.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015765.png" alt="Image"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span> <span class="comment">&lt;!--不是只能用于声明依赖的版本号。凡是需要统一声明后再引用的场合都可以使用。--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring-core依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring-core依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="六、Mavne继承（pom文件的继承）"><a href="#六、Mavne继承（pom文件的继承）" class="headerlink" title="六、Mavne继承（pom文件的继承）"></a>六、Mavne继承（pom文件的继承）</h2><ul><li><p>存在的问题：我们都知道在一个“模块项目1”中配置了“<strong>compile</strong>”范围的依赖jar包”，“其他模块项目”来依赖这个“模块项目1”的时候，“其他模块项目”中会自动的存在了“项目模块1的”“<strong>compile</strong>”范围的依赖jar包”。这是依赖的传递性。只用在“模块项目1”中声明一份就可以了。</p></li><li><p>但是：如果是““<strong>test</strong>”“<strong>provided</strong>”范围的依赖是不能传递的”，需要在每一个模块中都要，重复的手动添加““<strong>test</strong>”“<strong>provided</strong>”范围的依赖”，比如“junit依赖”，他就是“test范围的依赖”。（不能够传递的依赖，他就是零散的分散在各个模块当中，就很容易造成各个模块工程之间的版本不一致）。</p></li><li><p>这就存在一个问题，开发一个大型项目的时候，各个模块是不同开发组来开发的，使用“junit这种依赖”的时候，可能版本号就会不相同，导致各个模块之间不统一。</p></li><li><p>解决办法：使用Maven的继承，统一成同一个版本。（以junit依赖为例）</p></li><li><p>【1】专门创建一个模块是所有模块的“父模块”，可以用作““<strong>compile</strong>”范围的依赖jar包”传递依赖。也可以用作““<strong>test</strong>”“<strong>provided</strong>”范围的依赖”的版本管理。</p></li><li><p>【2】解决思路：将junit依赖统一提取到“父”工程中，在子工程中声明junit依赖时不指定版本，以父工程中统一设定的为准。同时也便于修改。</p></li><li><p>【3】操作步骤  [1]创建一个Maven工程作为父工程。注意：打包的方式pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atlml.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015851.png" alt="Image"></p></li><li><p>[2]在子工程中声明对父工程的引用（认干爹的一个仪式）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子工程中声明父工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atlml.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--以当前pom文件为基准的,找父工程pom.xml文件的相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>[3]在父工程中统一管理junit的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖管理，这里专门用来管理，不能够传递的依赖，进行版本号控制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- junit是“test”范围的依赖，不能够传递，在这里面统一管理版本号--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>[4]在子工程中删除junit依赖的版本号部分 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;version&gt;4.11&lt;/version&gt;--&gt;</span> 删除掉</span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>[5]实现效果</p><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015552.png" alt="Image"></li></ul></li><li><p>[6]：父模块的Pom.xml文件的配置。</p><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015722.png" alt="Image"></li></ul></li></ul><h2 id="七、Maven的聚合："><a href="#七、Maven的聚合：" class="headerlink" title="七、Maven的聚合："></a>七、Maven的聚合：</h2><ul><li><p>（聚合就是Maven中，各个模块的一键安装。）</p></li><li><p>注意：配置了继承的模块，在执行安装命令（ install）的时候，要先安装 “父模块”再安装其他模块才能成功。</p></li><li><p>Maven中的一件安装，就可以自动的按顺序，将每个模块都按依赖顺序进行安装。</p></li><li><p>实现一件安装步骤：</p><ul><li><p>【1】创建一个“总的聚合工程”，（一般把“父模块”作为“总的聚合工程”，大的情况下也是将，聚合的配置，也配在父模块内）</p></li><li><p>【2】在一个”总的聚合工程”的pom.xml文件中，配置各个參与聚合的模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置聚合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--指定各个子工程的相对路径--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hellow<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span>../HellowFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="八、Maven仓库地址"><a href="#八、Maven仓库地址" class="headerlink" title="八、Maven仓库地址"></a>八、Maven仓库地址</h2><ul><li><a href="https://mvnrepository.com/">Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com)</a></li><li><a href="https://developer.aliyun.com/mvn/search">仓库服务 (aliyun.com)</a></li></ul><h2 id="九、IDEA中Maven配置"><a href="#九、IDEA中Maven配置" class="headerlink" title="九、IDEA中Maven配置"></a>九、IDEA中Maven配置</h2><p><a href="https://www.jb51.net/article/259780.htm">IDEA配置Maven的超详细步骤_java_脚本之家 (jb51.net)</a></p><p><a href="https://blog.csdn.net/qq_42057154/article/details/106114515">IDEA配置Maven（详细版）_idea maven-CSDN博客</a></p><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;Maven&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、Maven的一些理解&quot;&gt;&lt;a href=&quot;#一、Maven的一些理解&quot; class=&quot;headerlink&quot; title=&quot;一、Maven的一些理解&quot;&gt;&lt;/a&gt;一、Maven的一些理解&lt;/h2&gt;</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    <category term="maven" scheme="https://protonlml.github.io/categories/java/maven/"/>
    
    
    <category term="maven" scheme="https://protonlml.github.io/tags/maven/"/>
    
    <category term="项目自动化构建工具" scheme="https://protonlml.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>javaScript</title>
    <link href="https://protonlml.github.io/2019/10/01/javascript/"/>
    <id>https://protonlml.github.io/2019/10/01/javascript/</id>
    <published>2019-10-01T04:00:00.000Z</published>
    <updated>2024-06-16T02:11:23.105Z</updated>
    
    <content type="html"><![CDATA[<h1><center>javaScript</center></h1><blockquote><p>静态网页资源的三剑客：HTML（文本），CSS（样式），JavaScript（行为）。把后面两个效果，加在HTML文本上，就会呈现出很好看的网页界面。</p><ol><li>程序设计有两种架构：1 c&#x2F;s架构，是客户端和服务器端，要开发两个程序。2 b&#x2F;s架构，是浏览器和服务端。只用浏览器来申请服务器端的资源，再展示出来就好了。只用开发服务器端一个软件。</li><li>javaWeb开发，是B&#x2F;S架构的。</li><li>事件：事件是什么意思？通俗的理解，HTML中的元素组件，被某个动作（事件的属性），触动后，会发生一定的变化。（执行了另一个js代码）。</li><li>将HTML，CSS，JavaScript分别独立出来，可以降低耦合度，</li></ol><p>javaScript最初被设计用于浏览器中，他和java语言没有关系，他是客户端脚本语言</p><p>javaScript语言运行出错，要在浏览器控制台上面查看。F12打开控制台。</p></blockquote><p>- </p><h2 id="一、javaScript"><a href="#一、javaScript" class="headerlink" title="一、javaScript"></a>一、javaScript</h2><ul><li>注意：在一个html的页面中，可以定义多个script的标签，而且存放的位置是任意的，但是会影响运行的先后顺序，一般都是等html页面元素全部加载完毕，再运行js代码，并且是一种等待状态。当在html中的某个位置，触发了某个事件，此时对应的js等待代码，就会执行。从而产生行为效果</li></ul><h3 id="1-javascript与HTML的关联方式："><a href="#1-javascript与HTML的关联方式：" class="headerlink" title="1.javascript与HTML的关联方式："></a>1.javascript与HTML的关联方式：</h3><ul><li><p>内部关联</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160949148.png" alt="image-20240130214055735"></p></li><li><p>外部关联</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951711.png" alt="image-20240130214133935"></p></li></ul><h3 id="2-javascript的数据类型"><a href="#2-javascript的数据类型" class="headerlink" title="2.javascript的数据类型"></a>2.javascript的数据类型</h3><ul><li><blockquote><p>原始数据类型：</p><pre><code>     1. number：数字 。 整数/小数/ NAN （not  a number 一个不是数字的数字类型）        2. string ：字符串。字符串 &quot;abc&quot; &quot;a&quot; &#39;abc&#39;        3. boolean：true 和 false        4. null：一个对象为空的占位符        5. undefined：未定义，如果一个变量没有给他初始化值，则会被默认赋值为undefined</code></pre><p>注意：NaN是number类型，他是（不是数字的数字）。在js当中，运算符，后面的运算数，不是运算符要求的类型，js就会自动的将运算数进行类型转换。比如：numb&#x3D; +”abc”;此时：number根据”+”运算符，如果是数字，就会直接转换成数字，但是转换符后面跟的不是数字类型，则会转换成不是数字的数字类型。值为NaN.</p></blockquote></li></ul><h3 id="3-JavaScript的变量"><a href="#3-JavaScript的变量" class="headerlink" title="3.JavaScript的变量"></a>3.JavaScript的变量</h3><ul><li><p>什么是变量：变量就是内存空间中的一小片区域。有类型，有名称，有值。比如：int a&#x3D;3;</p></li><li><p>JavaScript的变量是弱类型的，什么叫弱类型，就是不管定义什么类型的变量，都用var开头。</p></li><li><p>而java中定义整型用int，定义字符型用char 。所以java是强类型的。</p></li><li><p>☆ 通过typeof(变量名)可以得到变量的类型</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951978.png" alt="image-20240130215045915"></p></li><li><p>注释:你也许会问,为什么typeof运算符对于nul值会返回”object”.这实际上是javaScript最初实现中的个错误,然后被<br>ECMAScript沿用了,现在,null被认为是 对象的占位符,从而解释了这一矛盾,但从技求上来说,它仍是原始值。</p></li></ul><h3 id="4-javascript中的运算符"><a href="#4-javascript中的运算符" class="headerlink" title="4.javascript中的运算符"></a>4.javascript中的运算符</h3><ul><li><h4 id="①一元运算符：就是只有一个运运算数的运算符。"><a href="#①一元运算符：就是只有一个运运算数的运算符。" class="headerlink" title="①一元运算符：就是只有一个运运算数的运算符。"></a>①一元运算符：就是只有一个运运算数的运算符。</h4><ul><li>++ 、–、+（正号）、-（负号）</li><li>“++（–）”在前，先自增（自减），再运算。</li><li>“++（–）”在后，先运算，再自增（自减）。</li><li>+（-）（正负号）</li></ul></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160950599.png" alt="Image"></p></li><li><h4 id="②算数运算符：“-”，“-”，“-”，“-”-，“-”（和java中使用方法相同）"><a href="#②算数运算符：“-”，“-”，“-”，“-”-，“-”（和java中使用方法相同）" class="headerlink" title="②算数运算符：“+”，“-”，“* ”，“&#x2F;” ，“%”（和java中使用方法相同）"></a>②算数运算符：“+”，“-”，“* ”，“&#x2F;” ，“%”（和java中使用方法相同）</h4></li><li><h4 id="③赋值运算符：“-”，“-”“-”（和java中使用方法相同）"><a href="#③赋值运算符：“-”，“-”“-”（和java中使用方法相同）" class="headerlink" title="③赋值运算符：“+&#x3D;”，“-&#x3D;”“&#x3D;”（和java中使用方法相同）"></a>③赋值运算符：“+&#x3D;”，“-&#x3D;”“&#x3D;”（和java中使用方法相同）</h4></li><li><h4 id="④-比较运算符：“-”，“-”，“"><a href="#④-比较运算符：“-”，“-”，“" class="headerlink" title="④ 比较运算符：“&gt;”，“&lt;”，“&gt;&#x3D;”，“&lt;&#x3D;”，“&#x3D;&#x3D;”，   “&#x3D; &#x3D;&#x3D;（全等于）”"></a>④ 比较运算符：“&gt;”，“&lt;”，“&gt;&#x3D;”，“&lt;&#x3D;”，“&#x3D;&#x3D;”，   “&#x3D; &#x3D;&#x3D;（全等于）”</h4><ul><li>“&#x3D; &#x3D;”是比较两个数是否相等，“&#x3D;&#x3D;&#x3D;全等于”是加上了类型的比较。</li></ul></li><li><h3 id="⑤-逻辑运算符：“-”，“-”，“！”"><a href="#⑤-逻辑运算符：“-”，“-”，“！”" class="headerlink" title="⑤ 逻辑运算符：“&amp;&amp;”，“||”，“！”"></a>⑤ 逻辑运算符：“&amp;&amp;”，“||”，“！”</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951947.png" alt="Image [3]"></li></ul></li><li><h3 id="⑥-三元运算符“-？：表达式”"><a href="#⑥-三元运算符“-？：表达式”" class="headerlink" title="⑥ 三元运算符“ ？：表达式”"></a>⑥ 三元运算符“ <u>？：表达式</u>”</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951447.png" alt="Image [4]"></li></ul></li></ul><h2 id="二、javascript-中的特殊语法"><a href="#二、javascript-中的特殊语法" class="headerlink" title="二、javascript 中的特殊语法."></a>二、javascript 中的特殊语法.</h2><p>(了解一下就好，但是要和java规范一样写代码，不要省“；”，也不要省“var”，带var的变量，是局部变量，不带var的变量是全局变量 。)</p><h2 id="三、流程控制语句"><a href="#三、流程控制语句" class="headerlink" title="三、流程控制语句"></a>三、流程控制语句</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951597.png" alt="Image [5]"></p><h2 id="练习-：javascript（9x9乘法表）"><a href="#练习-：javascript（9x9乘法表）" class="headerlink" title="练习 ：javascript（9x9乘法表）"></a>练习 ：javascript（9x9乘法表）</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160959985.png" alt="Image [6]"></p><hr><hr><h2 id="四、BOM对象："><a href="#四、BOM对象：" class="headerlink" title="四、BOM对象："></a>四、BOM对象：</h2><ul><li><h4 id="概念：Browser-object-Model-浏览器对象模型。将浏览器各个组成部分封装为对象。"><a href="#概念：Browser-object-Model-浏览器对象模型。将浏览器各个组成部分封装为对象。" class="headerlink" title="概念：Browser object Model 浏览器对象模型。将浏览器各个组成部分封装为对象。"></a>概念：Browser object Model 浏览器对象模型。将浏览器各个组成部分封装为对象。</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160954667.png" alt="Image [13]"></p></li><li><h4 id="BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。"><a href="#BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。" class="headerlink" title="BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。"></a>BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。</h4><h3 id="①-window窗口对象。"><a href="#①-window窗口对象。" class="headerlink" title="① window窗口对象。"></a>① window窗口对象。</h3><ul><li><h4 id="window窗口的第一类方法：弹窗有关的方法"><a href="#window窗口的第一类方法：弹窗有关的方法" class="headerlink" title="window窗口的第一类方法：弹窗有关的方法"></a>window窗口的第一类方法：弹窗有关的方法</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161001435.png" alt="image-20240130231750600"></p></li><li><h4 id="window窗口的第二类方法：打开关闭窗口的方法。"><a href="#window窗口的第二类方法：打开关闭窗口的方法。" class="headerlink" title="window窗口的第二类方法：打开关闭窗口的方法。"></a>window窗口的第二类方法：打开关闭窗口的方法。</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161002045.png" alt="image-20240130232026695"></p></li><li><h4 id="window窗口的第三类方法：与定时器有关的方法"><a href="#window窗口的第三类方法：与定时器有关的方法" class="headerlink" title="window窗口的第三类方法：与定时器有关的方法"></a>window窗口的第三类方法：与定时器有关的方法</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161003416.png" alt="image-20240130232218944"></p></li><li><h4 id="Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（-html文件对象）。直接写就可以用"><a href="#Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（-html文件对象）。直接写就可以用" class="headerlink" title="Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（.html文件对象）。直接写就可以用"></a>Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（.html文件对象）。直接写就可以用</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161003635.png" alt="Image [27]"></p></li></ul></li></ul><h2 id="②、-Location地址栏对象"><a href="#②、-Location地址栏对象" class="headerlink" title="②、 Location地址栏对象"></a>②、 Location地址栏对象</h2><ul><li><p>Location 对象的方法。reload().用来刷新当前页面。 属性：href</p></li><li><p>Location地址栏对象，他的一个属性href。有两个作用，设置当前页面的URL和获取当前页面的完整的URL.（这里面的设置和获取URL都是针对当前页面的。设置的话，就是重新赋值，设置为新的地址，这样当前页面就会跳转到设置的地址页面中去）</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161003845.png" alt="Image [28]"></p></li><li><h3 id="倒计时跳转网页案例"><a href="#倒计时跳转网页案例" class="headerlink" title="倒计时跳转网页案例"></a>倒计时跳转网页案例</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161004716.png" alt="image-20240130233011287"></p></li></ul><h2 id="③、-history当前页面历史记录对象。"><a href="#③、-history当前页面历史记录对象。" class="headerlink" title="③、 history当前页面历史记录对象。"></a>③、 history当前页面历史记录对象。</h2><ul><li>属性：length：history.length；返回的是。历史记录的个数。 </li><li>方法：back();加载history列表中的上一个URL。绑定单击事件，就可以做一个后退的按钮。</li><li>方法： forword(); 加载history列表中的下一个URL。绑定单击事件，就可以做一个前进的按钮。</li><li>方法：go(); 加载history列表中的某一个具体页面。</li></ul><hr><hr><h2 id="五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML-DOM对象。）"><a href="#五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML-DOM对象。）" class="headerlink" title="五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML DOM对象。）"></a>五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML DOM对象。）</h2><ul><li><h4 id="☆-DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。"><a href="#☆-DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。" class="headerlink" title="☆ DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。"></a>☆ DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。</h4></li><li><h4 id="☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。"><a href="#☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。" class="headerlink" title="☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。"></a>☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。</h4></li><li><h4 id="DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析）"><a href="#DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析）" class="headerlink" title="DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析）"></a>DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析）</h4></li><li><h4 id="DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。"><a href="#DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。" class="headerlink" title="DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。"></a>DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161004804.png" alt="Image [7]"></p></li><li><h3 id="①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element-其他标签对象-对象。或者是创建Element-其他标签对象-对象。"><a href="#①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element-其他标签对象-对象。或者是创建Element-其他标签对象-对象。" class="headerlink" title="①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element(其他标签对象)对象。或者是创建Element (其他标签对象)对象。"></a>①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element(其他标签对象)对象。或者是创建Element (其他标签对象)对象。</h3><ul><li><h5 id="document-write-““-向页面上写出一条横线（就是往页面写出信息的）"><a href="#document-write-““-向页面上写出一条横线（就是往页面写出信息的）" class="headerlink" title="document.write(““)   向页面上写出一条横线（就是往页面写出信息的）"></a>document.write(“<hr>“)   向页面上写出一条横线（就是往页面写出信息的）</h5></li><li><h4 id="1-1-document对象：获取element对象的方法。"><a href="#1-1-document对象：获取element对象的方法。" class="headerlink" title="1.1 document对象：获取element对象的方法。"></a>1.1 document对象：获取element对象的方法。</h4></li><li><blockquote><ol><li>getElementById（） ：根据id属性值获取元素对象。id属性值一般唯一</li><li>getElementsByTagName （） ：根据元素名称获取元素对象们。返回值是一个数组</li><li>getElementsByClassName （）：根据Class属性值获取元素对象们。返回值是一个数组</li><li>getElementsByName（）：根据name属性值获取元素对象们。返回值是一个数组</li></ol></blockquote></li><li><h4 id="1-2-document对象：创建其他DOM对象："><a href="#1-2-document对象：创建其他DOM对象：" class="headerlink" title="1.2  document对象：创建其他DOM对象："></a>1.2  document对象：创建其他DOM对象：</h4></li><li><blockquote><ol><li>createElement（“标签名”）：创建元素节点（记住）</li><li>createAttribute（name）：创建拥有指定名称的属性节点，并返回新的Attr对象。（了解）</li><li>createComment（）：创建注释节点。（了解）</li><li>createTextNode（）：创建文本节点。（了解）</li></ol></blockquote></li></ul></li><li><h3 id="②：Element对象（元素标签对象）"><a href="#②：Element对象（元素标签对象）" class="headerlink" title="②：Element对象（元素标签对象）"></a>②：Element对象（元素标签对象）</h3><ul><li>1，获取&#x2F;创建：通过document来获取和创建</li><li>2.方法：<ul><li>removeAttribute（“”） ：删除属性</li><li>setAttribute（“属性名”，“属性值”） ：设置属性值。</li></ul></li><li>补充：input框框，有个value属性，用其节点对象.value可以得到，文本框里面的内容。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161004004.png" alt="Image [8]"></li></ul></li><li><h3 id="③：Node对象-（是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。"><a href="#③：Node对象-（是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。" class="headerlink" title="③：Node对象 （是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。"></a>③：Node对象 （是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。</h3></li><li><p>appendchild（节点对象名） ：向节点的子节点列表的结尾添加新的子节点。（增）</p></li><li><p>removechild（节点对象名） ：删除（并返回）当前节点的指定子节点。（删）</p></li><li><p>replacechild（节点对象名） ：用新节点替换一个子节点。（改，不常用）。</p></li><li><p>属性：父节点&#x3D;当前节点.parentNode; 返回当前节点的父节点。</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161004614.png" alt="Image [9]"></p></li></ul><h2 id="六、☆javascript-中的几个对象的学习。"><a href="#六、☆javascript-中的几个对象的学习。" class="headerlink" title="六、☆javascript 中的几个对象的学习。"></a>六、☆javascript 中的几个对象的学习。</h2><ul><li><h3 id="1-☆-function函数方法对象、Array数组对象。"><a href="#1-☆-function函数方法对象、Array数组对象。" class="headerlink" title="1.☆ function函数方法对象、Array数组对象。"></a>1.☆ function函数方法对象、Array数组对象。</h3></li><li><p>function对象，在javascript 中，定义方法，是用function对象，来定义方法的。</p><blockquote><ul><li>语法：function 方法名（参数列表）{方法体}</li><li>&#x2F;&#x2F; javascript中定义方法，的写法和java类似。 但是是用的function对象定义的方法</li><li>&#x2F;&#x2F; js中用function定义的方法，参数列表不用写类型，返回值不用写类型</li><li>&#x2F;&#x2F; js中用function定义的方法，如果有多个同名的方法，那么后面的同名方法，会覆盖前面的同名方法，</li><li>&#x2F;&#x2F; js中用function定义的方法，在调用方法时，只要方法名确定就会调用最后面的同名不同参数的方法。他和参数列表无关。</li><li>&#x2F;* js中用function定义的方法，参数列表的括号里面隐藏了一个内置对象，是一个arguments的数组。 所以当参数列表中不写形式参数时，function add(){ 方法体} 括号里面就是一个可变形参 每一个传递过来的实参，都存在arguments[0].arguments[1]……..等数组中。 *&#x2F;</li></ul></blockquote></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005585.png" alt="Image [31]"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005624.png" alt="Image [32]"></p></li><li><h3 id="2-☆-Array数组对象"><a href="#2-☆-Array数组对象" class="headerlink" title="2.☆ Array数组对象"></a>2.☆ Array数组对象</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005814.png" alt="image-20240130233856091"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005815.png" alt="image-20240130233912957"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005824.png" alt="image-20240130233952371"></li><li><img src="https://gitee.com/lmlpla/blogimages/raw/master/imgs/202401302340524.png" alt="image-20240130234025914"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005034.png" alt="image-20240130234102744"></li></ul></li><li><h3 id="3-☆-Date日期对象"><a href="#3-☆-Date日期对象" class="headerlink" title="3.☆ Date日期对象"></a>3.☆ Date日期对象</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006224.png" alt="image-20240130234717315"></li></ul></li><li><h3 id="4-☆Math数学对象"><a href="#4-☆Math数学对象" class="headerlink" title="4.☆Math数学对象"></a>4.☆Math数学对象</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006954.png" alt="image-20240130234909211"></li></ul></li><li><h3 id="5-☆-regExp：正则表达式对象。"><a href="#5-☆-regExp：正则表达式对象。" class="headerlink" title="5.☆ regExp：正则表达式对象。"></a>5.☆ regExp：正则表达式对象。</h3><ul><li><h5 id="先了解什么是正则表达式"><a href="#先了解什么是正则表达式" class="headerlink" title="先了解什么是正则表达式"></a>先了解什么是正则表达式</h5></li><li><p>正则表达式就是定义字符串的组成规则（通用的规则，在Java中或者其他语言中都可以使用）。在表单的输入框的地方，实现校验输入的字符串是不是符合正则表达式的规则。不符合校验失败，阻止表单的提交。 </p></li><li><p>☆ Javascript对表单的校验，是依赖于正则表达式的。</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006465.png" alt="image-20240130235118937"></p></li><li><h3 id="正则表达式对象。regExp"><a href="#正则表达式对象。regExp" class="headerlink" title="正则表达式对象。regExp"></a>正则表达式对象。regExp</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006474.png" alt="image-20240130235241803"></p></li></ul></li><li><h3 id="6-☆全局对象"><a href="#6-☆全局对象" class="headerlink" title="6.☆全局对象"></a>6.☆全局对象</h3><ul><li>在javascript中，有一个全局对象Global，他不用创建对象，直接用其内部的方法，就可以实现对应的功能，一般有字符串的URL编解码方法。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006591.png" alt="image-20240130235441038"></li></ul></li></ul><hr><hr><h2 id="七、-事件绑定的方式"><a href="#七、-事件绑定的方式" class="headerlink" title="七、 事件绑定的方式"></a>七、 事件绑定的方式</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007040.png" alt="Image [10]"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007483.png" alt="Image [11]"></p><ul><li><h3 id="得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。"><a href="#得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。" class="headerlink" title="得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。"></a>得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。</h3></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007833.png" alt="Image [12]"></p><hr><hr><h2 id="八、HTML-DOM：是关于如何获取、修改、添加或删除HTML元素的标准"><a href="#八、HTML-DOM：是关于如何获取、修改、添加或删除HTML元素的标准" class="headerlink" title="八、HTML DOM：是关于如何获取、修改、添加或删除HTML元素的标准"></a>八、HTML DOM：是关于如何获取、修改、添加或删除HTML元素的标准</h2><ul><li><h3 id="☆①所有的节点对象都有的关键的属性innerHTML"><a href="#☆①所有的节点对象都有的关键的属性innerHTML" class="headerlink" title="☆①所有的节点对象都有的关键的属性innerHTML"></a>☆①所有的节点对象都有的关键的属性innerHTML</h3><ul><li><p>innerHTML。是获取节点对象，里面的所有内容。就是获取了，一对“&lt;&gt;标签体&lt;&#x2F;&gt;”中的标签体的内容。标签体可以是一段文字，也可以是其他标签。 </p></li><li><p>通过给innerHTML赋值或者追加值，可以改表标签体的内容。如下图</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007153.png" alt="image-20240131000856980"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007874.png" alt="image-20240131000909451"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007864.png" alt="image-20240131000922589"></p></li><li><h5 id="上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。"><a href="#上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。" class="headerlink" title="上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。"></a>上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。</h5></li></ul></li><li><h3 id="☆②所有的节点对象都有的关键的属性style。"><a href="#☆②所有的节点对象都有的关键的属性style。" class="headerlink" title="☆②所有的节点对象都有的关键的属性style。"></a>☆②所有的节点对象都有的关键的属性style。</h3><ul><li><h4 id="1-给style属性赋值，就可以改变其样式。"><a href="#1-给style属性赋值，就可以改变其样式。" class="headerlink" title="1.给style属性赋值，就可以改变其样式。"></a>1.给style属性赋值，就可以改变其样式。</h4><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007847.png" alt="Image [70]"></li></ul></li><li><p>注意：两个单词的写法</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008113.png" alt="Image [71]"></p></li><li><p><img src="https://gitee.com/lmlpla/blogimages/raw/master/imgs/202401310011810.png" alt="image-20240131001138257"></p></li><li><h3 id="2-改变节点对象的class值。用className属性。"><a href="#2-改变节点对象的class值。用className属性。" class="headerlink" title="2. 改变节点对象的class值。用className属性。"></a>2. 改变节点对象的class值。用className属性。</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008443.png" alt="Image [72]"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008722.png" alt="Image [73]"></p></li><li><h4 id="3-要想设置和修改，节点的属性值。查Api文档。例如：-标签图片标签，每出现一次，一个-Image-对象就会被创建。找image对象的属性，src设置或返回图像的-URL"><a href="#3-要想设置和修改，节点的属性值。查Api文档。例如：-标签图片标签，每出现一次，一个-Image-对象就会被创建。找image对象的属性，src设置或返回图像的-URL" class="headerlink" title="3.要想设置和修改，节点的属性值。查Api文档。例如： 标签图片标签，每出现一次，一个 Image 对象就会被创建。找image对象的属性，src设置或返回图像的 URL"></a>3.要想设置和修改，节点的属性值。查Api文档。例如：<img> 标签图片标签，每出现一次，一个 Image 对象就会被创建。找image对象的属性，src设置或返回图像的 URL</h4></li></ul></li></ul><hr><hr><h2 id="九、事件"><a href="#九、事件" class="headerlink" title="九、事件"></a>九、事件</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008164.png" alt="Image [74]"></p><ul><li><h3 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h3><ul><li><h4 id="1-点击事件"><a href="#1-点击事件" class="headerlink" title="1.点击事件"></a>1.点击事件</h4></li><li><blockquote><ol><li><p>onclick：单机事件</p></li><li><p>ondblclick ：双击事件</p></li></ol></blockquote></li><li><h4 id="2-焦点事件"><a href="#2-焦点事件" class="headerlink" title="2.焦点事件"></a>2.焦点事件</h4></li><li><blockquote><ol><li>onblur：失去焦点</li></ol><ul><li>一般用于表单验证,当光标不在输入框时，就会失去焦点，触发onblur事件发生。</li></ul><ol start="2"><li>onfocus：元素获得焦点</li></ol></blockquote></li><li><h4 id="3-加载事件"><a href="#3-加载事件" class="headerlink" title="3.加载事件"></a>3.加载事件</h4></li><li><blockquote><ol><li>onload：一张页面或者一幅图像完成加载</li></ol><ul><li>内部加载方式：script标签如果写在head标签里面，在上面的话，要使用窗口的事件机制，加载事件来控制，js 代码，在HTML页面加载完全，才运行。</li><li>如下图</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008323.png" alt="Image [80]"></li></ul></blockquote></li><li><h4 id="4-鼠标事件"><a href="#4-鼠标事件" class="headerlink" title="4.鼠标事件"></a>4.鼠标事件</h4></li><li><blockquote><ol><li>onmousedown ：标按钮披按下.</li></ol><ul><li>定义方法时,定义一个形参,接受 event 对象.</li><li>eventi对象的button属性可以获取鼠标按钮键被点击了.</li></ul><ol start="2"><li>onmouseup  ：鼠标按键被松开.</li><li>onmousemove ：鼠标被移动.</li><li>onmouseover：鼠标移到某元素之上.</li><li>onmouseout：鼠标从某元素移开.</li></ol></blockquote></li><li><h4 id="5-键盘事件"><a href="#5-键盘事件" class="headerlink" title="5.键盘事件"></a>5.键盘事件</h4></li><li><blockquote><ol><li>onkeydown： 某个键盘按键被按下.</li><li>onkeyup ：某个键盘按键被松开.</li><li>onkeypress： 某个键盘按键被按下并松开.</li></ol></blockquote></li><li><h4 id="6-选择和改变事件"><a href="#6-选择和改变事件" class="headerlink" title="6.选择和改变事件"></a>6.选择和改变事件</h4></li><li><blockquote><ol><li>onchange：域的内容被改变.</li></ol><ul><li><h4 id="☆-当在选择的下拉列表上，选择某个选项会触发该事件。"><a href="#☆-当在选择的下拉列表上，选择某个选项会触发该事件。" class="headerlink" title="☆ 当在选择的下拉列表上，选择某个选项会触发该事件。"></a>☆ 当在选择的下拉列表上，选择某个选项会触发该事件。</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009283.png" alt="Image [81]"></p></li></ul><ol start="2"><li>onselect：文本被选中.</li></ol></blockquote></li><li><h4 id="7-表单事件"><a href="#7-表单事件" class="headerlink" title="7.表单事件:"></a>7.表单事件:</h4></li><li><blockquote><ol><li>onsubmit：确认按钮被点击.</li></ol><ul><li>可以阻止表单的提交<ul><li>方法返回falsel则表单被阻止提交.</li></ul></li><li>写法：</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009623.png" alt="Image [82]"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009823.png" alt="Image [83]"></li></ul><ol start="2"><li>onreset：重置按钮被点击.</li></ol></blockquote></li></ul></li></ul><hr><hr><h2 id="练习：动态表格案例"><a href="#练习：动态表格案例" class="headerlink" title="练习：动态表格案例"></a>练习：动态表格案例</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009683.png" alt="image-20240131000210183"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009764.png" alt="image-20240131000243636"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161010442.png" alt="image-20240131000254150"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161010003.png" alt="image-20240131000332037"></p><ul><li>☆动态表格案例总结：用DOM对象在内存层面你，不管创建了多少子节点或者父节点，这些结构都是在内存层面上的，在浏览器页面上不能够直接显示，要想显示，必须有html的已有标签对象。先获取已有的html标签对象节点，将内存层面上的节点，appendChild为已有节点的子节点。同时，属性的样式会关联到css样式表中，只要和css表中的选择器对应的上，就可以显示样式。</li><li>☆ 技巧：怎样获取当前标签的对象，直接在html标签后面，加上事件属性。绑定事件方式一，事件调用指定方法，括号里面写this。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161010543.png" alt="image-20240131000404203"></li><li>那么就可以在方法声明的地方，形式参数就是当前对象。如下图：</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161010436.png" alt="Image [62]"></li></ul><hr><hr><h2 id="总结1："><a href="#总结1：" class="headerlink" title="总结1："></a>总结1：</h2><ul><li><h3 id="怎么来理解BOM对象和DOM对象以及HTML-DOM对象？"><a href="#怎么来理解BOM对象和DOM对象以及HTML-DOM对象？" class="headerlink" title="怎么来理解BOM对象和DOM对象以及HTML DOM对象？"></a>怎么来理解BOM对象和DOM对象以及HTML DOM对象？</h3></li><li><p>1 . BOM对象，就是将浏览器各个组成部分，封装为对象。有显示器对象、浏览器对象、windows窗口对象、URL地址栏对象、以及历史记录对象，这5个BOM对象。windows窗口对象，是BOM对象中的主要对象，因为其他对象都在一个窗口当中。可以通过windows对象来获取，其他4个BOM对象。</p></li><li><p>2 .在windows窗口获取的document对象，是DOM对象。</p><ul><li>document对象是DOM对象的主要对象。DOM对象也在窗口内，但是只有document对象（.html文件对象）是通过窗口获取，其他DOM对象是通过document对象获取的。</li></ul></li><li><p>3 .document对象，他是将整个文档封装成一个document对象。对应着HTML里面最外层标签<html></html>。他可以获取其他节点对象</p><ul><li>document.getElementById()；。或者对象们；另外也可以创建其他DOM对象。</li></ul></li><li><p>4.有了一些基础的DOM对象，也就是有了某个标签的（节点）的对象之后。然后用HTML DOM来、对这个对象进行获取、修改、添加或删除操作。</p></li><li><p>5.从上往下看，一层一层的，从窗口(window)——&gt;文本对象(document)——&gt;单个文本元素对象(element)——&gt;单个文本元素操作（HTML DOM）这样方便记忆。也便于理解。</p></li><li><p>节点：在HTML中所有的单个元件，就是单个节点。对应着一对，一对的标签。</p></li><li><p>子节点：外标签包着内标签，也就是节点包着子节点。例如：<body>文字 <a>超链接</a></body>。</p></li><li><p>Node 节点对象：他可以认为是虚有的，它里面的方法用来“CRUDdom树”</p></li><li><p>其实就是所有的DOM对象，都是一个节点，DOM对象本身，就可以增加节点，删除节点，替换节点，查询节点。</p></li><li><p>有了DOM这些对象，用他们的功能。就可以用javaScript语言对HTML的标签进行操作。</p></li><li><p>要记住：虽然能用，JavaScript语言来操作，内存层面的HTML的元素对象代码，使其在浏览器上面显示样式。但是他和HTML里面的标签没有，任何关系。</p><ul><li>执行了“JavaScript语言操作的元件对象，比如添加节点，删除节点”不会再HTML文档中自动生成，HTML代码。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011212.png" alt="Image [84]"></p><ul><li><h3 id="理解、标签、标签体、标签属性、控制元素的样式。"><a href="#理解、标签、标签体、标签属性、控制元素的样式。" class="headerlink" title="理解、标签、标签体、标签属性、控制元素的样式。"></a>理解、标签、标签体、标签属性、控制元素的样式。</h3><blockquote><p>1.1标签: 标签就是一对对的&lt;&gt;&lt;&#x2F;&gt;。例如：<code>&lt;img&gt; &lt;/img&gt; </code></p><p>1.2标签体:一对标签里面的内容。例如：<code>&lt;img&gt;这是标签体，可以是子标签也可以是文字 &lt;/img&gt;</code></p><p>1.3 标签属性: 定义在标签&lt;&gt;里面的。例如：<code>&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;</code></p><p>1.4 标签控制样式:</p></blockquote></li></ul><h2 id="总结2："><a href="#总结2：" class="headerlink" title="总结2："></a>总结2：</h2><ul><li><h4 id="一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求-js代码，标签一般都写在-body标签的最下面。"><a href="#一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求-js代码，标签一般都写在-body标签的最下面。" class="headerlink" title="一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求 &lt;script&gt;js代码&lt;/script&gt;，标签一般都写在&lt;body&gt;......&lt;script&gt;&lt;/body&gt;body标签的最下面。"></a>一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求 <code>&lt;script&gt;js代码&lt;/script&gt;</code>，标签一般都写在<code>&lt;body&gt;......&lt;script&gt;&lt;/body&gt;</code>body标签的最下面。</h4></li><li><h4 id="js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。"><a href="#js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。" class="headerlink" title="js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。"></a>js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。</h4></li></ul><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;javaScript&lt;/center&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;静态网页资源的三剑客：HTML（文本），CSS（样式），JavaScript（行为）。把后面两个效果，加在HTML文本上，就会呈现出很好看的网页界面。&lt;/p&gt;
&lt;ol&gt;
&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="javaScript" scheme="https://protonlml.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>23.正则表达式</title>
    <link href="https://protonlml.github.io/2019/09/24/23.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://protonlml.github.io/2019/09/24/23.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-09-24T14:41:00.000Z</published>
    <updated>2024-06-20T00:55:50.778Z</updated>
    
    <content type="html"><![CDATA[<h1><center>正则表达式</center></h1><h2 id="一、校验字符串"><a href="#一、校验字符串" class="headerlink" title="一、校验字符串"></a>一、校验字符串</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200720328.png" alt="image-20240620072050304"></p><h1 id="工作中怎么使用"><a href="#工作中怎么使用" class="headerlink" title="工作中怎么使用"></a>工作中怎么使用</h1><ul><li><h3 id="1-IDEA中下载插件any-rule"><a href="#1-IDEA中下载插件any-rule" class="headerlink" title="1.IDEA中下载插件any-rule"></a>1.IDEA中下载插件any-rule</h3><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200739416.png" alt="image-20240620073947256"></p></li><li><h3 id="2-在代码中，定义一个字符串，然后右键使用"><a href="#2-在代码中，定义一个字符串，然后右键使用" class="headerlink" title="2.在代码中，定义一个字符串，然后右键使用"></a>2.在代码中，定义一个字符串，然后右键使用</h3></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200819980.png" alt="image-20240620081907879"></p><hr><hr><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200811053.png" alt="image-20240620081110501"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200812432.png" alt="image-20240620081221070"></p><hr><hr><h2 id="二、在一段文本中，查找满足要求的内容（爬虫）"><a href="#二、在一段文本中，查找满足要求的内容（爬虫）" class="headerlink" title="二、在一段文本中，查找满足要求的内容（爬虫）"></a>二、在一段文本中，查找满足要求的内容（爬虫）</h2><ul><li><h3 id="使用到两个对象"><a href="#使用到两个对象" class="headerlink" title="使用到两个对象"></a>使用到两个对象</h3></li><li><h3 id="1-Pattern-正则表达式对象"><a href="#1-Pattern-正则表达式对象" class="headerlink" title="1.Pattern(正则表达式对象)"></a>1.Pattern(正则表达式对象)</h3></li><li><h3 id="2-Matcher（文本匹配器对象）"><a href="#2-Matcher（文本匹配器对象）" class="headerlink" title="2.Matcher（文本匹配器对象）"></a>2.Matcher（文本匹配器对象）</h3></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200847996.png" alt="image-20240620084702653"></p><hr><hr><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200853664.png" alt="image-20240620085331330"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;正则表达式&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、校验字符串&quot;&gt;&lt;a href=&quot;#一、校验字符串&quot; class=&quot;headerlink&quot; title=&quot;一、校验字符串&quot;&gt;&lt;/a&gt;一、校验字符串&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https:/</summary>
      
    
    
    
    <category term="工具类" scheme="https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="工具类" scheme="https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>22.Biglnteger 和BigDecimal</title>
    <link href="https://protonlml.github.io/2019/09/24/22.Biglnteger%20%E5%92%8CBigDecimal/"/>
    <id>https://protonlml.github.io/2019/09/24/22.Biglnteger%20%E5%92%8CBigDecimal/</id>
    <published>2019-09-24T14:40:00.000Z</published>
    <updated>2024-06-19T22:26:30.654Z</updated>
    
    <content type="html"><![CDATA[<h1><center>Biglnteger 和BigDecimal</center></h1><h1 id="Biglnteger-大整数-（取值范围大）"><a href="#Biglnteger-大整数-（取值范围大）" class="headerlink" title="Biglnteger (大整数)（取值范围大）"></a>Biglnteger (大整数)（取值范围大）</h1><h2 id="为什么要有BigInteger"><a href="#为什么要有BigInteger" class="headerlink" title="为什么要有BigInteger?"></a>为什么要有BigInteger?</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200309923.png" alt="image-20240620030902770"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200310152.png" alt="image-20240620031054082"></p><hr><hr><h2 id="一、BigInteger构造方法创建对象"><a href="#一、BigInteger构造方法创建对象" class="headerlink" title="一、BigInteger构造方法创建对象"></a>一、BigInteger构造方法创建对象</h2><ul><li><h4 id="1-随机获取一个大整数，构造参数为-num-random-结果为-0-2-num-1"><a href="#1-随机获取一个大整数，构造参数为-num-random-结果为-0-2-num-1" class="headerlink" title="1. 随机获取一个大整数，构造参数为(num ,random) 结果为[0~ 2^num-1]"></a>1. 随机获取一个大整数，构造参数为(num ,random) 结果为[0~ 2^num-1]</h4></li></ul><p>![image-20240620031429030](22.Biglnteger 和BigDecimal.assets&#x2F;image-20240620031429030.png)</p><ul><li><h4 id="2-获取一个指定的大整数（常用）"><a href="#2-获取一个指定的大整数（常用）" class="headerlink" title="2.获取一个指定的大整数（常用）"></a>2.获取一个指定的大整数（常用）</h4><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200319019.png" alt="image-20240620031937896"></p></li><li><h4 id="3-获取一个指定进制的大整数（了解）"><a href="#3-获取一个指定进制的大整数（了解）" class="headerlink" title="3.获取一个指定进制的大整数（了解）"></a>3.获取一个指定进制的大整数（了解）</h4><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200325523.png" alt="image-20240620032518371"></p></li><li><h4 id="4-静态方法-获取BigIntegerl的对象-内部有优化（在Long类型范围内常用）"><a href="#4-静态方法-获取BigIntegerl的对象-内部有优化（在Long类型范围内常用）" class="headerlink" title="4.静态方法 获取BigIntegerl的对象,内部有优化（在Long类型范围内常用）"></a>4.静态方法 获取BigIntegerl的对象,内部有优化（在Long类型范围内常用）</h4><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200336806.png" alt="image-20240620033656834"></p></li><li><h4 id="5-对象一旦创建内部的数据不能发生改变"><a href="#5-对象一旦创建内部的数据不能发生改变" class="headerlink" title="5.对象一旦创建内部的数据不能发生改变"></a>5.对象一旦创建内部的数据不能发生改变</h4><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200340533.png" alt="image-20240620034033917"></p></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200341668.png" alt="image-20240620034131935"></p><hr><hr><h2 id="二、BigInteger常见的成员方法（用来计算的）"><a href="#二、BigInteger常见的成员方法（用来计算的）" class="headerlink" title="二、BigInteger常见的成员方法（用来计算的）"></a>二、BigInteger常见的成员方法（用来计算的）</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200343002.png" alt="image-20240620034326837"></p><p>![image-20240620034732920](22.Biglnteger 和BigDecimal.assets&#x2F;image-20240620034732920.png)</p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200351250.png" alt="image-20240620035143092"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200354008.png" alt="image-20240620035412837"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr><hr><h1 id="BigDecimal（大小数）（取值范围大）"><a href="#BigDecimal（大小数）（取值范围大）" class="headerlink" title="BigDecimal（大小数）（取值范围大）"></a>BigDecimal（大小数）（取值范围大）</h1><h2 id="为什么要有BigDecimal"><a href="#为什么要有BigDecimal" class="headerlink" title="为什么要有BigDecimal?"></a>为什么要有BigDecimal?</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200411944.png" alt="image-20240620041105390"></p><ul><li><h2 id="我们为了精确计算，就要使用这个BigDecimal对象"><a href="#我们为了精确计算，就要使用这个BigDecimal对象" class="headerlink" title="我们为了精确计算，就要使用这个BigDecimal对象"></a>我们为了精确计算，就要使用这个BigDecimal对象</h2></li><li><h2 id="用来表示很大的小数"><a href="#用来表示很大的小数" class="headerlink" title="用来表示很大的小数"></a>用来表示很大的小数</h2></li></ul><hr><hr><h2 id="一、BigDecimal构造方法创建对象"><a href="#一、BigDecimal构造方法创建对象" class="headerlink" title="一、BigDecimal构造方法创建对象"></a>一、BigDecimal构造方法创建对象</h2><ul><li><h4 id="1-使用-参数为double-的-构造方法创建（不推荐）"><a href="#1-使用-参数为double-的-构造方法创建（不推荐）" class="headerlink" title="1.使用 参数为double 的 构造方法创建（不推荐）"></a>1.使用 参数为double 的 构造方法创建（不推荐）</h4><ul><li><h4 id="细节：-这种方式可能是不精确的，所以不建议使用"><a href="#细节：-这种方式可能是不精确的，所以不建议使用" class="headerlink" title="细节： 这种方式可能是不精确的，所以不建议使用"></a>细节： 这种方式可能是不精确的，所以不建议使用</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200415521.png" alt="image-20240620041514628"></p></li><li><h4 id="2-使用参数为string的-构造方法（推荐）非常精确"><a href="#2-使用参数为string的-构造方法（推荐）非常精确" class="headerlink" title="2.使用参数为string的 构造方法（推荐）非常精确"></a>2.使用参数为string的 构造方法（推荐）非常精确</h4><ul><li><h4 id="细节：放心用，非常精确"><a href="#细节：放心用，非常精确" class="headerlink" title="细节：放心用，非常精确"></a>细节：放心用，非常精确</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200417638.png" alt="image-20240620041743534"></p></li><li><h4 id="3-通过静态方法获取对象"><a href="#3-通过静态方法获取对象" class="headerlink" title="3. 通过静态方法获取对象"></a>3. 通过静态方法获取对象</h4><ul><li><h4 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h4></li><li><h4 id="1-如果要表示的数字不大-没有超出doub1e的取值范围-建议使用静态方法"><a href="#1-如果要表示的数字不大-没有超出doub1e的取值范围-建议使用静态方法" class="headerlink" title="1.如果要表示的数字不大,没有超出doub1e的取值范围,建议使用静态方法"></a>1.如果要表示的数字不大,没有超出doub1e的取值范围,建议使用静态方法</h4></li><li><h4 id="2-如果要表示的数字比较大-超出了double的取值范围-建议使用String参数的构造方法"><a href="#2-如果要表示的数字比较大-超出了double的取值范围-建议使用String参数的构造方法" class="headerlink" title="2.如果要表示的数字比较大,超出了double的取值范围,建议使用String参数的构造方法"></a>2.如果要表示的数字比较大,超出了double的取值范围,建议使用String参数的构造方法</h4></li><li><h4 id="3-如果我们传递的是0-10之间的整数-包含0-包含10-那么方法会返回已经创建好的对象-不会重新new"><a href="#3-如果我们传递的是0-10之间的整数-包含0-包含10-那么方法会返回已经创建好的对象-不会重新new" class="headerlink" title="3.如果我们传递的是0~10之间的整数,包含0,包含10,那么方法会返回已经创建好的对象,不会重新new"></a>3.如果我们传递的是0~10之间的整数,包含0,包含10,那么方法会返回已经创建好的对象,不会重新new</h4></li></ul><p>![image-20240620042153353](22.Biglnteger 和BigDecimal.assets&#x2F;image-20240620042153353.png)</p></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200427044.png" alt="image-20240620042726184"></p><hr><hr><h2 id="二、BigDecimal常见的成员方法（用来计算的）"><a href="#二、BigDecimal常见的成员方法（用来计算的）" class="headerlink" title="二、BigDecimal常见的成员方法（用来计算的）"></a>二、BigDecimal常见的成员方法（用来计算的）</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200429669.png" alt="image-20240620042917658"></p><h2 id="注意：使用divide-来进行数据的除运算，如果不指定取几位小数，以及舍入模式的话，如果除不整是会报错的。所以我们一般除运算，会给全部参数的。"><a href="#注意：使用divide-来进行数据的除运算，如果不指定取几位小数，以及舍入模式的话，如果除不整是会报错的。所以我们一般除运算，会给全部参数的。" class="headerlink" title="注意：使用divide 来进行数据的除运算，如果不指定取几位小数，以及舍入模式的话，如果除不整是会报错的。所以我们一般除运算，会给全部参数的。"></a>注意：使用divide 来进行数据的除运算，如果不指定取几位小数，以及舍入模式的话，如果除不整是会报错的。所以我们一般除运算，会给全部参数的。</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200536240.png" alt="image-20240620053559878"></p><hr><hr><h2 id="三、BigDecimal底层存储方式"><a href="#三、BigDecimal底层存储方式" class="headerlink" title="三、BigDecimal底层存储方式"></a>三、BigDecimal底层存储方式</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200543651.png" alt="image-20240620054306041"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200626434.png" alt="image-20240620062622028"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;Biglnteger 和BigDecimal&lt;/center&gt;&lt;/h1&gt;

&lt;h1 id=&quot;Biglnteger-大整数-（取值范围大）&quot;&gt;&lt;a href=&quot;#Biglnteger-大整数-（取值范围大）&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="工具类" scheme="https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="工具类" scheme="https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>21.Object 和 Objects</title>
    <link href="https://protonlml.github.io/2019/09/24/21.Object%E5%92%8CObjects/"/>
    <id>https://protonlml.github.io/2019/09/24/21.Object%E5%92%8CObjects/</id>
    <published>2019-09-24T14:38:00.000Z</published>
    <updated>2024-06-19T18:59:45.629Z</updated>
    
    <content type="html"><![CDATA[<h1><center>Object 和 Objects</center></h1><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200133481.png" alt="image-20240620013316121"></p><h4 id="Object类是java中所有对象的父亲，每个类都默认继承Object"><a href="#Object类是java中所有对象的父亲，每个类都默认继承Object" class="headerlink" title="Object类是java中所有对象的父亲，每个类都默认继承Object"></a>Object类是java中所有对象的父亲，每个类都默认继承Object</h4><h4 id="Object-中没有属性值，因为定义父类，就是为了抽取子类共有的属性以及方法，所以作为顶级父类，没法写属性值"><a href="#Object-中没有属性值，因为定义父类，就是为了抽取子类共有的属性以及方法，所以作为顶级父类，没法写属性值" class="headerlink" title="Object 中没有属性值，因为定义父类，就是为了抽取子类共有的属性以及方法，所以作为顶级父类，没法写属性值"></a>Object 中没有属性值，因为定义父类，就是为了抽取子类共有的属性以及方法，所以作为顶级父类，没法写属性值</h4><h4 id="Object-中只有空参构造器，因为其没有属性，所有子类都有空参构造器，就是重写的Object的-内部有隐藏的super"><a href="#Object-中只有空参构造器，因为其没有属性，所有子类都有空参构造器，就是重写的Object的-内部有隐藏的super" class="headerlink" title="Object 中只有空参构造器，因为其没有属性，所有子类都有空参构造器，就是重写的Object的 内部有隐藏的super();"></a>Object 中只有空参构造器，因为其没有属性，所有子类都有空参构造器，就是重写的Object的 内部有隐藏的super();</h4><h4 id="Object-中的tostring-方法查看源码就是打印的对象地址值。子类要想展示属性，只有在子类内部重写tostring-方法"><a href="#Object-中的tostring-方法查看源码就是打印的对象地址值。子类要想展示属性，只有在子类内部重写tostring-方法" class="headerlink" title="Object 中的tostring() 方法查看源码就是打印的对象地址值。子类要想展示属性，只有在子类内部重写tostring()方法"></a>Object 中的tostring() 方法查看源码就是打印的对象地址值。子类要想展示属性，只有在子类内部重写tostring()方法</h4><p> <img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200137254.png" alt="image-20240620013733196"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200140984.png" alt="image-20240620014049564"></p><h3 id="注意：Object-中的克隆是浅克隆，只要原来的对象中的属性值改变了，则克隆后的对象中属性值也会被改变。"><a href="#注意：Object-中的克隆是浅克隆，只要原来的对象中的属性值改变了，则克隆后的对象中属性值也会被改变。" class="headerlink" title="注意：Object 中的克隆是浅克隆，只要原来的对象中的属性值改变了，则克隆后的对象中属性值也会被改变。"></a>注意：Object 中的克隆是浅克隆，只要原来的对象中的属性值改变了，则克隆后的对象中属性值也会被改变。</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200257760.png" alt="image-20240620025742751"></h2><hr><hr><h1 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406200259933.png" alt="image-20240620025935874"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;Object 和 Objects&lt;/center&gt;&lt;/h1&gt;

&lt;h1 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="工具类" scheme="https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="工具类" scheme="https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>19.System工具类</title>
    <link href="https://protonlml.github.io/2019/09/24/19.System%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://protonlml.github.io/2019/09/24/19.System%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2019-09-24T14:36:00.000Z</published>
    <updated>2024-06-19T08:47:09.806Z</updated>
    
    <content type="html"><![CDATA[<h1><center>System工具类</center></h1><h1 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406191646316.png" alt="image-20240619164651140"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406191641091.png" alt="image-20240619164115038"></p><ul><li><h4 id="拷贝数组，注意的细节"><a href="#拷贝数组，注意的细节" class="headerlink" title="拷贝数组，注意的细节"></a>拷贝数组，注意的细节</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406191646707.png" alt="image-20240619164619161"></p></li></ul><hr><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406191645320.png" alt="image-20240619164535616"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;System工具类&lt;/center&gt;&lt;/h1&gt;

&lt;h1 id=&quot;System-类&quot;&gt;&lt;a href=&quot;#System-类&quot; class=&quot;headerlink&quot; title=&quot;System 类&quot;&gt;&lt;/a&gt;System 类&lt;/h1&gt;&lt;p&gt;&lt;img src=</summary>
      
    
    
    
    <category term="工具类" scheme="https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="工具类" scheme="https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>20.Runtime工具类</title>
    <link href="https://protonlml.github.io/2019/09/24/20.Runtime%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://protonlml.github.io/2019/09/24/20.Runtime%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2019-09-24T14:36:00.000Z</published>
    <updated>2024-06-19T15:12:38.391Z</updated>
    
    <content type="html"><![CDATA[<h1><center>Runtime工具类</center></h1><h1 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h1><h2 id="需要用到java代码，来监控虚拟机的内存时，使用这个类"><a href="#需要用到java代码，来监控虚拟机的内存时，使用这个类" class="headerlink" title="需要用到java代码，来监控虚拟机的内存时，使用这个类"></a>需要用到java代码，来监控虚拟机的内存时，使用这个类</h2><hr><hr><ul><li><h3 id="表示当前虚拟机的运行环境（它是单例的）外界不能创建多个，只能创建一个。"><a href="#表示当前虚拟机的运行环境（它是单例的）外界不能创建多个，只能创建一个。" class="headerlink" title="表示当前虚拟机的运行环境（它是单例的）外界不能创建多个，只能创建一个。"></a>表示当前虚拟机的运行环境（它是单例的）外界不能创建多个，只能创建一个。</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406191654378.png" alt="image-20240619165411122"></p></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406192311404.png" alt="image-20240619231102483"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;Runtime工具类&lt;/center&gt;&lt;/h1&gt;

&lt;h1 id=&quot;Runtime类&quot;&gt;&lt;a href=&quot;#Runtime类&quot; class=&quot;headerlink&quot; title=&quot;Runtime类&quot;&gt;&lt;/a&gt;Runtime类&lt;/h1&gt;&lt;h2 id=&quot;需要用</summary>
      
    
    
    
    <category term="工具类" scheme="https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="工具类" scheme="https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>18.Math工具类</title>
    <link href="https://protonlml.github.io/2019/09/24/18.Math%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://protonlml.github.io/2019/09/24/18.Math%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2019-09-24T14:35:00.000Z</published>
    <updated>2024-06-19T08:32:18.180Z</updated>
    
    <content type="html"><![CDATA[<h1><center>Math工具类</center></h1><h1 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h1><ul><li><h2 id="1-是一个帮助我们用于进行数学计算的工具类"><a href="#1-是一个帮助我们用于进行数学计算的工具类" class="headerlink" title="1.是一个帮助我们用于进行数学计算的工具类"></a>1.是一个帮助我们用于进行数学计算的工具类</h2></li><li><h4 id="2-类是final-修饰-表示最终类，不能被继承。私有构造方法（在外界不能创建），所有的成员方法都是静态的（外界使用类名调用）"><a href="#2-类是final-修饰-表示最终类，不能被继承。私有构造方法（在外界不能创建），所有的成员方法都是静态的（外界使用类名调用）" class="headerlink" title="2.类是final 修饰 表示最终类，不能被继承。私有构造方法（在外界不能创建），所有的成员方法都是静态的（外界使用类名调用）"></a>2.类是final 修饰 表示最终类，不能被继承。私有构造方法（在外界不能创建），所有的成员方法都是静态的（外界使用类名调用）</h4></li></ul><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406191452335.png" alt="image-20240619145244255"></p><hr><h4 id="int-的-取值范围-2147483648-2147483647"><a href="#int-的-取值范围-2147483648-2147483647" class="headerlink" title="int 的 取值范围 -2147483648~2147483647"></a>int 的 取值范围 -2147483648~2147483647</h4><hr><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406191506120.png" alt="image-20240619150615160"></p><hr><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;Math工具类&lt;/center&gt;&lt;/h1&gt;

&lt;h1 id=&quot;Math-类&quot;&gt;&lt;a href=&quot;#Math-类&quot; class=&quot;headerlink&quot; title=&quot;Math 类&quot;&gt;&lt;/a&gt;Math 类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;1-是一个</summary>
      
    
    
    
    <category term="工具类" scheme="https://protonlml.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="工具类" scheme="https://protonlml.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>17.内部类</title>
    <link href="https://protonlml.github.io/2019/09/24/17.%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://protonlml.github.io/2019/09/24/17.%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2019-09-24T14:30:00.000Z</published>
    <updated>2024-06-18T14:16:00.101Z</updated>
    
    <content type="html"><![CDATA[<h1><center>内部类</h1><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181811863.png" alt="image-20240618181113362"></h2><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181758494.png" alt="image-20240618175817322"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181801896.png" alt="image-20240618180156981"></p><h2 id="一、成员内部类"><a href="#一、成员内部类" class="headerlink" title="一、成员内部类"></a>一、成员内部类</h2><h3 id="1-成员内部类的代码如何书写（如下和成员变量是一个级别的）"><a href="#1-成员内部类的代码如何书写（如下和成员变量是一个级别的）" class="headerlink" title="1.成员内部类的代码如何书写（如下和成员变量是一个级别的）"></a>1.成员内部类的代码如何书写（如下和成员变量是一个级别的）</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181812695.png" alt="image-20240618181206729"></li></ul><h3 id="2-如何创建成员内部类的对象"><a href="#2-如何创建成员内部类的对象" class="headerlink" title="2.如何创建成员内部类的对象"></a>2.如何创建成员内部类的对象</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181820923.png" alt="image-20240618182039972"></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181822229.png" alt="image-20240618182225127"></p><h3 id="3-成员内部类如何获取外部类的成员变量"><a href="#3-成员内部类如何获取外部类的成员变量" class="headerlink" title="3.成员内部类如何获取外部类的成员变量"></a>3.成员内部类如何获取外部类的成员变量</h3><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406182124621.png" alt="image-20240618212359566"></p><h2 id="二、静态内部类"><a href="#二、静态内部类" class="headerlink" title="二、静态内部类"></a>二、静态内部类</h2><ul><li><h4 id="静态内部类只能访问外部类中的静态变量和静态方法"><a href="#静态内部类只能访问外部类中的静态变量和静态方法" class="headerlink" title="静态内部类只能访问外部类中的静态变量和静态方法,"></a>静态内部类只能访问外部类中的静态变量和静态方法,</h4></li><li><h4 id="静态内部类-其里面如果想要访问外部类中的非静态-需要在内部创建外部类对象"><a href="#静态内部类-其里面如果想要访问外部类中的非静态-需要在内部创建外部类对象" class="headerlink" title="静态内部类,其里面如果想要访问外部类中的非静态,需要在内部创建外部类对象"></a>静态内部类,其里面如果想要访问外部类中的非静态,需要在内部创建外部类对象</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406182137696.png" alt="image-20240618213731485"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406182143148.png" alt="image-20240618214320205"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406182143234.png" alt="image-20240618214357638"></p><h2 id="三、局部内部类"><a href="#三、局部内部类" class="headerlink" title="三、局部内部类"></a>三、局部内部类</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406182150138.png" alt="image-20240618215013137"></p><hr><hr><h2 id="四、匿名内部类"><a href="#四、匿名内部类" class="headerlink" title="四、匿名内部类"></a>四、匿名内部类</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406182206405.png" alt="image-20240618220607374"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;内部类&lt;/h1&gt;

&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;img src=&quot;https://raw.githubusercontent.com/protonlml/blogimages</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>15.抽象类</title>
    <link href="https://protonlml.github.io/2019/09/24/15.%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://protonlml.github.io/2019/09/24/15.%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2019-09-24T14:00:00.000Z</published>
    <updated>2024-06-18T06:10:52.145Z</updated>
    
    <content type="html"><![CDATA[<h1><center>抽象类</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="1-把子类共性的方法，抽取到父类中之后，但是每个子类执行这个方法的方法体内容又是不一样的，（方法体不能确定）之前是每个子类重写这个方法，实现功能，有弊端，子类不重写这个方法也能调用就可能产生错误。"><a href="#1-把子类共性的方法，抽取到父类中之后，但是每个子类执行这个方法的方法体内容又是不一样的，（方法体不能确定）之前是每个子类重写这个方法，实现功能，有弊端，子类不重写这个方法也能调用就可能产生错误。" class="headerlink" title="1.把子类共性的方法，抽取到父类中之后，但是每个子类执行这个方法的方法体内容又是不一样的，（方法体不能确定）之前是每个子类重写这个方法，实现功能，有弊端，子类不重写这个方法也能调用就可能产生错误。"></a>1.把子类共性的方法，抽取到父类中之后，但是每个子类执行这个方法的方法体内容又是不一样的，（方法体不能确定）之前是每个子类重写这个方法，实现功能，有弊端，子类不重写这个方法也能调用就可能产生错误。</h3><h3 id="2-所以我们将抽取到父类中的共性方法，只定义方法名，不写方法体，这个就是抽象方法。"><a href="#2-所以我们将抽取到父类中的共性方法，只定义方法名，不写方法体，这个就是抽象方法。" class="headerlink" title="2.所以我们将抽取到父类中的共性方法，只定义方法名，不写方法体，这个就是抽象方法。"></a>2.所以我们将抽取到父类中的共性方法，只定义方法名，不写方法体，这个就是抽象方法。</h3><h3 id="3-抽象方法，所在的类，就叫抽象类"><a href="#3-抽象方法，所在的类，就叫抽象类" class="headerlink" title="3.抽象方法，所在的类，就叫抽象类"></a>3.抽象方法，所在的类，就叫抽象类</h3><h3 id="4-在继承父类之后的子类，必须实现抽象方法，不实现会报错。"><a href="#4-在继承父类之后的子类，必须实现抽象方法，不实现会报错。" class="headerlink" title="4.在继承父类之后的子类，必须实现抽象方法，不实现会报错。"></a>4.在继承父类之后的子类，必须实现抽象方法，不实现会报错。</h3><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181333498.png" alt="image-20240618133325282"></p><h2 id="二、抽象类的定义"><a href="#二、抽象类的定义" class="headerlink" title="二、抽象类的定义"></a>二、抽象类的定义</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181334729.png" alt="image-20240618133457691"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181336343.png" alt="image-20240618133621206"></p><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181338906.png" alt="image-20240618133822044"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h4 id="父类中的抽象方法，强制了在子类创建时，用统一的格式来重写这个抽象方法，目的是，让每个子类的这个方法都是统一的，在调用的时候很方便，不用再去每个子类中，找每个此功能方法的名称。"><a href="#父类中的抽象方法，强制了在子类创建时，用统一的格式来重写这个抽象方法，目的是，让每个子类的这个方法都是统一的，在调用的时候很方便，不用再去每个子类中，找每个此功能方法的名称。" class="headerlink" title="父类中的抽象方法，强制了在子类创建时，用统一的格式来重写这个抽象方法，目的是，让每个子类的这个方法都是统一的，在调用的时候很方便，不用再去每个子类中，找每个此功能方法的名称。"></a>父类中的抽象方法，强制了在子类创建时，用统一的格式来重写这个抽象方法，目的是，让每个子类的这个方法都是统一的，在调用的时候很方便，不用再去每个子类中，找每个此功能方法的名称。</h4><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181407082.png" alt="image-20240618140704007"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;抽象类&lt;/h1&gt;

&lt;h2 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h2&gt;&lt;h3 id=&quot;1-把子类共性的方法，抽取到父类中之后，但是每个子类执行这个方法的方法</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>16.接口</title>
    <link href="https://protonlml.github.io/2019/09/24/16.%E6%8E%A5%E5%8F%A3/"/>
    <id>https://protonlml.github.io/2019/09/24/16.%E6%8E%A5%E5%8F%A3/</id>
    <published>2019-09-24T14:00:00.000Z</published>
    <updated>2024-06-18T09:53:47.176Z</updated>
    
    <content type="html"><![CDATA[<h1><center>接口</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h4 id="抽象类，都是指父类，抽取子类共同的方法，定义为抽象方法。子类实现重写。抽象方法所在的类就是抽象类"><a href="#抽象类，都是指父类，抽取子类共同的方法，定义为抽象方法。子类实现重写。抽象方法所在的类就是抽象类" class="headerlink" title="抽象类，都是指父类，抽取子类共同的方法，定义为抽象方法。子类实现重写。抽象方法所在的类就是抽象类"></a>抽象类，都是指父类，抽取子类共同的方法，定义为抽象方法。子类实现重写。抽象方法所在的类就是抽象类</h4><h4 id="接口：就是一种规则，它把一些方法抽象出去，谁要用，谁就来实现这个接口，对其内部的方法进行重写"><a href="#接口：就是一种规则，它把一些方法抽象出去，谁要用，谁就来实现这个接口，对其内部的方法进行重写" class="headerlink" title="接口：就是一种规则，它把一些方法抽象出去，谁要用，谁就来实现这个接口，对其内部的方法进行重写"></a>接口：就是一种规则，它把一些方法抽象出去，谁要用，谁就来实现这个接口，对其内部的方法进行重写</h4><h4 id="接口：其实也是对方法名进行规范，项目中有很多类，都可以去实现接口，每个类实现了接口中的方法，名称是一样的，将来不管是哪个对象来调用（这个接口任意的实现类，的实现方法，名称都是统一的。）"><a href="#接口：其实也是对方法名进行规范，项目中有很多类，都可以去实现接口，每个类实现了接口中的方法，名称是一样的，将来不管是哪个对象来调用（这个接口任意的实现类，的实现方法，名称都是统一的。）" class="headerlink" title="接口：其实也是对方法名进行规范，项目中有很多类，都可以去实现接口，每个类实现了接口中的方法，名称是一样的，将来不管是哪个对象来调用（这个接口任意的实现类，的实现方法，名称都是统一的。）"></a>接口：其实也是对方法名进行规范，项目中有很多类，都可以去实现接口，每个类实现了接口中的方法，名称是一样的，将来不管是哪个对象来调用（这个接口任意的实现类，的实现方法，名称都是统一的。）</h4><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181417811.png" alt="image-20240618141753670"></p><h2 id="二、接口的定义和使用"><a href="#二、接口的定义和使用" class="headerlink" title="二、接口的定义和使用"></a>二、接口的定义和使用</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181422010.png" alt="image-20240618142205830"></p><h2 id="三、接口中成员的特点"><a href="#三、接口中成员的特点" class="headerlink" title="三、接口中成员的特点"></a>三、接口中成员的特点</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181530631.png" alt="image-20240618153058571"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181538818.png" alt="image-20240618153829725"></p><h2 id="四、接口和类之间的关系"><a href="#四、接口和类之间的关系" class="headerlink" title="四、接口和类之间的关系"></a>四、接口和类之间的关系</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181548334.png" alt="image-20240618154831212"></p><hr><hr><h1 id="接口拓展"><a href="#接口拓展" class="headerlink" title="接口拓展"></a>接口拓展</h1><h2 id="一、JDK8开始接口中新增的方法、"><a href="#一、JDK8开始接口中新增的方法、" class="headerlink" title="一、JDK8开始接口中新增的方法、"></a>一、JDK8开始接口中新增的方法、</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181608847.png" alt="image-20240618160824819"></p><hr><hr><h2 id="1-默认方法"><a href="#1-默认方法" class="headerlink" title="1.默认方法"></a>1.默认方法</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181616514.png" alt="image-20240618161617340"></p><ul><li><h3 id="为什么要在接口中定义-默认方法"><a href="#为什么要在接口中定义-默认方法" class="headerlink" title="为什么要在接口中定义 默认方法"></a>为什么要在接口中定义 默认方法</h3><h4 id="因为：接口会有升级，在后续的开发中，接口中的抽象方法会越来越多，只要接口中发生了变化，那么所有的实现类就不得不来跟着去改变。对于已经实现的很多实现类，都要修改无疑是很麻烦的事情。"><a href="#因为：接口会有升级，在后续的开发中，接口中的抽象方法会越来越多，只要接口中发生了变化，那么所有的实现类就不得不来跟着去改变。对于已经实现的很多实现类，都要修改无疑是很麻烦的事情。" class="headerlink" title="因为：接口会有升级，在后续的开发中，接口中的抽象方法会越来越多，只要接口中发生了变化，那么所有的实现类就不得不来跟着去改变。对于已经实现的很多实现类，都要修改无疑是很麻烦的事情。"></a>因为：接口会有升级，在后续的开发中，接口中的抽象方法会越来越多，只要接口中发生了变化，那么所有的实现类就不得不来跟着去改变。对于已经实现的很多实现类，都要修改无疑是很麻烦的事情。</h4><h4 id="所以：在接口中定义一个默认方法，其所有的实现类，都可以直接调用，不需要重写。"><a href="#所以：在接口中定义一个默认方法，其所有的实现类，都可以直接调用，不需要重写。" class="headerlink" title="所以：在接口中定义一个默认方法，其所有的实现类，都可以直接调用，不需要重写。"></a>所以：在接口中定义一个默认方法，其所有的实现类，都可以直接调用，不需要重写。</h4></li></ul><hr><hr><h2 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181622890.png" alt="image-20240618162245837"></p><ul><li><h4 id="接口中的静态方法，只与当前接口有关系，是不能够被其实现类重写的，调用也是通过接口来调用的"><a href="#接口中的静态方法，只与当前接口有关系，是不能够被其实现类重写的，调用也是通过接口来调用的" class="headerlink" title="接口中的静态方法，只与当前接口有关系，是不能够被其实现类重写的，调用也是通过接口来调用的"></a>接口中的静态方法，只与当前接口有关系，是不能够被其实现类重写的，调用也是通过接口来调用的</h4></li></ul><hr><hr><h2 id="3-JDK9在接口中可以写私有方法"><a href="#3-JDK9在接口中可以写私有方法" class="headerlink" title="3.JDK9在接口中可以写私有方法"></a>3.JDK9在接口中可以写私有方法</h2><ul><li><h3 id="a-接口中为什么会有私有方法？"><a href="#a-接口中为什么会有私有方法？" class="headerlink" title="a.接口中为什么会有私有方法？"></a>a.接口中为什么会有私有方法？</h3><ul><li><h4 id="起因：在接口中，我们定义了一些默认的方法，但是有些默认方法中有重复代码，我们就想在接口中提取出来一个方法来写这些重发代码。这些重复代码又仅仅是接口内部为default修饰的默认方法服务的。不想被外界使用。所以加了个private-修饰"><a href="#起因：在接口中，我们定义了一些默认的方法，但是有些默认方法中有重复代码，我们就想在接口中提取出来一个方法来写这些重发代码。这些重复代码又仅仅是接口内部为default修饰的默认方法服务的。不想被外界使用。所以加了个private-修饰" class="headerlink" title="起因：在接口中，我们定义了一些默认的方法，但是有些默认方法中有重复代码，我们就想在接口中提取出来一个方法来写这些重发代码。这些重复代码又仅仅是接口内部为default修饰的默认方法服务的。不想被外界使用。所以加了个private 修饰"></a>起因：在接口中，我们定义了一些默认的方法，但是有些默认方法中有重复代码，我们就想在接口中提取出来一个方法来写这些重发代码。这些重复代码又仅仅是接口内部为default修饰的默认方法服务的。不想被外界使用。所以加了个private 修饰</h4></li></ul></li><li><h3 id="b-私有方法有两种："><a href="#b-私有方法有两种：" class="headerlink" title="b.私有方法有两种："></a>b.私有方法有两种：</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181637981.png" alt="image-20240618163706792"></li></ul></li><li><h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181639276.png" alt="image-20240618163930124"></p><ul><li><h4 id="静态私有方法"><a href="#静态私有方法" class="headerlink" title="静态私有方法"></a>静态私有方法</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181641226.png" alt="image-20240618164141193"></p><hr><hr><h2 id="二、接口的应用"><a href="#二、接口的应用" class="headerlink" title="二、接口的应用"></a>二、接口的应用</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181649344.png" alt="image-20240618164945220"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181650437.png" alt="image-20240618165004029"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181650374.png" alt="image-20240618165042946"></p><hr><hr><h2 id="三、适配器设计模式"><a href="#三、适配器设计模式" class="headerlink" title="三、适配器设计模式"></a>三、适配器设计模式</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181753860.png" alt="image-20240618175337385"></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181751312.png" alt="image-20240618175119897"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;接口&lt;/h1&gt;

&lt;h2 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h2&gt;&lt;h4 id=&quot;抽象类，都是指父类，抽取子类共同的方法，定义为抽象方法。子类实现重写。抽</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>14.面向对象细节性的知识点</title>
    <link href="https://protonlml.github.io/2019/09/24/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%86%E8%8A%82%E6%80%A7%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://protonlml.github.io/2019/09/24/14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%86%E8%8A%82%E6%80%A7%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2019-09-24T13:50:00.000Z</published>
    <updated>2024-06-18T05:21:21.280Z</updated>
    
    <content type="html"><![CDATA[<h1><center>面向对象细节性的知识点</h1><h1 id="面向对象细节性的知识点"><a href="#面向对象细节性的知识点" class="headerlink" title="面向对象细节性的知识点"></a>面向对象细节性的知识点</h1><ul><li><h3 id="1-对象总结：在java中，一个java文件，一般就写一个class类，一个类就代表一类对象。"><a href="#1-对象总结：在java中，一个java文件，一般就写一个class类，一个类就代表一类对象。" class="headerlink" title="1.对象总结：在java中，一个java文件，一般就写一个class类，一个类就代表一类对象。"></a>1.对象总结：在java中，一个java文件，一般就写一个class类，一个类就代表一类对象。</h3></li><li><h3 id="2-类中有成员变量，成员方法，以及构造器。"><a href="#2-类中有成员变量，成员方法，以及构造器。" class="headerlink" title="2.类中有成员变量，成员方法，以及构造器。"></a>2.类中有成员变量，成员方法，以及构造器。</h3></li><li><h3 id="3-有两种类："><a href="#3-有两种类：" class="headerlink" title="3.有两种类："></a>3.有两种类：</h3><ul><li><h4 id="一般javaBen-这种类，只是为了描述对象使用，内部不会使用static来修饰成员变量，或者成员方法。"><a href="#一般javaBen-这种类，只是为了描述对象使用，内部不会使用static来修饰成员变量，或者成员方法。" class="headerlink" title="一般javaBen 这种类，只是为了描述对象使用，内部不会使用static来修饰成员变量，或者成员方法。"></a>一般javaBen 这种类，只是为了描述对象使用，内部不会使用static来修饰成员变量，或者成员方法。</h4></li><li><h4 id="另一种类，就是工具类，里面的成员方法比较多，而且是static修饰的，目的是方便用类进行调用"><a href="#另一种类，就是工具类，里面的成员方法比较多，而且是static修饰的，目的是方便用类进行调用" class="headerlink" title="另一种类，就是工具类，里面的成员方法比较多，而且是static修饰的，目的是方便用类进行调用"></a>另一种类，就是工具类，里面的成员方法比较多，而且是static修饰的，目的是方便用类进行调用</h4></li><li><h4 id="static-修饰的成员方法，或者成员变量，都是与类相关，随着类加载而加载。"><a href="#static-修饰的成员方法，或者成员变量，都是与类相关，随着类加载而加载。" class="headerlink" title="static 修饰的成员方法，或者成员变量，都是与类相关，随着类加载而加载。"></a>static 修饰的成员方法，或者成员变量，都是与类相关，随着类加载而加载。</h4></li></ul></li><li><h3 id="4-类与类之间，可以实现单继承，多层继承。"><a href="#4-类与类之间，可以实现单继承，多层继承。" class="headerlink" title="4.类与类之间，可以实现单继承，多层继承。"></a>4.类与类之间，可以实现单继承，多层继承。</h3><ul><li><h4 id="子类继承父类中所有公有的成员变量以及成员方法，子类都可以使用。子类还有自己的方法，这样子类的功能就变强大了。"><a href="#子类继承父类中所有公有的成员变量以及成员方法，子类都可以使用。子类还有自己的方法，这样子类的功能就变强大了。" class="headerlink" title="子类继承父类中所有公有的成员变量以及成员方法，子类都可以使用。子类还有自己的方法，这样子类的功能就变强大了。"></a>子类继承父类中所有公有的成员变量以及成员方法，子类都可以使用。子类还有自己的方法，这样子类的功能就变强大了。</h4></li><li><h4 id="子类中，如果定义了与父类中相同的方法，那么就称子类中，对该方法进行了重写。（这就是方法重写）目的是个性化子类当前方法功能"><a href="#子类中，如果定义了与父类中相同的方法，那么就称子类中，对该方法进行了重写。（这就是方法重写）目的是个性化子类当前方法功能" class="headerlink" title="子类中，如果定义了与父类中相同的方法，那么就称子类中，对该方法进行了重写。（这就是方法重写）目的是个性化子类当前方法功能"></a>子类中，如果定义了与父类中相同的方法，那么就称子类中，对该方法进行了重写。（这就是方法重写）目的是个性化子类当前方法功能</h4></li></ul></li><li><h3 id="5-有了继承，那么就有很多类，共同继承同一个父类，此时就形成一种关系叫做多态"><a href="#5-有了继承，那么就有很多类，共同继承同一个父类，此时就形成一种关系叫做多态" class="headerlink" title="5.有了继承，那么就有很多类，共同继承同一个父类，此时就形成一种关系叫做多态"></a>5.有了继承，那么就有很多类，共同继承同一个父类，此时就形成一种关系叫做多态</h3></li><li><h3 id="多态：目的是，在某个方法形式参数中，使用一类对象，来进行调用。参数可以使用父类来充当。只要继承了当前这个父类，那么其子类都能赋值于这某个方法形参上面进行使用"><a href="#多态：目的是，在某个方法形式参数中，使用一类对象，来进行调用。参数可以使用父类来充当。只要继承了当前这个父类，那么其子类都能赋值于这某个方法形参上面进行使用" class="headerlink" title="多态：目的是，在某个方法形式参数中，使用一类对象，来进行调用。参数可以使用父类来充当。只要继承了当前这个父类，那么其子类都能赋值于这某个方法形参上面进行使用"></a>多态：目的是，在某个方法形式参数中，使用一类对象，来进行调用。参数可以使用父类来充当。只要继承了当前这个父类，那么其子类都能赋值于这某个方法形参上面进行使用</h3></li></ul><hr><hr><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="一、什么是包"><a href="#一、什么是包" class="headerlink" title="一、什么是包"></a>一、什么是包</h2><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180107089.png" alt="image-20240618010737972"></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180110321.png" alt="image-20240618011009253"></p><h2 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180112838.png" alt="image-20240618011240474"></p><hr><hr><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><h2 id="一、final-修饰，方法，类，变量"><a href="#一、final-修饰，方法，类，变量" class="headerlink" title="一、final 修饰，方法，类，变量"></a>一、final 修饰，方法，类，变量</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180116437.png" alt="image-20240618011629270"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180126921.png" alt="image-20240618012639444"></p><hr><hr><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180137064.png" alt="image-20240618013727977"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180140999.png" alt="image-20240618014053071"></p><hr><hr><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><h3 id="代码块：局部代码块，构造代码块，静态代码块"><a href="#代码块：局部代码块，构造代码块，静态代码块" class="headerlink" title="代码块：局部代码块，构造代码块，静态代码块"></a>代码块：局部代码块，构造代码块，静态代码块</h3><h2 id="一、局部代码块（淘汰了，了解）"><a href="#一、局部代码块（淘汰了，了解）" class="headerlink" title="一、局部代码块（淘汰了，了解）"></a>一、局部代码块（淘汰了，了解）</h2><ul><li><h4 id="1-局部代码就是写在方法里面的一对单独的"><a href="#1-局部代码就是写在方法里面的一对单独的" class="headerlink" title="1.局部代码就是写在方法里面的一对单独的 { }"></a>1.局部代码就是写在方法里面的一对单独的 { }</h4></li><li><h4 id="2-本质的作用就是节约内存"><a href="#2-本质的作用就是节约内存" class="headerlink" title="2.本质的作用就是节约内存"></a>2.本质的作用就是节约内存</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181308802.png" alt="image-20240618130809765"></p><h2 id="二、构造代码块（淘汰了，了解）"><a href="#二、构造代码块（淘汰了，了解）" class="headerlink" title="二、构造代码块（淘汰了，了解）"></a>二、构造代码块（淘汰了，了解）</h2><ul><li><h4 id="1-构造代码块，就是在类中，写在成员位置的代码块，当我们创建本类对象时，会优先于构造方法执行。"><a href="#1-构造代码块，就是在类中，写在成员位置的代码块，当我们创建本类对象时，会优先于构造方法执行。" class="headerlink" title="1.构造代码块，就是在类中，写在成员位置的代码块，当我们创建本类对象时，会优先于构造方法执行。"></a>1.构造代码块，就是在类中，写在成员位置的代码块，当我们创建本类对象时，会优先于构造方法执行。</h4></li><li><h4 id="2-将多个构造方法中，重复的代码，写在构造代码块中（弊端：每次创建本类对象，都会执行一次，有局限性）"><a href="#2-将多个构造方法中，重复的代码，写在构造代码块中（弊端：每次创建本类对象，都会执行一次，有局限性）" class="headerlink" title="2. 将多个构造方法中，重复的代码，写在构造代码块中（弊端：每次创建本类对象，都会执行一次，有局限性）"></a>2. 将多个构造方法中，重复的代码，写在构造代码块中（弊端：每次创建本类对象，都会执行一次，有局限性）</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181304720.png" alt="image-20240618130422500"></p><h2 id="三、静态代码块"><a href="#三、静态代码块" class="headerlink" title="三、静态代码块"></a>三、静态代码块</h2><ul><li><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181311753.png" alt="image-20240618131119469"></h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181318379.png" alt="image-20240618131836167"></p></li><li><h5 id="当一个类被加载时，静态代码块会被执行。这个过程通常在首次创建类的实例之前发生，或者在访问类的静态成员变量或静态方法之前发生。静态代码块可以用来初始化静态成员变量，执行静态方法，加载静态资源，或者进行其他静态的初始化操作。"><a href="#当一个类被加载时，静态代码块会被执行。这个过程通常在首次创建类的实例之前发生，或者在访问类的静态成员变量或静态方法之前发生。静态代码块可以用来初始化静态成员变量，执行静态方法，加载静态资源，或者进行其他静态的初始化操作。" class="headerlink" title="当一个类被加载时，静态代码块会被执行。这个过程通常在首次创建类的实例之前发生，或者在访问类的静态成员变量或静态方法之前发生。静态代码块可以用来初始化静态成员变量，执行静态方法，加载静态资源，或者进行其他静态的初始化操作。"></a>当一个类被加载时，静态代码块会被执行。这个过程通常在首次创建类的实例之前发生，或者在访问类的静态成员变量或静态方法之前发生。静态代码块可以用来初始化静态成员变量，执行静态方法，加载静态资源，或者进行其他静态的初始化操作。</h5></li><li><h2 id="静态代码块的特点"><a href="#静态代码块的特点" class="headerlink" title="静态代码块的特点"></a>静态代码块的特点</h2></li><li><p><strong>执行顺序</strong>：静态代码块在类被加载时执行，按照它们在类中出现的顺序执行。如果一个类中有多个静态代码块，它们会按照在源代码中的顺序依次执行。</p></li><li><p><strong>只执行一次</strong>：静态代码块只会执行一次，即使类被加载多次也是如此。这意味着静态代码块中的代码在整个应用程序的生命周期中只会执行一次。</p></li><li><p><strong>访问权限</strong>：静态代码块可以访问类的静态成员变量和静态方法，但是不能直接访问非静态成员变量和非静态方法。非静态成员变量和非静态方法只有在类的实例被创建后才能被访问。</p></li><li><p><strong>异常处理</strong>：静态代码块中的异常可以通过捕获并处理来防止类加载失败。如果静态代码块中发生了异常，并且没有被处理，类加载过程将被终止，导致类加载失败。</p></li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406181313431.png" alt="image-20240618131347941"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;面向对象细节性的知识点&lt;/h1&gt;

&lt;h1 id=&quot;面向对象细节性的知识点&quot;&gt;&lt;a href=&quot;#面向对象细节性的知识点&quot; class=&quot;headerlink&quot; title=&quot;面向对象细节性的知识点&quot;&gt;&lt;/a&gt;面向对象细节性的知识点&lt;/h1&gt;&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>13.多态</title>
    <link href="https://protonlml.github.io/2019/09/24/13.%E5%A4%9A%E6%80%81/"/>
    <id>https://protonlml.github.io/2019/09/24/13.%E5%A4%9A%E6%80%81/</id>
    <published>2019-09-24T13:40:00.000Z</published>
    <updated>2024-06-18T08:57:53.199Z</updated>
    
    <content type="html"><![CDATA[<h1><center>多态</h1><h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><h2 id="封装-继承-多态"><a href="#封装-继承-多态" class="headerlink" title="封装      继承      多态"></a>封装      继承      多态</h2><hr><hr><h2 id="一、什么是多态"><a href="#一、什么是多态" class="headerlink" title="一、什么是多态"></a>一、什么是多态</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406172337419.png" alt="image-20240617233732931"></p><h2 id="多态：父类的引用，指向子类的对象"><a href="#多态：父类的引用，指向子类的对象" class="headerlink" title="多态：父类的引用，指向子类的对象"></a>多态：父类的引用，指向子类的对象</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406172338263.png" alt="image-20240617233856246"></p><h2 id="二、多态调用成员的特点"><a href="#二、多态调用成员的特点" class="headerlink" title="二、多态调用成员的特点"></a>二、多态调用成员的特点</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180001640.png" alt="image-20240618000101824"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180002666.png" alt="image-20240618000252571"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180003927.png" alt="image-20240618000356778"></p><hr><hr><h2 id="三、多态的优势与弊端"><a href="#三、多态的优势与弊端" class="headerlink" title="三、多态的优势与弊端"></a>三、多态的优势与弊端</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180016271.png" alt="image-20240618001619216"></p><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><ul><li><h2 id="就是-不能使用子类中特有的方法（因为使用的是父类的引用，创建的子类对象，调用方法时，用的是父引用-在父类中找成员变量，和找-子类重写的成员方法）"><a href="#就是-不能使用子类中特有的方法（因为使用的是父类的引用，创建的子类对象，调用方法时，用的是父引用-在父类中找成员变量，和找-子类重写的成员方法）" class="headerlink" title="就是 不能使用子类中特有的方法（因为使用的是父类的引用，创建的子类对象，调用方法时，用的是父引用 在父类中找成员变量，和找 子类重写的成员方法）"></a>就是 不能使用子类中特有的方法（因为使用的是父类的引用，创建的子类对象，调用方法时，用的是父引用 在父类中找成员变量，和找 子类重写的成员方法）</h2></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180024497.png" alt="image-20240618002454345"></p><hr><hr><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406180017563.png" alt="image-20240618001741501"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;多态&lt;/h1&gt;

&lt;h1 id=&quot;面向对象三大特征&quot;&gt;&lt;a href=&quot;#面向对象三大特征&quot; class=&quot;headerlink&quot; title=&quot;面向对象三大特征&quot;&gt;&lt;/a&gt;面向对象三大特征&lt;/h1&gt;&lt;h2 id=&quot;封装-继承-多态&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>12.继承</title>
    <link href="https://protonlml.github.io/2019/09/24/12.%E7%BB%A7%E6%89%BF/"/>
    <id>https://protonlml.github.io/2019/09/24/12.%E7%BB%A7%E6%89%BF/</id>
    <published>2019-09-24T13:30:00.000Z</published>
    <updated>2024-06-18T08:59:05.889Z</updated>
    
    <content type="html"><![CDATA[<h1><center>继承</h1><h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><h2 id="封装-继承-多态"><a href="#封装-继承-多态" class="headerlink" title="封装      继承      多态"></a>封装      继承      多态</h2><hr><hr><h2 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171016179.png" alt="image-20240617101602874"></p><h2 id="二、什么时继承，继承有哪些好处"><a href="#二、什么时继承，继承有哪些好处" class="headerlink" title="二、什么时继承，继承有哪些好处"></a>二、什么时继承，继承有哪些好处</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171016670.png" alt="image-20240617101643079"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171017887.png" alt="image-20240617101738485"></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171020517.png" alt="image-20240617102030302"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171021564.png" alt="image-20240617102059250"></p><h2 id="三、继承的特点"><a href="#三、继承的特点" class="headerlink" title="三、继承的特点"></a>三、继承的特点</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171026688.png" alt="image-20240617102633387"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171027208.png" alt="image-20240617102712126"></p><h2 id="注意：一个父类中所有的子类，需要是同一种事物"><a href="#注意：一个父类中所有的子类，需要是同一种事物" class="headerlink" title="注意：一个父类中所有的子类，需要是同一种事物"></a>注意：一个父类中所有的子类，需要是同一种事物</h2><hr><hr><h2 id="四、子类到底能继承父类中的哪些内容"><a href="#四、子类到底能继承父类中的哪些内容" class="headerlink" title="四、子类到底能继承父类中的哪些内容"></a>四、子类到底能继承父类中的哪些内容</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171110984.png" alt="image-20240617111008730"></p><h2 id="五、继承中：成员变量的访问特点"><a href="#五、继承中：成员变量的访问特点" class="headerlink" title="五、继承中：成员变量的访问特点"></a>五、继承中：成员变量的访问特点</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171117774.png" alt="image-20240617111739316"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171119179.png" alt="image-20240617111908944"></p><h2 id="六、继承中：成员方法的访问特点"><a href="#六、继承中：成员方法的访问特点" class="headerlink" title="六、继承中：成员方法的访问特点"></a>六、继承中：成员方法的访问特点</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171122664.png" alt="image-20240617112242579"></p><h2 id="七、方法的重写"><a href="#七、方法的重写" class="headerlink" title="七、方法的重写"></a>七、方法的重写</h2><h3 id="当父类方法，不能满足子类现在的需求时，需要进行方法重写"><a href="#当父类方法，不能满足子类现在的需求时，需要进行方法重写" class="headerlink" title="&#x3D;&#x3D;当父类方法，不能满足子类现在的需求时，需要进行方法重写&#x3D;&#x3D;"></a>&#x3D;&#x3D;当父类方法，不能满足子类现在的需求时，需要进行方法重写&#x3D;&#x3D;</h3><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171125875.png" alt="image-20240617112545713"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171451886.png" alt="image-20240617145137669"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171459709.png" alt="image-20240617145907470"></p><h2 id="八、继承中：构造方法的访问特点"><a href="#八、继承中：构造方法的访问特点" class="headerlink" title="八、继承中：构造方法的访问特点"></a>八、继承中：构造方法的访问特点</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171504965.png" alt="image-20240617150430866"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171508818.png" alt="image-20240617150847219"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171510240.png" alt="image-20240617151055043"></p><h3 id="创建对象的时候，给其属性设置默认值（使用构造器来设置）"><a href="#创建对象的时候，给其属性设置默认值（使用构造器来设置）" class="headerlink" title="创建对象的时候，给其属性设置默认值（使用构造器来设置）"></a>创建对象的时候，给其属性设置默认值（使用构造器来设置）</h3><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171515956.png" alt="image-20240617151528270"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;继承&lt;/h1&gt;

&lt;h1 id=&quot;面向对象三大特征&quot;&gt;&lt;a href=&quot;#面向对象三大特征&quot; class=&quot;headerlink&quot; title=&quot;面向对象三大特征&quot;&gt;&lt;/a&gt;面向对象三大特征&lt;/h1&gt;&lt;h2 id=&quot;封装-继承-多态&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>11.static静态关键字</title>
    <link href="https://protonlml.github.io/2019/09/24/11.static%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    <id>https://protonlml.github.io/2019/09/24/11.static%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</id>
    <published>2019-09-24T12:30:00.000Z</published>
    <updated>2024-06-17T02:03:16.292Z</updated>
    
    <content type="html"><![CDATA[<h1><center>static静态关键字</h1><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="一、在类中，对成员变量进行修饰（静态变量）"><a href="#一、在类中，对成员变量进行修饰（静态变量）" class="headerlink" title="一、在类中，对成员变量进行修饰（静态变量）"></a>一、在类中，对成员变量进行修饰（静态变量）</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406170015526.png" alt="image-20240617001547008"></p><ul><li><h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><ul><li><h5 id="学生对象，创建student的类时，可以将-teacherName-设置为-静态的，因为其所有的student的teacherName-是一样的"><a href="#学生对象，创建student的类时，可以将-teacherName-设置为-静态的，因为其所有的student的teacherName-是一样的" class="headerlink" title="学生对象，创建student的类时，可以将 teacherName 设置为 静态的，因为其所有的student的teacherName 是一样的"></a>学生对象，创建student的类时，可以将 teacherName 设置为 静态的，因为其所有的student的teacherName 是一样的</h5></li></ul></li></ul><h2 id="二、在类中，对成员方法进行修饰（静态方法）"><a href="#二、在类中，对成员方法进行修饰（静态方法）" class="headerlink" title="二、在类中，对成员方法进行修饰（静态方法）"></a>二、在类中，对成员方法进行修饰（静态方法）</h2><h4 id="static修饰的成员变量，或者成员方法，因为其都使用了static-关键字修饰，随着类加载而加载，和某个new出来的对象无关"><a href="#static修饰的成员变量，或者成员方法，因为其都使用了static-关键字修饰，随着类加载而加载，和某个new出来的对象无关" class="headerlink" title="static修饰的成员变量，或者成员方法，因为其都使用了static 关键字修饰，随着类加载而加载，和某个new出来的对象无关"></a>static修饰的成员变量，或者成员方法，因为其都使用了static 关键字修饰，随着类加载而加载，和某个new出来的对象无关</h4><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406170954946.png" alt="image-20240617095416486"></p><h2 id="三、一般我们在javaBen中很少用static修饰，工具类或者测试类中，使用的较多"><a href="#三、一般我们在javaBen中很少用static修饰，工具类或者测试类中，使用的较多" class="headerlink" title="三、一般我们在javaBen中很少用static修饰，工具类或者测试类中，使用的较多"></a>三、一般我们在javaBen中很少用static修饰，工具类或者测试类中，使用的较多</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406170956177.png" alt="image-20240617095633805"></p><h2 id="四、重新认识main方法"><a href="#四、重新认识main方法" class="headerlink" title="四、重新认识main方法"></a>四、重新认识main方法</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406171001558.png" alt="image-20240617100151309"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;static静态关键字&lt;/h1&gt;

&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;一、在类中，对成员变量进行修饰（静态变量）&quot;&gt;&lt;a href=&quot;#一、在类中，对成员变</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>10.集合</title>
    <link href="https://protonlml.github.io/2019/09/24/10.%E9%9B%86%E5%90%88/"/>
    <id>https://protonlml.github.io/2019/09/24/10.%E9%9B%86%E5%90%88/</id>
    <published>2019-09-24T12:00:00.000Z</published>
    <updated>2024-06-16T15:08:14.547Z</updated>
    
    <content type="html"><![CDATA[<h1><center>集合</center></h1><h2 id="一、集合和数组都是存数据的容器"><a href="#一、集合和数组都是存数据的容器" class="headerlink" title="一、集合和数组都是存数据的容器"></a>一、集合和数组都是存数据的容器</h2><ul><li><h4 id="1-集合和数组的区别"><a href="#1-集合和数组的区别" class="headerlink" title="1.集合和数组的区别"></a>1.集合和数组的区别</h4><ul><li><h5 id="数组：长度是固定的，可以存储基本数据类型，也可以存储引用数据类型"><a href="#数组：长度是固定的，可以存储基本数据类型，也可以存储引用数据类型" class="headerlink" title="数组：长度是固定的，可以存储基本数据类型，也可以存储引用数据类型"></a>数组：长度是固定的，可以存储基本数据类型，也可以存储引用数据类型</h5></li><li><h5 id="集合：-长度是可变的，只能存储引用数据类型。"><a href="#集合：-长度是可变的，只能存储引用数据类型。" class="headerlink" title="集合： 长度是可变的，只能存储引用数据类型。"></a>集合： 长度是可变的，只能存储引用数据类型。</h5></li></ul></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161049600.png" alt="image-20240614215622841"></p></li></ul><h2 id="二、集合的基本操作（增删改查）"><a href="#二、集合的基本操作（增删改查）" class="headerlink" title="二、集合的基本操作（增删改查）"></a>二、集合的基本操作（增删改查）</h2><ul><li><h4 id="对容器类的对象的操作，基本上就是增删改查"><a href="#对容器类的对象的操作，基本上就是增删改查" class="headerlink" title="对容器类的对象的操作，基本上就是增删改查"></a>对容器类的对象的操作，基本上就是增删改查</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161049703.png" alt="image-20240614220414018"></p></li><li><h4 id="1-创建集合对象（-中表示泛型）"><a href="#1-创建集合对象（-中表示泛型）" class="headerlink" title="1.创建集合对象（&lt;&gt; 中表示泛型）"></a>1.创建集合对象（&lt;&gt; 中表示泛型）</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161050420.png" alt="image-20240614230046252"></p></li></ul><hr><hr><h2 id="三、基本数据类型对应的包装类"><a href="#三、基本数据类型对应的包装类" class="headerlink" title="三、基本数据类型对应的包装类"></a>三、基本数据类型对应的包装类</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161050453.png" alt="image-20240615002212022"></p><h2 id="四、集合综合练习"><a href="#四、集合综合练习" class="headerlink" title="四、集合综合练习"></a>四、集合综合练习</h2><ul><li><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161050883.png" alt="image-20240615043351999"></h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161050676.png" alt="image-20240615043452052"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161050864.png" alt="image-20240615043542259"></p></li></ul><h2 id="五、知识点（标号的使用）"><a href="#五、知识点（标号的使用）" class="headerlink" title="五、知识点（标号的使用）"></a>五、知识点（标号的使用）</h2><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161050593.png" alt="image-20240615042125994"></li></ul><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;集合&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、集合和数组都是存数据的容器&quot;&gt;&lt;a href=&quot;#一、集合和数组都是存数据的容器&quot; class=&quot;headerlink&quot; title=&quot;一、集合和数组都是存数据的容器&quot;&gt;&lt;/a&gt;一、集合和数组都是存数</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>9.字符串综合练习</title>
    <link href="https://protonlml.github.io/2019/09/24/9.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/"/>
    <id>https://protonlml.github.io/2019/09/24/9.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0/</id>
    <published>2019-09-24T11:00:00.000Z</published>
    <updated>2024-06-16T15:08:20.268Z</updated>
    
    <content type="html"><![CDATA[<h1><center>字符串综合练习</center></h1><h2 id="一、转换罗马数字"><a href="#一、转换罗马数字" class="headerlink" title="一、转换罗马数字"></a>一、转换罗马数字</h2><ul><li><h4 id="使用到了-string-字符串-转-char-方法是toCharArray"><a href="#使用到了-string-字符串-转-char-方法是toCharArray" class="headerlink" title="使用到了 string 字符串 转 char[] :方法是toCharArray()"></a>使用到了 string 字符串 转 char[] :方法是toCharArray()</h4></li><li><h4 id="使用到将-char-i-某个char字符，转为-数字-：方法使用-Character-getNumericValue-chars-i"><a href="#使用到将-char-i-某个char字符，转为-数字-：方法使用-Character-getNumericValue-chars-i" class="headerlink" title="使用到将 char[i] 某个char字符，转为 数字 ：方法使用 Character.getNumericValue(chars[i]);"></a>使用到将 char[i] 某个char字符，转为 数字 ：方法使用 Character.getNumericValue(chars[i]);</h4></li><li><h4 id="使用jdk12中-的-switch的写法进行匹配"><a href="#使用jdk12中-的-switch的写法进行匹配" class="headerlink" title="使用jdk12中 的 switch的写法进行匹配"></a>使用jdk12中 的 switch的写法进行匹配</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161047944.png" alt="image-20240613232053432"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161048084.png" alt="image-20240614021756737"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161048195.png" alt="image-20240614021823302"></p><hr><hr><h2 id="二、调整字符串"><a href="#二、调整字符串" class="headerlink" title="二、调整字符串"></a>二、调整字符串</h2><ul><li><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161048185.png" alt="image-20240614213457577"></h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161048464.png" alt="image-20240614213531911"></p></li></ul><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;字符串综合练习&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、转换罗马数字&quot;&gt;&lt;a href=&quot;#一、转换罗马数字&quot; class=&quot;headerlink&quot; title=&quot;一、转换罗马数字&quot;&gt;&lt;/a&gt;一、转换罗马数字&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 i</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
