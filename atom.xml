<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://protonlml.github.io/atom.xml" rel="self"/>
  
  <link href="https://protonlml.github.io/"/>
  <updated>2024-06-16T01:41:24.580Z</updated>
  <id>https://protonlml.github.io/</id>
  
  <author>
    <name>𝚲𝚳𝚲</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码</title>
    <link href="https://protonlml.github.io/2024/01/01/%E6%8C%82%E5%B9%B4%E5%85%BD/"/>
    <id>https://protonlml.github.io/2024/01/01/%E6%8C%82%E5%B9%B4%E5%85%BD/</id>
    <published>2024-01-01T03:00:00.000Z</published>
    <updated>2024-06-16T01:41:24.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="换新颜给博客网站右上角添加悬挂年兽-喜增龙年喜气源码"><a href="#换新颜给博客网站右上角添加悬挂年兽-喜增龙年喜气源码" class="headerlink" title="换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码"></a>换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码</h1><ul><li><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul><li>这篇文章介绍了一个在博客网站右上角添加悬挂年兽的方法。通过在CSS代码中插入相应的素材链接，可以实现在网站右上角挂上一个龙的效果。对于自定义主题的网站，可以将相关的CSS和HTML代码添加到自定义头部中。对于全屏网站，建议在CSS代码的16行左右插入一行代码以实现相应效果。</li></ul></li></ul><h1 id="一、简介-教程"><a href="#一、简介-教程" class="headerlink" title="一、简介-教程"></a>一、简介-教程</h1><blockquote><p>换新颜新气象，给网站右上角挂一个龙，吸吸龙气</p><p>css第6行放入下面素材链接（本站开了防盗所以给你也无用就放下面了）</p><p>如果你的主题是自定义，那就是主题设置自定义里面</p><p>自定义css</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">850px</span>)&#123;</span><br><span class="line">    <span class="selector-class">.NewYear</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">260px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">display</span>: inline-block;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">https://img.ly522.com/LY/uploads/2023/12/longgyaj.gif</span>) no-repeat <span class="number">50%</span>/<span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">        <span class="attribute">position</span>: fixed;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">85.8%</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">55px</span>;</span><br><span class="line">        <span class="attribute">z-index</span>: <span class="number">50</span>;</span><br><span class="line">        <span class="attribute">cursor</span>: pointer;</span><br><span class="line">        <span class="attribute">animation</span>: new-year <span class="number">1.2s</span> ease-in-out <span class="number">0s</span> infinite alternate;</span><br><span class="line">        <span class="attribute">margin-left</span>: -<span class="number">1px</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">pointer-events</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@keyframes</span> new-year&#123;</span><br><span class="line">      <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">10deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="number">100%</span>&#123;</span><br><span class="line">                <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">10deg</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="html放到你的自定义头部html即可！！"><a href="#html放到你的自定义头部html即可！！" class="headerlink" title="html放到你的自定义头部html即可！！"></a>html放到你的自定义头部html即可！！</h3></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;NewYear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：如果你的是全屏网站建议在pointer-events: none;下面加一行。即css代码16行左右哪里加</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">z-index</span>: <span class="number">999</span>;</span><br></pre></td></tr></table></figure><blockquote><h3 id="演示图"><a href="#演示图" class="headerlink" title="演示图"></a>演示图</h3></blockquote><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160941751.png" alt="image-20240118020305488"></p><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div><p>​     </p></escape>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;换新颜给博客网站右上角添加悬挂年兽-喜增龙年喜气源码&quot;&gt;&lt;a href=&quot;#换新颜给博客网站右上角添加悬挂年兽-喜增龙年喜气源码&quot; class=&quot;headerlink&quot; title=&quot;换新颜给博客网站右上角添加悬挂年兽 喜增龙年喜气源码&quot;&gt;&lt;/a&gt;换新颜给博客网站</summary>
      
    
    
    
    <category term="新年快乐" scheme="https://protonlml.github.io/categories/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"/>
    
    
    <category term="春节挂件" scheme="https://protonlml.github.io/tags/%E6%98%A5%E8%8A%82%E6%8C%82%E4%BB%B6/"/>
    
    <category term="技巧优化" scheme="https://protonlml.github.io/tags/%E6%8A%80%E5%B7%A7%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>matery主题的使用</title>
    <link href="https://protonlml.github.io/2020/03/17/matery%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://protonlml.github.io/2020/03/17/matery%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-17T03:00:00.000Z</published>
    <updated>2024-06-16T02:11:38.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="matery主题的使用"><a href="#matery主题的使用" class="headerlink" title="matery主题的使用"></a>matery主题的使用</h1><h1 id="一、下载matery主题"><a href="#一、下载matery主题" class="headerlink" title="一、下载matery主题"></a>一、下载matery主题</h1><ul><li><h3 id="1-GitHub源项目"><a href="#1-GitHub源项目" class="headerlink" title="1.GitHub源项目"></a>1.GitHub源项目</h3></li><li><p><a href="https://github.com/blinkfox/hexo-theme-matery">GitHub - blinkfox&#x2F;hexo-theme-matery: 一个基于材料设计和响应式设计而成的全面、美观的Hexo主题。</a></p></li><li><h3 id="2-在本地clone下来"><a href="#2-在本地clone下来" class="headerlink" title="2.在本地clone下来"></a>2.在本地clone下来</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/blinkfox/hexo-theme-matery.git</span></span><br></pre></td></tr></table></figure><h1 id="二、配置hexo根yml文件"><a href="#二、配置hexo根yml文件" class="headerlink" title="二、配置hexo根yml文件"></a>二、配置hexo根yml文件</h1><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011622.png" alt="image-20240112005024106"></li></ul><h1 id="三、自定义主题"><a href="#三、自定义主题" class="headerlink" title="三、自定义主题"></a>三、自定义主题</h1><ul><li><h3 id="1-修改导航名称和路径图标"><a href="#1-修改导航名称和路径图标" class="headerlink" title="1.修改导航名称和路径图标"></a>1.修改导航名称和路径图标</h3><ul><li><h5 id="添加导航二级菜单的写法（如下是“关于”一级菜单修改）"><a href="#添加导航二级菜单的写法（如下是“关于”一级菜单修改）" class="headerlink" title="添加导航二级菜单的写法（如下是“关于”一级菜单修改）"></a>添加导航二级菜单的写法（如下是“关于”一级菜单修改）</h5></li><li><p>注意：1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>) </p></li><li><p>​             2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找  ,线上的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">About:</span><br><span class="line">   url: /about</span><br><span class="line">   # icon: fas fa-user-circle 注释掉原来的，加上下面这一段</span><br><span class="line">   icon: fas fa-list</span><br><span class="line">   children:</span><br><span class="line">     - name: 爱的颜色</span><br><span class="line">       url: /love</span><br><span class="line">       icon: fas fa-heart</span><br><span class="line">     - name: 生日快乐</span><br><span class="line">       url: /birthday</span><br><span class="line">       icon: fas fa-cake</span><br></pre></td></tr></table></figure></li><li><h3 id="2-手机二级菜单配置"><a href="#2-手机二级菜单配置" class="headerlink" title="2.手机二级菜单配置"></a>2.手机二级菜单配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">navMenu:</span></span><br><span class="line">  <span class="attr">mleft:</span> <span class="literal">true</span>    <span class="comment">#  二级侧栏子菜单是否对齐左边</span></span><br><span class="line">  <span class="attr">bgColor:</span> <span class="string">&quot; &quot;</span>   <span class="comment">#  二级侧栏子菜单背景颜色,留空即为全局背景色</span></span><br></pre></td></tr></table></figure></li><li><h3 id="3-首页中间右侧-banner"><a href="#3-首页中间右侧-banner" class="headerlink" title="3.首页中间右侧 banner"></a>3.首页中间右侧 banner</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">githubLink:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                                   <span class="comment"># 是否开启</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/sitoi/sitoi.github.io</span>  <span class="comment"># GitHub 仓库地址</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Fork</span> <span class="string">Me</span>                                 <span class="comment"># 显示文字</span></span><br></pre></td></tr></table></figure></li><li><h3 id="4-首页轮播图相关配置"><a href="#4-首页轮播图相关配置" class="headerlink" title="4.首页轮播图相关配置"></a>4.首页轮播图相关配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">showPrevNext:</span> <span class="literal">false</span>     <span class="comment"># 是否显示左右切换按钮</span></span><br><span class="line">  <span class="attr">showIndicators:</span> <span class="literal">false</span>   <span class="comment"># 是否显示指示器</span></span><br><span class="line">  <span class="attr">autoLoop:</span> <span class="literal">false</span>         <span class="comment"># 是否自动轮播</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="number">120</span>           <span class="comment"># 切换延迟时间，默认单位 秒</span></span><br><span class="line">  <span class="attr">intervalTime:</span> <span class="number">5000</span>      <span class="comment"># 自动切换下一张的间隔时间</span></span><br></pre></td></tr></table></figure></li></ul><p>参考：</p><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐 (blinkfox.github.io)</a></p><p><a href="https://sitoi.cn/posts/63466.html">基于 Hexo GitHub 从零开始搭建个人博客（三）：Matery 主题（DIY 版）详细配置教程，附博客源码 | Sitoi</a></p><p><a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-23">(๑•̀ㅂ•́) ✧被发现了～ (sunhwee.com)</a></p><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;matery主题的使用&quot;&gt;&lt;a href=&quot;#matery主题的使用&quot; class=&quot;headerlink&quot; title=&quot;matery主题的使用&quot;&gt;&lt;/a&gt;matery主题的使用&lt;/h1&gt;&lt;h1 id=&quot;一、下载matery主题&quot;&gt;&lt;a href=&quot;#一、下载m</summary>
      
    
    
    
    <category term="博客相关" scheme="https://protonlml.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Hexo" scheme="https://protonlml.github.io/tags/Hexo/"/>
    
    <category term="matery主题" scheme="https://protonlml.github.io/tags/matery%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>3.git初始化仓库的两种方式</title>
    <link href="https://protonlml.github.io/2019/10/10/3.git%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://protonlml.github.io/2019/10/10/3.git%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2019-10-10T06:00:00.000Z</published>
    <updated>2024-06-16T15:09:12.803Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a5182027ce7105558ee628cc6dd9c31b18b9288da20527907f36e388a2aeca88">5e0f427b1806d2606f470abb7dec961a1e6f0f3829a50da35d12fcf113ec95129d05f73f815986a2211f597479a8969b58363e65bacbd800fdfb55462b459655d3fa134e8cf36feb2ba4d3c811a1960a53a4d0210b81321ff5fdc037adefe49f349e0e2b2ee52be3053b1678f8b813eeeffc068d065f26dc1e573c3727e073919aa8728aa1b6a558f465623ac795a03cf3a04265133b28b8c85f3fc3f95738fdb09998672bcaa1cdca4b82ac75f87e576ec62196467a80cf3c8dc64b401438ce7876ea172c84db3a20eaae669a484ca2f7773d3a2200d64efb17973169eec80409f883b40ac910dea136c937a3de612d787c342991e6687102228fa64acda61e28915ad4c0139d466835a1ef22d2fc457e3bcbd317bb3fcb3ac5a0908eebe8247dbafd8d2d8be690f25e1df0cf1d4a5d6be59b6b434adeeefa2a630668ec5337727f1022a9bd55a00802c776092300370197f1be0480db36905ae3848c9616aa82896c46d33991939fd8ad267648580271ac551a91c7d0adc71b556173a4390c0d7f738f5213887eaf25ae34027b143e52380bb330e715124be3d658550df8ac83f7b283b369c7867945cf8217a1c66e1005253e3300c78af2c1e19704068ac35049bed41937b2336e2928b73aaf9750e39041f7bc784f598d4575d486c73eee15e92094585d15221a5d13af6e1bc9b245e9745726aa83028d1bbb05023fdd1a5a9f1361d1e0e664b02323787932cb56016bc37a6dc011c7b985e6b11bacc5f83c702211d273c856a71781230c7884b1d1bdc8ef33c2c43a8810386b735388cf7448837fbc9b6c7c78d314ded26e6843aa6043f9f287a9d8c601b62aab7d3333f769846f1577284b9e4eb6e1a9fc2be6de2d8f31de6c1edb700bb46ce2af6e2de55f0ffdc56c716607422fe20a755a043c590d2a503aeeb5fa54a469dd57c16b14318f2108cf74b90b1f7328bc9bb76604b12f73347badb214605cd00d61319438cb6b556d224ae3892a594082e2c3f12538cd83ae3ec7c487c1ce97ceb19cbf1db55c4abfdfd6f68d05481ec970717664fba0d651feb962f8364b5c554773bac1ec43c343fa9ceb55371cf85f747fcada65dff50d39bf3b56224444613c6f64da6b0a5d9fa52363636d286c17173d9268ccc58f1241fe4d17a6da161035596a50ffd129e896d68203ffaba896f60e7f9fbd90da721513a90cb734dfd9abf2df2b4ecebbdaa603caf70e89b861b1d1599928985789404e5733c2c7b73fd63fb2e34d2b506e0e1b7bd5d973e44979ba7f95648489dd361d582ac51c8f2c3ee0baaab6a041a5e0a0263defe3f1611fd3e3555133f1c3d84b387b1304b18fbb09e3aa9994ac42b4efc928ce927bec97326e9433651386310b2a57536b73cd8bd24c5e573df9987e62e212744f22779bf259ec2c9629eef065788a9db57941a8117ccb053ef6880ec48d01ee4f668de22ee60798e4cb39bef7ba7ad7480050f02ebcd469b08083ac7cb40763d35964b99e89be4f8ee4dbd765c382ddb627ed31224cb0453f1fd270ef7d74b8ab7fb4fc8ec415bfeeb1ed2846cf400b449068dc98b476419b6d1998e31e633c273a597989fd8c1b2fa88ef9ff276f275beea56095a5dfcf2d3ec46e49401e1ef51f2606367e454df284e2472ca8ba1eb366c15877cd28f4204e8b18dd7fdffdf61129cb987de1c814ed2dbe620d8a69ff71aa4f03afc71e220a500a61fd53e58842ba9a17d53d2e4514539cfa99b3f6b5a9031ade79f29189ecdccc81af75ef98b30696310b49a82d31315b8ac97d7885125c0783cbc0f4701e9139c9c35c1b4083c190d3805e60404150b9b9bb71cb3d7124cbefdc007e3a3f5303d8db70241487410955a68d12d3e5cab93a67c9c0564afe6df54f63b75f2df1cbaaa940e3c87eb346372ce39a658fad02c759d0848be86b6780b2cbc21cc12382ada68ed04c6630f776773da49ed0b4f69c329343ff5b2c74ff591dd63b7454b96b457b5bc10d36338505243694b38dd0ec10f166af71075b884c6d4a20ab4919aef911a8ea4986efe47d1d323597da9d92ef598b21d7c9e8dc7d8442acd5d4d2a706fc9b3164f21b3c5e6ddccd7e16c10f51f5e435555a8d146274c0f4dce77abeec1c36593b555b93f5a0178dcde3466a3a899945c4f1106ec107adb821fe88c59e8520a6c1a4541afedbd3410d25bd3d5b832eca05c8cd9960dc8f2e6852089083a09650422b7ff1ee2e7b664b325de2b060b7eaeb5e0767f0d3e7eb80a557e2d57037ec509ebbe165e0916ebb0f701fe8f641bc85cd91d8abd20486b71c6c4c2b30351e9b2dde1ba09f4119939e93a911151c9364c28d96a96d31b7429752c920d33f8d48eeb0428f8088d9e1e451e1fa18bc17df23eb87621e81e670909bf0f26445bb49da2d438d158d385d206ef04c746b65b5150b2c320a91c46bebe0200a1fcd7cfba04ff762039ae8b062a3f99ffdcec9382b6b4983fd3fb1633cf59fbb9905d8c5041002d09338e189bbb488e2ad534d962f8016f7946a83f1e576399b4cf6151942890776e7e32964f590a5c8b16d2f904487941d86e825bffb20e2d30d1fa3e9376f20e940bb66d6300d03ad05c67f7a7f1c170a5527294b9cfbf5036ec0ea0d29c5f2cdd7166eccd30aa6cd384dbf2ed7b616ae3ddef0a77174ad28cc11fb849f81e00d80c79fb7f17f32379dd1ce55a51ed5052cd911a6d4a6f41b980aaa295ba758e346d82db21ae6e68aad508634e2c39e2b0680ed0c1ce28de8328f4c8d3c57b1c5ab0219807606ceeb9e069229c3f5c348f0854786a0fc08eef2f14aa4590148dc40ab84ef15043194990c883eb0d79173f6147ddef7b777f9db816f0c624da04923d12dc10b2aa51d346018e814aff08de1930608268bafae995af0d9271985fd4dd20447143dbabe3c4d5ea134a2bf766583235782950a2b60f8b09c9640053f43ab1ca713345f43475d3a4fa11a8d079c5f4ec24887267d99c7588cd7f2245cc28fdaee69f59c1bc87be8a710f128237fe33e257cadf231d78e8cc78111fc6adc322e08e2699c177700e978545295b908dc604c81dbad84d99f1efb5c313da3d211c67af1db2ec19ad9cf1eac120d2ed7098dee343ddcaf8265b9e4191702542b5c2874bc40d43d48facbbdbc5ae275eea266ad7da3f9e9ea3a43a3d6a84f7906e4e9f68835377655b13932ab59631022d2945d865dba3ece14870391063789a334055e82d5b11b7ab79d4ecfe7f1ef6d245e594d3dbf2d36417ad123235f04042bdff1c1292288a10d7debc0d219ddabfb4d31b791591d077b4edc0f472baadd08c4f32a661663c41f0e8f203b89bddfcdaa36d9a7bbbf1eacfb68e1233082e617abbe3f345407c72024020e8eb1939241fb6caef86771812b3d796940642bcd768ce6dcd2f631f78c902cb659e36ac43cfbeb76c57537afd2adf08257f7672177b3837b66b8406284baafd1059a9331c1fbbb4fe498e9756f67d02fdcd449cd32838eb1f26cf739e35a01d593777004ac46a048e9a2ecd3b9debcba055cd969055c23e20024048f55e48dfbb2d282d19b55dd3b6a41d21150cead86840033743bc8b9158adadbe1d4d061da97cf4231d1e6916fb77a3488b5b73dc06e55ba749c6a84100bf72f483faef977f4af01aad2fd753c78a8ee454c08f1a6f9692e5bef16ac58780803b853e3e7db914b8ecea7a45a030ee847eafed747b1a833b32308b951a355fb962cff281311986d9232bbbc870aa1d182d3324bbca065d6967cc9e272c7d1c522f6d40f01efe5f10b64d4f4d55de7ba6e966490b561c08c6e15ff5a5c372b4ac960bd2f2c78503569380cc390d1953adb6ade723000a442842073899eb0fe443599a7b3dc9b0845047c02de98817e5a14b1b603917c17c67b72af77e39ca333b8680ce8e7ebed562ea21193bd131ec3bc8edce5d67dc459ec2d01d79fa0fab481615b779366f21581ff5c4844d5a4e36c16af208cc747b63442ecf5bf19d4bb0c44dd959fa748e26ef7752283e280c7572a9076cea8d8b3950873ecc79acb06bf2f3dcd1b2a4cf8d1381b5e2d1e1c97d8cbd67b027f9fe07dc94a2994d5347cd5ff6be7b10bc5c71b9689c74b0e4fd6881a87b377bfb11607fda606ac32405b5063e737fe4e0973fb791107037a8206c794301b3266aa7c0871d0063149d55d12c52457724bb5a41cad6cbff2f01817f115e36321ae0671832064b2d61be2b630c190f848c1c76316bc5d941b0906500ea1954c224bcac31546add270e0f7a97318c4329f26beb3ac8ab30fb2f0608fb209d36c417717de3c9ece89ba62a3c97f6eb70db472dd0347bff95980817f3c18b17952101e7874ad7a6f4a83070f4793d4a6a8e5c5dd7a315a7fb5b49659a4344251c8bcd67c592d4f5f7092f372494355502aa9d78c5877f560e3bc88f9adef10f313fbccc1202967754a7be6a7ab1368179d5f347eb05b009daac266c869f5077084bbe6340258ac2a97dd735609acd7b6b297a6cf446814403ad0a4c5feeacf082c3945aeabd3d979c36d22a1b619c3bff2b32a64dc93fd22a04937b4cbf73a4ad6946dbff6437d34e3ff3f60cc07edb3063699b768fe88a51a8c9b516a5e0a6dc0df2735da95dff0a50fe22ebef84ba0dee7de86a3c292bab83b1298e9b94eca093d084e16803008017d00fe4ce193e33a9345b762eedfb1e773304b7c2e6429e5e8c799bd49b8c76b4fe64099d2c27c70f07f6de1cf1c3771f97c28407f873069d86fd37241551f276230ba3030969e0c1096a2e8b3d5e2bcb8b7112f29a6f4824dafca4a2b8ff4231999994422ad73a5a7744eb3f8b8bcf92cb03b7bc0ce8255323f7848b741f032e5edfedebb1e4180fb382c3c66e178cf1c6802577c4487a819a26ffb1595de64216e6a8214d122a36f9a5bcfe1bf821473ca3a51c88b3f8e6ab6b2eaf6d04832177f29b3b7a6a9497e118edf5477f762b55edfb917dae111e0dad4318a5c39dff37187c7a2f2aa710df073290da8ed253d7a9541180593db5a9128a360b82ad3360b6730f297638b8f4645e632cbfd9a5c2defb91a25862247178a0419a7f00a130fc660cfeccad6fffbc25cb51d226fe2bde0a5740217e8bf91815cf248641bef02eddfceb979830680fef315428d249758ed7f4f9f26d49a9783ad470889fb3f2710bbe82f683b6b256f12ab2fc5857b650c810b4080bb183031545462568cf6bb86fb6357d36afd20828e899230c6d86383c9a26ab09246d93894adf8b563287b358f495093add03cb71e3764346ecac0a1eb4e31d03e17dc76055926a05682619d7bf73d438f01ff7d9d51834e4f8cce8b374a406d3c1d3c2d072f67c5258f67fe93a5c1c6db089f052267aef80f66401c5509b8df6274d441c3230342d58638d93d002c8ca715f020639cec69da78d780bce16ef960f5624aedb0bf3650816957bfc6094c2327e67d203db3185b2e3344fd60364ac42f78e37a62926019a2532a3332e25204847d237ef2a5d508f691147122c8900a66e2f723d53201b5957496d063177dd71eac0c34a0bebfee5412de8d7d7ed6723ef2133f373cd04025b3cc11ffe5b1bf2c3e29136721ddc53c49063be93f391e3cce89d3e134ba7c343ee0d330641bada2b869a569393e8d5ca82fc0c6ffa04aa467d839fb2b646c0c65ee35782f02a3dcf4ae4ea069cd0e8eeb2ab4e900f6a6150d0cfe042b295942bf2c2bbf4f5a699688956cad186ab18717c46990d5d27aa550dd2aae06206bbb062a555753179e0e6b385e21040655e04b36f87bf78122352a50622368141bc75b469db614aa743a54a31bd5535bd0748c57c3b24e432f24a49b7c9b6269c4b54133d223354035f335b493d1d7ab51b22dea70e386775d77eafb3eaaf74b6f8e3af88b1da19d546855b63ae7e432ea6369f452425099104faa0300f7b5e8630d3c8676e31189afb90476485fe084016e2e8159a466acc630d4fc8365660d5eb6dd52bcaf944591dfe607adbd1cf5a807604a9db921409d5a8f390c0f942d671741f8da9d2bb49783cabfc19c2d5b36ebb625d84738a57f9e4925d3475f63bc03ebeadb033cc96c134795c9a3aaa5226bed4c3ac2879d72d8b191978d9c6115acbdd87b27437b3ec2e0cd4b16340125525e4d11615db5e06cd8e1813a5836d35b6b186a0e076409a5fd5fc78c85f2e6e695a74e2649e73003ebd089d4f6812afa1d2730fb72f8c91d47aeeb7829f2bca85d34c0884c5fadc0c1566c3aa72a7411ab27366ebfac7632d21081baf6a38a48265462b077c10e869853a177c94af4526065a58cdee5f6857d7ba87294372c88eed32c5e2ce0895a72aa8c8660f0f531f6a3d8b955da7008dd66179b9c71aeb67ee90253ed2a15146b96833b05ee5148110d2c95af74472c586547daab7e67fe9262a846e231ce1538feb395de1e4e388b0fd6ecb9899bd893479da89a9ecc2fd66911f9553d6e2849d947c39d50f65f0dc054504658c3b94910a1af8f36bf369964d2ac29c8ca96bc47c9160b0a10996a5d5055ac9a5a5cd74695c78c17938a85d07315ee26e9232a55e6f198a844be374391c84f5344a6fd062b5e1d1808a02520182bb3b34218c5859258c17b1893bd1aecddb8a689f74ca4ede4fb64e385e18f8e1fc3f5824b2b58225b3a6d3560bcdb4dc2f86d99ee5417301bf33ec186074014cae8aa9b43b5e86a32271c428959b4381f6e68832dece76a517e04da53a7da761c33f7bfd2b06517e1ae650c2003d8b0baedab3dbbc6570ac82132e7b0b8043e9bdbea634d0576f9a47ce7104452df13ec31d3390d849144a41a2466e9bc333a42d1c977cb73f0bcc5e957f72d8ddef4737d9a95c51fe632b0717ada0cddc2e7d05df0c2fa0ebbd88d473980f3a091eefcbd2952a845b16be3b303ac489c2ef1f92d48c5f768801fbef19d9cb70f01f4da8f439586f7962720ac04f8c29cac77c2c91dd05205d09264ba70d977b0c0ebf189ec4d263615ed306e7624e9506092d7ac30210083eff345e21c7d06d219f397329fc3753e20b74ba0953f5cbad2cf502a98d8ed2a863cd072821f332a683059b2c2da247536bfc2634215349b3ae33ecf1e4cf93c51018d2a4c2d0716bf2833c666a20567673dcf245aad1f90175a6db7b703e99b949ae6ec0d2de240ba2283871545dda40967b8c45566a66365837d5a20312953b909ffcb80446859f30ccd1c75434acfe6037494602ed4c7e8c4dd694f4299190eb66e1db1715cdfd4a74f7448e1f402919a98522174cc8951101e3026b3a5d3ee836ad7c667dadb823712adab4a2372c3d41e88a93a159ce04ef4b99e8ceb60269a4830e69c8ec2966abe07a36b1cf815ff955b2cb36093d833c977a44adc9838f66c5a0f7ffe41e338f800a4e706d69bc89a623110c0415049a7f26944f1a2517a4b2ad5e67650d9e4f2fb4557eab2b8deb0f86f9dc71afda01600304b49b9676d741b7624d8f287d396ec59b636973f1018749b6f3e6895917712792371e5ed3e3c9ad98c3be900435f3067f2506c324d545ff9eff845f8d1d3b077f083b93e4c0d4f7eb27d50d9819439bdc554b63b79b731539ecf418e919141f94291d9c583e36229e33c790af01e2579d7e9a3a435efcbfc6889dfad69be0c197cf3f159c7e01c90b8cef79e97ecc63b6fdc7c70eb3b3ee71e47583e0c3afb008e5f86c819a08940156504392e5e026691f1b4748de804dff297cdc89e4411080cc20c66184806ba9fd4c923b08e92e9b0fa77e27fadd908ab96b151002b4a4c17880cd3e66ce21e792f914cc252f42b5d960e8436b98d81f6684b15684d38827b702be2b9741f681568a93778e2d749208e5f4af263d80e9155a26f4cdfbb2423c5a9c07f9f259d8f747acba2a632153d39ba095ac8b601bd106930168bd2f4a5d81cbbd96c30fef2323935412612e1a5cd4c3ab2800f41a937c1e57612a1a7461cfd3d2224e70f3fb5f259a907cea89f0c91a570d98ebb7a48fb799c4538e0b056c44c4d6644b4bf990b71b728549e7a01487277c7cac6669fc17b8624ee6b73b6a6bbeefc1adfacb87783f4c207d0c2810cc288d4db2d57ecebe5270f9fa55516ab0bc9934d3f751c08cbc60747822d1ebd80cde8fc657a54d422300e7d1ac320193acd24590ac68e22e4e04714f0dde120ac8d3183a1b946178fd0ff654e5f2b6cb06ba3d5ba5606ba71ddd7359d2e22d0ccf32dadc166e1639981acc03216550d90d1297973c28624a887d2aa1ed0e5226eab9ff6acac97b63acff7e6fecb4c277edc05eda20e5df8ba9051eaaaf5f872b57c9ea1cc9363492750e14801bc310f60f35fbfaeea01ce0efcd9a6fe5d3c034d13fe0f5cd8379bd22e0a3d29051db498e92db6e8ef8fd04ffa675a5f9874593a0af419e54f343f24e41ca236472c2ec2d0e006079869d2a213592c75f4743afea1c3465d62e523f403c1ca8bed7e6499fbcacce28c5c8c5e8a6ff895f23479299b41efc9ffcbca8bae2a5a1b1dd6682d3d2f3f0db6a61686bafdea4ca856f0bcc478f71c9ea9f93d564b22fc726fc16d6716b07f35985fbe1c9321039b231d9dc697341b643f6b4f1274b603df74e7eac00e03296baa0e30daa90d11908ae920feb41ac84b0447b22685168fb1a82d34a8058f8a507e76c65076e373fd04471072fb76487d3c4a5a784f8470fe349e69d4a92d892554b6b8887622490a80df32340434626a3abeeba16d637dc6a1117674579950610cbd4a2c0621acf6e5a4bf646569ba29e1ab1f6a589d1450e100a665a51c95c90ab920692a3045a9861e132897a7bb768ff14da8b062eca14e48916a6712e8c9c69cf69a429b5958c37cf3a960f6d8a031fc1161a123ceed02d50f09b9233d90be6022258b541d12c9724bb1f6d38cbc970fbd9dd77765e8d931e0a1f376b75231348b9dc7d3402c060fac3b1c99e769da451fba2bbeb86e61a990705d85d99db7932478e3659637f51a7403a4d530e052e5a8ba43a1aa4817652d03b3051bae6bb50f5f0ade64646590b399e4fd11e941849746e3c9ad8e9e86b1be0470cf287e00d86dbf89b51200826132e625e7744433b4b1a11712c7d5e76b2fef84370df77b358b09d04dd258d71d4977598e87b4cfb3ea948d0ffd3ce9f2f7d3784f13f98775bd38322b20d9dac7e7bc2fe343e8a1a7a6ca82753121f6abc4e883e73cbc49c0b1f44037a5e15c8708306978cde82381b272cc183e7b9669ee226bfb78f6a575f9e0804e6613943eea389288302e3747eec2ec41d72451e9cd918acde73ad006dc11ce1b0c38833c96285b3ea2cddb836103b6dbb0b84d734ac558f4652de7a34bf700f5f6786b7c869135b9cfa681841a18f06eb4b32072d97aacef31bfda8a6f6f889fcc0174a6e8de564f2b36b94fd2d6645e7a39c9667fa12c8ccd1db53a13202b6b0ee677fcc0b60faf2f3cc7f8d535917601335b35afac811251ba518c093f2e4b353ca272428dd90f02236643df2f3e66229911191fe5109461275077f970aff7d9f179e507193376a339ea67ef9d5701a1811d5c59d96c13cc49f1db2c490fb026535494e9396cc02ff2fdf7e66b1d1b9818b220447627b17c809ebba71ddf6cf9f8c2bd706af6e628c56cebc0a2285203e201840aa4cd18ee36b7d3850400d35d5bb93fe8cce63351fb0a47b2bb224fa667e4cbf3ba4cf7402636fb4452c9b5d1f57546808e6fd7ebb1cfafdfbd6c7812e3ce964d46068a45cae41a7e652a46790883dba0e8e0608bc4e3d077ed0396fc62bcb92539222c9ddc0ed8ddfa1e5fad5d47e1fb1f8a2950b9414615d2f72f0c3b0ac4657019ee7d2db0f6d4341c5cf1b6c2dc8022bd45d9e17c218c49fa9ae44d985813d48e6c137e187c67b69dccd7722b911aa1994791e3fb0cb70761383211f2c6d095d51397726a348e2171b25bba7f14e6567697c3421502846c43666d55bdc53986f35d18d6efa3fd0a2235c0734f3ca40846b8ab6f50b3c8827f5020e0dcd9957d13d936bba41f051fdab1d5f0659f850bcae9b43078ebfbd6aca3ca3d6b45f77dd6fd1cd73fdc7d33a7e2b5f2aaf811074bf5e703c47636b3fbc916d425d0e6626aa3eab184c2894406321b94e101fb528c14e384ddf0f380616564f9c9fc022a91ff5cf4c4032adcc0b0615776560fd71e54763907a11a62ee3afd34a8581676072898268199353284250065731ac4886a2dd3d1e54697ac0186dca833caec396024b87030a4543f233cf0580818d58fd3ee24bbbffe5849857900de2347610e67350626c4377c598829ea16c16b39c76cf6b60c29989cd3899b8a638b173563b1c04c1dd9df6ee8ba421f4271d1cd24cb8030c6e7115f04ccd7436606e7cc15c5499ce45bf13c80fac8c5322cd4cab6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="经验" scheme="https://protonlml.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="经验" scheme="https://protonlml.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://protonlml.github.io/2019/10/10/Maven/"/>
    <id>https://protonlml.github.io/2019/10/10/Maven/</id>
    <published>2019-10-10T03:00:00.000Z</published>
    <updated>2024-06-16T02:15:54.402Z</updated>
    
    <content type="html"><![CDATA[<h1><center>Maven</center></h1><h2 id="一、Maven的一些理解"><a href="#一、Maven的一些理解" class="headerlink" title="一、Maven的一些理解"></a>一、Maven的一些理解</h2><ul><li>1.项目的构建，是指项目的“打包”，“编译”，“部署”，“运行”等一系列操作。 </li><li>2.用Maven就可以使我们的项目，能够自动化构建。 </li><li>3.maven是java项目的自动化构建工具。   </li><li>4.Maven可以，将一个大型的项目的不同功能，拆分成多个模块，分别进行开发管理。 </li><li>5.Maven可以，通过配置poom文件，来导入某个技术的jar包，同时会自动的导入这个jar包的相关依赖jar包。</li></ul><h2 id="二、Maven程序的执行原理"><a href="#二、Maven程序的执行原理" class="headerlink" title="二、Maven程序的执行原理"></a>二、Maven程序的执行原理</h2><ol><li><p>maven核心程序指的是，解压后的maven程序目录。也是maven软件的目录里面的内容。</p></li><li><p>Maven在自动构建项目的时候，使用插件会在本地仓库中找，使用依赖jar包也在本地仓库中找。本地找不到就到中央仓库中下载。 </p></li><li><p>怎么使用maven？（不用开发工具）</p><ol><li>创建一个maven规定的项目目录结构，在有poom.xml文件的目录下面，执行maven命令</li><li>当我们执行的Maven命令需要用到某些插件的时候，Maven核心程序会首先到本地仓库中查找</li><li>本地仓库的默认位置：[系统当前用户的家目录].m2\repository(Maven找插件的时候，自动创建)</li><li>Maven核心程序如果在本地仓库中找不到需要的插件的时候，那么它会自动联网，到中央仓库中下载。</li></ol></li><li><p>Maven的生命周期就是指的是“项目的构建过程”，项目的构建是有顺序的，执行的任何一个Maven命令都是从生命周期的头开始。</p></li><li><p>Maven构建项目完成之后，生成的“产品”就放在“项目src所在目录”中的“target”目录中。</p></li><li><p>Pom</p><ol><li>【1】含义：project Object Model 项目对象模型。</li><li>pom.xml对于Maven工程师核心配置文件，与构建过程相关的一切设置都在这个文件中进行</li></ol></li><li><p>Maven坐标类比一下：</p><ol><li><p>数学中可以用（x,yz）三个项量来确定一个空间的点。</p></li><li><p>Maven的pom文件中，也是使用三个项量，来在仓库中唯一定位一个Maven工程</p><ul><li>[1]：<strong>g</strong>roupid：公司或组织域名倒序+项目名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;cn.itcast&lt;/groupId&gt;</span><br></pre></td></tr></table></figure><ul><li>[2]：<strong>a</strong>rtifactid：模块名 </li><li>[3]：<strong>v</strong>ersion：版本<ul><li>只要讲“<strong>gav</strong>”就讲的是Maven的坐标。</li></ul></li><li>[4] :Maven工程的坐标与仓库中的路径对应关系。<ul><li>在Maven仓库里面。每一个Maven工程，他的坐标一定是不重复的，即标识了这个Maven工程信息，同时也决定了他在仓库中存放的目录是什么。</li></ul></li></ul></li></ol></li><li><p>仓库中保存的内容：宽泛的说就是（Maven工程项目）  </p><ul><li>主要有3大块：<ul><li>-[1]：Maven核心软件，自身所需要的一些插件</li><li>[2]：第三方框架或工具的jar包(其实就是第三方项目，打成了jar包)</li><li>[3]：我们自己开发的工程。Maven将“插件”、“框架jar包”、“我们自己的项目”都用统一的目录结构，放在了仓库中，这样就方便Maven核心程序的管理和使用。</li></ul></li></ul></li><li><p>pom.xml文件解析。</p><ul><li>创建的Maven项目中有pom.xml文件，他是Maven项目的核心配置文件。<ul><li>【1】.除了上面三个坐标用来，定位当前项目用Maven核心程序安装在仓库中的位置。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011049.png" alt="Image"></li><li>2】.中间部分是“依赖部分”，就是指当前项目，所使用的到的“其他模块项目和jar包”，在Maven仓库中的坐标。如果仓库中没有指定的依赖jar包，就会自动从私服上面下载，私服上面没有就会到中央仓库中下载。<ul><li>但是如果当前项目，用到我们自己写的模块，这时候就需要将，要使用的模块项目给“安装”到仓库中，用“ mvn install”命令进行安装。是不可能从网上下载的，因为这是我们自己写的，不是第三方jar包项目。这样我们就可以将一个大的项目，进行拆分成很多小的模块，然后各个模块之间用“依赖坐标”，来互相关联。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011083.png" alt="Image"></li></ul></li><li>【3】最下面是“插件”部分。<ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011313.png" alt="Image"></li></ul></li></ul></li></ul></li><li><p>依赖</p><ol><li>①Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。<ul><li>对于我们自己开发的Maven工程，使用mvn install命令安装后就可以进入仓库。</li></ul></li><li>②依赖的范围<ul><li>【1】在pom.xml文件中<scope>依赖的范围</scope></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012747.png" alt="Image"></li><li>依赖的范围一般常用的有三个：compile，test、provided三个。</li><li>依赖范围：意思就是，当前项目所依赖的这个“依赖”，在编译，测试，打包。过程当中时候有效。<ul><li>[1]compile范围的“依赖”（编译范围）</li><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：参与</li><li>是否 参与部署：参与</li><li>[2]test范围的“依赖”（测试范围）</li><li>对主程序是否有效：无效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li><li>典型例子：“junit依赖”它就是测试依赖，这个jar包，不参与打包，在主程序中没有。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012081.png" alt="Image"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012133.png" alt="Image"></li><li>[3]provided范围的“依赖”，通常是为web工程来添加的（不参与部署的范围）。<ul><li>说明只要加了provided范围的“依赖”，web容器中都有。比如：servlet的这个依赖，部署的时候就不需要，因为Tomcat服务器本身就有servlet的jar包。</li></ul></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012653.png" alt="Image"></li><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li><li>典型例子：servlet-api.jar</li></ul></li></ul></li></ol></li><li><p>maven命令是什么？</p><ul><li>maven这个程序，用来构建项目所使用的命令。（这些命令的顺序，就是生命周期的顺序）</li><li>比如【1】清理：mvn clean</li><li>【2】：编译主程序：mvn compile</li><li>【3】：编译测试程序：mvn test-compile</li><li>【4】：执行测试：mvn test</li><li>【5】：打包：mvn package</li><li>【6】：安装：mvn install</li><li>【7】：生成站点：mvn site这些命令，构成了Maven构建项目时的，不同生命周期，</li></ul></li><li><p>12.Maven的生命周期</p><ul><li>【1】意思：就是Maven构建项目的的，各个构建环节执行的顺序。：不能打乱顺序，必须按照既定的正确顺序来执行，是生命周期的各个阶段的命令来实现的。</li><li>【2】生命周期是在Maven的核心程序中定义了，抽象的生命周期。 生命周期中各个阶段的具体任务是由插件来完成的。</li><li>【3】有三套独立的生命周期：<ul><li>①Clean Lifecycle（清理生命周期）在进行，在真正的构建一个项目之前，必须先进行一些清理工作。</li><li>②Default lifecycle（默认的生命周期）构建的核心部分，编译，测试，打包，安装，部署等等。</li><li>③Site Lifecycle（生成站点生命周期）生成项目报告，站点，发布站点。</li></ul></li><li>【4】每个生命周期的具体实现<ul><li>比如：只执行“mvn clean 清理命令”就会进行清理生命周期。</li><li>执行“mvn install 安装命令”就会进行Maven构建项目的默认生命周期，此时Maven核心程序，会从头开始执行“clean清理”,“compile 编译”，“test-compile 编译测试”，“test 执行测试”，“package 打包”，“install 安装”这一系列的过程。</li><li>执行“site 生成站点”，也会从头开始，将所有过程进行一边。这是生成站点生命周期</li><li>Maven核心程序为了更好的实现自动化构建，按照这一的特点执行生命周期中的各个阶段：不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行。</li></ul></li><li>【5】生命周期的各个阶段仅仅定义了要执行的任务是什么（命令）完成这个命令，是由特定的Maven插件来完成的。<ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012162.png" alt="Image"></li></ul></li></ul></li><li><p>创建Maven工程之前，需要将IDEA编辑器，和本地下载的Maven程序，进行关联配置。具体操作，见文末。</p></li></ol><hr><hr><h2 id="三、使用IDEA创建普通的javaMaven工程"><a href="#三、使用IDEA创建普通的javaMaven工程" class="headerlink" title="三、使用IDEA创建普通的javaMaven工程"></a>三、使用IDEA创建普通的javaMaven工程</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012762.png" alt="Image"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012115.png" alt="Image"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161012201.png" alt="Image"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013282.png" alt="Image"></p><h2 id="四、-使用IDEA创建webMaven工程（Maven要聚合模块的做法）"><a href="#四、-使用IDEA创建webMaven工程（Maven要聚合模块的做法）" class="headerlink" title="四、.使用IDEA创建webMaven工程（Maven要聚合模块的做法）"></a>四、.使用IDEA创建webMaven工程（Maven要聚合模块的做法）</h2><ul><li><p>【1】必须先创建一个空的工程。在空的工程中添加模块。（每次添加模块都要使用快捷键“ctrl+alt+shift+s”来调出<strong>Project Structure窗口，在这个窗口中添加模块，不能直接在模块上面右键添加模块。（在模块上右键模块会添加到“模块里面”）</strong>）</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013762.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013442.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013622.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013162.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161013194.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014349.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014424.png" alt="Image"></p></li><li><h3 id="【标准的Maven工程，分模块的大型web项目，目录结构】"><a href="#【标准的Maven工程，分模块的大型web项目，目录结构】" class="headerlink" title="【标准的Maven工程，分模块的大型web项目，目录结构】"></a>【标准的Maven工程，分模块的大型web项目，目录结构】</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014593.png" alt="Image"></p></li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><h5 id="我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。"><a href="#我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。" class="headerlink" title="我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。"></a>我们在用Maven程序，在开发web项目的时候，可以将一个大型的web项目拆分成多个“模块项目”，然后如果模块之间要相互使用的话，就要在pom文件中，添加一个指定“模块依赖坐标”就可以使用了，但是此时模块项目并没有安装到“仓库当中”，开发过程相互调用没有问题。但是如果部署运行的话就要在Maven仓库中安装。不过这个安装步骤不用我们做了，在我们开发完程序后，进行部署运行的时候，Maven程序会自动将所需要的“模块依赖”安装到仓库中。</h5></li></ul><h2 id="五、依赖"><a href="#五、依赖" class="headerlink" title="五、依赖"></a>五、依赖</h2><ul><li><h3 id="依赖的传递性："><a href="#依赖的传递性：" class="headerlink" title="依赖的传递性："></a>依赖的传递性：</h3><ul><li>【1】依赖的传递性是指，如果在一个大型的项目当中，各个模块相互依赖，那么在“最下面的模块（依赖关系最下面，这个模块只是被依赖，不去依赖别的模块）”中，pom.xml文件里面，配置的<strong>compile</strong>”范围的依赖jar包，其他模块的pom.xml文件虽然没有声明一样的<strong>compile</strong>”范围的依赖jar包，但是也可以使用这个依赖。</li><li>【2】前提是“<strong>compile</strong>”范围的依赖才能传递，“<strong>test</strong>”“<strong>provided</strong>”范围的依赖不能传递。所以在各个工程模块中，能够传递的依赖，只在“最下面”模块中声明一次就可以了，不能够传递的“<strong>test</strong>”“<strong>provided</strong>”范围的依赖就得各个模块中重复声明依赖。比如：servlet的依赖，他就是“provided范围的模块”，需要在每一个项目模块pom.xml文件中，都要重复声明。</li><li>【3】我们在开发项目的时候，会有一个专门的模块来负责维护这些框架jar包的依赖信息的。在这个模块中，全部都写“<strong>compile</strong>”范围的依赖”，让其他功能模块，来依赖这个“专门模块”，就可以实现“<strong>compile</strong>”范围的依赖”通用。</li><li>【4】子类继承了父类模块，也可以实现依赖传递，默认就是依赖的，不需要再在子类中，重新声明依赖父类，只在子类中声明父类就可以了。</li></ul></li><li><h3 id="依赖的排除："><a href="#依赖的排除：" class="headerlink" title="依赖的排除："></a>依赖的排除：</h3><ul><li>依赖的排除，在哪个工程里面排除的，就在哪个工程里面生效。</li><li>【1】当我们导入某些依赖jar包的时候，Maven会自动将这个jar的其他依赖jar包也一起导入到工程当中，这个时候，如果不需要这个额外的jar包，就可以用“排除依赖”来进行排除。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014762.png" alt="Image"></li><li>【2】找到要排除的依赖的ID（假如spring-jcl依赖要被排除）</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014723.png" alt="Image"></li><li>3】添加<exclusions> </exclusions>标签</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161014062.png" alt="Image"></li></ul></li><li><h3 id="依赖原则："><a href="#依赖原则：" class="headerlink" title="依赖原则："></a>依赖原则：</h3><ul><li><h4 id="解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决）"><a href="#解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决）" class="headerlink" title="解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决）"></a>解决的是依赖“jar包”冲突的问题。（Maven中内置的一个原则，我们也改变不了，发生jar包冲突的时候，Maven会自动的将冲突解决）</h4></li><li><p>前提是因为“依赖的传递性”导致的jar包冲突问题。</p></li><li><p>冲突情景：</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015782.png" alt="Image"></p></li><li><p><img src="https://gitee.com/lmlpla/blogimages/raw/master/imgs/202401281057892.png" alt="Image"></p></li><li><p><strong>properties标签</strong>配合自定义标签声明数据的配置并。(可以利用这个标签，实现在一个页面上，同种类型的框架jar包，版本号相同，)在父模块中就更简便了</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015754.png" alt="Image"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015765.png" alt="Image"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span> <span class="comment">&lt;!--不是只能用于声明依赖的版本号。凡是需要统一声明后再引用的场合都可以使用。--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring-core依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring-core依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="六、Mavne继承（pom文件的继承）"><a href="#六、Mavne继承（pom文件的继承）" class="headerlink" title="六、Mavne继承（pom文件的继承）"></a>六、Mavne继承（pom文件的继承）</h2><ul><li><p>存在的问题：我们都知道在一个“模块项目1”中配置了“<strong>compile</strong>”范围的依赖jar包”，“其他模块项目”来依赖这个“模块项目1”的时候，“其他模块项目”中会自动的存在了“项目模块1的”“<strong>compile</strong>”范围的依赖jar包”。这是依赖的传递性。只用在“模块项目1”中声明一份就可以了。</p></li><li><p>但是：如果是““<strong>test</strong>”“<strong>provided</strong>”范围的依赖是不能传递的”，需要在每一个模块中都要，重复的手动添加““<strong>test</strong>”“<strong>provided</strong>”范围的依赖”，比如“junit依赖”，他就是“test范围的依赖”。（不能够传递的依赖，他就是零散的分散在各个模块当中，就很容易造成各个模块工程之间的版本不一致）。</p></li><li><p>这就存在一个问题，开发一个大型项目的时候，各个模块是不同开发组来开发的，使用“junit这种依赖”的时候，可能版本号就会不相同，导致各个模块之间不统一。</p></li><li><p>解决办法：使用Maven的继承，统一成同一个版本。（以junit依赖为例）</p></li><li><p>【1】专门创建一个模块是所有模块的“父模块”，可以用作““<strong>compile</strong>”范围的依赖jar包”传递依赖。也可以用作““<strong>test</strong>”“<strong>provided</strong>”范围的依赖”的版本管理。</p></li><li><p>【2】解决思路：将junit依赖统一提取到“父”工程中，在子工程中声明junit依赖时不指定版本，以父工程中统一设定的为准。同时也便于修改。</p></li><li><p>【3】操作步骤  [1]创建一个Maven工程作为父工程。注意：打包的方式pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atlml.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015851.png" alt="Image"></p></li><li><p>[2]在子工程中声明对父工程的引用（认干爹的一个仪式）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子工程中声明父工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atlml.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--以当前pom文件为基准的,找父工程pom.xml文件的相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>[3]在父工程中统一管理junit的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖管理，这里专门用来管理，不能够传递的依赖，进行版本号控制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- junit是“test”范围的依赖，不能够传递，在这里面统一管理版本号--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>[4]在子工程中删除junit依赖的版本号部分 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;version&gt;4.11&lt;/version&gt;--&gt;</span> 删除掉</span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>[5]实现效果</p><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015552.png" alt="Image"></li></ul></li><li><p>[6]：父模块的Pom.xml文件的配置。</p><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161015722.png" alt="Image"></li></ul></li></ul><h2 id="七、Maven的聚合："><a href="#七、Maven的聚合：" class="headerlink" title="七、Maven的聚合："></a>七、Maven的聚合：</h2><ul><li><p>（聚合就是Maven中，各个模块的一键安装。）</p></li><li><p>注意：配置了继承的模块，在执行安装命令（ install）的时候，要先安装 “父模块”再安装其他模块才能成功。</p></li><li><p>Maven中的一件安装，就可以自动的按顺序，将每个模块都按依赖顺序进行安装。</p></li><li><p>实现一件安装步骤：</p><ul><li><p>【1】创建一个“总的聚合工程”，（一般把“父模块”作为“总的聚合工程”，大的情况下也是将，聚合的配置，也配在父模块内）</p></li><li><p>【2】在一个”总的聚合工程”的pom.xml文件中，配置各个參与聚合的模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置聚合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--指定各个子工程的相对路径--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hellow<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">module</span>&gt;</span>../HellowFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="八、Maven仓库地址"><a href="#八、Maven仓库地址" class="headerlink" title="八、Maven仓库地址"></a>八、Maven仓库地址</h2><ul><li><a href="https://mvnrepository.com/">Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com)</a></li><li><a href="https://developer.aliyun.com/mvn/search">仓库服务 (aliyun.com)</a></li></ul><h2 id="九、IDEA中Maven配置"><a href="#九、IDEA中Maven配置" class="headerlink" title="九、IDEA中Maven配置"></a>九、IDEA中Maven配置</h2><p><a href="https://www.jb51.net/article/259780.htm">IDEA配置Maven的超详细步骤_java_脚本之家 (jb51.net)</a></p><p><a href="https://blog.csdn.net/qq_42057154/article/details/106114515">IDEA配置Maven（详细版）_idea maven-CSDN博客</a></p><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;Maven&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、Maven的一些理解&quot;&gt;&lt;a href=&quot;#一、Maven的一些理解&quot; class=&quot;headerlink&quot; title=&quot;一、Maven的一些理解&quot;&gt;&lt;/a&gt;一、Maven的一些理解&lt;/h2&gt;</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    <category term="maven" scheme="https://protonlml.github.io/categories/java/maven/"/>
    
    
    <category term="maven" scheme="https://protonlml.github.io/tags/maven/"/>
    
    <category term="项目自动化构建工具" scheme="https://protonlml.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>javaScript</title>
    <link href="https://protonlml.github.io/2019/10/01/javascript/"/>
    <id>https://protonlml.github.io/2019/10/01/javascript/</id>
    <published>2019-10-01T04:00:00.000Z</published>
    <updated>2024-06-16T02:11:23.105Z</updated>
    
    <content type="html"><![CDATA[<h1><center>javaScript</center></h1><blockquote><p>静态网页资源的三剑客：HTML（文本），CSS（样式），JavaScript（行为）。把后面两个效果，加在HTML文本上，就会呈现出很好看的网页界面。</p><ol><li>程序设计有两种架构：1 c&#x2F;s架构，是客户端和服务器端，要开发两个程序。2 b&#x2F;s架构，是浏览器和服务端。只用浏览器来申请服务器端的资源，再展示出来就好了。只用开发服务器端一个软件。</li><li>javaWeb开发，是B&#x2F;S架构的。</li><li>事件：事件是什么意思？通俗的理解，HTML中的元素组件，被某个动作（事件的属性），触动后，会发生一定的变化。（执行了另一个js代码）。</li><li>将HTML，CSS，JavaScript分别独立出来，可以降低耦合度，</li></ol><p>javaScript最初被设计用于浏览器中，他和java语言没有关系，他是客户端脚本语言</p><p>javaScript语言运行出错，要在浏览器控制台上面查看。F12打开控制台。</p></blockquote><p>- </p><h2 id="一、javaScript"><a href="#一、javaScript" class="headerlink" title="一、javaScript"></a>一、javaScript</h2><ul><li>注意：在一个html的页面中，可以定义多个script的标签，而且存放的位置是任意的，但是会影响运行的先后顺序，一般都是等html页面元素全部加载完毕，再运行js代码，并且是一种等待状态。当在html中的某个位置，触发了某个事件，此时对应的js等待代码，就会执行。从而产生行为效果</li></ul><h3 id="1-javascript与HTML的关联方式："><a href="#1-javascript与HTML的关联方式：" class="headerlink" title="1.javascript与HTML的关联方式："></a>1.javascript与HTML的关联方式：</h3><ul><li><p>内部关联</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160949148.png" alt="image-20240130214055735"></p></li><li><p>外部关联</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951711.png" alt="image-20240130214133935"></p></li></ul><h3 id="2-javascript的数据类型"><a href="#2-javascript的数据类型" class="headerlink" title="2.javascript的数据类型"></a>2.javascript的数据类型</h3><ul><li><blockquote><p>原始数据类型：</p><pre><code>     1. number：数字 。 整数/小数/ NAN （not  a number 一个不是数字的数字类型）        2. string ：字符串。字符串 &quot;abc&quot; &quot;a&quot; &#39;abc&#39;        3. boolean：true 和 false        4. null：一个对象为空的占位符        5. undefined：未定义，如果一个变量没有给他初始化值，则会被默认赋值为undefined</code></pre><p>注意：NaN是number类型，他是（不是数字的数字）。在js当中，运算符，后面的运算数，不是运算符要求的类型，js就会自动的将运算数进行类型转换。比如：numb&#x3D; +”abc”;此时：number根据”+”运算符，如果是数字，就会直接转换成数字，但是转换符后面跟的不是数字类型，则会转换成不是数字的数字类型。值为NaN.</p></blockquote></li></ul><h3 id="3-JavaScript的变量"><a href="#3-JavaScript的变量" class="headerlink" title="3.JavaScript的变量"></a>3.JavaScript的变量</h3><ul><li><p>什么是变量：变量就是内存空间中的一小片区域。有类型，有名称，有值。比如：int a&#x3D;3;</p></li><li><p>JavaScript的变量是弱类型的，什么叫弱类型，就是不管定义什么类型的变量，都用var开头。</p></li><li><p>而java中定义整型用int，定义字符型用char 。所以java是强类型的。</p></li><li><p>☆ 通过typeof(变量名)可以得到变量的类型</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951978.png" alt="image-20240130215045915"></p></li><li><p>注释:你也许会问,为什么typeof运算符对于nul值会返回”object”.这实际上是javaScript最初实现中的个错误,然后被<br>ECMAScript沿用了,现在,null被认为是 对象的占位符,从而解释了这一矛盾,但从技求上来说,它仍是原始值。</p></li></ul><h3 id="4-javascript中的运算符"><a href="#4-javascript中的运算符" class="headerlink" title="4.javascript中的运算符"></a>4.javascript中的运算符</h3><ul><li><h4 id="①一元运算符：就是只有一个运运算数的运算符。"><a href="#①一元运算符：就是只有一个运运算数的运算符。" class="headerlink" title="①一元运算符：就是只有一个运运算数的运算符。"></a>①一元运算符：就是只有一个运运算数的运算符。</h4><ul><li>++ 、–、+（正号）、-（负号）</li><li>“++（–）”在前，先自增（自减），再运算。</li><li>“++（–）”在后，先运算，再自增（自减）。</li><li>+（-）（正负号）</li></ul></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160950599.png" alt="Image"></p></li><li><h4 id="②算数运算符：“-”，“-”，“-”，“-”-，“-”（和java中使用方法相同）"><a href="#②算数运算符：“-”，“-”，“-”，“-”-，“-”（和java中使用方法相同）" class="headerlink" title="②算数运算符：“+”，“-”，“* ”，“&#x2F;” ，“%”（和java中使用方法相同）"></a>②算数运算符：“+”，“-”，“* ”，“&#x2F;” ，“%”（和java中使用方法相同）</h4></li><li><h4 id="③赋值运算符：“-”，“-”“-”（和java中使用方法相同）"><a href="#③赋值运算符：“-”，“-”“-”（和java中使用方法相同）" class="headerlink" title="③赋值运算符：“+&#x3D;”，“-&#x3D;”“&#x3D;”（和java中使用方法相同）"></a>③赋值运算符：“+&#x3D;”，“-&#x3D;”“&#x3D;”（和java中使用方法相同）</h4></li><li><h4 id="④-比较运算符：“-”，“-”，“"><a href="#④-比较运算符：“-”，“-”，“" class="headerlink" title="④ 比较运算符：“&gt;”，“&lt;”，“&gt;&#x3D;”，“&lt;&#x3D;”，“&#x3D;&#x3D;”，   “&#x3D; &#x3D;&#x3D;（全等于）”"></a>④ 比较运算符：“&gt;”，“&lt;”，“&gt;&#x3D;”，“&lt;&#x3D;”，“&#x3D;&#x3D;”，   “&#x3D; &#x3D;&#x3D;（全等于）”</h4><ul><li>“&#x3D; &#x3D;”是比较两个数是否相等，“&#x3D;&#x3D;&#x3D;全等于”是加上了类型的比较。</li></ul></li><li><h3 id="⑤-逻辑运算符：“-”，“-”，“！”"><a href="#⑤-逻辑运算符：“-”，“-”，“！”" class="headerlink" title="⑤ 逻辑运算符：“&amp;&amp;”，“||”，“！”"></a>⑤ 逻辑运算符：“&amp;&amp;”，“||”，“！”</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951947.png" alt="Image [3]"></li></ul></li><li><h3 id="⑥-三元运算符“-？：表达式”"><a href="#⑥-三元运算符“-？：表达式”" class="headerlink" title="⑥ 三元运算符“ ？：表达式”"></a>⑥ 三元运算符“ <u>？：表达式</u>”</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951447.png" alt="Image [4]"></li></ul></li></ul><h2 id="二、javascript-中的特殊语法"><a href="#二、javascript-中的特殊语法" class="headerlink" title="二、javascript 中的特殊语法."></a>二、javascript 中的特殊语法.</h2><p>(了解一下就好，但是要和java规范一样写代码，不要省“；”，也不要省“var”，带var的变量，是局部变量，不带var的变量是全局变量 。)</p><h2 id="三、流程控制语句"><a href="#三、流程控制语句" class="headerlink" title="三、流程控制语句"></a>三、流程控制语句</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160951597.png" alt="Image [5]"></p><h2 id="练习-：javascript（9x9乘法表）"><a href="#练习-：javascript（9x9乘法表）" class="headerlink" title="练习 ：javascript（9x9乘法表）"></a>练习 ：javascript（9x9乘法表）</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160959985.png" alt="Image [6]"></p><hr><hr><h2 id="四、BOM对象："><a href="#四、BOM对象：" class="headerlink" title="四、BOM对象："></a>四、BOM对象：</h2><ul><li><h4 id="概念：Browser-object-Model-浏览器对象模型。将浏览器各个组成部分封装为对象。"><a href="#概念：Browser-object-Model-浏览器对象模型。将浏览器各个组成部分封装为对象。" class="headerlink" title="概念：Browser object Model 浏览器对象模型。将浏览器各个组成部分封装为对象。"></a>概念：Browser object Model 浏览器对象模型。将浏览器各个组成部分封装为对象。</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406160954667.png" alt="Image [13]"></p></li><li><h4 id="BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。"><a href="#BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。" class="headerlink" title="BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。"></a>BOM对象有五个：窗口对象、历史记录对象、地址栏对象、浏览器对象、显示器对象。</h4><h3 id="①-window窗口对象。"><a href="#①-window窗口对象。" class="headerlink" title="① window窗口对象。"></a>① window窗口对象。</h3><ul><li><h4 id="window窗口的第一类方法：弹窗有关的方法"><a href="#window窗口的第一类方法：弹窗有关的方法" class="headerlink" title="window窗口的第一类方法：弹窗有关的方法"></a>window窗口的第一类方法：弹窗有关的方法</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161001435.png" alt="image-20240130231750600"></p></li><li><h4 id="window窗口的第二类方法：打开关闭窗口的方法。"><a href="#window窗口的第二类方法：打开关闭窗口的方法。" class="headerlink" title="window窗口的第二类方法：打开关闭窗口的方法。"></a>window窗口的第二类方法：打开关闭窗口的方法。</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161002045.png" alt="image-20240130232026695"></p></li><li><h4 id="window窗口的第三类方法：与定时器有关的方法"><a href="#window窗口的第三类方法：与定时器有关的方法" class="headerlink" title="window窗口的第三类方法：与定时器有关的方法"></a>window窗口的第三类方法：与定时器有关的方法</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161003416.png" alt="image-20240130232218944"></p></li><li><h4 id="Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（-html文件对象）。直接写就可以用"><a href="#Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（-html文件对象）。直接写就可以用" class="headerlink" title="Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（.html文件对象）。直接写就可以用"></a>Window窗口对象属性，可以获取其他BOM对象，和一个DOM对象document（.html文件对象）。直接写就可以用</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161003635.png" alt="Image [27]"></p></li></ul></li></ul><h2 id="②、-Location地址栏对象"><a href="#②、-Location地址栏对象" class="headerlink" title="②、 Location地址栏对象"></a>②、 Location地址栏对象</h2><ul><li><p>Location 对象的方法。reload().用来刷新当前页面。 属性：href</p></li><li><p>Location地址栏对象，他的一个属性href。有两个作用，设置当前页面的URL和获取当前页面的完整的URL.（这里面的设置和获取URL都是针对当前页面的。设置的话，就是重新赋值，设置为新的地址，这样当前页面就会跳转到设置的地址页面中去）</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161003845.png" alt="Image [28]"></p></li><li><h3 id="倒计时跳转网页案例"><a href="#倒计时跳转网页案例" class="headerlink" title="倒计时跳转网页案例"></a>倒计时跳转网页案例</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161004716.png" alt="image-20240130233011287"></p></li></ul><h2 id="③、-history当前页面历史记录对象。"><a href="#③、-history当前页面历史记录对象。" class="headerlink" title="③、 history当前页面历史记录对象。"></a>③、 history当前页面历史记录对象。</h2><ul><li>属性：length：history.length；返回的是。历史记录的个数。 </li><li>方法：back();加载history列表中的上一个URL。绑定单击事件，就可以做一个后退的按钮。</li><li>方法： forword(); 加载history列表中的下一个URL。绑定单击事件，就可以做一个前进的按钮。</li><li>方法：go(); 加载history列表中的某一个具体页面。</li></ul><hr><hr><h2 id="五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML-DOM对象。）"><a href="#五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML-DOM对象。）" class="headerlink" title="五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML DOM对象。）"></a>五、DOM对象（只要是标记语言都有DOM对象，我们这里说的是HTML DOM对象。）</h2><ul><li><h4 id="☆-DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。"><a href="#☆-DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。" class="headerlink" title="☆ DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。"></a>☆ DOM对象，其实就是把html文档里面的各个标签，都看做是一个对象。</h4></li><li><h4 id="☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。"><a href="#☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。" class="headerlink" title="☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。"></a>☆操作DOM对象，就相当于，在内存层面，来写HTML的代码。没有实体的标签，每个标签，都定义成了对象，每个标签都是一个节点对象。</h4></li><li><h4 id="DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析）"><a href="#DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析）" class="headerlink" title="DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析）"></a>DOM方式：就是将标记语言，把文本全部给加载到内存里面去，形成一个DOM树。（标记语言文本的解析）</h4></li><li><h4 id="DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。"><a href="#DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。" class="headerlink" title="DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。"></a>DOM对象：通俗理解就是将HTML或者XML标记语言，各个部分封装为一个一个的对象。（一对标签可以看做一个对象，也叫节点，因为在树上）。在内存中对应着DOM树形结构。</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161004804.png" alt="Image [7]"></p></li><li><h3 id="①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element-其他标签对象-对象。或者是创建Element-其他标签对象-对象。"><a href="#①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element-其他标签对象-对象。或者是创建Element-其他标签对象-对象。" class="headerlink" title="①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element(其他标签对象)对象。或者是创建Element (其他标签对象)对象。"></a>①：document对象、最大的DOM对象。（html文档对象），其他的标签对象，都在他的内部，所以是通过document来，获取Element(其他标签对象)对象。或者是创建Element (其他标签对象)对象。</h3><ul><li><h5 id="document-write-““-向页面上写出一条横线（就是往页面写出信息的）"><a href="#document-write-““-向页面上写出一条横线（就是往页面写出信息的）" class="headerlink" title="document.write(““)   向页面上写出一条横线（就是往页面写出信息的）"></a>document.write(“<hr>“)   向页面上写出一条横线（就是往页面写出信息的）</h5></li><li><h4 id="1-1-document对象：获取element对象的方法。"><a href="#1-1-document对象：获取element对象的方法。" class="headerlink" title="1.1 document对象：获取element对象的方法。"></a>1.1 document对象：获取element对象的方法。</h4></li><li><blockquote><ol><li>getElementById（） ：根据id属性值获取元素对象。id属性值一般唯一</li><li>getElementsByTagName （） ：根据元素名称获取元素对象们。返回值是一个数组</li><li>getElementsByClassName （）：根据Class属性值获取元素对象们。返回值是一个数组</li><li>getElementsByName（）：根据name属性值获取元素对象们。返回值是一个数组</li></ol></blockquote></li><li><h4 id="1-2-document对象：创建其他DOM对象："><a href="#1-2-document对象：创建其他DOM对象：" class="headerlink" title="1.2  document对象：创建其他DOM对象："></a>1.2  document对象：创建其他DOM对象：</h4></li><li><blockquote><ol><li>createElement（“标签名”）：创建元素节点（记住）</li><li>createAttribute（name）：创建拥有指定名称的属性节点，并返回新的Attr对象。（了解）</li><li>createComment（）：创建注释节点。（了解）</li><li>createTextNode（）：创建文本节点。（了解）</li></ol></blockquote></li></ul></li><li><h3 id="②：Element对象（元素标签对象）"><a href="#②：Element对象（元素标签对象）" class="headerlink" title="②：Element对象（元素标签对象）"></a>②：Element对象（元素标签对象）</h3><ul><li>1，获取&#x2F;创建：通过document来获取和创建</li><li>2.方法：<ul><li>removeAttribute（“”） ：删除属性</li><li>setAttribute（“属性名”，“属性值”） ：设置属性值。</li></ul></li><li>补充：input框框，有个value属性，用其节点对象.value可以得到，文本框里面的内容。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161004004.png" alt="Image [8]"></li></ul></li><li><h3 id="③：Node对象-（是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。"><a href="#③：Node对象-（是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。" class="headerlink" title="③：Node对象 （是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。"></a>③：Node对象 （是所有DOM对象的父亲），它里面定义了，对节点的，增删改的方法。所以所有的DOM对象，都有这三类方法。这样所有的当前节点，都可以添加它的子节点，也都可以删除它的子节点，也可以获取它的父节点。</h3></li><li><p>appendchild（节点对象名） ：向节点的子节点列表的结尾添加新的子节点。（增）</p></li><li><p>removechild（节点对象名） ：删除（并返回）当前节点的指定子节点。（删）</p></li><li><p>replacechild（节点对象名） ：用新节点替换一个子节点。（改，不常用）。</p></li><li><p>属性：父节点&#x3D;当前节点.parentNode; 返回当前节点的父节点。</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161004614.png" alt="Image [9]"></p></li></ul><h2 id="六、☆javascript-中的几个对象的学习。"><a href="#六、☆javascript-中的几个对象的学习。" class="headerlink" title="六、☆javascript 中的几个对象的学习。"></a>六、☆javascript 中的几个对象的学习。</h2><ul><li><h3 id="1-☆-function函数方法对象、Array数组对象。"><a href="#1-☆-function函数方法对象、Array数组对象。" class="headerlink" title="1.☆ function函数方法对象、Array数组对象。"></a>1.☆ function函数方法对象、Array数组对象。</h3></li><li><p>function对象，在javascript 中，定义方法，是用function对象，来定义方法的。</p><blockquote><ul><li>语法：function 方法名（参数列表）{方法体}</li><li>&#x2F;&#x2F; javascript中定义方法，的写法和java类似。 但是是用的function对象定义的方法</li><li>&#x2F;&#x2F; js中用function定义的方法，参数列表不用写类型，返回值不用写类型</li><li>&#x2F;&#x2F; js中用function定义的方法，如果有多个同名的方法，那么后面的同名方法，会覆盖前面的同名方法，</li><li>&#x2F;&#x2F; js中用function定义的方法，在调用方法时，只要方法名确定就会调用最后面的同名不同参数的方法。他和参数列表无关。</li><li>&#x2F;* js中用function定义的方法，参数列表的括号里面隐藏了一个内置对象，是一个arguments的数组。 所以当参数列表中不写形式参数时，function add(){ 方法体} 括号里面就是一个可变形参 每一个传递过来的实参，都存在arguments[0].arguments[1]……..等数组中。 *&#x2F;</li></ul></blockquote></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005585.png" alt="Image [31]"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005624.png" alt="Image [32]"></p></li><li><h3 id="2-☆-Array数组对象"><a href="#2-☆-Array数组对象" class="headerlink" title="2.☆ Array数组对象"></a>2.☆ Array数组对象</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005814.png" alt="image-20240130233856091"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005815.png" alt="image-20240130233912957"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005824.png" alt="image-20240130233952371"></li><li><img src="https://gitee.com/lmlpla/blogimages/raw/master/imgs/202401302340524.png" alt="image-20240130234025914"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161005034.png" alt="image-20240130234102744"></li></ul></li><li><h3 id="3-☆-Date日期对象"><a href="#3-☆-Date日期对象" class="headerlink" title="3.☆ Date日期对象"></a>3.☆ Date日期对象</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006224.png" alt="image-20240130234717315"></li></ul></li><li><h3 id="4-☆Math数学对象"><a href="#4-☆Math数学对象" class="headerlink" title="4.☆Math数学对象"></a>4.☆Math数学对象</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006954.png" alt="image-20240130234909211"></li></ul></li><li><h3 id="5-☆-regExp：正则表达式对象。"><a href="#5-☆-regExp：正则表达式对象。" class="headerlink" title="5.☆ regExp：正则表达式对象。"></a>5.☆ regExp：正则表达式对象。</h3><ul><li><h5 id="先了解什么是正则表达式"><a href="#先了解什么是正则表达式" class="headerlink" title="先了解什么是正则表达式"></a>先了解什么是正则表达式</h5></li><li><p>正则表达式就是定义字符串的组成规则（通用的规则，在Java中或者其他语言中都可以使用）。在表单的输入框的地方，实现校验输入的字符串是不是符合正则表达式的规则。不符合校验失败，阻止表单的提交。 </p></li><li><p>☆ Javascript对表单的校验，是依赖于正则表达式的。</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006465.png" alt="image-20240130235118937"></p></li><li><h3 id="正则表达式对象。regExp"><a href="#正则表达式对象。regExp" class="headerlink" title="正则表达式对象。regExp"></a>正则表达式对象。regExp</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006474.png" alt="image-20240130235241803"></p></li></ul></li><li><h3 id="6-☆全局对象"><a href="#6-☆全局对象" class="headerlink" title="6.☆全局对象"></a>6.☆全局对象</h3><ul><li>在javascript中，有一个全局对象Global，他不用创建对象，直接用其内部的方法，就可以实现对应的功能，一般有字符串的URL编解码方法。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161006591.png" alt="image-20240130235441038"></li></ul></li></ul><hr><hr><h2 id="七、-事件绑定的方式"><a href="#七、-事件绑定的方式" class="headerlink" title="七、 事件绑定的方式"></a>七、 事件绑定的方式</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007040.png" alt="Image [10]"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007483.png" alt="Image [11]"></p><ul><li><h3 id="得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。"><a href="#得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。" class="headerlink" title="得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。"></a>得到标签元素的对象。来换其属性值，和换其内容值。要查看参考文档找对应对象的方法。</h3></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007833.png" alt="Image [12]"></p><hr><hr><h2 id="八、HTML-DOM：是关于如何获取、修改、添加或删除HTML元素的标准"><a href="#八、HTML-DOM：是关于如何获取、修改、添加或删除HTML元素的标准" class="headerlink" title="八、HTML DOM：是关于如何获取、修改、添加或删除HTML元素的标准"></a>八、HTML DOM：是关于如何获取、修改、添加或删除HTML元素的标准</h2><ul><li><h3 id="☆①所有的节点对象都有的关键的属性innerHTML"><a href="#☆①所有的节点对象都有的关键的属性innerHTML" class="headerlink" title="☆①所有的节点对象都有的关键的属性innerHTML"></a>☆①所有的节点对象都有的关键的属性innerHTML</h3><ul><li><p>innerHTML。是获取节点对象，里面的所有内容。就是获取了，一对“&lt;&gt;标签体&lt;&#x2F;&gt;”中的标签体的内容。标签体可以是一段文字，也可以是其他标签。 </p></li><li><p>通过给innerHTML赋值或者追加值，可以改表标签体的内容。如下图</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007153.png" alt="image-20240131000856980"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007874.png" alt="image-20240131000909451"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007864.png" alt="image-20240131000922589"></p></li><li><h5 id="上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。"><a href="#上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。" class="headerlink" title="上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。"></a>上图中第3行，之后的表格，都是通过JavaScript代码（里面操作各种对象），一行一行添加的。很面向对象。写出来的代码非常的多。就会想简化写法。用innerHTML可以直接获取到上面的table的标签体，并且在后面追加样式就好了。这样简化了js代码，但不是面向对象了。</h5></li></ul></li><li><h3 id="☆②所有的节点对象都有的关键的属性style。"><a href="#☆②所有的节点对象都有的关键的属性style。" class="headerlink" title="☆②所有的节点对象都有的关键的属性style。"></a>☆②所有的节点对象都有的关键的属性style。</h3><ul><li><h4 id="1-给style属性赋值，就可以改变其样式。"><a href="#1-给style属性赋值，就可以改变其样式。" class="headerlink" title="1.给style属性赋值，就可以改变其样式。"></a>1.给style属性赋值，就可以改变其样式。</h4><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161007847.png" alt="Image [70]"></li></ul></li><li><p>注意：两个单词的写法</p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008113.png" alt="Image [71]"></p></li><li><p><img src="https://gitee.com/lmlpla/blogimages/raw/master/imgs/202401310011810.png" alt="image-20240131001138257"></p></li><li><h3 id="2-改变节点对象的class值。用className属性。"><a href="#2-改变节点对象的class值。用className属性。" class="headerlink" title="2. 改变节点对象的class值。用className属性。"></a>2. 改变节点对象的class值。用className属性。</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008443.png" alt="Image [72]"></p></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008722.png" alt="Image [73]"></p></li><li><h4 id="3-要想设置和修改，节点的属性值。查Api文档。例如：-标签图片标签，每出现一次，一个-Image-对象就会被创建。找image对象的属性，src设置或返回图像的-URL"><a href="#3-要想设置和修改，节点的属性值。查Api文档。例如：-标签图片标签，每出现一次，一个-Image-对象就会被创建。找image对象的属性，src设置或返回图像的-URL" class="headerlink" title="3.要想设置和修改，节点的属性值。查Api文档。例如： 标签图片标签，每出现一次，一个 Image 对象就会被创建。找image对象的属性，src设置或返回图像的 URL"></a>3.要想设置和修改，节点的属性值。查Api文档。例如：<img> 标签图片标签，每出现一次，一个 Image 对象就会被创建。找image对象的属性，src设置或返回图像的 URL</h4></li></ul></li></ul><hr><hr><h2 id="九、事件"><a href="#九、事件" class="headerlink" title="九、事件"></a>九、事件</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008164.png" alt="Image [74]"></p><ul><li><h3 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h3><ul><li><h4 id="1-点击事件"><a href="#1-点击事件" class="headerlink" title="1.点击事件"></a>1.点击事件</h4></li><li><blockquote><ol><li><p>onclick：单机事件</p></li><li><p>ondblclick ：双击事件</p></li></ol></blockquote></li><li><h4 id="2-焦点事件"><a href="#2-焦点事件" class="headerlink" title="2.焦点事件"></a>2.焦点事件</h4></li><li><blockquote><ol><li>onblur：失去焦点</li></ol><ul><li>一般用于表单验证,当光标不在输入框时，就会失去焦点，触发onblur事件发生。</li></ul><ol start="2"><li>onfocus：元素获得焦点</li></ol></blockquote></li><li><h4 id="3-加载事件"><a href="#3-加载事件" class="headerlink" title="3.加载事件"></a>3.加载事件</h4></li><li><blockquote><ol><li>onload：一张页面或者一幅图像完成加载</li></ol><ul><li>内部加载方式：script标签如果写在head标签里面，在上面的话，要使用窗口的事件机制，加载事件来控制，js 代码，在HTML页面加载完全，才运行。</li><li>如下图</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161008323.png" alt="Image [80]"></li></ul></blockquote></li><li><h4 id="4-鼠标事件"><a href="#4-鼠标事件" class="headerlink" title="4.鼠标事件"></a>4.鼠标事件</h4></li><li><blockquote><ol><li>onmousedown ：标按钮披按下.</li></ol><ul><li>定义方法时,定义一个形参,接受 event 对象.</li><li>eventi对象的button属性可以获取鼠标按钮键被点击了.</li></ul><ol start="2"><li>onmouseup  ：鼠标按键被松开.</li><li>onmousemove ：鼠标被移动.</li><li>onmouseover：鼠标移到某元素之上.</li><li>onmouseout：鼠标从某元素移开.</li></ol></blockquote></li><li><h4 id="5-键盘事件"><a href="#5-键盘事件" class="headerlink" title="5.键盘事件"></a>5.键盘事件</h4></li><li><blockquote><ol><li>onkeydown： 某个键盘按键被按下.</li><li>onkeyup ：某个键盘按键被松开.</li><li>onkeypress： 某个键盘按键被按下并松开.</li></ol></blockquote></li><li><h4 id="6-选择和改变事件"><a href="#6-选择和改变事件" class="headerlink" title="6.选择和改变事件"></a>6.选择和改变事件</h4></li><li><blockquote><ol><li>onchange：域的内容被改变.</li></ol><ul><li><h4 id="☆-当在选择的下拉列表上，选择某个选项会触发该事件。"><a href="#☆-当在选择的下拉列表上，选择某个选项会触发该事件。" class="headerlink" title="☆ 当在选择的下拉列表上，选择某个选项会触发该事件。"></a>☆ 当在选择的下拉列表上，选择某个选项会触发该事件。</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009283.png" alt="Image [81]"></p></li></ul><ol start="2"><li>onselect：文本被选中.</li></ol></blockquote></li><li><h4 id="7-表单事件"><a href="#7-表单事件" class="headerlink" title="7.表单事件:"></a>7.表单事件:</h4></li><li><blockquote><ol><li>onsubmit：确认按钮被点击.</li></ol><ul><li>可以阻止表单的提交<ul><li>方法返回falsel则表单被阻止提交.</li></ul></li><li>写法：</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009623.png" alt="Image [82]"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009823.png" alt="Image [83]"></li></ul><ol start="2"><li>onreset：重置按钮被点击.</li></ol></blockquote></li></ul></li></ul><hr><hr><h2 id="练习：动态表格案例"><a href="#练习：动态表格案例" class="headerlink" title="练习：动态表格案例"></a>练习：动态表格案例</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009683.png" alt="image-20240131000210183"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161009764.png" alt="image-20240131000243636"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161010442.png" alt="image-20240131000254150"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161010003.png" alt="image-20240131000332037"></p><ul><li>☆动态表格案例总结：用DOM对象在内存层面你，不管创建了多少子节点或者父节点，这些结构都是在内存层面上的，在浏览器页面上不能够直接显示，要想显示，必须有html的已有标签对象。先获取已有的html标签对象节点，将内存层面上的节点，appendChild为已有节点的子节点。同时，属性的样式会关联到css样式表中，只要和css表中的选择器对应的上，就可以显示样式。</li><li>☆ 技巧：怎样获取当前标签的对象，直接在html标签后面，加上事件属性。绑定事件方式一，事件调用指定方法，括号里面写this。</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161010543.png" alt="image-20240131000404203"></li><li>那么就可以在方法声明的地方，形式参数就是当前对象。如下图：</li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161010436.png" alt="Image [62]"></li></ul><hr><hr><h2 id="总结1："><a href="#总结1：" class="headerlink" title="总结1："></a>总结1：</h2><ul><li><h3 id="怎么来理解BOM对象和DOM对象以及HTML-DOM对象？"><a href="#怎么来理解BOM对象和DOM对象以及HTML-DOM对象？" class="headerlink" title="怎么来理解BOM对象和DOM对象以及HTML DOM对象？"></a>怎么来理解BOM对象和DOM对象以及HTML DOM对象？</h3></li><li><p>1 . BOM对象，就是将浏览器各个组成部分，封装为对象。有显示器对象、浏览器对象、windows窗口对象、URL地址栏对象、以及历史记录对象，这5个BOM对象。windows窗口对象，是BOM对象中的主要对象，因为其他对象都在一个窗口当中。可以通过windows对象来获取，其他4个BOM对象。</p></li><li><p>2 .在windows窗口获取的document对象，是DOM对象。</p><ul><li>document对象是DOM对象的主要对象。DOM对象也在窗口内，但是只有document对象（.html文件对象）是通过窗口获取，其他DOM对象是通过document对象获取的。</li></ul></li><li><p>3 .document对象，他是将整个文档封装成一个document对象。对应着HTML里面最外层标签<html></html>。他可以获取其他节点对象</p><ul><li>document.getElementById()；。或者对象们；另外也可以创建其他DOM对象。</li></ul></li><li><p>4.有了一些基础的DOM对象，也就是有了某个标签的（节点）的对象之后。然后用HTML DOM来、对这个对象进行获取、修改、添加或删除操作。</p></li><li><p>5.从上往下看，一层一层的，从窗口(window)——&gt;文本对象(document)——&gt;单个文本元素对象(element)——&gt;单个文本元素操作（HTML DOM）这样方便记忆。也便于理解。</p></li><li><p>节点：在HTML中所有的单个元件，就是单个节点。对应着一对，一对的标签。</p></li><li><p>子节点：外标签包着内标签，也就是节点包着子节点。例如：<body>文字 <a>超链接</a></body>。</p></li><li><p>Node 节点对象：他可以认为是虚有的，它里面的方法用来“CRUDdom树”</p></li><li><p>其实就是所有的DOM对象，都是一个节点，DOM对象本身，就可以增加节点，删除节点，替换节点，查询节点。</p></li><li><p>有了DOM这些对象，用他们的功能。就可以用javaScript语言对HTML的标签进行操作。</p></li><li><p>要记住：虽然能用，JavaScript语言来操作，内存层面的HTML的元素对象代码，使其在浏览器上面显示样式。但是他和HTML里面的标签没有，任何关系。</p><ul><li>执行了“JavaScript语言操作的元件对象，比如添加节点，删除节点”不会再HTML文档中自动生成，HTML代码。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406161011212.png" alt="Image [84]"></p><ul><li><h3 id="理解、标签、标签体、标签属性、控制元素的样式。"><a href="#理解、标签、标签体、标签属性、控制元素的样式。" class="headerlink" title="理解、标签、标签体、标签属性、控制元素的样式。"></a>理解、标签、标签体、标签属性、控制元素的样式。</h3><blockquote><p>1.1标签: 标签就是一对对的&lt;&gt;&lt;&#x2F;&gt;。例如：<code>&lt;img&gt; &lt;/img&gt; </code></p><p>1.2标签体:一对标签里面的内容。例如：<code>&lt;img&gt;这是标签体，可以是子标签也可以是文字 &lt;/img&gt;</code></p><p>1.3 标签属性: 定义在标签&lt;&gt;里面的。例如：<code>&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;</code></p><p>1.4 标签控制样式:</p></blockquote></li></ul><h2 id="总结2："><a href="#总结2：" class="headerlink" title="总结2："></a>总结2：</h2><ul><li><h4 id="一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求-js代码，标签一般都写在-body标签的最下面。"><a href="#一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求-js代码，标签一般都写在-body标签的最下面。" class="headerlink" title="一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求 &lt;script&gt;js代码&lt;/script&gt;，标签一般都写在&lt;body&gt;......&lt;script&gt;&lt;/body&gt;body标签的最下面。"></a>一般都是先加载了web的HTML界面之后，JavaScript脚本语言才会加载，这样js里面获取的元素对象，才会被拿到。如果是内部加载的话。所以要求 <code>&lt;script&gt;js代码&lt;/script&gt;</code>，标签一般都写在<code>&lt;body&gt;......&lt;script&gt;&lt;/body&gt;</code>body标签的最下面。</h4></li><li><h4 id="js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。"><a href="#js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。" class="headerlink" title="js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。"></a>js代码（可以理解为一个一个的等待的动作），就像是当HTML页面加载完全之后，它已经运行了内部代码，但是，都还是在等待的状态。如果界面中触发了某个事件，就会执行相应“事件器代码”，完成效果。</h4></li></ul><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;javaScript&lt;/center&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;静态网页资源的三剑客：HTML（文本），CSS（样式），JavaScript（行为）。把后面两个效果，加在HTML文本上，就会呈现出很好看的网页界面。&lt;/p&gt;
&lt;ol&gt;
&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="javaScript" scheme="https://protonlml.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>50.IO（字节流&amp;字符流）</title>
    <link href="https://protonlml.github.io/2019/09/26/50.IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81&amp;%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/"/>
    <id>https://protonlml.github.io/2019/09/26/50.IO%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81&amp;%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89/</id>
    <published>2019-09-26T01:31:00.000Z</published>
    <updated>2024-07-03T09:09:52.423Z</updated>
    
    <content type="html"><![CDATA[<h1><center>IO（字节流&字符流）</center></h1><h2 id="一、IO流分类"><a href="#一、IO流分类" class="headerlink" title="一、IO流分类"></a>一、IO流分类</h2><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;IO（字节流&amp;字符流）&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、IO流分类&quot;&gt;&lt;a href=&quot;#一、IO流分类&quot; class=&quot;headerlink&quot; title=&quot;一、IO流分类&quot;&gt;&lt;/a&gt;一、IO流分类&lt;/h2&gt;&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;©</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>49.File类</title>
    <link href="https://protonlml.github.io/2019/09/26/49.File/"/>
    <id>https://protonlml.github.io/2019/09/26/49.File/</id>
    <published>2019-09-26T00:31:00.000Z</published>
    <updated>2024-07-03T09:07:14.962Z</updated>
    
    <content type="html"><![CDATA[<h1><center>File类</center></h1><h2 id="一、File"><a href="#一、File" class="headerlink" title="一、File"></a>一、File</h2><ul><li><h3 id="对File的理解"><a href="#对File的理解" class="headerlink" title="对File的理解"></a>对File的理解</h3></li><li><h4 id="File-出现，new出来肯定是带（绝对路径的，已经存在的）"><a href="#File-出现，new出来肯定是带（绝对路径的，已经存在的）" class="headerlink" title="File 出现，new出来肯定是带（绝对路径的，已经存在的）"></a>File 出现，new出来肯定是带（绝对路径的，已经存在的）</h4><ul><li><h4 id="1-形参中是文件的绝对路径（此时就表示一个文件）"><a href="#1-形参中是文件的绝对路径（此时就表示一个文件）" class="headerlink" title="1.形参中是文件的绝对路径（此时就表示一个文件）"></a>1.形参中是文件的绝对路径（此时就表示一个文件）</h4></li><li><h4 id="2-形参中是文件夹的绝对路径（此时就表示一个文件夹）"><a href="#2-形参中是文件夹的绝对路径（此时就表示一个文件夹）" class="headerlink" title="2.形参中是文件夹的绝对路径（此时就表示一个文件夹）"></a>2.形参中是文件夹的绝对路径（此时就表示一个文件夹）</h4></li></ul></li></ul><hr><ul><li><h4 id="new-File-形参-是-不存在的路径，就表示一个路径而已，使用File中的方法来创建实际文件或者文件夹。"><a href="#new-File-形参-是-不存在的路径，就表示一个路径而已，使用File中的方法来创建实际文件或者文件夹。" class="headerlink" title="new File(形参) 是 不存在的路径，就表示一个路径而已，使用File中的方法来创建实际文件或者文件夹。"></a>new File(形参) 是 不存在的路径，就表示一个路径而已，使用File中的方法来创建实际文件或者文件夹。</h4></li></ul><hr><ul><li><h4 id="为什么要用File类，就是为了表述系统中的文件，使用File类中的方法，对当前File进行操作。"><a href="#为什么要用File类，就是为了表述系统中的文件，使用File类中的方法，对当前File进行操作。" class="headerlink" title="为什么要用File类，就是为了表述系统中的文件，使用File类中的方法，对当前File进行操作。"></a>为什么要用File类，就是为了表述系统中的文件，使用File类中的方法，对当前File进行操作。</h4></li></ul><hr><hr><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021751478.png" alt="image-20240702175109110"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021751937.png" alt="image-20240702175127948"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021814490.png" alt="image-20240702181421477"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021811150.png" alt="image-20240702181153076"></p><h2 id="二、File-的方法"><a href="#二、File-的方法" class="headerlink" title="二、File 的方法"></a>二、File 的方法</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021815581.png" alt="image-20240702181526494"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407022152070.png" alt="image-20240702215257042"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021815145.png" alt="image-20240702181546913"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407022155698.png" alt="image-20240702215518579"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021819918.png" alt="image-20240702181630094"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407022202896.png" alt="image-20240702220240753"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h3 id="1-file获取文件名f-getName-带后缀名"><a href="#1-file获取文件名f-getName-带后缀名" class="headerlink" title="1.file获取文件名f.getName()带后缀名"></a>1.file获取文件名f.getName()带后缀名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个方法找某一个文件夹中，是否有以 avi 结尾的电影。</span></span><br><span class="line"><span class="comment"> * （暂时不需要考虑子文件夹）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\lml\\Downloads\\aaa&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> existAvi(file);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">existAvi</span><span class="params">(File file)</span>&#123;</span><br><span class="line">        <span class="comment">// C:\Users\lml\Downloads\aaa 文件夹</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="comment">// 遍历aaa文件夹下的 文件夹以及文件的路径</span></span><br><span class="line">            <span class="keyword">if</span>(f.isFile()&amp;&amp;f.getName().endsWith(<span class="string">&quot;.avi&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-涉及到多级文件夹，需要递归"><a href="#2-涉及到多级文件夹，需要递归" class="headerlink" title="2.涉及到多级文件夹，需要递归"></a>2.涉及到多级文件夹，需要递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atlml.file_demo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到电脑中所有以avi结尾的电影。</span></span><br><span class="line"><span class="comment"> * (需要考虑子文件夹）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  思想：把大问题拆分，拆到某一个文件夹中不包含其他文件夹为止</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *        递归思想，就是将大的问题，拆成小的问题去解决</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *        凡事要考虑文件夹里面的内容了，就使用下面的套路</span></span><br><span class="line"><span class="comment"> *        写递归方法的套路</span></span><br><span class="line"><span class="comment"> *        套路：</span></span><br><span class="line"><span class="comment"> *          1.进入文件夹</span></span><br><span class="line"><span class="comment"> *          2.遍历数组</span></span><br><span class="line"><span class="comment"> *              2.1.遍历内部：判断，如果是文件  就执行题目的业务逻辑</span></span><br><span class="line"><span class="comment"> *              2.2.遍历内部：判断，如果不是文件，他就是文件夹，继续调用当前方法，递归</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/* File file = new File(&quot;C:\\&quot;); //C盘</span></span><br><span class="line"><span class="comment">        findAVI(file);*/</span></span><br><span class="line">        findAVI();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询电脑上 所有盘符 中 avi文件的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findAVI</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        File[] files = File.listRoots(); <span class="comment">//获取系统中所有的盘符</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            findAVI(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归方法</span></span><br><span class="line"><span class="comment">     * 递归查询 指定文件夹 中的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findAVI</span><span class="params">(File file)</span>&#123;</span><br><span class="line">        <span class="comment">//1.进入文件夹,找到当前文件夹下面 所有的路径</span></span><br><span class="line">        <span class="comment">// 包含当前文件夹下的 所有文件夹，文件</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意细节：file可能为null 因为盘符有权限可能进不去</span></span><br><span class="line">        <span class="keyword">if</span>(files!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.遍历数组</span></span><br><span class="line">            <span class="keyword">for</span> (File src : files) &#123;</span><br><span class="line">                <span class="comment">//3.判断，如果是文件就执行题目的业务逻辑</span></span><br><span class="line">                <span class="keyword">if</span>(src.isFile())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(src.getName().endsWith(<span class="string">&quot;.avi&quot;</span>))&#123;</span><br><span class="line">                        System.out.println(src);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//4.判断，如果不是文件，他就是文件夹，继续调用当前方法，递归</span></span><br><span class="line">                    <span class="comment">// 注意 src 一定是 file 的下级目录</span></span><br><span class="line">                    findAVI(src);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-删除多级文件夹"><a href="#3-删除多级文件夹" class="headerlink" title="3.删除多级文件夹"></a>3.删除多级文件夹</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除多级文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先思考删除一个文件夹内的内容怎么删</span></span><br><span class="line"><span class="comment">         * 如果 当前文件夹下面 还有文件夹 再调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\lml\\Downloads\\aaa\\eee&quot;</span>);</span><br><span class="line">        deleteMultilevelDirectory(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 文件夹地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除成功与否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteMultilevelDirectory</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span>(file.isFile())&#123; <span class="comment">//是文件直接删除</span></span><br><span class="line">                    file.delete();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123; <span class="comment">//是文件夹，且文件夹不是空的 递归</span></span><br><span class="line">                    deleteMultilevelDirectory(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自己也删</span></span><br><span class="line">        src.delete();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-递归多级目录，递归方法中的局部变量怎么统计"><a href="#4-递归多级目录，递归方法中的局部变量怎么统计" class="headerlink" title="4.递归多级目录，递归方法中的局部变量怎么统计"></a>4.递归多级目录，递归方法中的局部变量怎么统计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ① 打印格式如下：</span></span><br><span class="line"><span class="comment"> * ②    txt：3个</span></span><br><span class="line"><span class="comment"> * ③    doc：4个</span></span><br><span class="line"><span class="comment"> * ④     jpg：6个</span></span><br><span class="line"><span class="comment"> * 。。。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\lml\\Downloads\\aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; count = getCount(file);</span><br><span class="line">        System.out.println(count); <span class="comment">//&#123;jpg=9, txt=4, xlsx=1, avi=1, doc=4&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计文件夹下面的 各种文件格式 个数</span></span><br><span class="line"><span class="comment">     * 并打印</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  使用了 map 的统计思想</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *        因为是递归方法，</span></span><br><span class="line"><span class="comment">     *        所以其中的 局部变量怎么能产生关系?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *        就是在调用递归之后，回到当前方法，把递归的值，返回给当前</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; <span class="title function_">getCount</span><span class="params">(File src)</span> &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Integer&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                    <span class="comment">//如果当前是文件，判断文件的 格式 并记录</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">                    <span class="comment">//注意这里的截取 点 要加 双反斜线</span></span><br><span class="line">                    String[] split = name.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (split.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="comment">//这里是有后缀名的文件才进行统计</span></span><br><span class="line">                        <span class="comment">//a.txt 统计 //a.a.b,txt 统计</span></span><br><span class="line">                        <span class="comment">// aaa无后缀名 不统计</span></span><br><span class="line">                        <span class="comment">//利用Map 进行统计</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> split[split.length - <span class="number">1</span>]; <span class="comment">//后缀</span></span><br><span class="line">                        <span class="keyword">if</span> (hm.containsKey(suffix)) &#123;</span><br><span class="line">                            <span class="comment">//map中已经存在这个 格式 如：txt</span></span><br><span class="line">                            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> hm.get(suffix);</span><br><span class="line">                            count++;</span><br><span class="line">                            hm.put(suffix, count);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//第一次添加</span></span><br><span class="line">                            hm.put(suffix, <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不是文件，是文件夹（递归）结果是子文件夹的统计</span></span><br><span class="line">                    <span class="comment">// hm &#123;txt=3,doc=4,jpg=1 &#125;</span></span><br><span class="line">                    <span class="comment">// map&#123;txt=1,doc=1,jpg=1,xlsx=1&#125;</span></span><br><span class="line">                    Map&lt;String, Integer&gt; map = getCount(file); <span class="comment">//走到这一步，下面就先不看，再旁边想象新的方法，结果放在这里</span></span><br><span class="line">                    <span class="comment">//遍历map</span></span><br><span class="line">                    map.forEach((k, v) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hm.containsKey(k)) &#123;</span><br><span class="line">                            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> hm.get(k);</span><br><span class="line">                            <span class="comment">// 说明已经有 这个后缀</span></span><br><span class="line">                            hm.put(k, v + count);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//这里表示hm中不存在的 key格式值</span></span><br><span class="line">                            hm.put(k, v);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-递归方法中的局部变量怎么处理"><a href="#5-递归方法中的局部变量怎么处理" class="headerlink" title="5.递归方法中的局部变量怎么处理"></a>5.递归方法中的局部变量怎么处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计一个文件夹内所有文件的总大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo8</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1.先路径定义到 这个文件夹</span></span><br><span class="line"><span class="comment">         * 2. 将文件夹展开</span></span><br><span class="line"><span class="comment">         *     如果是文件直接统计大小</span></span><br><span class="line"><span class="comment">         *     如果是文件夹，继续递归第2步</span></span><br><span class="line"><span class="comment">         *     最终将所有的文件大小加在一起</span></span><br><span class="line"><span class="comment">         *  3.返回统计值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//这里统计 aaa文件夹总大小</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\lml\\Downloads\\aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> countTotalSize(file);</span><br><span class="line">        System.out.println(size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Long <span class="title function_">countTotalSize</span><span class="params">(File src)</span> &#123;</span><br><span class="line">        <span class="comment">//注意这个length是局部变量，第二次递归的时候，这个值就又变成了0</span></span><br><span class="line">        <span class="comment">// 怎么解决？把递归的结果加在第一次执行时length上面。</span></span><br><span class="line">        <span class="comment">// 执行到递归时，就想旁边有一个一模一样的方法，它的计算和 当前方法执行 没有关系</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                    <span class="comment">//如果是文件，直接算出大小</span></span><br><span class="line">                    length = length + file.length();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    length = length + countTotalSize(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;File类&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、File&quot;&gt;&lt;a href=&quot;#一、File&quot; class=&quot;headerlink&quot; title=&quot;一、File&quot;&gt;&lt;/a&gt;一、File&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;对File的理</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>47.方法引用</title>
    <link href="https://protonlml.github.io/2019/09/26/47.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <id>https://protonlml.github.io/2019/09/26/47.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</id>
    <published>2019-09-26T00:30:00.000Z</published>
    <updated>2024-07-02T07:48:13.556Z</updated>
    
    <content type="html"><![CDATA[<h1><center>方法引用</center></h1><h2 id="一、方法引用"><a href="#一、方法引用" class="headerlink" title="一、方法引用"></a>一、方法引用</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021240777.png" alt="image-20240702124045853"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021245617.png" alt="image-20240702124552617"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021246558.png" alt="image-20240702124614489"></p><hr><hr><h2 id="二、方法引用的分类"><a href="#二、方法引用的分类" class="headerlink" title="二、方法引用的分类"></a>二、方法引用的分类</h2><ul><li><h3 id="1-引用静态方法"><a href="#1-引用静态方法" class="headerlink" title="1.引用静态方法"></a>1.引用静态方法</h3><ul><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021419699.png" alt="image-20240702141907998"></p></li><li><h4 id="例："><a href="#例：" class="headerlink" title="例："></a>例：<img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021431396.png" alt="image-20240702143137496"></h4></li></ul></li><li><h3 id="2-引用成员方法"><a href="#2-引用成员方法" class="headerlink" title="2.引用成员方法"></a>2.引用成员方法</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021432123.png" alt="image-20240702143232058"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021435931.png" alt="image-20240702143539302"></li></ul></li><li><h3 id="3-引用构造方法"><a href="#3-引用构造方法" class="headerlink" title="3.引用构造方法"></a>3.引用构造方法</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021437786.png" alt="image-20240702143748751"></li><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021445431.png" alt="image-20240702144527089"></li></ul></li></ul><h2 id="三、方法引用的理解"><a href="#三、方法引用的理解" class="headerlink" title="三、方法引用的理解"></a>三、方法引用的理解</h2><ul><li><h4 id="（大小写转换）"><a href="#（大小写转换）" class="headerlink" title="（大小写转换）"></a>（大小写转换）</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021454045.png" alt="image-20240702145425612"></p><h2 id="四、数组构造器引用"><a href="#四、数组构造器引用" class="headerlink" title="四、数组构造器引用"></a>四、数组构造器引用</h2><ul><li><h4 id="以后stream流收集为Array数组的时候，就可以使用”数组的构造器引用”"><a href="#以后stream流收集为Array数组的时候，就可以使用”数组的构造器引用”" class="headerlink" title="以后stream流收集为Array数组的时候，就可以使用”数组的构造器引用”"></a>以后stream流收集为Array数组的时候，就可以使用”数组的构造器引用”</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021509490.png" alt="image-202407021508003"></p></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021512049.png" alt="image-20240702151246628"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="创建一个student类"><a href="#创建一个student类" class="headerlink" title="创建一个student类"></a>创建一个student类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atlml.stream_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.age = Integer.parseInt(str.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拼接数据</span></span><br><span class="line"><span class="comment">     * 把姓名和年龄拼接成：张三-23的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">splicing</span><span class="params">(Student student)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student.getName()+<span class="string">&quot;-&quot;</span>+student.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用Student构造器方法引用"><a href="#使用Student构造器方法引用" class="headerlink" title="使用Student构造器方法引用"></a>使用Student构造器方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 集合中存储一些字符串的数据，比如：张三，23。</span></span><br><span class="line"><span class="comment">        * 收集到Student：类型的数组当中（使用方法引用完成）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       </span><br><span class="line">       ArrayList&lt;String&gt; manName = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Collections.addAll(manName, <span class="string">&quot;蔡徐坤,23&quot;</span>, <span class="string">&quot;吴京,29&quot;</span>, <span class="string">&quot;林根锡,15&quot;</span>, <span class="string">&quot;顾佳,66&quot;</span>, <span class="string">&quot;叶问,54&quot;</span>, <span class="string">&quot;洪金宝,32&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Student[] students = manName.stream()</span><br><span class="line">               <span class="comment">// 下面这句话怎么理解， 就是stream上的 每个元素，都调用了，new Student() 方法，并且又将结果返回给 stream流上。</span></span><br><span class="line">               <span class="comment">// map处理过后，stream流上面全是student对象</span></span><br><span class="line">               .map(Student::<span class="keyword">new</span>) <span class="comment">//使用 student的构造器方法 引用</span></span><br><span class="line"></span><br><span class="line">               .toArray(Student[]::<span class="keyword">new</span>);<span class="comment">// 使用student 数组构造引用</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">           System.out.println(student);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用Student中成员方法引用"><a href="#使用Student中成员方法引用" class="headerlink" title="使用Student中成员方法引用"></a>使用Student中成员方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 创建集合添加学生对象，学生对象属性：name,age</span></span><br><span class="line"><span class="comment">        * 只获取姓名并放到数组当中（使用方法引用完成）</span></span><br><span class="line"><span class="comment">        * &quot;蔡徐坤,23&quot;, &quot;吴京,29&quot;, &quot;林根锡,15&quot;, &quot;顾佳,66&quot;, &quot;叶问,54&quot;, &quot;洪金宝,32&quot;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蔡徐坤&quot;</span>,<span class="number">23</span>));</span><br><span class="line">       students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;吴京&quot;</span>,<span class="number">29</span>));</span><br><span class="line">       students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林根锡&quot;</span>,<span class="number">15</span>));</span><br><span class="line">       students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;顾佳&quot;</span>,<span class="number">66</span>));</span><br><span class="line">       students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;叶问&quot;</span>,<span class="number">54</span>));</span><br><span class="line"></span><br><span class="line">       String[] names = students.stream()</span><br><span class="line">               .map(Student::getName)</span><br><span class="line">               .toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">      Arrays.stream(names).forEach(n-&gt; System.out.println(n));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="使用Student中静态方法引用"><a href="#使用Student中静态方法引用" class="headerlink" title="使用Student中静态方法引用"></a>使用Student中静态方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *创建集合添加学生对象，学生对象属性：name,age</span></span><br><span class="line"><span class="comment">         * 把姓名和年龄拼接成：张三-23的字符串，并放到数组当中（使用方法引用完成）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蔡徐坤&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;吴京&quot;</span>,<span class="number">29</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林根锡&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;顾佳&quot;</span>,<span class="number">66</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;叶问&quot;</span>,<span class="number">54</span>));</span><br><span class="line"></span><br><span class="line">        String[] students1 = students.stream()</span><br><span class="line">                .map(Student::splicing)</span><br><span class="line">                .toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Arrays.toString(students1);</span><br><span class="line">        System.out.println(s);<span class="comment">//[蔡徐坤-23, 吴京-29, 林根锡-15, 顾佳-66, 叶问-54]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;方法引用&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、方法引用&quot;&gt;&lt;a href=&quot;#一、方法引用&quot; class=&quot;headerlink&quot; title=&quot;一、方法引用&quot;&gt;&lt;/a&gt;一、方法引用&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>48.异常体系</title>
    <link href="https://protonlml.github.io/2019/09/26/48.%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <id>https://protonlml.github.io/2019/09/26/48.%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</id>
    <published>2019-09-26T00:30:00.000Z</published>
    <updated>2024-07-02T09:48:48.069Z</updated>
    
    <content type="html"><![CDATA[<h1><center>异常体系</center></h1><h2 id="一、异常体系"><a href="#一、异常体系" class="headerlink" title="一、异常体系"></a>一、异常体系</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021553622.png" alt="image-20240702155320190"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021554823.png" alt="image-20240702155408624"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021556964.png" alt="image-20240702155633774"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021557462.png" alt="image-20240702155721568"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021559675.png" alt="image-20240702155936907"></p><hr><hr><h2 id="二、捕获异常"><a href="#二、捕获异常" class="headerlink" title="二、捕获异常"></a>二、捕获异常</h2><ul><li><h4 id="在代码中将可能存在异常的部分，使用-try-catch包裹住，在catch中捕获异常，并进行处理（可以记录到日志）"><a href="#在代码中将可能存在异常的部分，使用-try-catch包裹住，在catch中捕获异常，并进行处理（可以记录到日志）" class="headerlink" title="在代码中将可能存在异常的部分，使用 try-catch包裹住，在catch中捕获异常，并进行处理（可以记录到日志）"></a>在代码中将可能存在异常的部分，使用 try-catch包裹住，在catch中捕获异常，并进行处理（可以记录到日志）</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021606419.png" alt="image-20240702160658424"></p></li><li><h3 id="目的：当代码出现异常时，可以让程序继续往下执行，而不是交给虚拟机默认处理，给系统停止了"><a href="#目的：当代码出现异常时，可以让程序继续往下执行，而不是交给虚拟机默认处理，给系统停止了" class="headerlink" title="目的：当代码出现异常时，可以让程序继续往下执行，而不是交给虚拟机默认处理，给系统停止了"></a>目的：当代码出现异常时，可以让程序继续往下执行，而不是交给虚拟机默认处理，给系统停止了</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021608571.png" alt="image-20240702160840893"></p></li></ul><p> <img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021609203.png" alt="image-20240702160947706"></p><h2 id="三、异常类中的常见方法"><a href="#三、异常类中的常见方法" class="headerlink" title="三、异常类中的常见方法"></a>三、异常类中的常见方法</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021610134.png" alt="image-20240702161022322"></p><h2 id="四、异常的抛出处理"><a href="#四、异常的抛出处理" class="headerlink" title="四、异常的抛出处理"></a>四、异常的抛出处理</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021611197.png" alt="image-20240702161144548"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021612771.png" alt="image-20240702161250842"></p><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021613102.png" alt="image-20240702161349512"></p><hr><hr><h2 id="五、自定义异常类（类名要见名知意）"><a href="#五、自定义异常类（类名要见名知意）" class="headerlink" title="五、自定义异常类（类名要见名知意）"></a>五、自定义异常类（类名要见名知意）</h2><ul><li><h2 id="意义：就是为了让控制台的报错信息更加见名知意"><a href="#意义：就是为了让控制台的报错信息更加见名知意" class="headerlink" title="意义：就是为了让控制台的报错信息更加见名知意"></a>意义：就是为了让控制台的报错信息更加见名知意</h2><ul><li><h3 id="目的是：在Java中，没有一个异常能够完美-表示-当前出现的问题"><a href="#目的是：在Java中，没有一个异常能够完美-表示-当前出现的问题" class="headerlink" title="目的是：在Java中，没有一个异常能够完美 表示 当前出现的问题"></a>目的是：在Java中，没有一个异常能够完美 表示 当前出现的问题</h3></li><li><h3 id="自定义一个异常类，表示当前出现问题的异常类"><a href="#自定义一个异常类，表示当前出现问题的异常类" class="headerlink" title="自定义一个异常类，表示当前出现问题的异常类"></a>自定义一个异常类，表示当前出现问题的异常类</h3></li></ul></li><li><p><img src="/48.%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.assets/image-20240702174743886.png" alt="image-20240702174743886"></p></li><li></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021632052.png" alt="image-20240702163258096"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;异常体系&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、异常体系&quot;&gt;&lt;a href=&quot;#一、异常体系&quot; class=&quot;headerlink&quot; title=&quot;一、异常体系&quot;&gt;&lt;/a&gt;一、异常体系&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>46.stream流</title>
    <link href="https://protonlml.github.io/2019/09/26/46.stream%E6%B5%81/"/>
    <id>https://protonlml.github.io/2019/09/26/46.stream%E6%B5%81/</id>
    <published>2019-09-26T00:22:00.000Z</published>
    <updated>2024-07-02T08:28:17.181Z</updated>
    
    <content type="html"><![CDATA[<h1><center>stream流</center></h1><h2 id="一、流的思想"><a href="#一、流的思想" class="headerlink" title="一、流的思想"></a>一、流的思想</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012216079.png" alt="image-20240701221652019"></p><h2 id="二、为什么要用stream流"><a href="#二、为什么要用stream流" class="headerlink" title="二、为什么要用stream流"></a>二、为什么要用stream流</h2><ul><li><h3 id="目的是为了，简化-集合、数组的操作（配合Lambda表达式使用）"><a href="#目的是为了，简化-集合、数组的操作（配合Lambda表达式使用）" class="headerlink" title="目的是为了，简化 集合、数组的操作（配合Lambda表达式使用）"></a>目的是为了，简化 集合、数组的操作（配合Lambda表达式使用）</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012221449.png" alt="image-20240701222112324"></p></li></ul><h2 id="三、获取Stream流"><a href="#三、获取Stream流" class="headerlink" title="三、获取Stream流"></a>三、获取Stream流</h2><ul><li><h4 id="这个stream流，一般就是用来简化集合的操作的，所以它和集合是分不开的，使用集合可以直接调用stream方法，来上流"><a href="#这个stream流，一般就是用来简化集合的操作的，所以它和集合是分不开的，使用集合可以直接调用stream方法，来上流" class="headerlink" title="这个stream流，一般就是用来简化集合的操作的，所以它和集合是分不开的，使用集合可以直接调用stream方法，来上流"></a>这个stream流，一般就是用来简化集合的操作的，所以它和集合是分不开的，使用集合可以直接调用stream方法，来上流</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012225826.png" alt="image-20240701222543063"></p></li><li><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012229694.png" alt="image-20240701222910161"></p></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012230358.png" alt="image-20240701223019895"></p><h2 id="四、Stream流的中间方法"><a href="#四、Stream流的中间方法" class="headerlink" title="四、Stream流的中间方法"></a>四、Stream流的中间方法</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012231373.png" alt="image-20240701223156962"></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012336458.png" alt="image-20240701233628414"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012337342.png" alt="image-20240701233739091"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012338285.png" alt="image-20240701233828377"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012339770.png" alt="image-20240701233942691"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012340536.png" alt="image-20240701233959589"></p><hr><hr><h2 id="五、Stream流中的终结方法"><a href="#五、Stream流中的终结方法" class="headerlink" title="五、Stream流中的终结方法"></a>五、Stream流中的终结方法</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012340750.png" alt="image-20240701234038096"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012350467.png" alt="image-20240701235035635"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407021508003.png" alt="image-20240702150852771"></p><h2 id="收集到集合当中（List集合，以及Map集合）"><a href="#收集到集合当中（List集合，以及Map集合）" class="headerlink" title="收集到集合当中（List集合，以及Map集合）"></a>收集到集合当中（List集合，以及Map集合）</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012357987.png" alt="image-20240701235747816"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202407012358504.png" alt="image-20240701235858457"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atlml.stream_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 现在有两个ArrayList集合，</span></span><br><span class="line"><span class="comment">         * 第一个集合中：存储6名男演员的名字和年龄。</span></span><br><span class="line"><span class="comment">         * 第二个集合中：存储6名女演员的名字和年龄。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 姓名和年龄中间用逗号隔开。比如：张三,23</span></span><br><span class="line"><span class="comment">         * 要求完成如下的操作：</span></span><br><span class="line"><span class="comment">         * 1，男演员只要名字为 3个字的 前两人</span></span><br><span class="line"><span class="comment">         * 2，女演员只要姓杨的，并且不要第一个</span></span><br><span class="line"><span class="comment">         * 3，把过滤后的男演员姓名和女演员姓名合并到一起</span></span><br><span class="line"><span class="comment">         * 4，将上一步的演员信息封装成Actor对象。</span></span><br><span class="line"><span class="comment">         * 5，将所有的演员对象都保存到List集合中。</span></span><br><span class="line"><span class="comment">         * 备注：演员类Actor，属性有：name,age</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; manName = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(manName, <span class="string">&quot;蔡徐坤,23&quot;</span>, <span class="string">&quot;吴京,29&quot;</span>, <span class="string">&quot;林根锡,15&quot;</span>, <span class="string">&quot;顾佳,66&quot;</span>, <span class="string">&quot;叶问,54&quot;</span>, <span class="string">&quot;洪金宝,32&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; girlName = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(girlName, <span class="string">&quot;杨幂,20&quot;</span>, <span class="string">&quot;刘诗诗,28&quot;</span>, <span class="string">&quot;赵丽颖,22&quot;</span>, <span class="string">&quot;高圆圆,29&quot;</span>, <span class="string">&quot;张甜甜,33&quot;</span>, <span class="string">&quot;杨政馨,46&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list1 = manName.stream()</span><br><span class="line">                .filter(s -&gt; (s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]).length() == <span class="number">3</span>)</span><br><span class="line">                .limit(<span class="number">2</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = girlName.stream()</span><br><span class="line">                .filter(s -&gt; s.startsWith(<span class="string">&quot;杨&quot;</span>))</span><br><span class="line">                .skip(<span class="number">1</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* ArrayList&lt;Actor&gt; actors = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Stream.concat(list1.stream(), list2.stream())</span></span><br><span class="line"><span class="comment">                .forEach(l -&gt; &#123;</span></span><br><span class="line"><span class="comment">            String[] split = l.split(&quot;,&quot;);</span></span><br><span class="line"><span class="comment">            String name = split[0];</span></span><br><span class="line"><span class="comment">            int age = Integer.parseInt(split[1]);</span></span><br><span class="line"><span class="comment">            actors.add(new Actor(name, age));</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Actor&gt; actors = Stream.concat(list1.stream(), list2.stream())</span><br><span class="line">                .map(s -&gt; <span class="keyword">new</span> <span class="title class_">Actor</span>(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(actors);<span class="comment">//[Actor&#123;name=&#x27;蔡徐坤&#x27;, age=23&#125;, Actor&#123;name=&#x27;林根锡&#x27;, age=15&#125;, Actor&#123;name=&#x27;杨政馨&#x27;, age=46&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;stream流&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、流的思想&quot;&gt;&lt;a href=&quot;#一、流的思想&quot; class=&quot;headerlink&quot; title=&quot;一、流的思想&quot;&gt;&lt;/a&gt;一、流的思想&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://r</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>45.集合进阶-12-TreeMap</title>
    <link href="https://protonlml.github.io/2019/09/25/45.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-12-TreeMap/"/>
    <id>https://protonlml.github.io/2019/09/25/45.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-12-TreeMap/</id>
    <published>2019-09-25T00:22:00.000Z</published>
    <updated>2024-06-28T09:05:07.988Z</updated>
    
    <content type="html"><![CDATA[<h1><center>TreeMap</center></h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281637731.png" alt="image-20240628163714743"></p><ul><li><h3 id="1-第一种排序规则"><a href="#1-第一种排序规则" class="headerlink" title="1.第一种排序规则"></a>1.第一种排序规则</h3></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281659906.png" alt="image-20240628165916283"></p><ul><li><h3 id="2-第二种排序规则"><a href="#2-第二种排序规则" class="headerlink" title="2.第二种排序规则"></a>2.第二种排序规则</h3></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281704454.png" alt="image-20240628165655914"></p><hr><hr><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h4 id="使用Map-来进行统计"><a href="#使用Map-来进行统计" class="headerlink" title="使用Map 来进行统计"></a>使用Map 来进行统计</h4><ul><li><h4 id="这里使用TreeMap因为结果有-字母升序排列"><a href="#这里使用TreeMap因为结果有-字母升序排列" class="headerlink" title="这里使用TreeMap因为结果有 字母升序排列"></a>这里使用TreeMap因为结果有 字母升序排列</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281703525.png" alt="image-20240628170322006"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;TreeMap&lt;/center&gt;&lt;/h1&gt;



&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281637731.png&quot; al</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>44.集合进阶-11-LinkedHashMap</title>
    <link href="https://protonlml.github.io/2019/09/25/44.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-11-LinkedHashMap/"/>
    <id>https://protonlml.github.io/2019/09/25/44.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-11-LinkedHashMap/</id>
    <published>2019-09-25T00:20:00.000Z</published>
    <updated>2024-06-28T08:35:55.935Z</updated>
    
    <content type="html"><![CDATA[<h1><center>LinkedHashMap</center></h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281633904.png" alt="image-20240628163318996"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281634049.png" alt="image-20240628163442102"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;LinkedHashMap&lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281633904.png</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>43.集合进阶-10-HashMap</title>
    <link href="https://protonlml.github.io/2019/09/25/43.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-10-HashMap/"/>
    <id>https://protonlml.github.io/2019/09/25/43.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-10-HashMap/</id>
    <published>2019-09-25T00:18:00.000Z</published>
    <updated>2024-06-28T08:31:56.325Z</updated>
    
    <content type="html"><![CDATA[<h1><center>HashMap</center></h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281625712.png" alt="image-20240628162507511"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281629568.png" alt="image-20240628162926278"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281629398.png" alt="image-20240628162943964"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281630003.png" alt="image-20240628163033088"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;HashMap&lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281625712.png&quot; alt=</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>42.集合进阶-09-双列集合Map、常用API、三种遍历方式</title>
    <link href="https://protonlml.github.io/2019/09/25/42.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-09-Map%E7%89%B9%E7%82%B9%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%81%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
    <id>https://protonlml.github.io/2019/09/25/42.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-09-Map%E7%89%B9%E7%82%B9%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%81%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</id>
    <published>2019-09-25T00:10:00.000Z</published>
    <updated>2024-06-28T08:21:57.091Z</updated>
    
    <content type="html"><![CDATA[<h1><center>双列集合Map</center></h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281609438.png" alt="image-20240628160931984"></p><h2 id="一、双列集合的特点"><a href="#一、双列集合的特点" class="headerlink" title="一、双列集合的特点"></a>一、双列集合的特点</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281608400.png" alt="image-20240628160851236"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281608458.png" alt="image-20240628160827195"></p><hr><hr><h2 id="二、Map中常见的API"><a href="#二、Map中常见的API" class="headerlink" title="二、Map中常见的API"></a>二、Map中常见的API</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281610860.png" alt="image-20240628161030546"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281612320.png" alt="image-20240628161234185"></p><h2 id="三、Map的三种遍历方式"><a href="#三、Map的三种遍历方式" class="headerlink" title="三、Map的三种遍历方式"></a>三、Map的三种遍历方式</h2><ul><li><h3 id="1-键找值"><a href="#1-键找值" class="headerlink" title="1.键找值"></a>1.键找值</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281619632.png" alt="image-20240628161935255"></li></ul></li><li><h3 id="2-键值对Entry对象"><a href="#2-键值对Entry对象" class="headerlink" title="2.键值对Entry对象"></a>2.键值对Entry对象</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281617466.png" alt="image-20240628161742321"></li></ul></li><li><h3 id="3-Lambda表达式遍历"><a href="#3-Lambda表达式遍历" class="headerlink" title="3.Lambda表达式遍历"></a>3.Lambda表达式遍历</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281621501.png" alt="image-20240628162115427"></li></ul></li></ul><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;双列集合Map&lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406281609438.png&quot; alt=</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>41.集合进阶-08-TreeSet详解</title>
    <link href="https://protonlml.github.io/2019/09/25/41.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-08-TreeSet%E8%AF%A6%E8%A7%A3/"/>
    <id>https://protonlml.github.io/2019/09/25/41.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-08-TreeSet%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-09-24T23:13:00.000Z</published>
    <updated>2024-06-28T09:08:59.726Z</updated>
    
    <content type="html"><![CDATA[<h1><center>TreeSet详解</center></h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261445305.png" alt="image-20240626144503012"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261445818.png" alt="image-20240626144535832"></p><h2 id="一、TreeSet"><a href="#一、TreeSet" class="headerlink" title="一、TreeSet"></a>一、TreeSet</h2><ul><li><h4 id="TreeSet集合，底层是红黑树结构"><a href="#TreeSet集合，底层是红黑树结构" class="headerlink" title="TreeSet集合，底层是红黑树结构"></a>TreeSet集合，底层是红黑树结构</h4></li><li><h4 id="★★★存入treeSet中的元素，遍历出来，默认就是按照从小到大来排序的。★★★"><a href="#★★★存入treeSet中的元素，遍历出来，默认就是按照从小到大来排序的。★★★" class="headerlink" title="★★★存入treeSet中的元素，遍历出来，默认就是按照从小到大来排序的。★★★"></a>★★★存入treeSet中的元素，遍历出来，默认就是按照从小到大来排序的。★★★</h4><ul><li><h4 id="1-存数值类型，然后遍历，默认就是从小到大遍历出来的。"><a href="#1-存数值类型，然后遍历，默认就是从小到大遍历出来的。" class="headerlink" title="1.存数值类型，然后遍历，默认就是从小到大遍历出来的。"></a>1.存数值类型，然后遍历，默认就是从小到大遍历出来的。</h4></li><li><h4 id="2-存字符串，是按照字符在ASCII码表中的数字升序进行排序的"><a href="#2-存字符串，是按照字符在ASCII码表中的数字升序进行排序的" class="headerlink" title="2.存字符串，是按照字符在ASCII码表中的数字升序进行排序的"></a>2.存字符串，是按照字符在ASCII码表中的数字升序进行排序的</h4><ul><li><h5 id="如果说字符串中的字符比较多，它是从字符串首字母按个比较的，此时和字符串的长度没有关系。例如”aaa”-”ab”-”aba”-从小到大遍历出来。它相比较前两个字符串的首字母a-一样就-再比较第二位的字母，b-a-直接确定了大小关系，后面所有字母不再看了。随后进行第二个字符串和第三个字符串的比较。"><a href="#如果说字符串中的字符比较多，它是从字符串首字母按个比较的，此时和字符串的长度没有关系。例如”aaa”-”ab”-”aba”-从小到大遍历出来。它相比较前两个字符串的首字母a-一样就-再比较第二位的字母，b-a-直接确定了大小关系，后面所有字母不再看了。随后进行第二个字符串和第三个字符串的比较。" class="headerlink" title="如果说字符串中的字符比较多，它是从字符串首字母按个比较的，此时和字符串的长度没有关系。例如”aaa”,”ab”,”aba” 从小到大遍历出来。它相比较前两个字符串的首字母a,一样就 再比较第二位的字母，b&gt;a 直接确定了大小关系，后面所有字母不再看了。随后进行第二个字符串和第三个字符串的比较。"></a>如果说字符串中的字符比较多，它是从字符串首字母按个比较的，此时和字符串的长度没有关系。例如”aaa”,”ab”,”aba” 从小到大遍历出来。它相比较前两个字符串的首字母a,一样就 再比较第二位的字母，b&gt;a 直接确定了大小关系，后面所有字母不再看了。随后进行第二个字符串和第三个字符串的比较。</h5></li></ul></li></ul></li></ul><hr><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261518770.png" alt="image-20240626144908197"></p><hr><ul><li><h4 id="3-存入自定义对象类型，该怎么比较呢？"><a href="#3-存入自定义对象类型，该怎么比较呢？" class="headerlink" title="3.存入自定义对象类型，该怎么比较呢？"></a>3.存入自定义对象类型，该怎么比较呢？</h4><ul><li><h4 id="因为treeSet集合底层是红黑树，所以其内部自定义对象，不用再重写hashCode和equals方法。用不到哈希值。"><a href="#因为treeSet集合底层是红黑树，所以其内部自定义对象，不用再重写hashCode和equals方法。用不到哈希值。" class="headerlink" title="因为treeSet集合底层是红黑树，所以其内部自定义对象，不用再重写hashCode和equals方法。用不到哈希值。"></a>因为treeSet集合底层是红黑树，所以其内部自定义对象，不用再重写hashCode和equals方法。用不到哈希值。</h4></li><li><h4 id="但是，要比较两个自定义对象，得指定某个属性来比较。"><a href="#但是，要比较两个自定义对象，得指定某个属性来比较。" class="headerlink" title="但是，要比较两个自定义对象，得指定某个属性来比较。"></a>但是，要比较两个自定义对象，得指定某个属性来比较。</h4></li></ul></li></ul><h2 id="TreeSet的两种比较方式"><a href="#TreeSet的两种比较方式" class="headerlink" title="TreeSet的两种比较方式"></a>TreeSet的两种比较方式</h2><ul><li><h3 id="第一种-自定义类-实现Comparable接口：指定比较规则"><a href="#第一种-自定义类-实现Comparable接口：指定比较规则" class="headerlink" title="第一种 自定义类 实现Comparable接口：指定比较规则"></a>第一种 自定义类 实现Comparable<E>接口：指定比较规则</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261519023.png" alt="image-20240626151956480"></p></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261514517.png" alt="image-20240626151438030"></p><ul><li><h3 id="第二种-比较器排序"><a href="#第二种-比较器排序" class="headerlink" title="第二种 比较器排序"></a>第二种 比较器排序</h3></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261520626.png" alt="image-20240626152005484"></p></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261608947.png" alt="image-20240626160829904"></p><h2 id="使用原则：默认使用第一种，如果第一种不能满足当前需求，就是用第二种。"><a href="#使用原则：默认使用第一种，如果第一种不能满足当前需求，就是用第二种。" class="headerlink" title="使用原则：默认使用第一种，如果第一种不能满足当前需求，就是用第二种。"></a>使用原则：默认使用第一种，如果第一种不能满足当前需求，就是用第二种。</h2><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *学生的比较规则</span><br><span class="line"> *按照总分从高到低输出到控制台</span><br><span class="line"> *如果总分一·样，按照语文成绩排</span><br><span class="line"> *如果语文一样，按照数学成绩排</span><br><span class="line"> *如果数学成绩一样，按照英语成绩排</span><br><span class="line"> *如果英文成绩一样，按照年龄排</span><br><span class="line"> * 如果年龄一样，按照姓名的字母顺序排</span><br><span class="line"> *如果都一样，认为是同一个学生，不存。</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261729555.png" alt="image-20240626172941360"></p><hr><hr><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261631210.png" alt="image-20240626163135176"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;TreeSet详解&lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261445305.png&quot; al</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>40.集合进阶-07-HashSet、LinkedHashSet详解</title>
    <link href="https://protonlml.github.io/2019/09/25/40.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-07-HashSet%E3%80%81LinkedHashSet%E8%AF%A6%E8%A7%A3/"/>
    <id>https://protonlml.github.io/2019/09/25/40.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-07-HashSet%E3%80%81LinkedHashSet%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-09-24T23:12:00.000Z</published>
    <updated>2024-06-26T06:33:52.102Z</updated>
    
    <content type="html"><![CDATA[<h1><center>HashSet、LinkedHashSet详解</center></h1><p>HashSet、LinkedHashSet详解</p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406252330979.png" alt="image-20240625233018639"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261331139.png" alt="image-20240626133145753"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261331289.png" alt="image-20240626133157075"></p><hr><hr><h1 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h1><ul><li><h2 id="什么是哈希值？"><a href="#什么是哈希值？" class="headerlink" title="什么是哈希值？"></a>什么是哈希值？</h2><ul><li><h4 id="在java中，对象的整数表现形式，就是将对象进行计算得出来一个整数值-。"><a href="#在java中，对象的整数表现形式，就是将对象进行计算得出来一个整数值-。" class="headerlink" title="在java中，对象的整数表现形式，就是将对象进行计算得出来一个整数值 。"></a>在java中，对象的整数表现形式，就是将对象进行计算得出来一个整数值 。</h4></li></ul></li><li><h3 id="哈希值根据什么计算？"><a href="#哈希值根据什么计算？" class="headerlink" title="哈希值根据什么计算？"></a>哈希值根据什么计算？</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261337235.png" alt="image-20240626133723683"></li></ul></li><li><h3 id="哈希值可以用来判断两个对象是否相等，（不是地址值是否相等，而是对象中的属性值是否相等）"><a href="#哈希值可以用来判断两个对象是否相等，（不是地址值是否相等，而是对象中的属性值是否相等）" class="headerlink" title="哈希值可以用来判断两个对象是否相等，（不是地址值是否相等，而是对象中的属性值是否相等）"></a>哈希值可以用来判断两个对象是否相等，（不是地址值是否相等，而是对象中的属性值是否相等）</h3><ul><li><h4 id="一般两个对象，即使是其属性完全相同，由于是两个对象，他们的地址值肯定不同，他们也必然不可能是同一个对象。"><a href="#一般两个对象，即使是其属性完全相同，由于是两个对象，他们的地址值肯定不同，他们也必然不可能是同一个对象。" class="headerlink" title="一般两个对象，即使是其属性完全相同，由于是两个对象，他们的地址值肯定不同，他们也必然不可能是同一个对象。"></a>一般两个对象，即使是其属性完全相同，由于是两个对象，他们的地址值肯定不同，他们也必然不可能是同一个对象。</h4></li><li><h4 id="比较两个对象，它们都没有重写Object中的-hashCode方法，那么他们的哈希值就是通过他们的地址值计算得来，肯定是不相同的哈希值。即使是他么的属性值完全相同，他们也不能相等。"><a href="#比较两个对象，它们都没有重写Object中的-hashCode方法，那么他们的哈希值就是通过他们的地址值计算得来，肯定是不相同的哈希值。即使是他么的属性值完全相同，他们也不能相等。" class="headerlink" title="比较两个对象，它们都没有重写Object中的 hashCode方法，那么他们的哈希值就是通过他们的地址值计算得来，肯定是不相同的哈希值。即使是他么的属性值完全相同，他们也不能相等。"></a>比较两个对象，它们都没有重写Object中的 hashCode方法，那么他们的哈希值就是通过他们的地址值计算得来，肯定是不相同的哈希值。即使是他么的属性值完全相同，他们也不能相等。</h4></li><li><h4 id="所以我们在比较两个对象的时候，在对象里面要重写hashCode方法，使用对象属性来计算哈希值，只要是两个对象的属性值相同，那么他们的哈希值就相等，他们也被判定为相等。（地址值不一样）"><a href="#所以我们在比较两个对象的时候，在对象里面要重写hashCode方法，使用对象属性来计算哈希值，只要是两个对象的属性值相同，那么他们的哈希值就相等，他们也被判定为相等。（地址值不一样）" class="headerlink" title="所以我们在比较两个对象的时候，在对象里面要重写hashCode方法，使用对象属性来计算哈希值，只要是两个对象的属性值相同，那么他们的哈希值就相等，他们也被判定为相等。（地址值不一样）"></a>所以我们在比较两个对象的时候，在对象里面要重写hashCode方法，使用对象属性来计算哈希值，只要是两个对象的属性值相同，那么他们的哈希值就相等，他们也被判定为相等。（地址值不一样）</h4></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261352835.png" alt="image-20240626135247545"></p><h1 id="HashSet底层原理（哈希表）"><a href="#HashSet底层原理（哈希表）" class="headerlink" title="HashSet底层原理（哈希表）"></a>HashSet底层原理（哈希表）</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261409956.png" alt="image-20240626140940477"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261411266.png" alt="image-20240626141109076"></p><ul><li><h4 id="★★★重写hashCode的目的是：想通过对象的属性值来计算哈希值，而不是地址值计算哈希值★★★"><a href="#★★★重写hashCode的目的是：想通过对象的属性值来计算哈希值，而不是地址值计算哈希值★★★" class="headerlink" title="★★★重写hashCode的目的是：想通过对象的属性值来计算哈希值，而不是地址值计算哈希值★★★"></a>★★★重写hashCode的目的是：想通过对象的属性值来计算哈希值，而不是地址值计算哈希值★★★</h4><ul><li><h4 id="用来确定对象存放在数组的哪个位置"><a href="#用来确定对象存放在数组的哪个位置" class="headerlink" title="用来确定对象存放在数组的哪个位置"></a>用来确定对象存放在数组的哪个位置</h4></li></ul></li><li><h4 id="★★★重写equals的目的是：想要对象比较的时候，比的也是对象中的属性，而不是对象地址值★★★"><a href="#★★★重写equals的目的是：想要对象比较的时候，比的也是对象中的属性，而不是对象地址值★★★" class="headerlink" title="★★★重写equals的目的是：想要对象比较的时候，比的也是对象中的属性，而不是对象地址值★★★"></a>★★★重写equals的目的是：想要对象比较的时候，比的也是对象中的属性，而不是对象地址值★★★</h4><ul><li><h4 id="确定了对像的位置，比较对象属性"><a href="#确定了对像的位置，比较对象属性" class="headerlink" title="确定了对像的位置，比较对象属性"></a>确定了对像的位置，比较对象属性</h4></li></ul></li><li><h4 id="★★★只要记住存入到hashSet集合中的自定义对象，都要重写hashCode和equals方法★★★"><a href="#★★★只要记住存入到hashSet集合中的自定义对象，都要重写hashCode和equals方法★★★" class="headerlink" title="★★★只要记住存入到hashSet集合中的自定义对象，都要重写hashCode和equals方法★★★"></a>★★★只要记住存入到hashSet集合中的自定义对象，都要重写hashCode和equals方法★★★</h4><ul><li><h4 id="因为：Set-是一个不允许重复元素的集合，它使用-hashCode-和-equals-方法来判断元素是否相等。如果您不重写这两个方法，Set-将无法正确识别相同内容的自定义对象。"><a href="#因为：Set-是一个不允许重复元素的集合，它使用-hashCode-和-equals-方法来判断元素是否相等。如果您不重写这两个方法，Set-将无法正确识别相同内容的自定义对象。" class="headerlink" title="因为：Set 是一个不允许重复元素的集合，它使用 hashCode() 和 equals() 方法来判断元素是否相等。如果您不重写这两个方法，Set 将无法正确识别相同内容的自定义对象。"></a>因为：<code>Set</code> 是一个不允许重复元素的集合，它使用 <code>hashCode()</code> 和 <code>equals()</code> 方法来判断元素是否相等。如果您不重写这两个方法，<code>Set</code> 将无法正确识别相同内容的自定义对象。</h4></li></ul></li></ul><hr><hr><h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261431946.png" alt="image-20240626143127725"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261433953.png" alt="image-20240626143313762"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;HashSet、LinkedHashSet详解&lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;HashSet、LinkedHashSet详解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/protonlml/b</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>39.集合进阶-06-ArrayList源码分析</title>
    <link href="https://protonlml.github.io/2019/09/25/39.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E8%A7%84%E5%88%99%E3%80%81%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3%EF%BC%89/"/>
    <id>https://protonlml.github.io/2019/09/25/39.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E8%A7%84%E5%88%99%E3%80%81%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3%EF%BC%89/</id>
    <published>2019-09-24T23:11:00.000Z</published>
    <updated>2024-06-23T09:54:27.246Z</updated>
    
    <content type="html"><![CDATA[<h1><center>ArrayList源码分析</center></h1><h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;ArrayList源码分析&lt;/center&gt;&lt;/h1&gt;

&lt;h1 id=&quot;ArrayList源码分析&quot;&gt;&lt;a href=&quot;#ArrayList源码分析&quot; class=&quot;headerlink&quot; title=&quot;ArrayList源码分析&quot;&gt;&lt;/a&gt;ArrayL</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>38.集合进阶-05数据结构（平衡二叉树旋转机制）</title>
    <link href="https://protonlml.github.io/2019/09/25/38.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-05%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <id>https://protonlml.github.io/2019/09/25/38.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-05%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC%E6%9C%BA%E5%88%B6%EF%BC%89/</id>
    <published>2019-09-24T23:10:00.000Z</published>
    <updated>2024-06-26T02:36:51.792Z</updated>
    
    <content type="html"><![CDATA[<h1><center>（平衡二叉树旋转机制）</center></h1><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;（平衡二叉树旋转机制）&lt;/center&gt;&lt;/h1&gt;























&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;© 版权声明&lt;/p&gt;
&lt;escape&gt;

&lt;div&gt;
    &lt;h3 align=&quot;center&quot;  style=&quot;color: b</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>37.集合进阶-04-数据结构(二叉树,二叉查找树,平衡二叉树)</title>
    <link href="https://protonlml.github.io/2019/09/25/37.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C%E5%8F%89%E6%A0%91,%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91,%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)/"/>
    <id>https://protonlml.github.io/2019/09/25/37.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C%E5%8F%89%E6%A0%91,%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91,%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91)/</id>
    <published>2019-09-24T23:09:00.000Z</published>
    <updated>2024-06-26T02:36:00.705Z</updated>
    
    <content type="html"><![CDATA[<h1><center>数据结构(二叉树,二叉查找树,平衡二叉树)</center></h1><h2 id="一、二叉树（二叉查找树为了提高查询效率）"><a href="#一、二叉树（二叉查找树为了提高查询效率）" class="headerlink" title="一、二叉树（二叉查找树为了提高查询效率）"></a>一、二叉树（二叉查找树为了提高查询效率）</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406252305197.png" alt="image-20240625230538805"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406252313174.png" alt="image-20240625231313162"></p><h2 id="二、二叉查找树的添加原理"><a href="#二、二叉查找树的添加原理" class="headerlink" title="二、二叉查找树的添加原理"></a>二、二叉查找树的添加原理</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406252319271.png" alt="image-20240625231953790"></p><h2 id="三、查找节点"><a href="#三、查找节点" class="headerlink" title="三、查找节点"></a>三、查找节点</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406252322193.png" alt="image-20240625232225015"></p><h2 id="四、所有二叉树的遍历方式"><a href="#四、所有二叉树的遍历方式" class="headerlink" title="四、所有二叉树的遍历方式"></a>四、所有二叉树的遍历方式</h2><ul><li><h3 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406252326494.png" alt="image-20240625232625441"></li></ul></li><li><h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261009739.png" alt="image-20240626100946265"></li></ul></li><li><h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261010675.png" alt="image-20240626101020508"></li></ul></li><li><h3 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4.层序遍历"></a>4.层序遍历</h3><ul><li><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261010307.png" alt="image-20240626101050663"></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261011102.png" alt="image-20240626101154821"></p><h2 id="五、二叉查找树的弊端"><a href="#五、二叉查找树的弊端" class="headerlink" title="五、二叉查找树的弊端"></a>五、二叉查找树的弊端</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261020703.png" alt="image-20240626102058231"></p><ul><li><h3 id="因为二叉查找树。有这样的弊端，所以就出现了平衡二叉树"><a href="#因为二叉查找树。有这样的弊端，所以就出现了平衡二叉树" class="headerlink" title="因为二叉查找树。有这样的弊端，所以就出现了平衡二叉树"></a>因为二叉查找树。有这样的弊端，所以就出现了平衡二叉树</h3></li></ul><h2 id="六、平衡二叉树"><a href="#六、平衡二叉树" class="headerlink" title="六、平衡二叉树"></a>六、平衡二叉树</h2><ul><li><h4 id="下列不是平衡二叉树"><a href="#下列不是平衡二叉树" class="headerlink" title="下列不是平衡二叉树"></a>下列不是平衡二叉树</h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261025486.png" alt="image-20240626102512901"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261025158.png" alt="image-20240626102557703"></p><h1 id="二叉树结构的演变"><a href="#二叉树结构的演变" class="headerlink" title="二叉树结构的演变"></a>二叉树结构的演变</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406261035625.png" alt="image-20240626103536594"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;数据结构(二叉树,二叉查找树,平衡二叉树)&lt;/center&gt;&lt;/h1&gt;



&lt;h2 id=&quot;一、二叉树（二叉查找树为了提高查询效率）&quot;&gt;&lt;a href=&quot;#一、二叉树（二叉查找树为了提高查询效率）&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>36.集合进阶-03-泛型类、泛型方法、泛型接口</title>
    <link href="https://protonlml.github.io/2019/09/25/36.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-03-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/"/>
    <id>https://protonlml.github.io/2019/09/25/36.%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6-03-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3/</id>
    <published>2019-09-24T23:08:00.000Z</published>
    <updated>2024-06-25T14:22:33.033Z</updated>
    
    <content type="html"><![CDATA[<h1><center>泛型类、泛型方法、泛型接口</center></h1><h2 id="一、泛型是什么"><a href="#一、泛型是什么" class="headerlink" title="一、泛型是什么"></a>一、泛型是什么</h2><ul><li><h4 id="ArrayList-strs-new-ArrayList"><a href="#ArrayList-strs-new-ArrayList" class="headerlink" title="ArrayList  strs&#x3D;new ArrayList&lt;&gt;();"></a>ArrayList <strong><String></strong> strs&#x3D;new ArrayList&lt;&gt;();</h4></li><li><h4 id="这里面的尖括号-就是指泛型"><a href="#这里面的尖括号-就是指泛型" class="headerlink" title="这里面的尖括号  ,就是指泛型."></a>这里面的尖括号 <strong><String></strong> ,就是指泛型.</h4></li><li><h4 id="说白了，就是用来限定集合中存入数据的类型，不能随便存，只能存泛型指定的类型。"><a href="#说白了，就是用来限定集合中存入数据的类型，不能随便存，只能存泛型指定的类型。" class="headerlink" title="说白了，就是用来限定集合中存入数据的类型，不能随便存，只能存泛型指定的类型。"></a>说白了，就是用来限定集合中存入数据的类型，不能随便存，只能存泛型指定的类型。</h4></li></ul><h2 id="二、为什么要用泛型"><a href="#二、为什么要用泛型" class="headerlink" title="二、为什么要用泛型"></a>二、为什么要用泛型</h2><ul><li><h4 id="因为：-如果我-没有给集合指定类型，默认认为所有的数据类型都是Object类型此时可以往集合添加任意的数据类型。带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。"><a href="#因为：-如果我-没有给集合指定类型，默认认为所有的数据类型都是Object类型此时可以往集合添加任意的数据类型。带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。" class="headerlink" title="因为： 如果我]没有给集合指定类型，默认认为所有的数据类型都是Object类型此时可以往集合添加任意的数据类型。带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。"></a>因为： 如果我]没有给集合指定类型，默认认为所有的数据类型都是Object类型此时可以往集合添加任意的数据类型。带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。</h4></li><li><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251642920.png" alt="image-20240625164220282"></p></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251647188.png" alt="image-20240625164735183"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251656032.png" alt="image-20240625165623866"></p><hr><hr><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251734699.png" alt="image-20240625173418709"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251812521.png" alt="image-20240625181257479"></p><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251813074.png" alt="image-20240625181355530"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251815371.png" alt="image-20240625181505522"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251815408.png" alt="image-20240625181529826"></p><hr><hr><h2 id="可变形参的写法"><a href="#可变形参的写法" class="headerlink" title="可变形参的写法"></a>可变形参的写法</h2><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251819637.png" alt="image-20240625181901805"></p><hr><hr><h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251820158.png" alt="image-20240625182031005"></p><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251827317.png" alt="image-20240625182735788"></p><ul><li><h2 id="泛型的通配符-“-”"><a href="#泛型的通配符-“-”" class="headerlink" title="泛型的通配符  “?”"></a>泛型的通配符  “?”</h2></li><li><h4 id="泛型的通配符是一个问号：-“-”-，"><a href="#泛型的通配符是一个问号：-“-”-，" class="headerlink" title="泛型的通配符是一个问号： “?” ，"></a>泛型的通配符是一个问号： “?” ，</h4></li><li><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406251910988.png" alt="image-20240625191043839"></h4></li></ul><p><img src="https://raw.githubusercontent.com/protonlml/blogimages/master/imgs/202406252222293.png" alt="image-20240625222219852"></p><hr><hr><p>© 版权声明</p><escape><div>    <h3 align="center"  style="color: brown;" >版权声明</h3>    <table>           <tr>            <ol>                <li>本网站名称：𝚲𝚳𝚲</li>                <li>𝚲𝚳𝚲提供的资源仅供您个人用于非商业性目的。</li>                <li>本站文章部分内容可能来源于网络，仅供大家学习与参考，如有侵权，请联系我进行删除处理。</li>                <li>本站一切资源不代表本站立场，并不代表本站赞同其观点和对其真实性负责。</li>                <li>本站一律禁止以任何方式发布或转载任何违法的相关信息，访客发现请举报</li>                 <li>本站资源大多存储在云盘，如发现链接失效，请联系我，我会第一时间更新。</li>                <li>本站强烈打击盗版/破解等有损他人权益和违法作为，请支持正版！</li>              </ol>        </tr>    </table></div></escape><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;泛型类、泛型方法、泛型接口&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;一、泛型是什么&quot;&gt;&lt;a href=&quot;#一、泛型是什么&quot; class=&quot;headerlink&quot; title=&quot;一、泛型是什么&quot;&gt;&lt;/a&gt;一、泛型是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4</summary>
      
    
    
    
    <category term="java" scheme="https://protonlml.github.io/categories/java/"/>
    
    
    <category term="java基础" scheme="https://protonlml.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
